;; ../../../../spec-concrete/0-aux.watsup:18.1-18.21
def $sum(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:20.1-20.21
def $max(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:22.1-22.21
def $min(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:28.1-28.29
def $int_to_text(int) : text =

;; ../../../../spec-concrete/0-aux.watsup:30.1-30.31
def $concat_text(text*) : text =

   ;; ../../../../spec-concrete/0-aux.watsup:31.1-31.27
   clause 0(text*{text <- text*}) = ""
      -- if text*{text <- text*} matches []

   ;; ../../../../spec-concrete/0-aux.watsup:32.1-32.58
   clause 1(text*{text <- text*}) = t_h ++ $concat_text(t_t*{t_t <- t_t*})
      -- if text*{text <- text*} matches _ :: _
      -- let t_h :: t_t*{t_t <- t_t*} = text*{text <- text*}

;; ../../../../spec-concrete/0-aux.watsup:34.1-34.37
def $strip_prefix(text, text) : text =

;; ../../../../spec-concrete/0-aux.watsup:35.1-35.37
def $strip_suffix(text, text) : text =

;; ../../../../spec-concrete/0-aux.watsup:41.1-41.23
def $init_(nat) : nat* =

   ;; ../../../../spec-concrete/0-aux.watsup:42.1-42.20
   clause 0(nat) = []
      -- if (nat = 0)

   ;; ../../../../spec-concrete/0-aux.watsup:43.1-44.15
   clause 1(n) = (n - 1) :: $init_((n - 1))
      -- otherwise

;; ../../../../spec-concrete/0-aux.watsup:46.1-46.29
def $repeat_<X>(X, nat) : X* =

   ;; ../../../../spec-concrete/0-aux.watsup:47.1-47.28
   clause 0(X, nat) = []
      -- if (nat = 0)

   ;; ../../../../spec-concrete/0-aux.watsup:48.1-49.15
   clause 1(X, n) = [X] ++ $repeat_<X>(X, (n - 1))
      -- otherwise

;; ../../../../spec-concrete/0-aux.watsup:51.1-51.22
def $rev_<X>(X*) : X* =

;; ../../../../spec-concrete/0-aux.watsup:53.1-53.28
def $concat_<X>(X**) : X* =

;; ../../../../spec-concrete/0-aux.watsup:55.1-55.39
def $partition_<X>(X*, nat) : (X*, X*) =

;; ../../../../spec-concrete/0-aux.watsup:57.1-57.35
def $assoc_<X, Y>(X, (X, Y)*) : Y? =

;; ../../../../spec-concrete/0-aux.watsup:59.1-59.29
def $distinct_<K>(K*) : bool =

;; ../../../../spec-concrete/0-aux.watsup:65.17-65.24
syntax set<K> = 
   | `{` K* `}`

;; ../../../../spec-concrete/0-aux.watsup:67.1-67.27
def $empty_set<K> : set<K> =

   ;; ../../../../spec-concrete/0-aux.watsup:68.1-68.29
   clause 0 = `{` [] `}`

;; ../../../../spec-concrete/0-aux.watsup:70.1-70.33
def $in_set<K>(K, set<K>) : bool =

   ;; ../../../../spec-concrete/0-aux.watsup:71.1-71.41
   clause 0(K, `{` K_e*{K_e <- K_e*} `}`) = K <- K_e*{K_e <- K_e*}

;; ../../../../spec-concrete/0-aux.watsup:73.1-73.47
def $intersect_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:75.1-75.43
def $union_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:77.1-77.37
def $unions_set<K>(set<K>*) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:79.1-79.42
def $diff_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:81.1-81.39
def $sub_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:83.1-83.38
def $eq_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:89.21-89.27
syntax pair<K, V> = 
   | K `:` V

;; ../../../../spec-concrete/0-aux.watsup:91.20-91.35
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec-concrete/0-aux.watsup:93.1-93.33
def $empty_map<K, V> : map<K, V> =

   ;; ../../../../spec-concrete/0-aux.watsup:94.1-94.32
   clause 0 = `{` [] `}`

;; ../../../../spec-concrete/0-aux.watsup:96.1-96.39
def $dom_map<K, V>(map<K, V>) : set<K> =

   ;; ../../../../spec-concrete/0-aux.watsup:97.1-97.45
   clause 0(`{` K `:` V*{K <- K*, V <- V*} `}`) = `{` K*{K <- K*} `}`

;; ../../../../spec-concrete/0-aux.watsup:99.1-99.39
def $find_map<K, V>(map<K, V>, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:101.1-101.41
def $find_maps<K, V>(map<K, V>*, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:103.1-103.48
def $add_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:105.1-105.51
def $adds_map<K, V>(map<K, V>, K*, V*) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:107.1-107.51
def $update_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/1-syntax.watsup:6.1-7.7
syntax trailingCommaOpt = 
   | ``EMPTY`
   | `,`

;; ../../../../spec-concrete/1-syntax.watsup:14.1-16.35
syntax number = 
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)

;; ../../../../spec-concrete/1-syntax.watsup:22.24-22.57
syntax stringLiteral = 
   | `"` text `"` hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:35.21-35.29
syntax identifier = 
   | ``ID` text

;; ../../../../spec-concrete/1-syntax.watsup:36.25-36.34
syntax typeIdentifier = 
   | ``TID` text

;; ../../../../spec-concrete/1-syntax.watsup:43.1-45.30
syntax nonTypeName = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`

;; ../../../../spec-concrete/1-syntax.watsup:48.1-49.23
syntax prefixedNonTypeName = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName

;; ../../../../spec-concrete/1-syntax.watsup:55.19-55.33
syntax typeName = typeIdentifier

;; ../../../../spec-concrete/1-syntax.watsup:58.1-59.21
syntax prefixedTypeName = 
   | ``TID` text
   | ``TID.` typeName

;; ../../../../spec-concrete/1-syntax.watsup:66.1-68.36
syntax tableCustomName = 
   | ``ID` text
   | ``TID` text
   | `APPLY`
   | `STATE`
   | `TYPE`
   | `PRIORITY`

;; ../../../../spec-concrete/1-syntax.watsup:75.1-77.9
syntax name = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``TID` text
   | `LIST`

;; ../../../../spec-concrete/1-syntax.watsup:80.1-81.21
syntax nameList = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``TID` text
   | `LIST`
   | nameList `,` name

;; ../../../../spec-concrete/1-syntax.watsup:83.1-83.40
def $flatten_nameList(nameList) : name* =

   ;; ../../../../spec-concrete/1-syntax.watsup:84.1-84.35
   clause 0(nameList) = [name]
      -- if nameList <: name
      -- let name = nameList as name

   ;; ../../../../spec-concrete/1-syntax.watsup:85.1-86.42
   clause 1(nameList') = $flatten_nameList(nameList) ++ [name]
      -- if nameList' matches `%,%`
      -- let nameList `,` name = nameList'

;; ../../../../spec-concrete/1-syntax.watsup:88.17-88.21
syntax member = name

;; ../../../../spec-concrete/1-syntax.watsup:94.20-94.45
syntax direction = 
   | ``EMPTY`
   | `IN`
   | `OUT`
   | `INOUT`

;; ../../../../spec-concrete/1-syntax.watsup:107.1-118.32
syntax baseType = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`

;; ../../../../spec-concrete/1-syntax.watsup:126.26-126.64
syntax specializedType = 
   | prefixedTypeName `<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:129.1-130.20
syntax namedType = 
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:136.26-136.51
syntax headerStackType = 
   | namedType `[` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:144.19-144.41
syntax listType = 
   | `LIST<` typeArgument `>`

;; ../../../../spec-concrete/1-syntax.watsup:150.20-150.47
syntax tupleType = 
   | `TUPLE<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:157.1-161.14
syntax type = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:164.1-166.15
syntax typeOrVoid = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | ``ID` text

;; ../../../../spec-concrete/1-syntax.watsup:172.24-172.28
syntax typeParameter = name

;; ../../../../spec-concrete/1-syntax.watsup:175.1-176.39
syntax typeParameterList = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``TID` text
   | `LIST`
   | typeParameterList `,` typeParameter

;; ../../../../spec-concrete/1-syntax.watsup:178.1-178.67
def $flatten_typeParameterList(typeParameterList) : typeParameter* =

   ;; ../../../../spec-concrete/1-syntax.watsup:179.1-179.62
   clause 0(typeParameterList) = [typeParameter]
      -- if typeParameterList <: typeParameter
      -- let typeParameter = typeParameterList as typeParameter

   ;; ../../../../spec-concrete/1-syntax.watsup:180.1-181.69
   clause 1(typeParameterList') = $flatten_typeParameterList(typeParameterList) ++ [typeParameter]
      -- if typeParameterList' matches `%,%`
      -- let typeParameterList `,` typeParameter = typeParameterList'

;; ../../../../spec-concrete/1-syntax.watsup:184.1-185.27
syntax typeParameterListOpt = 
   | ``EMPTY`
   | `<` typeParameterList `>`

;; ../../../../spec-concrete/1-syntax.watsup:187.1-187.73
def $flatten_typeParameterListOpt(typeParameterListOpt) : typeParameter* =

   ;; ../../../../spec-concrete/1-syntax.watsup:188.1-188.48
   clause 0(typeParameterListOpt) = []
      -- if typeParameterListOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:189.1-190.50
   clause 1(typeParameterListOpt) = $flatten_typeParameterList(typeParameterList)
      -- if typeParameterListOpt matches `<%>`
      -- let `<` typeParameterList `>` = typeParameterListOpt

;; ../../../../spec-concrete/1-syntax.watsup:199.3-199.52
syntax parameter = 
   | annotationList direction type name initializerOpt

;; ../../../../spec-concrete/1-syntax.watsup:202.1-203.39
syntax nonEmptyParameterList = 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList `,` parameter

;; ../../../../spec-concrete/1-syntax.watsup:206.1-207.26
syntax parameterList = 
   | ``EMPTY`
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList `,` parameter

;; ../../../../spec-concrete/1-syntax.watsup:209.1-209.55
def $flatten_parameterList(parameterList) : parameter* =

   ;; ../../../../spec-concrete/1-syntax.watsup:210.1-210.41
   clause 0(parameterList) = []
      -- if parameterList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:211.1-211.50
   clause 1(parameterList) = [parameter]
      -- if parameterList <: parameter
      -- let parameter = parameterList as parameter

   ;; ../../../../spec-concrete/1-syntax.watsup:212.1-213.67
   clause 2(parameterList) = $flatten_parameterList(nonEmptyParameterList as parameterList) ++ [parameter]
      -- if parameterList <: nonEmptyParameterList
      -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
      -- if nonEmptyParameterList' matches `%,%`
      -- let nonEmptyParameterList `,` parameter = nonEmptyParameterList'

;; ../../../../spec-concrete/1-syntax.watsup:219.31-219.40
syntax constructorParameter = parameter

;; ../../../../spec-concrete/1-syntax.watsup:221.35-221.48
syntax constructorParameterList = parameterList

;; ../../../../spec-concrete/1-syntax.watsup:224.1-225.23
syntax constructorParameterListOpt = 
   | ``EMPTY`
   | `(` parameterList `)`

;; ../../../../spec-concrete/1-syntax.watsup:227.1-228.26
def $flatten_constructorParameterListOpt(constructorParameterListOpt) : constructorParameter* =

   ;; ../../../../spec-concrete/1-syntax.watsup:230.1-230.55
   clause 0(constructorParameterListOpt) = []
      -- if constructorParameterListOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:231.1-232.42
   clause 1(constructorParameterListOpt) = $flatten_parameterList(parameterList)
      -- if constructorParameterListOpt matches `(%)`
      -- let `(` parameterList `)` = constructorParameterListOpt

;; ../../../../spec-concrete/1-syntax.watsup:238.26-238.44
syntax namedExpression = 
   | name `=` expression

;; ../../../../spec-concrete/1-syntax.watsup:241.1-242.43
syntax namedExpressionList = 
   | name `=` expression
   | namedExpressionList `,` namedExpression

;; ../../../../spec-concrete/1-syntax.watsup:244.1-244.73
def $flatten_namedExpressionList(namedExpressionList) : namedExpression* =

   ;; ../../../../spec-concrete/1-syntax.watsup:245.1-245.68
   clause 0(namedExpressionList) = [namedExpression]
      -- if namedExpressionList <: namedExpression
      -- let namedExpression = namedExpressionList as namedExpression

   ;; ../../../../spec-concrete/1-syntax.watsup:246.1-247.75
   clause 1(namedExpressionList') = $flatten_namedExpressionList(namedExpressionList) ++ [namedExpression]
      -- if namedExpressionList' matches `%,%`
      -- let namedExpressionList `,` namedExpression = namedExpressionList'

;; ../../../../spec-concrete/1-syntax.watsup:258.1-260.18
syntax literalExpression = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:267.1-268.9
syntax referenceExpression = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`

;; ../../../../spec-concrete/1-syntax.watsup:274.28-274.32
syntax defaultExpression = 
   | `...`

;; ../../../../spec-concrete/1-syntax.watsup:282.15-282.32
syntax unop = 
   | `!`
   | `~`
   | `-`
   | `+`

;; ../../../../spec-concrete/1-syntax.watsup:284.26-284.41
syntax unaryExpression = 
   | unop expression

;; ../../../../spec-concrete/1-syntax.watsup:287.1-289.35
syntax binop = 
   | `*`
   | `/`
   | `%`
   | `+`
   | `-`
   | `|+|`
   | `|-|`
   | `<<`
   | `>>`
   | `<=`
   | `>=`
   | `<`
   | `>`
   | `!=`
   | `==`
   | `&`
   | `^`
   | `|`
   | `++`
   | `&&`
   | `||`

;; ../../../../spec-concrete/1-syntax.watsup:291.27-291.54
syntax binaryExpression = 
   | expression binop expression

;; ../../../../spec-concrete/1-syntax.watsup:294.3-294.38
syntax binaryExpressionNonBrace = 
   | expressionNonBrace binop expression

;; ../../../../spec-concrete/1-syntax.watsup:297.3-297.41
syntax ternaryExpression = 
   | expression `?` expression `:` expression

;; ../../../../spec-concrete/1-syntax.watsup:300.3-300.49
syntax ternaryExpressionNonBrace = 
   | expressionNonBrace `?` expression `:` expression

;; ../../../../spec-concrete/1-syntax.watsup:306.25-306.45
syntax castExpression = 
   | `(` type `)` expression

;; ../../../../spec-concrete/1-syntax.watsup:315.1-316.48
syntax dataExpression = 
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`

;; ../../../../spec-concrete/1-syntax.watsup:325.3-325.18
syntax errorAccessExpression = 
   | `ERROR.` member

;; ../../../../spec-concrete/1-syntax.watsup:328.3-328.29
syntax memberAccessExpression = 
   | memberAccessBase `.` member

;; ../../../../spec-concrete/1-syntax.watsup:331.1-332.45
syntax indexAccessExpression = 
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:335.1-337.26
syntax accessExpression = 
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:340.3-340.37
syntax memberAccessExpressionNonBrace = 
   | memberAccessBaseNonBrace `.` member

;; ../../../../spec-concrete/1-syntax.watsup:343.1-344.53
syntax indexAccessExpressionNonBrace = 
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:347.1-349.34
syntax accessExpressionNonBrace = 
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:363.1-364.62
syntax callExpression = 
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`

;; ../../../../spec-concrete/1-syntax.watsup:367.1-368.70
syntax callExpressionNonBrace = 
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`

;; ../../../../spec-concrete/1-syntax.watsup:374.34-374.49
syntax parenthesizedExpression = 
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:381.1-391.28
syntax expression = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:395.1-397.33
syntax expressionList = 
   | ``EMPTY`
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expressionList `,` expression

;; ../../../../spec-concrete/1-syntax.watsup:399.1-399.58
def $flatten_expressionList(expressionList) : expression* =

   ;; ../../../../spec-concrete/1-syntax.watsup:400.1-400.42
   clause 0(expressionList) = []
      -- if expressionList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:401.1-401.53
   clause 1(expressionList) = [expression]
      -- if expressionList <: expression
      -- let expression = expressionList as expression

   ;; ../../../../spec-concrete/1-syntax.watsup:402.1-403.60
   clause 2(expressionList') = $flatten_expressionList(expressionList) ++ [expression]
      -- if expressionList' matches `%,%`
      -- let expressionList `,` expression = expressionList'

;; ../../../../spec-concrete/1-syntax.watsup:406.1-407.15
syntax memberAccessBase = 
   | ``TID` text
   | ``TID.` typeName
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:409.36-409.50
syntax sequenceElementExpression = expressionList

;; ../../../../spec-concrete/1-syntax.watsup:412.1-415.54
syntax recordElementExpression = 
   | name `=` expression
   | name `=` expression `,...`
   | name `=` expression `,` namedExpressionList
   | name `=` expression `,` namedExpressionList `,...`

;; ../../../../spec-concrete/1-syntax.watsup:418.1-419.28
syntax dataElementExpression = 
   | ``EMPTY`
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expressionList `,` expression
   | name `=` expression
   | name `=` expression `,...`
   | name `=` expression `,` namedExpressionList
   | name `=` expression `,` namedExpressionList `,...`

;; ../../../../spec-concrete/1-syntax.watsup:421.24-421.34
syntax routineTarget = expression

;; ../../../../spec-concrete/1-syntax.watsup:422.28-422.37
syntax constructorTarget = namedType

;; ../../../../spec-concrete/1-syntax.watsup:425.1-426.22
syntax callTarget = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:433.1-441.28
syntax expressionNonBrace = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace `?` expression `:` expression
   | `(` type `)` expression
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:444.1-445.23
syntax memberAccessBaseNonBrace = 
   | ``TID` text
   | ``TID.` typeName
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace `?` expression `:` expression
   | `(` type `)` expression
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:447.32-447.50
syntax routineTargetNonBrace = expressionNonBrace

;; ../../../../spec-concrete/1-syntax.watsup:450.1-451.22
syntax callTargetNonBrace = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace `?` expression `:` expression
   | `(` type `)` expression
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:453.1-453.57
def $expressionNonBrace(expressionNonBrace) : expression =

   ;; ../../../../spec-concrete/1-syntax.watsup:454.1-454.63
   clause 0(expressionNonBrace) = literalExpression as expression
      -- if expressionNonBrace <: literalExpression
      -- let literalExpression = expressionNonBrace as literalExpression

   ;; ../../../../spec-concrete/1-syntax.watsup:455.1-455.67
   clause 1(expressionNonBrace) = referenceExpression as expression
      -- if expressionNonBrace <: referenceExpression
      -- let referenceExpression = expressionNonBrace as referenceExpression

   ;; ../../../../spec-concrete/1-syntax.watsup:456.1-456.59
   clause 2(expressionNonBrace) = unaryExpression as expression
      -- if expressionNonBrace <: unaryExpression
      -- let unaryExpression = expressionNonBrace as unaryExpression

   ;; ../../../../spec-concrete/1-syntax.watsup:457.1-461.65
   clause 3(expressionNonBrace) = expression_l binop expression_r as expression
      -- if expressionNonBrace <: binaryExpressionNonBrace
      -- let expressionNonBrace_l binop expression_r = expressionNonBrace as binaryExpressionNonBrace
      -- let expression_l = $expressionNonBrace(expressionNonBrace_l)

   ;; ../../../../spec-concrete/1-syntax.watsup:462.1-466.71
   clause 4(expressionNonBrace) = expression_cond `?` expression_true `:` expression_false as expression
      -- if expressionNonBrace <: ternaryExpressionNonBrace
      -- let expressionNonBrace_cond `?` expression_true `:` expression_false = expressionNonBrace as ternaryExpressionNonBrace
      -- let expression_cond = $expressionNonBrace(expressionNonBrace_cond)

   ;; ../../../../spec-concrete/1-syntax.watsup:467.1-467.57
   clause 5(expressionNonBrace) = castExpression as expression
      -- if expressionNonBrace <: castExpression
      -- let castExpression = expressionNonBrace as castExpression

   ;; ../../../../spec-concrete/1-syntax.watsup:468.1-468.71
   clause 6(expressionNonBrace) = errorAccessExpression as expression
      -- if expressionNonBrace <: errorAccessExpression
      -- let errorAccessExpression = expressionNonBrace as errorAccessExpression

   ;; ../../../../spec-concrete/1-syntax.watsup:469.1-470.31
   clause 7(expressionNonBrace) = prefixedTypeName as memberAccessBase `.` member as expression
      -- if expressionNonBrace <: memberAccessExpressionNonBrace
      -- let memberAccessBaseNonBrace `.` member = expressionNonBrace as memberAccessExpressionNonBrace
      -- if memberAccessBaseNonBrace <: prefixedTypeName
      -- let prefixedTypeName = memberAccessBaseNonBrace as prefixedTypeName

   ;; ../../../../spec-concrete/1-syntax.watsup:471.1-473.71
   clause 8(expressionNonBrace) = expression_base as memberAccessBase `.` member as expression
      -- if expressionNonBrace <: memberAccessExpressionNonBrace
      -- let memberAccessBaseNonBrace `.` member = expressionNonBrace as memberAccessExpressionNonBrace
      -- if memberAccessBaseNonBrace <: expressionNonBrace
      -- let expressionNonBrace_base = memberAccessBaseNonBrace as expressionNonBrace
      -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

   ;; ../../../../spec-concrete/1-syntax.watsup:474.1-478.71
   clause 9(expressionNonBrace) = expression_base `[` expression_index `]` as expression
      -- if expressionNonBrace <: indexAccessExpressionNonBrace
      -- let indexAccessExpressionNonBrace = expressionNonBrace as indexAccessExpressionNonBrace
      -- if indexAccessExpressionNonBrace matches `%[%]`
      -- let expressionNonBrace_base `[` expression_index `]` = indexAccessExpressionNonBrace
      -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

   ;; ../../../../spec-concrete/1-syntax.watsup:479.1-483.71
   clause 10(expressionNonBrace) = expression_base `[` expression_hi `:` expression_lo `]` as expression
      -- if expressionNonBrace <: indexAccessExpressionNonBrace
      -- let indexAccessExpressionNonBrace = expressionNonBrace as indexAccessExpressionNonBrace
      -- if indexAccessExpressionNonBrace matches `%[%:%]`
      -- let expressionNonBrace_base `[` expression_hi `:` expression_lo `]` = indexAccessExpressionNonBrace
      -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

   ;; ../../../../spec-concrete/1-syntax.watsup:484.1-488.61
   clause 11(expressionNonBrace') = expression as callTarget `(` argumentList `)` as expression
      -- if expressionNonBrace' <: callExpressionNonBrace
      -- let callExpressionNonBrace = expressionNonBrace' as callExpressionNonBrace
      -- if callExpressionNonBrace matches `%(%)`
      -- let callTargetNonBrace `(` argumentList `)` = callExpressionNonBrace
      -- if callTargetNonBrace <: expressionNonBrace
      -- let expressionNonBrace = callTargetNonBrace as expressionNonBrace
      -- let expression = $expressionNonBrace(expressionNonBrace)

   ;; ../../../../spec-concrete/1-syntax.watsup:489.1-492.40
   clause 12(expressionNonBrace) = constructorTarget as callTarget `(` argumentList `)` as expression
      -- if expressionNonBrace <: callExpressionNonBrace
      -- let callExpressionNonBrace = expressionNonBrace as callExpressionNonBrace
      -- if callExpressionNonBrace matches `%(%)`
      -- let callTargetNonBrace `(` argumentList `)` = callExpressionNonBrace
      -- if callTargetNonBrace <: constructorTarget
      -- let constructorTarget = callTargetNonBrace as constructorTarget

   ;; ../../../../spec-concrete/1-syntax.watsup:493.1-497.61
   clause 13(expressionNonBrace') = expression `<` realTypeArgumentList `>(` argumentList `)` as expression
      -- if expressionNonBrace' <: callExpressionNonBrace
      -- let callExpressionNonBrace = expressionNonBrace' as callExpressionNonBrace
      -- if callExpressionNonBrace matches `%<%>(%)`
      -- let expressionNonBrace `<` realTypeArgumentList `>(` argumentList `)` = callExpressionNonBrace
      -- let expression = $expressionNonBrace(expressionNonBrace)

   ;; ../../../../spec-concrete/1-syntax.watsup:498.1-498.75
   clause 14(expressionNonBrace) = parenthesizedExpression as expression
      -- if expressionNonBrace <: parenthesizedExpression
      -- let parenthesizedExpression = expressionNonBrace as parenthesizedExpression

;; ../../../../spec-concrete/1-syntax.watsup:505.1-509.7
syntax simpleKeysetExpression = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expression `&&&` expression
   | expression `..` expression
   | `DEFAULT`
   | `_`

;; ../../../../spec-concrete/1-syntax.watsup:512.1-513.57
syntax simpleKeysetExpressionList = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expression `&&&` expression
   | expression `..` expression
   | `DEFAULT`
   | `_`
   | simpleKeysetExpressionList `,` simpleKeysetExpression

;; ../../../../spec-concrete/1-syntax.watsup:515.1-516.28
def $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList) : simpleKeysetExpression* =

   ;; ../../../../spec-concrete/1-syntax.watsup:517.1-518.27
   clause 0(simpleKeysetExpressionList) = [simpleKeysetExpression]
      -- if simpleKeysetExpressionList <: simpleKeysetExpression
      -- let simpleKeysetExpression = simpleKeysetExpressionList as simpleKeysetExpression

   ;; ../../../../spec-concrete/1-syntax.watsup:519.1-523.34
   clause 1(simpleKeysetExpressionList') = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList) ++ [simpleKeysetExpression]
      -- if simpleKeysetExpressionList' matches `%,%`
      -- let simpleKeysetExpressionList `,` simpleKeysetExpression = simpleKeysetExpressionList'

;; ../../../../spec-concrete/1-syntax.watsup:526.1-530.62
syntax tupleKeysetExpression = 
   | `(` expression `&&&` expression `)`
   | `(` expression `..` expression `)`
   | `(DEFAULT)`
   | `(_)`
   | `(` simpleKeysetExpression `,` simpleKeysetExpressionList `)`

;; ../../../../spec-concrete/1-syntax.watsup:533.1-534.26
syntax keysetExpression = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expression `&&&` expression
   | expression `..` expression
   | `DEFAULT`
   | `_`
   | `(` expression `&&&` expression `)`
   | `(` expression `..` expression `)`
   | `(DEFAULT)`
   | `(_)`
   | `(` simpleKeysetExpression `,` simpleKeysetExpressionList `)`

;; ../../../../spec-concrete/1-syntax.watsup:541.1-543.7
syntax realTypeArgument = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | `_`

;; ../../../../spec-concrete/1-syntax.watsup:546.1-547.45
syntax realTypeArgumentList = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | `_`
   | realTypeArgumentList `,` realTypeArgument

;; ../../../../spec-concrete/1-syntax.watsup:549.1-549.76
def $flatten_realTypeArgumentList(realTypeArgumentList) : realTypeArgument* =

   ;; ../../../../spec-concrete/1-syntax.watsup:550.1-550.71
   clause 0(realTypeArgumentList) = [realTypeArgument]
      -- if realTypeArgumentList <: realTypeArgument
      -- let realTypeArgument = realTypeArgumentList as realTypeArgument

   ;; ../../../../spec-concrete/1-syntax.watsup:551.1-552.78
   clause 1(realTypeArgumentList') = $flatten_realTypeArgumentList(realTypeArgumentList) ++ [realTypeArgument]
      -- if realTypeArgumentList' matches `%,%`
      -- let realTypeArgumentList `,` realTypeArgument = realTypeArgumentList'

;; ../../../../spec-concrete/1-syntax.watsup:555.1-556.16
syntax typeArgument = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | `_`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`

;; ../../../../spec-concrete/1-syntax.watsup:560.1-562.37
syntax typeArgumentList = 
   | ``EMPTY`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | `_`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | typeArgumentList `,` typeArgument

;; ../../../../spec-concrete/1-syntax.watsup:564.1-564.64
def $flatten_typeArgumentList(typeArgumentList) : typeArgument* =

   ;; ../../../../spec-concrete/1-syntax.watsup:565.1-565.44
   clause 0(typeArgumentList) = []
      -- if typeArgumentList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:566.1-566.59
   clause 1(typeArgumentList) = [typeArgument]
      -- if typeArgumentList <: typeArgument
      -- let typeArgument = typeArgumentList as typeArgument

   ;; ../../../../spec-concrete/1-syntax.watsup:567.1-568.66
   clause 2(typeArgumentList') = $flatten_typeArgumentList(typeArgumentList) ++ [typeArgument]
      -- if typeArgumentList' matches `%,%`
      -- let typeArgumentList `,` typeArgument = typeArgumentList'

;; ../../../../spec-concrete/1-syntax.watsup:575.1-578.7
syntax argument = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | name `=` expression
   | name `=_`
   | `_`

;; ../../../../spec-concrete/1-syntax.watsup:581.1-582.37
syntax argumentListNonEmpty = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | name `=` expression
   | name `=_`
   | `_`
   | argumentListNonEmpty `,` argument

;; ../../../../spec-concrete/1-syntax.watsup:585.1-586.25
syntax argumentList = 
   | ``EMPTY`
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | name `=` expression
   | name `=_`
   | `_`
   | argumentListNonEmpty `,` argument

;; ../../../../spec-concrete/1-syntax.watsup:588.1-588.52
def $flatten_argumentList(argumentList) : argument* =

   ;; ../../../../spec-concrete/1-syntax.watsup:589.1-589.40
   clause 0(argumentList) = []
      -- if argumentList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:590.1-590.47
   clause 1(argumentList) = [argument]
      -- if argumentList <: argument
      -- let argument = argumentList as argument

   ;; ../../../../spec-concrete/1-syntax.watsup:591.1-592.62
   clause 2(argumentList) = $flatten_argumentList(argumentListNonEmpty as argumentList) ++ [argument]
      -- if argumentList <: argumentListNonEmpty
      -- let argumentListNonEmpty' = argumentList as argumentListNonEmpty
      -- if argumentListNonEmpty' matches `%,%`
      -- let argumentListNonEmpty `,` argument = argumentListNonEmpty'

;; ../../../../spec-concrete/1-syntax.watsup:599.1-603.16
syntax lvalue = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | lvalue `.` member
   | lvalue `[` expression `]`
   | lvalue `[` expression `:` expression `]`
   | `(` lvalue `)`

;; ../../../../spec-concrete/1-syntax.watsup:613.25-613.27
syntax emptyStatement = 
   | `;`

;; ../../../../spec-concrete/1-syntax.watsup:620.1-622.34
syntax assignop = 
   | `=`
   | `+=`
   | `-=`
   | `|+|=`
   | `|-|=`
   | `*=`
   | `/=`
   | `%=`
   | `<<=`
   | `>>=`
   | `&=`
   | `^=`
   | `|=`

;; ../../../../spec-concrete/1-syntax.watsup:624.30-624.59
syntax assignmentStatement = 
   | lvalue assignop expression `;`

;; ../../../../spec-concrete/1-syntax.watsup:631.1-632.54
syntax callStatement = 
   | lvalue `(` argumentList `);`
   | lvalue `<` typeArgumentList `>(` argumentList `);`

;; ../../../../spec-concrete/1-syntax.watsup:638.37-638.76
syntax directApplicationStatement = 
   | namedType `.APPLY(` argumentList `);`

;; ../../../../spec-concrete/1-syntax.watsup:645.1-646.25
syntax returnStatement = 
   | `RETURN;`
   | `RETURN` expression `;`

;; ../../../../spec-concrete/1-syntax.watsup:652.24-652.31
syntax exitStatement = 
   | `EXIT;`

;; ../../../../spec-concrete/1-syntax.watsup:660.25-660.70
syntax blockStatement = 
   | annotationList `{` blockElementStatementList `}`

;; ../../../../spec-concrete/1-syntax.watsup:669.1-670.48
syntax conditionalStatement = 
   | `IF(` expression `)` statement
   | `IF(` expression `)` statement `ELSE` statement

;; ../../../../spec-concrete/1-syntax.watsup:679.1-682.31
syntax forInitStatement = 
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression

;; ../../../../spec-concrete/1-syntax.watsup:685.1-686.53
syntax forInitStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression
   | forInitStatementListNonEmpty `,` forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:689.1-690.33
syntax forInitStatementList = 
   | ``EMPTY`
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression
   | forInitStatementListNonEmpty `,` forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:692.29-692.45
syntax forUpdateStatement = forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:695.1-696.57
syntax forUpdateStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty `,` forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:699.1-700.35
syntax forUpdateStatementList = 
   | ``EMPTY`
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty `,` forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:703.1-704.30
syntax forCollectionExpression = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expression `..` expression

;; ../../../../spec-concrete/1-syntax.watsup:707.1-712.81
syntax forStatement = 
   | annotationList `FOR(` forInitStatementList `;` expression `;` forUpdateStatementList `)` statement
   | annotationList `FOR(` type name `IN` forCollectionExpression `)` statement
   | annotationList `FOR(` annotationListNonEmpty type name `IN` forCollectionExpression `)` statement

;; ../../../../spec-concrete/1-syntax.watsup:719.1-720.23
syntax switchLabel = 
   | `DEFAULT`
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace `?` expression `:` expression
   | `(` type `)` expression
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:723.1-724.19
syntax switchCase = 
   | switchLabel `:` blockStatement
   | switchLabel `:`

;; ../../../../spec-concrete/1-syntax.watsup:727.1-728.30
syntax switchCaseList = 
   | ``EMPTY`
   | switchCaseList switchCase

;; ../../../../spec-concrete/1-syntax.watsup:730.1-730.58
def $flatten_switchCaseList(switchCaseList) : switchCase* =

   ;; ../../../../spec-concrete/1-syntax.watsup:731.1-731.42
   clause 0(switchCaseList) = []
      -- if switchCaseList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:732.1-733.62
   clause 1(switchCaseList') = $flatten_switchCaseList(switchCaseList) ++ [switchCase]
      -- if switchCaseList' matches `%%`
      -- let switchCaseList switchCase = switchCaseList'

;; ../../../../spec-concrete/1-syntax.watsup:735.26-735.68
syntax switchStatement = 
   | `SWITCH(` expression `){` switchCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:741.25-741.33
syntax breakStatement = 
   | `BREAK;`

;; ../../../../spec-concrete/1-syntax.watsup:743.28-743.39
syntax continueStatement = 
   | `CONTINUE;`

;; ../../../../spec-concrete/1-syntax.watsup:750.1-761.20
syntax statement = 
   | `;`
   | lvalue assignop expression `;`
   | lvalue `(` argumentList `);`
   | lvalue `<` typeArgumentList `>(` argumentList `);`
   | namedType `.APPLY(` argumentList `);`
   | `RETURN;`
   | `RETURN` expression `;`
   | `EXIT;`
   | annotationList `{` blockElementStatementList `}`
   | `IF(` expression `)` statement
   | `IF(` expression `)` statement `ELSE` statement
   | annotationList `FOR(` forInitStatementList `;` expression `;` forUpdateStatementList `)` statement
   | annotationList `FOR(` type name `IN` forCollectionExpression `)` statement
   | annotationList `FOR(` annotationListNonEmpty type name `IN` forCollectionExpression `)` statement
   | `BREAK;`
   | `CONTINUE;`
   | `SWITCH(` expression `){` switchCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:771.22-771.35
syntax initializer = 
   | `=` expression

;; ../../../../spec-concrete/1-syntax.watsup:774.3-774.48
syntax constantDeclaration = 
   | annotationList `CONST` type name initializer `;`

;; ../../../../spec-concrete/1-syntax.watsup:777.1-778.16
syntax initializerOpt = 
   | ``EMPTY`
   | `=` expression

;; ../../../../spec-concrete/1-syntax.watsup:781.3-781.45
syntax variableDeclaration = 
   | annotationList type name initializerOpt `;`

;; ../../../../spec-concrete/1-syntax.watsup:784.1-786.14
syntax blockElementStatement = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type name initializerOpt `;`
   | `;`
   | lvalue assignop expression `;`
   | lvalue `(` argumentList `);`
   | lvalue `<` typeArgumentList `>(` argumentList `);`
   | namedType `.APPLY(` argumentList `);`
   | `RETURN;`
   | `RETURN` expression `;`
   | `EXIT;`
   | annotationList `{` blockElementStatementList `}`
   | `IF(` expression `)` statement
   | `IF(` expression `)` statement `ELSE` statement
   | annotationList `FOR(` forInitStatementList `;` expression `;` forUpdateStatementList `)` statement
   | annotationList `FOR(` type name `IN` forCollectionExpression `)` statement
   | annotationList `FOR(` annotationListNonEmpty type name `IN` forCollectionExpression `)` statement
   | `BREAK;`
   | `CONTINUE;`
   | `SWITCH(` expression `){` switchCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:789.1-790.52
syntax blockElementStatementList = 
   | ``EMPTY`
   | blockElementStatementList blockElementStatement

;; ../../../../spec-concrete/1-syntax.watsup:792.1-793.27
def $flatten_blockElementStatementList(blockElementStatementList) : blockElementStatement* =

   ;; ../../../../spec-concrete/1-syntax.watsup:794.1-794.53
   clause 0(blockElementStatementList) = []
      -- if blockElementStatementList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:795.1-799.30
   clause 1(blockElementStatementList') = $flatten_blockElementStatementList(blockElementStatementList) ++ [blockElementStatement]
      -- if blockElementStatementList' matches `%%`
      -- let blockElementStatementList blockElementStatement = blockElementStatementList'

;; ../../../../spec-concrete/1-syntax.watsup:806.3-806.58
syntax functionPrototype = 
   | typeOrVoid name typeParameterListOpt `(` parameterList `)`

;; ../../../../spec-concrete/1-syntax.watsup:809.3-809.50
syntax functionDeclaration = 
   | annotationList functionPrototype blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:816.3-816.63
syntax actionDeclaration = 
   | annotationList `ACTION` name `(` parameterList `)` blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:824.28-824.57
syntax objectInitializer = 
   | `={` objectDeclarationList `}`

;; ../../../../spec-concrete/1-syntax.watsup:828.1-829.68
syntax instantiation = 
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`

;; ../../../../spec-concrete/1-syntax.watsup:832.1-833.18
syntax objectDeclaration = 
   | annotationList functionPrototype blockStatement
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`

;; ../../../../spec-concrete/1-syntax.watsup:836.1-837.44
syntax objectDeclarationList = 
   | ``EMPTY`
   | objectDeclarationList objectDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:839.1-839.79
def $flatten_objectDeclarationList(objectDeclarationList) : objectDeclaration* =

   ;; ../../../../spec-concrete/1-syntax.watsup:840.1-840.49
   clause 0(objectDeclarationList) = []
      -- if objectDeclarationList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:841.1-845.29
   clause 1(objectDeclarationList') = $flatten_objectDeclarationList(objectDeclarationList) ++ [objectDeclaration]
      -- if objectDeclarationList' matches `%%`
      -- let objectDeclarationList objectDeclaration = objectDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:851.27-851.46
syntax errorDeclaration = 
   | `ERROR{` nameList `}`

;; ../../../../spec-concrete/1-syntax.watsup:857.31-857.72
syntax matchKindDeclaration = 
   | `MATCH_KIND{` nameList trailingCommaOpt `}`

;; ../../../../spec-concrete/1-syntax.watsup:868.1-869.76
syntax enumTypeDeclaration = 
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`

;; ../../../../spec-concrete/1-syntax.watsup:875.20-875.47
syntax typeField = 
   | annotationList type name `;`

;; ../../../../spec-concrete/1-syntax.watsup:878.1-879.28
syntax typeFieldList = 
   | ``EMPTY`
   | typeFieldList typeField

;; ../../../../spec-concrete/1-syntax.watsup:881.1-881.55
def $flatten_typeFieldList(typeFieldList) : typeField* =

   ;; ../../../../spec-concrete/1-syntax.watsup:882.1-882.41
   clause 0(typeFieldList) = []
      -- if typeFieldList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:883.1-884.59
   clause 1(typeFieldList') = $flatten_typeFieldList(typeFieldList) ++ [typeField]
      -- if typeFieldList' matches `%%`
      -- let typeFieldList typeField = typeFieldList'

;; ../../../../spec-concrete/1-syntax.watsup:887.3-887.69
syntax structTypeDeclaration = 
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:890.3-890.69
syntax headerTypeDeclaration = 
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:893.3-893.75
syntax headerUnionTypeDeclaration = 
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:896.1-899.31
syntax derivedTypeDeclaration = 
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:906.1-907.27
syntax typedefType = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:910.1-911.37
syntax typedefDeclaration = 
   | annotationList `TYPEDEF` typedefType name `;`
   | annotationList `TYPE` type name `;`

;; ../../../../spec-concrete/1-syntax.watsup:918.3-918.45
syntax externFunctionDeclaration = 
   | annotationList `EXTERN` functionPrototype `;`

;; ../../../../spec-concrete/1-syntax.watsup:921.1-923.49
syntax methodPrototype = 
   | annotationList typeIdentifier `(` parameterList `);`
   | annotationList functionPrototype `;`
   | annotationList `ABSTRACT` functionPrototype `;`

;; ../../../../spec-concrete/1-syntax.watsup:926.1-927.40
syntax methodPrototypeList = 
   | ``EMPTY`
   | methodPrototypeList methodPrototype

;; ../../../../spec-concrete/1-syntax.watsup:929.1-929.73
def $flatten_methodPrototypeList(methodPrototypeList) : methodPrototype* =

   ;; ../../../../spec-concrete/1-syntax.watsup:930.1-930.47
   clause 0(methodPrototypeList) = []
      -- if methodPrototypeList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:931.1-934.77
   clause 1(methodPrototypeList') = $flatten_methodPrototypeList(methodPrototypeList) ++ [methodPrototype]
      -- if methodPrototypeList' matches `%%`
      -- let methodPrototypeList methodPrototype = methodPrototypeList'

;; ../../../../spec-concrete/1-syntax.watsup:937.3-937.82
syntax externObjectDeclaration = 
   | annotationList `EXTERN` nonTypeName typeParameterListOpt `{` methodPrototypeList `}`

;; ../../../../spec-concrete/1-syntax.watsup:940.1-941.28
syntax externDeclaration = 
   | annotationList `EXTERN` functionPrototype `;`
   | annotationList `EXTERN` nonTypeName typeParameterListOpt `{` methodPrototypeList `}`

;; ../../../../spec-concrete/1-syntax.watsup:951.21-951.48
syntax selectCase = 
   | keysetExpression `:` name `;`

;; ../../../../spec-concrete/1-syntax.watsup:954.1-955.30
syntax selectCaseList = 
   | ``EMPTY`
   | selectCaseList selectCase

;; ../../../../spec-concrete/1-syntax.watsup:957.1-957.58
def $flatten_selectCaseList(selectCaseList) : selectCase* =

   ;; ../../../../spec-concrete/1-syntax.watsup:958.1-958.42
   clause 0(selectCaseList) = []
      -- if selectCaseList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:959.1-960.62
   clause 1(selectCaseList') = $flatten_selectCaseList(selectCaseList) ++ [selectCase]
      -- if selectCaseList' matches `%%`
      -- let selectCaseList selectCase = selectCaseList'

;; ../../../../spec-concrete/1-syntax.watsup:962.27-962.73
syntax selectExpression = 
   | `SELECT(` expressionList `){` selectCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:969.1-970.21
syntax stateExpression = 
   | name `;`
   | `SELECT(` expressionList `){` selectCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:973.1-974.31
syntax transitionStatement = 
   | ``EMPTY`
   | `TRANSITION` stateExpression

;; ../../../../spec-concrete/1-syntax.watsup:981.1-983.21
syntax valueSetType = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | `TUPLE<` typeArgumentList `>`
   | ``TID` text
   | ``TID.` typeName

;; ../../../../spec-concrete/1-syntax.watsup:986.3-986.69
syntax valueSetDeclaration = 
   | annotationList `VALUE_SET<` valueSetType `>(` expression `)` name `;`

;; ../../../../spec-concrete/1-syntax.watsup:993.3-993.72
syntax parserTypeDeclaration = 
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:1001.31-1001.70
syntax parserBlockStatement = 
   | annotationList `{` parserStatementList `}`

;; ../../../../spec-concrete/1-syntax.watsup:1004.1-1011.25
syntax parserStatement = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type name initializerOpt `;`
   | `;`
   | lvalue assignop expression `;`
   | lvalue `(` argumentList `);`
   | lvalue `<` typeArgumentList `>(` argumentList `);`
   | namedType `.APPLY(` argumentList `);`
   | annotationList `{` parserStatementList `}`
   | `IF(` expression `)` statement
   | `IF(` expression `)` statement `ELSE` statement

;; ../../../../spec-concrete/1-syntax.watsup:1014.1-1015.40
syntax parserStatementList = 
   | ``EMPTY`
   | parserStatementList parserStatement

;; ../../../../spec-concrete/1-syntax.watsup:1017.1-1017.73
def $flatten_parserStatementList(parserStatementList) : parserStatement* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1018.1-1018.47
   clause 0(parserStatementList) = []
      -- if parserStatementList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1019.1-1020.77
   clause 1(parserStatementList') = $flatten_parserStatementList(parserStatementList) ++ [parserStatement]
      -- if parserStatementList' matches `%%`
      -- let parserStatementList parserStatement = parserStatementList'

;; ../../../../spec-concrete/1-syntax.watsup:1023.3-1023.73
syntax parserState = 
   | annotationList `STATE` name `{` parserStatementList transitionStatement `}`

;; ../../../../spec-concrete/1-syntax.watsup:1026.1-1027.32
syntax parserStateList = 
   | annotationList `STATE` name `{` parserStatementList transitionStatement `}`
   | parserStateList parserState

;; ../../../../spec-concrete/1-syntax.watsup:1029.1-1029.61
def $flatten_parserStateList(parserStateList) : parserState* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1030.1-1030.56
   clause 0(parserStateList) = [parserState]
      -- if parserStateList <: parserState
      -- let parserState = parserStateList as parserState

   ;; ../../../../spec-concrete/1-syntax.watsup:1031.1-1032.65
   clause 1(parserStateList') = $flatten_parserStateList(parserStateList) ++ [parserState]
      -- if parserStateList' matches `%%`
      -- let parserStateList parserState = parserStateList'

;; ../../../../spec-concrete/1-syntax.watsup:1035.1-1038.24
syntax parserLocalDeclaration = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`
   | annotationList type name initializerOpt `;`
   | annotationList `VALUE_SET<` valueSetType `>(` expression `)` name `;`

;; ../../../../spec-concrete/1-syntax.watsup:1041.1-1042.54
syntax parserLocalDeclarationList = 
   | ``EMPTY`
   | parserLocalDeclarationList parserLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1044.1-1045.28
def $flatten_parserLocalDeclarationList(parserLocalDeclarationList) : parserLocalDeclaration* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1046.1-1046.54
   clause 0(parserLocalDeclarationList) = []
      -- if parserLocalDeclarationList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1047.1-1051.34
   clause 1(parserLocalDeclarationList') = $flatten_parserLocalDeclarationList(parserLocalDeclarationList) ++ [parserLocalDeclaration]
      -- if parserLocalDeclarationList' matches `%%`
      -- let parserLocalDeclarationList parserLocalDeclaration = parserLocalDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:1054.3-1056.52
syntax parserDeclaration = 
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` parserLocalDeclarationList parserStateList `}`

;; ../../../../spec-concrete/1-syntax.watsup:1066.16-1066.21
syntax const = 
   | `CONST`

;; ../../../../spec-concrete/1-syntax.watsup:1069.1-1070.10
syntax constOpt = 
   | ``EMPTY`
   | `CONST`

;; ../../../../spec-concrete/1-syntax.watsup:1072.1-1072.41
def $flatten_constOpt(constOpt) : const? =

   ;; ../../../../spec-concrete/1-syntax.watsup:1073.1-1073.36
   clause 0(constOpt) = ?()
      -- if constOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1074.1-1074.37
   clause 1(constOpt) = ?(const)
      -- if constOpt <: const
      -- let const = constOpt as const

;; ../../../../spec-concrete/1-syntax.watsup:1080.19-1080.55
syntax tableKey = 
   | expression `:` name annotationList `;`

;; ../../../../spec-concrete/1-syntax.watsup:1083.1-1084.26
syntax tableKeyList = 
   | ``EMPTY`
   | tableKeyList tableKey

;; ../../../../spec-concrete/1-syntax.watsup:1086.1-1086.52
def $flatten_tableKeyList(tableKeyList) : tableKey* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1087.1-1087.40
   clause 0(tableKeyList) = []
      -- if tableKeyList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1088.1-1089.56
   clause 1(tableKeyList') = $flatten_tableKeyList(tableKeyList) ++ [tableKey]
      -- if tableKeyList' matches `%%`
      -- let tableKeyList tableKey = tableKeyList'

;; ../../../../spec-concrete/1-syntax.watsup:1096.1-1097.42
syntax tableActionReference = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | prefixedNonTypeName `(` argumentList `)`

;; ../../../../spec-concrete/1-syntax.watsup:1099.22-1099.60
syntax tableAction = 
   | annotationList tableActionReference `;`

;; ../../../../spec-concrete/1-syntax.watsup:1102.1-1103.32
syntax tableActionList = 
   | ``EMPTY`
   | tableActionList tableAction

;; ../../../../spec-concrete/1-syntax.watsup:1105.1-1105.61
def $flatten_tableActionList(tableActionList) : tableAction* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1106.1-1106.43
   clause 0(tableActionList) = []
      -- if tableActionList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1107.1-1108.63
   clause 1(tableActionList') = $flatten_tableActionList(tableActionList) ++ [tableAction]
      -- if tableActionList' matches `%%`
      -- let tableActionList tableAction = tableActionList'

;; ../../../../spec-concrete/1-syntax.watsup:1115.1-1116.35
syntax tableEntryPriority = 
   | `PRIORITY=` number `:`
   | `PRIORITY=(` expression `):`

;; ../../../../spec-concrete/1-syntax.watsup:1119.1-1120.72
syntax tableEntry = 
   | constOpt tableEntryPriority keysetExpression `:` tableActionReference annotationList `;`
   | constOpt keysetExpression `:` tableActionReference annotationList `;`

;; ../../../../spec-concrete/1-syntax.watsup:1123.1-1124.30
syntax tableEntryList = 
   | ``EMPTY`
   | tableEntryList tableEntry

;; ../../../../spec-concrete/1-syntax.watsup:1126.1-1126.58
def $flatten_tableEntryList(tableEntryList) : tableEntry* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1127.1-1127.42
   clause 0(tableEntryList) = []
      -- if tableEntryList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1128.1-1129.62
   clause 1(tableEntryList') = $flatten_tableEntryList(tableEntryList) ++ [tableEntry]
      -- if tableEntryList' matches `%%`
      -- let tableEntryList tableEntry = tableEntryList'

;; ../../../../spec-concrete/1-syntax.watsup:1136.1-1139.59
syntax tableProperty = 
   | `KEY={` tableKeyList `}`
   | `ACTIONS={` tableActionList `}`
   | annotationList constOpt `ENTRIES={` tableEntryList `}`
   | annotationList constOpt tableCustomName initializer `;`

;; ../../../../spec-concrete/1-syntax.watsup:1142.1-1143.36
syntax tablePropertyList = 
   | ``EMPTY`
   | tablePropertyList tableProperty

;; ../../../../spec-concrete/1-syntax.watsup:1145.1-1145.67
def $flatten_tablePropertyList(tablePropertyList) : tableProperty* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1146.1-1146.45
   clause 0(tablePropertyList) = []
      -- if tablePropertyList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1147.1-1148.69
   clause 1(tablePropertyList') = $flatten_tablePropertyList(tablePropertyList) ++ [tableProperty]
      -- if tablePropertyList' matches `%%`
      -- let tablePropertyList tableProperty = tablePropertyList'

;; ../../../../spec-concrete/1-syntax.watsup:1151.3-1151.51
syntax tableDeclaration = 
   | annotationList `TABLE` name `{` tablePropertyList `}`

;; ../../../../spec-concrete/1-syntax.watsup:1158.3-1158.73
syntax controlTypeDeclaration = 
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:1164.22-1164.36
syntax controlBody = blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:1167.1-1171.21
syntax controlLocalDeclaration = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`
   | annotationList type name initializerOpt `;`
   | annotationList `ACTION` name `(` parameterList `)` blockStatement
   | annotationList `TABLE` name `{` tablePropertyList `}`

;; ../../../../spec-concrete/1-syntax.watsup:1174.1-1175.56
syntax controlLocalDeclarationList = 
   | ``EMPTY`
   | controlLocalDeclarationList controlLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1177.1-1178.29
def $flatten_controlLocalDeclarationList(controlLocalDeclarationList) : controlLocalDeclaration* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1180.1-1180.55
   clause 0(controlLocalDeclarationList) = []
      -- if controlLocalDeclarationList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1181.1-1185.32
   clause 1(controlLocalDeclarationList') = $flatten_controlLocalDeclarationList(controlLocalDeclarationList) ++ [controlLocalDeclaration]
      -- if controlLocalDeclarationList' matches `%%`
      -- let controlLocalDeclarationList controlLocalDeclaration = controlLocalDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:1188.3-1190.55
syntax controlDeclaration = 
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` controlLocalDeclarationList `APPLY` controlBody `}`

;; ../../../../spec-concrete/1-syntax.watsup:1197.3-1197.73
syntax packageTypeDeclaration = 
   | annotationList `PACKAGE` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:1204.1-1208.27
syntax typeDeclaration = 
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `TYPEDEF` typedefType name `;`
   | annotationList `TYPE` type name `;`
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `);`
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `);`
   | annotationList `PACKAGE` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:1215.1-1224.20
syntax declaration = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`
   | annotationList functionPrototype blockStatement
   | annotationList `ACTION` name `(` parameterList `)` blockStatement
   | `ERROR{` nameList `}`
   | `MATCH_KIND{` nameList trailingCommaOpt `}`
   | annotationList `EXTERN` functionPrototype `;`
   | annotationList `EXTERN` nonTypeName typeParameterListOpt `{` methodPrototypeList `}`
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` parserLocalDeclarationList parserStateList `}`
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` controlLocalDeclarationList `APPLY` controlBody `}`
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `TYPEDEF` typedefType name `;`
   | annotationList `TYPE` type name `;`
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `);`
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `);`
   | annotationList `PACKAGE` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:1231.1-1248.27
syntax annotationToken = 
   | `UNEXPECTED_TOKEN`
   | `ABSTRACT`
   | `ACTION`
   | `ACTIONS`
   | `APPLY`
   | `BOOL`
   | `BIT`
   | `BREAK`
   | `CONST`
   | `CONTINUE`
   | `CONTROL`
   | `DEFAULT`
   | `ELSE`
   | `ENTRIES`
   | `ENUM`
   | `ERROR`
   | `EXIT`
   | `EXTERN`
   | `FALSE`
   | `FOR`
   | `HEADER`
   | `HEADER_UNION`
   | `IF`
   | `IN`
   | `INOUT`
   | `INT`
   | `KEY`
   | `MATCH_KIND`
   | `TYPE`
   | `OUT`
   | `PARSER`
   | `PACKAGE`
   | `PRAGMA`
   | `RETURN`
   | `SELECT`
   | `STATE`
   | `STRING`
   | `STRUCT`
   | `SWITCH`
   | `TABLE`
   | `THIS`
   | `TRANSITION`
   | `TRUE`
   | `TUPLE`
   | `TYPEDEF`
   | `VARBIT`
   | `VALUE_SET`
   | `LIST`
   | `VOID`
   | `_`
   | ``ID` text
   | ``TID` text
   | `"` text `"` hint(print "#%#")
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `&&&`
   | `..`
   | `<<`
   | `&&`
   | `||`
   | `==`
   | `!=`
   | `>=`
   | `<=`
   | `++`
   | `+`
   | `|+|`
   | `-`
   | `|-|`
   | `*`
   | `/`
   | `%`
   | `|`
   | `&`
   | `^`
   | `~`
   | `[`
   | `]`
   | `{`
   | `}`
   | `<`
   | `>`
   | `!`
   | `:`
   | `,`
   | `?`
   | `.`
   | `=`
   | `;`
   | `@`

;; ../../../../spec-concrete/1-syntax.watsup:1251.1-1253.35
syntax annotationBody = 
   | ``EMPTY`
   | annotationBody `(` annotationBody `)`
   | annotationBody annotationToken

;; ../../../../spec-concrete/1-syntax.watsup:1256.3-1256.41
syntax structuredAnnotationBody = 
   | dataElementExpression trailingCommaOpt

;; ../../../../spec-concrete/1-syntax.watsup:1259.1-1261.42
syntax annotation = 
   | `@` name
   | `@` name `(` annotationBody `)`
   | `@` name `[` structuredAnnotationBody `]`

;; ../../../../spec-concrete/1-syntax.watsup:1264.1-1265.38
syntax annotationListNonEmpty = 
   | `@` name
   | `@` name `(` annotationBody `)`
   | `@` name `[` structuredAnnotationBody `]`
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1268.1-1269.27
syntax annotationList = 
   | ``EMPTY`
   | `@` name
   | `@` name `(` annotationBody `)`
   | `@` name `[` structuredAnnotationBody `]`
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1276.1-1278.17
syntax p4program = 
   | ``EMPTY`
   | p4program declaration
   | p4program `;`

;; ../../../../spec-concrete/1-syntax.watsup:1280.1-1280.49
def $flatten_p4program(p4program) : declaration* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1281.1-1281.37
   clause 0(p4program) = []
      -- if p4program matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1282.1-1283.53
   clause 1(p4program') = $flatten_p4program(p4program) ++ [declaration]
      -- if p4program' matches `%%`
      -- let p4program declaration = p4program'

   ;; ../../../../spec-concrete/1-syntax.watsup:1284.1-1285.34
   clause 2(p4program') = $flatten_p4program(p4program)
      -- if p4program' matches `%;`
      -- let p4program `;` = p4program'

;; ../../../../spec-concrete/2.0-domain.watsup:5.17-5.21
syntax nameIR = text

;; ../../../../spec-concrete/2.0-domain.watsup:7.1-7.25
def $name(name) : nameIR =

   ;; ../../../../spec-concrete/2.0-domain.watsup:9.1-9.21
   clause 0(name) = t
      -- if name <: identifier
      -- let ``ID` t = name as identifier

   ;; ../../../../spec-concrete/2.0-domain.watsup:10.1-10.22
   clause 1(name) = t
      -- if name <: typeIdentifier
      -- let ``TID` t = name as typeIdentifier

   ;; ../../../../spec-concrete/2.0-domain.watsup:11.1-11.27
   clause 2(name) = "apply"
      -- if (name = `APPLY` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:12.1-12.23
   clause 3(name) = "key"
      -- if (name = `KEY` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:13.1-13.31
   clause 4(name) = "actions"
      -- if (name = `ACTIONS` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:14.1-14.27
   clause 5(name) = "state"
      -- if (name = `STATE` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:15.1-15.31
   clause 6(name) = "entries"
      -- if (name = `ENTRIES` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:16.1-16.25
   clause 7(name) = "type"
      -- if (name = `TYPE` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:17.1-17.33
   clause 8(name) = "priority"
      -- if (name = `PRIORITY` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:18.1-18.25
   clause 9(name) = "list"
      -- if name matches `LIST`

;; ../../../../spec-concrete/2.0-domain.watsup:20.1-20.47
def $tableCustomName(tableCustomName) : nameIR =

   ;; ../../../../spec-concrete/2.0-domain.watsup:22.1-22.32
   clause 0(tableCustomName) = t
      -- if tableCustomName <: identifier
      -- let ``ID` t = tableCustomName as identifier

   ;; ../../../../spec-concrete/2.0-domain.watsup:23.1-23.33
   clause 1(tableCustomName) = t
      -- if tableCustomName <: typeIdentifier
      -- let ``TID` t = tableCustomName as typeIdentifier

   ;; ../../../../spec-concrete/2.0-domain.watsup:24.1-24.38
   clause 2(tableCustomName) = "apply"
      -- if tableCustomName matches `APPLY`

   ;; ../../../../spec-concrete/2.0-domain.watsup:25.1-25.38
   clause 3(tableCustomName) = "state"
      -- if tableCustomName matches `STATE`

   ;; ../../../../spec-concrete/2.0-domain.watsup:26.1-26.36
   clause 4(tableCustomName) = "type"
      -- if tableCustomName matches `TYPE`

   ;; ../../../../spec-concrete/2.0-domain.watsup:27.1-27.44
   clause 5(tableCustomName) = "priority"
      -- if tableCustomName matches `PRIORITY`

;; ../../../../spec-concrete/2.0-domain.watsup:33.13-33.17
syntax id = text

;; ../../../../spec-concrete/2.0-domain.watsup:39.14-39.16
syntax tid = id

;; ../../../../spec-concrete/2.0-domain.watsup:41.1-41.23
def $fresh_tid : tid =

;; ../../../../spec-concrete/2.0-domain.watsup:42.1-42.28
def $fresh_tids(nat) : tid* =

   ;; ../../../../spec-concrete/2.0-domain.watsup:44.1-44.25
   clause 0(nat) = []
      -- if (nat = 0)

   ;; ../../../../spec-concrete/2.0-domain.watsup:45.1-46.15
   clause 1(n) = $fresh_tid :: $fresh_tids((n - 1))
      -- otherwise

;; ../../../../spec-concrete/2.0-domain.watsup:56.14-56.24
syntax pid = 
   | id `#` bool

;; ../../../../spec-concrete/2.0-domain.watsup:57.14-57.26
syntax rid = 
   | id `(` pid* `)`

;; ../../../../spec-concrete/2.0-domain.watsup:59.1-59.36
def $rid(name, parameterList) : rid =

   ;; ../../../../spec-concrete/2.0-domain.watsup:63.1-64.42
   clause 0(name, parameterList) = $name(name) `(` $pids(parameterList) `)`

;; ../../../../spec-concrete/2.0-domain.watsup:60.1-60.32
def $pids(parameterList) : pid* =

   ;; ../../../../spec-concrete/2.0-domain.watsup:66.1-66.24
   clause 0(parameterList) = []
      -- if parameterList matches ``EMPTY`

   ;; ../../../../spec-concrete/2.0-domain.watsup:67.1-67.39
   clause 1(parameterList) = [$pid(parameter)]
      -- if parameterList <: parameter
      -- let parameter = parameterList as parameter

   ;; ../../../../spec-concrete/2.0-domain.watsup:68.1-69.56
   clause 2(parameterList) = $pids(nonEmptyParameterList as parameterList) ++ [$pid(parameter)]
      -- if parameterList <: nonEmptyParameterList
      -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
      -- if nonEmptyParameterList' matches `%,%`
      -- let nonEmptyParameterList `,` parameter = nonEmptyParameterList'

;; ../../../../spec-concrete/2.0-domain.watsup:61.1-61.26
def $pid(parameter) : pid =

   ;; ../../../../spec-concrete/2.0-domain.watsup:71.1-71.51
   clause 0(_annotationList _direction _type name initializerOpt) = $name(name) `#` false
      -- if initializerOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/2.0-domain.watsup:72.1-72.55
   clause 1(_annotationList _direction _type name initializerOpt) = $name(name) `#` true
      -- if initializerOpt <: initializer
      -- let initializer = initializerOpt as initializer

;; ../../../../spec-concrete/2.0-domain.watsup:78.14-78.17
syntax cid = rid

;; ../../../../spec-concrete/2.0-domain.watsup:80.1-80.50
def $cid(name, constructorParameterListOpt) : cid =

   ;; ../../../../spec-concrete/2.0-domain.watsup:82.1-82.46
   clause 0(name, constructorParameterListOpt) = $name(name) `(` [] `)`
      -- if constructorParameterListOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/2.0-domain.watsup:83.1-84.42
   clause 1(name, constructorParameterListOpt) = $name(name) `(` $pids(parameterList) `)`
      -- if constructorParameterListOpt matches `(%)`
      -- let `(` parameterList `)` = constructorParameterListOpt

;; ../../../../spec-concrete/2.0-domain.watsup:88.1-88.48
def $expression_as_lvalue(expression) : lvalue? =

   ;; ../../../../spec-concrete/2.0-domain.watsup:90.1-90.69
   clause 0(expression) = ?(referenceExpression as lvalue)
      -- if expression <: referenceExpression
      -- let referenceExpression = expression as referenceExpression

   ;; ../../../../spec-concrete/2.0-domain.watsup:91.1-92.51
   clause 1(expression') = ?(lvalue `.` member)
      -- if expression' <: memberAccessExpression
      -- let memberAccessBase `.` member = expression' as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression = memberAccessBase as expression
      -- let lvalue'?{lvalue' <- lvalue'?} = $expression_as_lvalue(expression)
      -- if lvalue'?{lvalue' <- lvalue'?} matches (_)
      -- let ?(lvalue) = lvalue'?{lvalue' <- lvalue'?}

   ;; ../../../../spec-concrete/2.0-domain.watsup:93.1-94.51
   clause 2(expression') = ?(`(` lvalue `)`)
      -- if expression' <: parenthesizedExpression
      -- let `(` expression `)` = expression' as parenthesizedExpression
      -- let lvalue'?{lvalue' <- lvalue'?} = $expression_as_lvalue(expression)
      -- if lvalue'?{lvalue' <- lvalue'?} matches (_)
      -- let ?(lvalue) = lvalue'?{lvalue' <- lvalue'?}

;; ../../../../spec-concrete/2.0-domain.watsup:99.14-99.17
syntax oid = id*

;; ../../../../spec-concrete/2.1.1-value.watsup:14.1-17.15
syntax primitiveValue = 
   | `B` bool
   | `ERROR.` id
   | `MATCH_KIND.` id
   | `"` text `"`

;; ../../../../spec-concrete/2.1.1-value.watsup:24.1-25.21
syntax numberValue = 
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | nat `V` int `#` nat

;; ../../../../spec-concrete/2.1.1-value.watsup:27.20-27.50
syntax baseValue = 
   | `B` bool
   | `ERROR.` id
   | `MATCH_KIND.` id
   | `"` text `"`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | nat `V` int `#` nat

;; ../../../../spec-concrete/2.1.1-value.watsup:35.20-35.31
syntax listValue = 
   | `[` value* `]`

;; ../../../../spec-concrete/2.1.1-value.watsup:36.21-36.32
syntax tupleValue = 
   | `(` value* `)`

;; ../../../../spec-concrete/2.1.1-value.watsup:37.27-37.55
syntax headerStackValue = 
   | `[` value* `#(` nat `;` nat `)]`

;; ../../../../spec-concrete/2.1.1-value.watsup:39.21-39.32
syntax fieldValue = 
   | value id `;`

;; ../../../../spec-concrete/2.1.1-value.watsup:41.22-41.49
syntax structValue = 
   | `STRUCT` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:42.22-42.49
syntax headerValue = 
   | `HEADER` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:43.27-43.60
syntax headerUnionValue = 
   | `HEADER_UNION` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:46.1-47.23
syntax enumValue = 
   | tid `.` id
   | tid `.` id `#` value

;; ../../../../spec-concrete/2.1.1-value.watsup:50.1-56.14
syntax dataValue = 
   | `[` value* `]`
   | `(` value* `)`
   | `[` value* `#(` nat `;` nat `)]`
   | `STRUCT` tid `{` fieldValue* `}`
   | `HEADER` tid `{` fieldValue* `}`
   | `HEADER_UNION` tid `{` fieldValue* `}`
   | tid `.` id
   | tid `.` id `#` value

;; ../../../../spec-concrete/2.1.1-value.watsup:62.23-62.30
syntax defaultValue = 
   | `DEFAULT`

;; ../../../../spec-concrete/2.1.1-value.watsup:64.29-64.33
syntax invalidHeaderValue = 
   | `{#}`

;; ../../../../spec-concrete/2.1.1-value.watsup:67.1-68.28
syntax sequenceValue = 
   | `SEQ(` value* `)`
   | `SEQ(` value* `,...)`

;; ../../../../spec-concrete/2.1.1-value.watsup:71.1-72.36
syntax recordValue = 
   | `RECORD{` fieldValue* `}`
   | `RECORD{` fieldValue* `,...}`

;; ../../../../spec-concrete/2.1.1-value.watsup:75.1-77.29
syntax setValue = 
   | `SET{` value `}`
   | `SET{` value `&&&` value `}`
   | `SET{` value `..` value `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:80.1-81.38
syntax tableValue = 
   | `TABLE_ENUM` tid `.` id
   | `TABLE_STRUCT` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:84.1-89.15
syntax synthesizedValue = 
   | `DEFAULT`
   | `{#}`
   | `SEQ(` value* `)`
   | `SEQ(` value* `,...)`
   | `RECORD{` fieldValue* `}`
   | `RECORD{` fieldValue* `,...}`
   | `SET{` value `}`
   | `SET{` value `&&&` value `}`
   | `SET{` value `..` value `}`
   | `TABLE_ENUM` tid `.` id
   | `TABLE_STRUCT` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:95.31-95.37
syntax objectReferenceValue = 
   | `!` oid

;; ../../../../spec-concrete/2.1.1-value.watsup:102.1-105.25
syntax value = 
   | `B` bool
   | `ERROR.` id
   | `MATCH_KIND.` id
   | `"` text `"`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | nat `V` int `#` nat
   | `[` value* `]`
   | `(` value* `)`
   | `[` value* `#(` nat `;` nat `)]`
   | `STRUCT` tid `{` fieldValue* `}`
   | `HEADER` tid `{` fieldValue* `}`
   | `HEADER_UNION` tid `{` fieldValue* `}`
   | tid `.` id
   | tid `.` id `#` value
   | `DEFAULT`
   | `{#}`
   | `SEQ(` value* `)`
   | `SEQ(` value* `,...)`
   | `RECORD{` fieldValue* `}`
   | `RECORD{` fieldValue* `,...}`
   | `SET{` value `}`
   | `SET{` value `&&&` value `}`
   | `SET{` value `..` value `}`
   | `TABLE_ENUM` tid `.` id
   | `TABLE_STRUCT` tid `{` fieldValue* `}`
   | `!` oid

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:5.1-5.28
def $to_int(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:12.1-12.31
def $to_bitstr(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:18.1-18.28
def $to_number(value) : int =

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:20.1-20.24
   clause 0(value) = i
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i = number

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:21.1-21.38
   clause 1(value) = $to_int(w as int, i)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i = number

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:22.1-22.26
   clause 2(value) = i
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i = number

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:23.1-23.31
   clause 3(value) = i
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%V%#%`
      -- let w `V` i `#` _nat = numberValue

;; ../../../../spec-concrete/2.2.1-type.watsup:14.1-18.11
syntax primitiveTypeIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`

;; ../../../../spec-concrete/2.2.1-type.watsup:25.1-28.20
syntax numberTypeIR = 
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:30.21-30.51
syntax baseTypeIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:40.1-41.31
syntax namedTypeIR = 
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:52.1-53.20
syntax aliasTypeIR = 
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:59.21-59.37
syntax listTypeIR = 
   | `LIST<` typeIR `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:60.22-60.40
syntax tupleTypeIR = 
   | `TUPLE<` typeIR* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:61.28-61.43
syntax headerStackTypeIR = 
   | typeIR `[` nat `]`

;; ../../../../spec-concrete/2.2.1-type.watsup:63.22-63.34
syntax fieldTypeIR = 
   | typeIR id `;`

;; ../../../../spec-concrete/2.2.1-type.watsup:65.23-65.51
syntax structTypeIR = 
   | `STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:66.23-66.51
syntax headerTypeIR = 
   | `HEADER` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:67.28-67.62
syntax headerUnionTypeIR = 
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:69.23-69.37
syntax valueFieldIR = 
   | id `=` value `;`

;; ../../../../spec-concrete/2.2.1-type.watsup:72.1-73.42
syntax enumTypeIR = 
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:76.1-82.15
syntax dataTypeIR = 
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:92.3-92.40
syntax externObjectTypeIR = 
   | `EXTERN` tid map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/2.2.1-type.watsup:93.29-93.57
syntax parserObjectTypeIR = 
   | `PARSER(` parameterTypeIR* `)`

;; ../../../../spec-concrete/2.2.1-type.watsup:94.30-94.59
syntax controlObjectTypeIR = 
   | `CONTROL(` parameterTypeIR* `)`

;; ../../../../spec-concrete/2.2.1-type.watsup:95.30-95.50
syntax packageObjectTypeIR = 
   | `PACKAGE<` typeIR* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:96.28-96.47
syntax tableObjectTypeIR = 
   | `TABLE` tid `#` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:99.1-103.22
syntax objectTypeIR = 
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:106.1-108.17
syntax definedTypeIR = 
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:114.24-114.31
syntax defaultTypeIR = 
   | `DEFAULT`

;; ../../../../spec-concrete/2.2.1-type.watsup:116.30-116.44
syntax invalidHeaderTypeIR = 
   | `HEADER_INVALID`

;; ../../../../spec-concrete/2.2.1-type.watsup:119.1-120.29
syntax sequenceTypeIR = 
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`

;; ../../../../spec-concrete/2.2.1-type.watsup:123.1-124.37
syntax recordTypeIR = 
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`

;; ../../../../spec-concrete/2.2.1-type.watsup:126.20-126.36
syntax setTypeIR = 
   | `SET<` typeIR* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:129.1-130.39
syntax tableTypeIR = 
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:133.1-138.16
syntax synthesizedTypeIR = 
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:145.1-148.22
syntax typeIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:154.24-154.30
syntax monoTypeDefIR = typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:156.24-156.48
syntax polyTypeDefIR = 
   | typeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:158.20-158.49
syntax typeDefIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`
   | typeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:164.26-164.52
syntax parameterTypeIR = 
   | direction typeIR id value?

;; ../../../../spec-concrete/2.2.1-type.watsup:171.1-174.53
syntax functionTypeIR = 
   | `BUILTIN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `FUNCTION(` parameterTypeIR* `)->` typeIR
   | `ACTION(` parameterTypeIR* `)`
   | `EXTERN_FUNCTION(` parameterTypeIR* `)->` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:177.1-182.27
syntax methodTypeIR = 
   | `BUILTIN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHODABSTRACT(` parameterTypeIR* `)->` typeIR
   | `PARSER_APPLY(` parameterTypeIR* `)`
   | `CONTROL_APPLY(` parameterTypeIR* `)`
   | `TABLE_APPLY->` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:185.1-186.17
syntax routineTypeIR = 
   | `BUILTIN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `FUNCTION(` parameterTypeIR* `)->` typeIR
   | `ACTION(` parameterTypeIR* `)`
   | `EXTERN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `BUILTIN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHODABSTRACT(` parameterTypeIR* `)->` typeIR
   | `PARSER_APPLY(` parameterTypeIR* `)`
   | `CONTROL_APPLY(` parameterTypeIR* `)`
   | `TABLE_APPLY->` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:192.31-192.44
syntax monoRoutineTypeDefIR = routineTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:194.31-194.62
syntax polyRoutineTypeDefIR = 
   | routineTypeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:197.1-198.25
syntax routineTypeDefIR = 
   | `BUILTIN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `FUNCTION(` parameterTypeIR* `)->` typeIR
   | `ACTION(` parameterTypeIR* `)`
   | `EXTERN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `BUILTIN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHODABSTRACT(` parameterTypeIR* `)->` typeIR
   | `PARSER_APPLY(` parameterTypeIR* `)`
   | `CONTROL_APPLY(` parameterTypeIR* `)`
   | `TABLE_APPLY->` typeIR
   | routineTypeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:204.37-204.52
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:211.3-211.58
syntax constructorTypeIR = 
   | `CONSTRUCTOR(` constructorParameterTypeIR* `)->` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:217.31-217.66
syntax constructorTypeDefIR = 
   | constructorTypeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:9.1-9.34
def $is_baseTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:10.1-10.38
   clause 0(typeIR) = true
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:11.1-12.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:16.1-16.39
def $is_primitiveTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:17.1-17.48
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:18.1-19.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:21.1-21.35
def $is_void_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:22.1-22.33
   clause 0(typeIR) = true
      -- if (typeIR = `VOID` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:23.1-24.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:26.1-26.35
def $is_bool_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:27.1-27.33
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:28.1-29.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:31.1-31.36
def $is_error_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:32.1-32.35
   clause 0(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:33.1-34.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:36.1-36.40
def $is_matchkind_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:37.1-37.44
   clause 0(typeIR) = true
      -- if (typeIR = `MATCH_KIND` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:38.1-39.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:41.1-41.37
def $is_string_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:42.1-42.37
   clause 0(typeIR) = true
      -- if (typeIR = `STRING` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:43.1-44.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:48.1-48.36
def $is_numberTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:49.1-49.42
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:50.1-51.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:53.1-53.44
def $is_arbitrary_int_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:54.1-54.41
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:55.1-56.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:58.1-58.40
def $is_fixed_int_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:59.1-59.44
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:60.1-61.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:63.1-63.40
def $is_fixed_bit_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:64.1-64.44
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:65.1-66.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:78.1-78.36
def $is_objectTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:79.1-79.42
   clause 0(typeIR) = true
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:80.1-81.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:83.1-83.44
def $is_extern_object_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:84.1-84.48
   clause 0(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:85.1-86.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:88.1-88.45
def $is_package_object_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:89.1-89.53
   clause 0(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:90.1-91.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:95.1-95.41
def $is_synthesizedTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:96.1-96.52
   clause 0(typeIR) = true
      -- if typeIR <: synthesizedTypeIR
      -- let synthesizedTypeIR = typeIR as synthesizedTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:97.1-98.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:100.1-100.34
def $is_set_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:101.1-101.38
   clause 0(typeIR) = true
      -- if typeIR <: setTypeIR
      -- let `SET<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as setTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:102.1-103.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:5.16-5.24
syntax bound = set<tid>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:6.16-6.32
syntax theta = map<tid, typeIR>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:8.1-8.31
def $free_type(typeIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:27.1-27.38
   clause 0(typeIR) = `{` [] `}`
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:31.1-31.35
   clause 1(typeIR) = `{` [tid] `}`
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:33.1-36.59
   clause 2(typeIR') = $union_set<tid>(bound_base, bound_args)
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR `<` typeIR*{typeIR <- typeIR*} `>` = namedTypeIR
      -- let bound_base = $free_typeDef(polyTypeDefIR as typeDefIR)
      -- let bound_args = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:40.1-40.54
   clause 3(typeIR') = $free_type(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:42.1-42.51
   clause 4(typeIR') = $free_type(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:46.1-46.54
   clause 5(typeIR') = $free_type(typeIR)
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR `>` = typeIR' as listTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:48.1-49.42
   clause 6(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:51.1-51.51
   clause 7(typeIR') = $free_type(typeIR)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:53.1-54.42
   clause 8(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:56.1-57.42
   clause 9(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerUnionTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:59.1-60.42
   clause 10(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:62.1-62.41
   clause 11(typeIR) = `{` [] `}`
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:64.1-64.61
   clause 12(typeIR') = $free_type(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:68.1-69.62
   clause 13(typeIR) = $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*{routineTypeDefIR <- routineTypeDefIR*})
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid `{` _rid `:` routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} `}` = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:71.1-74.64
   clause 14(typeIR) = bound_params
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as parserObjectTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:76.1-79.64
   clause 15(typeIR) = bound_params
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as controlObjectTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:81.1-82.42
   clause 16(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as packageObjectTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:84.1-84.55
   clause 17(typeIR') = $free_type(typeIR)
      -- if typeIR' <: tableObjectTypeIR
      -- let `TABLE` _tid `#` typeIR = typeIR' as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:88.1-88.35
   clause 18(typeIR) = `{` [] `}`
      -- if (typeIR = `DEFAULT` as typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:90.1-90.42
   clause 19(typeIR) = `{` [] `}`
      -- if (typeIR = `HEADER_INVALID` as typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:92.1-93.42
   clause 20(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:95.1-96.42
   clause 21(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `,...>` = sequenceTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:98.1-99.42
   clause 22(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = recordTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:101.1-102.42
   clause 23(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `,...}` = recordTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:104.1-105.42
   clause 24(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:107.1-107.47
   clause 25(typeIR) = `{` [] `}`
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` _tid `{` _id*{_id <- _id*} `}` = tableTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:109.1-109.49
   clause 26(typeIR) = `{` [] `}`
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:9.1-9.37
def $free_typeDef(typeDefIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:115.1-115.47
   clause 0(typeDefIR) = $free_type(typeIR)
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:117.1-120.49
   clause 1(typeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = typeDefIR as polyTypeDefIR
      -- let bound_base = $free_typeDef(typeIR_base as typeDefIR)
      -- let bound_tparams = `{` tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} `}`

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:10.1-10.49
def $free_parameterType(parameterTypeIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:126.1-126.59
   clause 0(_direction typeIR _id _value?{_value <- _value?}) = $free_type(typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:11.1-11.45
def $free_routineType(routineTypeIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:132.1-138.43
   clause 0(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:140.1-146.43
   clause 1(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:148.1-153.64
   clause 2(routineTypeIR) = bound_params
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:155.1-161.43
   clause 3(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:163.1-169.43
   clause 4(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:171.1-177.43
   clause 5(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:179.1-185.43
   clause 6(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:187.1-192.64
   clause 7(routineTypeIR) = bound_params
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:194.1-199.64
   clause 8(routineTypeIR) = bound_params
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:201.1-205.43
   clause 9(routineTypeIR) = bound_ret
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_ret = methodTypeIR
      -- let bound_ret = $free_type(typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:12.1-12.51
def $free_routineTypeDef(routineTypeDefIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:211.1-212.37
   clause 0(routineTypeDefIR) = $free_routineType(routineTypeIR)
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:214.1-219.49
   clause 1(routineTypeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let bound_base = $free_routineTypeDef(routineTypeIR as routineTypeDefIR)
      -- let bound_tparams = `{` tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} `}`

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:14.1-14.40
def $subst_type(theta, typeIR) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:227.1-228.52
   clause 0(theta, typeIR') = typeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $find_map<tid, typeIR>(theta, tid)
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:230.1-234.53
   clause 1(theta, typeIR') = polyTypeDefIR_subst `<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR `<` typeIR*{typeIR <- typeIR*} `>` = namedTypeIR
      -- let typeDefIR = $subst_typeDef(theta, polyTypeDefIR as typeDefIR)
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR_subst = typeDefIR as polyTypeDefIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:238.1-240.50
   clause 2(theta, typeIR') = `TYPEDEF` tid typeIR_subst as typeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` tid typeIR = aliasTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:242.1-244.50
   clause 3(theta, typeIR') = `TYPE` tid typeIR_subst as typeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` tid typeIR = aliasTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:248.1-250.50
   clause 4(theta, typeIR') = `LIST<` typeIR_subst `>` as typeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR `>` = typeIR' as listTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:252.1-254.53
   clause 5(theta, typeIR') = `TUPLE<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:256.1-258.50
   clause 6(theta, typeIR') = typeIR_subst `[` n `]` as typeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n `]` = typeIR' as headerStackTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:260.1-265.57
   clause 7(theta, typeIR) = `STRUCT` tid `{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `}` as typeIR
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as structTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:267.1-272.57
   clause 8(theta, typeIR) = `HEADER` tid `{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `}` as typeIR
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:274.1-279.57
   clause 9(theta, typeIR) = `HEADER_UNION` tid `{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `}` as typeIR
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerUnionTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:281.1-286.50
   clause 10(theta, typeIR') = `ENUM` tid `#` typeIR_subst `{` valueFieldIR*{valueFieldIR <- valueFieldIR*} `}` as typeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` typeIR `{` valueFieldIR*{valueFieldIR <- valueFieldIR*} `}` = enumTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:290.1-296.59
   clause 11(theta, typeIR) = `EXTERN` tid `{` rid `:` routineTypeDefIR_subst*{rid <- rid*, routineTypeDefIR_subst <- routineTypeDefIR_subst*} `}` as typeIR
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` tid `{` rid `:` routineTypeDefIR*{rid <- rid*, routineTypeDefIR <- routineTypeDefIR*} `}` = typeIR as externObjectTypeIR
      -- (let routineTypeDefIR_subst = $subst_routineTypeDef(theta, routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*, routineTypeDefIR_subst <- routineTypeDefIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:298.1-301.57
   clause 12(theta, typeIR) = `PARSER(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as typeIR
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as parserObjectTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:303.1-306.57
   clause 13(theta, typeIR) = `CONTROL(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as typeIR
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as controlObjectTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:308.1-310.53
   clause 14(theta, typeIR') = `PACKAGE<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as packageObjectTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:312.1-314.50
   clause 15(theta, typeIR') = `TABLE` tid `#` typeIR_subst as typeIR
      -- if typeIR' <: tableObjectTypeIR
      -- let `TABLE` tid `#` typeIR = typeIR' as tableObjectTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:318.1-320.53
   clause 16(theta, typeIR') = `SEQ<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:322.1-324.53
   clause 17(theta, typeIR') = `SEQ<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `,...>` as typeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `,...>` = sequenceTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:326.1-331.57
   clause 18(theta, typeIR) = `RECORD{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `}` as typeIR
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = recordTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:333.1-338.57
   clause 19(theta, typeIR) = `RECORD{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `,...}` as typeIR
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `,...}` = recordTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:340.1-342.53
   clause 20(theta, typeIR') = `SET<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:346.1-347.15
   clause 21(theta, typeIR) = typeIR
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:15.1-15.49
def $subst_typeDef(theta, typeDefIR) : typeDefIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:353.1-353.63
   clause 0(theta, typeDefIR) = $subst_type(theta, typeIR) as typeDefIR
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:355.1-374.62
   clause 1(theta, typeDefIR) = typeIR_base_subst `<` tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} `,` tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} `>` as typeDefIR
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = typeDefIR as polyTypeDefIR
      -- let `{` tid_free*{tid_free <- tid_free*} `}` = $diff_set<tid>($free_type(typeIR_base), `{` tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} `}`)
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
      -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
      -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
      -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
      -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, `TID` tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
      -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, `TID` tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
      -- let typeIR_base_subst = $subst_type(theta'', typeIR_base)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:16.1-16.67
def $subst_parameterType(theta, parameterTypeIR) : parameterTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:380.1-382.50
   clause 0(theta, direction typeIR id value?{value <- value?}) = direction typeIR_subst id value?{value <- value?}
      -- let typeIR_subst = $subst_type(theta, typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:17.1-17.61
def $subst_routineType(theta, routineTypeIR) : routineTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:388.1-395.58
   clause 0(theta, routineTypeIR) = `BUILTIN_FUNCTION(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:397.1-404.58
   clause 1(theta, routineTypeIR) = `FUNCTION(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:406.1-412.57
   clause 2(theta, routineTypeIR) = `ACTION(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:414.1-421.58
   clause 3(theta, routineTypeIR) = `EXTERN_FUNCTION(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:423.1-430.58
   clause 4(theta, routineTypeIR) = `BUILTIN_METHOD(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:432.1-439.58
   clause 5(theta, routineTypeIR) = `EXTERN_METHOD(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:441.1-448.58
   clause 6(theta, routineTypeIR) = `EXTERN_METHODABSTRACT(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:450.1-456.57
   clause 7(theta, routineTypeIR) = `PARSER_APPLY(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:458.1-464.57
   clause 8(theta, routineTypeIR) = `CONTROL_APPLY(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:466.1-471.58
   clause 9(theta, routineTypeIR) = `TABLE_APPLY->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_ret = methodTypeIR
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:18.1-18.70
def $subst_routineTypeDef(theta, routineTypeDefIR) : routineTypeDefIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:477.1-478.45
   clause 0(theta, routineTypeDefIR) = $subst_routineType(theta, routineTypeIR) as routineTypeDefIR
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:480.1-499.73
   clause 1(theta, routineTypeDefIR) = routineTypeIR_subst `<` tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} `,` tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} `>` as routineTypeDefIR
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let `{` tid_free*{tid_free <- tid_free*} `}` = $diff_set<tid>($free_routineType(routineTypeIR), `{` tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} `}`)
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
      -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
      -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
      -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
      -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, `TID` tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
      -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, `TID` tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
      -- let routineTypeIR_subst = $subst_routineType(theta'', routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:19.1-19.73
def $subst_constructorType(theta, constructorTypeIR) : constructorTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:505.1-512.58
   clause 0(theta, `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_obj) = `CONSTRUCTOR(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_obj_subst
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_obj_subst = $subst_type(theta, typeIR_obj)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:522.1-522.53
def $specialize_typeDef(typeDefIR, typeIR*) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:524.1-524.46
   clause 0(typeDefIR, typeIR'*{typeIR' <- typeIR'*}) = typeIR
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches []

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:526.1-529.49
   clause 1(typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $subst_type(theta, typeIR_base)
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = typeDefIR as polyTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- let theta = `{` tid_tparam `:` typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} `}`

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:535.1-536.29
def $specialize_routineTypeDef(routineTypeDefIR, typeIR*) : (routineTypeDefIR, tid*) =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:538.1-539.25
   clause 0(routineTypeDefIR, typeIR*{typeIR <- typeIR*}) = (routineTypeIR as routineTypeDefIR, [])
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches []

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:541.1-548.49
   clause 1(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR) as routineTypeDefIR, [])
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
      -- let theta = `{` tid_tparam `:` typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} `}`

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:550.1-558.54
   clause 2(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
      -- let theta = `{` tid_tparam `:` `TID` tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} `}`

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:560.1-571.53
   clause 3(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ `TID` tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
      -- let theta = `{` tid_tparam `:` typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} `}`

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:577.1-578.30
def $specialize_constructorTypeDef(constructorTypeDefIR, typeIR*) : (constructorTypeIR, tid*) =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:580.1-589.57
   clause 0(constructorTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>`, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, [])
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
      -- let theta = `{` tid_tparam `:` typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} `}`
      -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:591.1-601.57
   clause 1(constructorTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>`, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
      -- let theta = `{` tid_tparam `:` `TID` tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} `}`
      -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:603.1-616.57
   clause 2(constructorTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>`, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ `TID` tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
      -- let theta = `{` tid_tparam `:` typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} `}`
      -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:623.1-623.28
def $canon(typeIR) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:625.1-626.65
   clause 0(typeIR') = $canon(typeIR)
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR
      -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:628.1-628.46
   clause 1(typeIR') = $canon(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:630.1-631.15
   clause 2(typeIR) = typeIR
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:7.1-7.38
def $is_nominal_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:10.1-11.40
   clause 0(typeIR) = $is_nominal_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:8.1-8.39
def $is_nominal_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:12.1-12.41
   clause 0(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:13.1-13.48
   clause 1(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:14.1-14.48
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:15.1-15.54
   clause 3(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:16.1-16.46
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:17.1-17.51
   clause 5(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:18.1-18.43
   clause 6(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:19.1-19.45
   clause 7(typeIR) = true
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:20.1-21.15
   clause 8(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:25.1-25.42
def $is_defaultable_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:28.1-29.44
   clause 0(typeIR) = $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:26.1-26.43
def $is_defaultable_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:30.1-30.41
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:31.1-31.42
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:32.1-32.43
   clause 2(typeIR) = true
      -- if (typeIR = `STRING` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:33.1-33.49
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:34.1-35.35
   clause 4(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:36.1-37.40
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:38.1-39.35
   clause 6(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:40.1-41.40
   clause 7(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:42.1-43.40
   clause 8(typeIR') = true
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:44.1-45.40
   clause 9(typeIR') = true
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerUnionTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:46.1-46.50
   clause 10(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:47.1-48.35
   clause 11(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:49.1-50.15
   clause 12(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:54.1-54.40
def $is_equalable_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:57.1-58.42
   clause 0(typeIR) = $is_equalable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:55.1-55.41
def $is_equalable_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:59.1-59.40
   clause 0(typeIR) = false
      -- if (typeIR = `VOID` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:60.1-60.43
   clause 1(typeIR) = false
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:61.1-61.46
   clause 2(typeIR) = false
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:62.1-62.49
   clause 3(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:63.1-63.50
   clause 4(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:64.1-64.50
   clause 5(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:65.1-65.48
   clause 6(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:66.1-66.43
   clause 7(typeIR) = false
      -- if (typeIR = `DEFAULT` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:67.1-67.54
   clause 8(typeIR) = false
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` _typeIR*{_typeIR <- _typeIR*} `,...>` = sequenceTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:68.1-68.57
   clause 9(typeIR) = false
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `,...}` = recordTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:69.1-69.50
   clause 10(typeIR) = false
      -- if (typeIR = `HEADER_INVALID` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:70.1-70.46
   clause 11(typeIR) = false
      -- if typeIR <: setTypeIR
      -- let `SET<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as setTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:71.1-71.55
   clause 12(typeIR) = false
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` _tid `{` _id*{_id <- _id*} `}` = tableTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:72.1-72.57
   clause 13(typeIR) = false
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:73.1-74.15
   clause 14(typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:5.1-7.20
relation Type_alpha: typeIR `~~` typeIR

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:27.1-28.27
   rule basetype: typeIR `~~` typeIR'
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR
      -- if typeIR' <: baseTypeIR
      -- let baseTypeIR' = typeIR' as baseTypeIR
      -- if (baseTypeIR = baseTypeIR')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:32.1-33.26
   rule nametype: typeIR `~~` typeIR'
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `TID%`
      -- let `TID` tid' = namedTypeIR'
      -- if (tid = tid')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:35.1-43.41
   rule spectype-nominal: typeIR `~~` typeIR'
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_a `<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_b `<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = namedTypeIR'
      -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
      -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
      -- if Type_alpha: typeIR_a_spec `~~` typeIR_b_spec holds
      -- if ($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:45.1-52.46
   rule spectype-structural: typeIR `~~` typeIR'
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_a `<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_b `<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = namedTypeIR'
      -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
      -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
      -- if Type_alpha: typeIR_a_spec `~~` typeIR_b_spec holds
      -- if (~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:56.1-58.38
   rule typedeftype-left: typeIR `~~` typeIR_b
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR_a = aliasTypeIR
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:60.1-62.38
   rule typedeftype-right: typeIR_a `~~` typeIR
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR_b = aliasTypeIR
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:64.1-66.38
   rule newtype: typeIR `~~` typeIR'
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` tid typeIR_a = aliasTypeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR' = typeIR' as aliasTypeIR
      -- if aliasTypeIR' matches `TYPE%%`
      -- let `TYPE` tid' typeIR_b = aliasTypeIR'
      -- if (tid = tid')
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:70.1-72.38
   rule listtype: typeIR `~~` typeIR'
      -- if typeIR <: listTypeIR
      -- let `LIST<` typeIR_a `>` = typeIR as listTypeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR_b `>` = typeIR' as listTypeIR
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:74.1-76.41
   rule tupletype: typeIR `~~` typeIR'
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = typeIR as tupleTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:78.1-80.38
   rule stacktype: typeIR `~~` typeIR'
      -- if typeIR <: headerStackTypeIR
      -- let typeIR_a `[` n_s `]` = typeIR as headerStackTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_s' `]` = typeIR' as headerStackTypeIR
      -- if (n_s = n_s')
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:82.1-85.45
   rule structtype: typeIR `~~` typeIR'
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_f_a id_f `;`*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} `}` = typeIR as structTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` tid' `{` typeIR_f_b id_f' `;`*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} `}` = typeIR' as structTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a `~~` typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:87.1-90.45
   rule headertype: typeIR `~~` typeIR'
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_f_a id_f `;`*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} `}` = typeIR as headerTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` tid' `{` typeIR_f_b id_f' `;`*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} `}` = typeIR' as headerTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a `~~` typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:92.1-95.45
   rule headeruniontype: typeIR `~~` typeIR'
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` tid `{` typeIR_f_a id_f `;`*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} `}` = typeIR as headerUnionTypeIR
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` tid' `{` typeIR_f_b id_f' `;`*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} `}` = typeIR' as headerUnionTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a `~~` typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:97.1-98.49
   rule enumtype: typeIR `~~` typeIR'
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` tid `{` id_f*{id_f <- id_f*} `}` = enumTypeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR' = typeIR' as enumTypeIR
      -- if enumTypeIR' matches `ENUM%{%}`
      -- let `ENUM` tid' `{` id_f'*{id_f' <- id_f'*} `}` = enumTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:100.1-103.38
   rule serenumtype: typeIR `~~` typeIR'
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` typeIR_a `{` id_f `=` value_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = enumTypeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR' = typeIR' as enumTypeIR
      -- if enumTypeIR' matches `ENUM%#%{%}`
      -- let `ENUM` tid' `#` typeIR_b `{` id_f' `=` value_f' `;`*{id_f' <- id_f'*, value_f' <- value_f'*} `}` = enumTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if (value_f = value_f'))*{value_f <- value_f*, value_f' <- value_f'*}
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:107.1-119.73
   rule externtype: typeIR `~~` typeIR'
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` tid `{` rid_a `:` routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} `}` = typeIR as externObjectTypeIR
      -- if typeIR' <: externObjectTypeIR
      -- let `EXTERN` tid' `{` rid_b `:` routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} `}` = typeIR' as externObjectTypeIR
      -- if (tid = tid')
      -- if $eq_set<rid>(`{` rid_a*{rid_a <- rid_a*} `}`, `{` rid_b*{rid_b <- rid_b*} `}`)
      -- (let routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} = $find_map<rid, routineTypeDefIR>(`{` rid_a `:` routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} `}`, rid_a))*{rid_a <- rid_a*, routineTypeDefIR? <- routineTypeDefIR?*}
      -- (if routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} matches (_))*{routineTypeDefIR? <- routineTypeDefIR?*}
      -- (let ?(routineTypeDefIR_a') = routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?})*{routineTypeDefIR? <- routineTypeDefIR?*, routineTypeDefIR_a' <- routineTypeDefIR_a'*}
      -- (let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_map<rid, routineTypeDefIR>(`{` rid_b `:` routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} `}`, rid_a))*{rid_a <- rid_a*, routineTypeDefIR'? <- routineTypeDefIR'?*}
      -- (if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_))*{routineTypeDefIR'? <- routineTypeDefIR'?*}
      -- (let ?(routineTypeDefIR_b') = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?})*{routineTypeDefIR'? <- routineTypeDefIR'?*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}
      -- (if RoutineTypeDef_alpha: routineTypeDefIR_a' `~~` routineTypeDefIR_b' holds)*{routineTypeDefIR_a' <- routineTypeDefIR_a'*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:121.1-123.68
   rule parsertype: typeIR `~~` typeIR'
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = typeIR as parserObjectTypeIR
      -- if typeIR' <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = typeIR' as parserObjectTypeIR
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:125.1-127.68
   rule controltype: typeIR `~~` typeIR'
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = typeIR as controlObjectTypeIR
      -- if typeIR' <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = typeIR' as controlObjectTypeIR
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:129.1-131.41
   rule packagetype: typeIR `~~` typeIR'
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = typeIR as packageObjectTypeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as packageObjectTypeIR
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:133.1-135.38
   rule tabletype: typeIR `~~` typeIR'
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` tid `#` typeIR_a = typeIR as tableObjectTypeIR
      -- if typeIR' <: tableObjectTypeIR
      -- let `TABLE` tid' `#` typeIR_b = typeIR' as tableObjectTypeIR
      -- if (tid = tid')
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:139.1-140.21
   rule defaulttype: typeIR `~~` typeIR'
      -- if (typeIR = `DEFAULT` as typeIR)
      -- if (typeIR' = `DEFAULT` as typeIR)

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:142.1-144.41
   rule sequencetype: typeIR `~~` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SEQ<%>`
      -- let `SEQ<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = sequenceTypeIR'
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:146.1-148.41
   rule sequencedefaulttype: typeIR `~~` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_b*{typeIR_b <- typeIR_b*} `,...>` = sequenceTypeIR'
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:150.1-152.41
   rule recordtype: typeIR `~~` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id `;`*{id <- id*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR' = typeIR' as recordTypeIR
      -- if recordTypeIR' matches `RECORD{%}`
      -- let `RECORD{` typeIR_b id' `;`*{id' <- id'*, typeIR_b <- typeIR_b*} `}` = recordTypeIR'
      -- (if (id = id'))*{id <- id*, id' <- id'*}
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:154.1-157.41
   rule recorddefaulttype: typeIR `~~` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id `;`*{id <- id*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR' = typeIR' as recordTypeIR
      -- if recordTypeIR' matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_b id' `;`*{id' <- id'*, typeIR_b <- typeIR_b*} `,...}` = recordTypeIR'
      -- (if (id = id'))*{id <- id*, id' <- id'*}
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:159.1-160.35
   rule invalidtype: typeIR `~~` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if (typeIR' = `HEADER_INVALID` as typeIR)

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:162.1-164.38
   rule settype: typeIR' `~~` typeIR'''
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_a] = typeIR*{typeIR <- typeIR*}
      -- if typeIR''' <: setTypeIR
      -- let `SET<` typeIR''*{typeIR'' <- typeIR''*} `>` = typeIR''' as setTypeIR
      -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
      -- let [typeIR_b] = typeIR''*{typeIR'' <- typeIR''*}
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:166.1-167.61
   rule tableenumtype: typeIR `~~` typeIR'
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` tid `{` id_f*{id_f <- id_f*} `}` = tableTypeIR
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR' = typeIR' as tableTypeIR
      -- if tableTypeIR' matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` tid' `{` id_f'*{id_f' <- id_f'*} `}` = tableTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:169.1-172.45
   rule tablestructtype: typeIR `~~` typeIR'
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` tid `{` typeIR_f_a id_f `;`*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} `}` = tableTypeIR
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR' = typeIR' as tableTypeIR
      -- if tableTypeIR' matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` tid' `{` typeIR_f_b id_f' `;`*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} `}` = tableTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a `~~` typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:9.1-11.20
relation ParameterType_alpha: parameterTypeIR `~~` parameterTypeIR

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:178.1-180.38
   rule : _direction typeIR_a _id _value?{_value <- _value?} `~~` _direction' typeIR_b _id' _value'?{_value' <- _value'?}
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:13.1-15.20
relation RoutineType_alpha: routineTypeIR `~~` routineTypeIR

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:186.1-190.46
   rule builtinfunction: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:192.1-196.46
   rule function: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:198.1-200.68
   rule action: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:202.1-206.46
   rule externfunction: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:208.1-212.46
   rule builtinmethod: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:214.1-218.46
   rule externmethod: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:220.1-224.46
   rule externmethod-abstract: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:226.1-229.68
   rule parserapply: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:231.1-234.68
   rule controlapply: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:236.1-239.46
   rule tableapply: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_ret_b = methodTypeIR'
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:17.1-19.20
relation RoutineTypeDef_alpha: routineTypeDefIR `~~` routineTypeDefIR

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:245.1-247.59
   rule mono: routineTypeDefIR `~~` routineTypeDefIR'
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR_a = routineTypeDefIR as routineTypeIR
      -- if routineTypeDefIR' <: routineTypeIR
      -- let routineTypeIR_b = routineTypeDefIR' as routineTypeIR
      -- if RoutineType_alpha: routineTypeIR_a `~~` routineTypeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:249.1-268.71
   rule poly: routineTypeDefIR `~~` routineTypeDefIR'
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR_a `<` tid_a*{tid_a <- tid_a*} `,` tid_hidden_a*{tid_hidden_a <- tid_hidden_a*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR_b `<` tid_b*{tid_b <- tid_b*} `,` tid_hidden_b*{tid_hidden_b <- tid_hidden_b*} `>` = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if (|tid_a*{tid_a <- tid_a*}| = |tid_b*{tid_b <- tid_b*}|)
      -- if (|tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}| = |tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}|)
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids((|tid_a*{tid_a <- tid_a*}| + |tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}|))
      -- let tid_a'*{tid_a' <- tid_a'*} = tid_a*{tid_a <- tid_a*} ++ tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}
      -- let theta_a = `{` tid_a' `:` `TID` tid_fresh as typeIR*{tid_a' <- tid_a'*, tid_fresh <- tid_fresh*} `}`
      -- let routineTypeIR_a_subst = $subst_routineType(theta_a, routineTypeIR_a)
      -- let tid_b'*{tid_b' <- tid_b'*} = tid_b*{tid_b <- tid_b*} ++ tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}
      -- let theta_b = `{` tid_b' `:` `TID` tid_fresh as typeIR*{tid_b' <- tid_b'*, tid_fresh <- tid_fresh*} `}`
      -- let routineTypeIR_b_subst = $subst_routineType(theta_b, routineTypeIR_b)
      -- if RoutineType_alpha: routineTypeIR_a_subst `~~` routineTypeIR_b_subst holds

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:5.14-5.30
syntax ctk = 
   | `LCTK`
   | `CTK`
   | `DYN`

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:7.1-7.30
def $join_ctk(ctk, ctk) : ctk =

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:9.1-9.33
   clause 0(ctk, ctk') = `LCTK`
      -- if ctk matches `LCTK`
      -- if ctk' matches `LCTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:10.1-10.31
   clause 1(ctk, ctk') = `CTK`
      -- if ctk matches `LCTK`
      -- if ctk' matches `CTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:11.1-11.31
   clause 2(ctk, ctk') = `CTK`
      -- if ctk matches `CTK`
      -- if ctk' matches `LCTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:12.1-12.30
   clause 3(ctk, ctk') = `CTK`
      -- if ctk matches `CTK`
      -- if ctk' matches `CTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:13.1-14.15
   clause 4(ctk_a, ctk_b) = `DYN`
      -- otherwise

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:16.1-16.27
def $joins_ctk(ctk*) : ctk =

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:18.1-18.26
   clause 0(ctk*{ctk <- ctk*}) = `DYN`
      -- if ctk*{ctk <- ctk*} matches []

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:19.1-19.26
   clause 1(ctk'*{ctk' <- ctk'*}) = ctk
      -- if ctk'*{ctk' <- ctk'*} matches [ _/1 ]
      -- let [ctk] = ctk'*{ctk' <- ctk'*}

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:20.1-20.57
   clause 2(ctk'*{ctk' <- ctk'*}) = $join_ctk(ctk_a, ctk_b)
      -- if ctk'*{ctk' <- ctk'*} matches _ :: _
      -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
      -- if ctk*{ctk <- ctk*} matches [ _/1 ]
      -- let [ctk_b] = ctk*{ctk <- ctk*}

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:21.1-22.40
   clause 3(ctk'*{ctk' <- ctk'*}) = $joins_ctk(ctk_d :: ctk_c*{ctk_c <- ctk_c*})
      -- if ctk'*{ctk' <- ctk'*} matches _ :: _
      -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
      -- if ctk*{ctk <- ctk*} matches _ :: _
      -- let ctk_b :: ctk_c*{ctk_c <- ctk_c*} = ctk*{ctk <- ctk*}
      -- let ctk_d = $join_ctk(ctk_a, ctk_b)

;; ../../../../spec-concrete/3-numerics.watsup:5.1-5.21
def $pow2(nat) : int =

;; ../../../../spec-concrete/3-numerics.watsup:7.1-7.25
def $shl(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:8.1-8.25
def $shr(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:9.1-9.36
def $shr_arith(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:11.1-11.21
def $bneg(int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:12.1-12.26
def $band(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:13.1-13.26
def $bxor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:14.1-14.25
def $bor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:16.1-16.33
def $bitacc(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:24.1-24.28
def $un_bnot(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:26.1-27.22
   clause 0(value) = w `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i = number
      -- let i' = $bneg(i)

;; ../../../../spec-concrete/3-numerics.watsup:31.1-31.28
def $un_lnot(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:33.1-33.27
   clause 0(value) = `B` ~b as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b = primitiveValue

;; ../../../../spec-concrete/3-numerics.watsup:37.1-37.28
def $un_plus(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:39.1-39.24
   clause 0(value) = `D` i as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i = number

   ;; ../../../../spec-concrete/3-numerics.watsup:40.1-40.28
   clause 1(value) = w `W` i as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i = number

   ;; ../../../../spec-concrete/3-numerics.watsup:41.1-41.28
   clause 2(value) = w `S` i as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i = number

;; ../../../../spec-concrete/3-numerics.watsup:45.1-45.29
def $un_minus(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:47.1-47.29
   clause 0(value) = `D` -i as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i = number

   ;; ../../../../spec-concrete/3-numerics.watsup:48.1-49.29
   clause 1(value) = w `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i = number
      -- let i' = ($pow2(w) - i)

   ;; ../../../../spec-concrete/3-numerics.watsup:50.1-51.46
   clause 2(value) = w `S` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i = number
      -- let i' = $to_bitstr(w as int, $to_int(w as int, -i))

;; ../../../../spec-concrete/3-numerics.watsup:59.1-59.36
def $bin_plus(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:61.1-61.45
   clause 0(value, value') = `D` (i_l + i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:62.1-65.43
   clause 1(value, value') = w `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:66.1-69.43
   clause 2(value, value') = w `S` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:84.1-87.43
   clause 3(value, value') = w `S` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:102.1-105.43
   clause 4(value, value') = w `S` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:73.1-73.39
def $bin_satplus(value, value) : value =

;; ../../../../spec-concrete/3-numerics.watsup:77.1-77.37
def $bin_minus(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:79.1-79.46
   clause 0(value, value') = `D` (i_l - i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:80.1-83.43
   clause 1(value, value') = w `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:98.1-101.43
   clause 2(value, value') = w `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:91.1-91.40
def $bin_satminus(value, value) : value =

;; ../../../../spec-concrete/3-numerics.watsup:95.1-95.35
def $bin_mul(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:97.1-97.44
   clause 0(value, value') = `D` (i_l * i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

;; ../../../../spec-concrete/3-numerics.watsup:109.1-109.35
def $bin_div(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:111.1-111.44
   clause 0(value, value') = `D` (i_l / i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

;; ../../../../spec-concrete/3-numerics.watsup:115.1-115.35
def $bin_mod(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:117.1-117.44
   clause 0(value, value') = `D` (i_l \ i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

;; ../../../../spec-concrete/3-numerics.watsup:121.1-121.35
def $bin_shl(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:123.1-123.46
   clause 0(value, value') = `D` $shl(i_l, i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:124.1-124.50
   clause 1(value, value') = `D` $shl(i_l, i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r `W` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:125.1-126.33
   clause 2(value, value') = `D` $shl(i_l, i_r') as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r `S` i_r = number'
      -- let i_r' = $to_int(w_r as int, i_r)

   ;; ../../../../spec-concrete/3-numerics.watsup:128.1-129.49
   clause 3(value, value') = $bin_shl(w_l `W` i_l as value, w_l `W` $to_int(w_l as int, i_r) as value)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:130.1-131.45
   clause 4(value, value') = w_l `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r `W` i_r = number'
      -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:132.1-134.46
   clause 5(value, value') = w_l `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r `S` i_r = number'
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:136.1-137.49
   clause 6(value, value') = $bin_shl(w_l `S` i_l as value, w_l `S` $to_int(w_l as int, i_r) as value)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:138.1-140.46
   clause 7(value, value') = w_l `S` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r `W` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:141.1-144.47
   clause 8(value, value') = w_l `S` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r `S` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:148.1-148.35
def $bin_shr(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:150.1-150.46
   clause 0(value, value') = `D` $shr(i_l, i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:151.1-151.50
   clause 1(value, value') = `D` $shr(i_l, i_r) as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r `W` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:152.1-153.33
   clause 2(value, value') = `D` $shr(i_l, i_r') as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r `S` i_r = number'
      -- let i_r' = $to_int(w_r as int, i_r)

   ;; ../../../../spec-concrete/3-numerics.watsup:155.1-156.49
   clause 3(value, value') = $bin_shr(w_l `W` i_l as value, w_l `W` $to_int(w_l as int, i_r) as value)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:157.1-158.45
   clause 4(value, value') = w_l `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r `W` i_r = number'
      -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:159.1-161.46
   clause 5(value, value') = w_l `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r `S` i_r = number'
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:163.1-167.34
   clause 6(value, value') = w_l `S` i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:168.1-172.34
   clause 7(value, value') = w_l `S` i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:173.1-177.34
   clause 8(value, value') = w_l `S` i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r `W` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:178.1-182.34
   clause 9(value, value') = w_l `S` i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r `W` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:183.1-188.34
   clause 10(value, value') = w_l `S` i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r `S` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:189.1-194.34
   clause 11(value, value') = w_l `S` i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r `S` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

;; ../../../../spec-concrete/3-numerics.watsup:198.1-198.33
def $bin_le(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:200.1-200.42
   clause 0(value, value') = (i_l <= i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:201.1-201.46
   clause 1(value, value') = (i_l <= i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:202.1-204.31
   clause 2(value, value') = (i_l' <= i_r')
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:208.1-208.33
def $bin_ge(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:210.1-210.42
   clause 0(value, value') = (i_l >= i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:211.1-211.46
   clause 1(value, value') = (i_l >= i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:212.1-214.31
   clause 2(value, value') = (i_l' >= i_r')
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:218.1-218.33
def $bin_lt(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:220.1-220.41
   clause 0(value, value') = (i_l < i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:221.1-221.45
   clause 1(value, value') = (i_l < i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:222.1-224.31
   clause 2(value, value') = (i_l' < i_r')
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:228.1-228.33
def $bin_gt(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:230.1-230.41
   clause 0(value, value') = (i_l > i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_r = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:231.1-231.45
   clause 1(value, value') = (i_l > i_r)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:232.1-234.31
   clause 2(value, value') = (i_l' > i_r')
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:238.1-238.33
def $bin_eq(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:242.1-243.42
   clause 0(value, value') = (primitiveValue_a = primitiveValue_b)
      -- if value <: primitiveValue
      -- let primitiveValue_a = value as primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue_b = value' as primitiveValue

   ;; ../../../../spec-concrete/3-numerics.watsup:245.1-245.40
   clause 1(value, value') = (i_a = i_b)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i_a = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `D%`
      -- let `D` i_b = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:246.1-246.63
   clause 2(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_a `W` i_a = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_b `W` i_b = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:247.1-247.63
   clause 3(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_a `S` i_a = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_b `S` i_b = number'

   ;; ../../../../spec-concrete/3-numerics.watsup:248.1-248.73
   clause 4(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%V%#%`
      -- let w_a `V` i_a `#` _nat = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%V%#%`
      -- let w_b `V` i_b `#` _nat' = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:250.1-251.33
   clause 5(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
      -- if value <: listValue
      -- let `[` value_a*{value_a <- value_a*} `]` = value as listValue
      -- if value' <: listValue
      -- let `[` value_b*{value_b <- value_b*} `]` = value' as listValue

   ;; ../../../../spec-concrete/3-numerics.watsup:252.1-253.33
   clause 6(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
      -- if value <: tupleValue
      -- let `(` value_a*{value_a <- value_a*} `)` = value as tupleValue
      -- if value' <: tupleValue
      -- let `(` value_b*{value_b <- value_b*} `)` = value' as tupleValue

   ;; ../../../../spec-concrete/3-numerics.watsup:254.1-255.52
   clause 7(value, value') = ($bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*}) /\ (n_s_a = n_s_b))
      -- if value <: headerStackValue
      -- let `[` value_a*{value_a <- value_a*} `#(` _nat `;` n_s_a `)]` = value as headerStackValue
      -- if value' <: headerStackValue
      -- let `[` value_b*{value_b <- value_b*} `#(` _nat' `;` n_s_b `)]` = value' as headerStackValue

   ;; ../../../../spec-concrete/3-numerics.watsup:256.1-261.67
   clause 8(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: structValue
      -- let `STRUCT` tid_a `{` value_f_a id_f_a `;`*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} `}` = value as structValue
      -- if value' <: structValue
      -- let `STRUCT` tid_b `{` value_f_b id_f_b `;`*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} `}` = value' as structValue

   ;; ../../../../spec-concrete/3-numerics.watsup:262.1-267.67
   clause 9(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: headerValue
      -- let `HEADER` tid_a `{` value_f_a id_f_a `;`*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} `}` = value as headerValue
      -- if value' <: headerValue
      -- let `HEADER` tid_b `{` value_f_b id_f_b `;`*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} `}` = value' as headerValue

   ;; ../../../../spec-concrete/3-numerics.watsup:268.1-273.67
   clause 10(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: headerUnionValue
      -- let `HEADER_UNION` tid_a `{` value_f_a id_f_a `;`*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} `}` = value as headerUnionValue
      -- if value' <: headerUnionValue
      -- let `HEADER_UNION` tid_b `{` value_f_b id_f_b `;`*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} `}` = value' as headerUnionValue

   ;; ../../../../spec-concrete/3-numerics.watsup:274.1-275.41
   clause 11(value, value') = ((tid_a = tid_b) /\ (id_f_a = id_f_b))
      -- if value <: enumValue
      -- let enumValue = value as enumValue
      -- if enumValue matches `%.%`
      -- let tid_a `.` id_f_a = enumValue
      -- if value' <: enumValue
      -- let enumValue' = value' as enumValue
      -- if enumValue' matches `%.%`
      -- let tid_b `.` id_f_b = enumValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:276.1-277.74
   clause 12(value, value') = (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))
      -- if value <: enumValue
      -- let enumValue = value as enumValue
      -- if enumValue matches `%.%#%`
      -- let tid_a `.` id_f_a `#` value_f_a = enumValue
      -- if value' <: enumValue
      -- let enumValue' = value' as enumValue
      -- if enumValue' matches `%.%#%`
      -- let tid_b `.` id_f_b `#` value_f_b = enumValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:278.1-278.31
   clause 13(value, value') = true
      -- if (value = `{#}` as value)
      -- if (value' = `{#}` as value)

;; ../../../../spec-concrete/3-numerics.watsup:239.1-239.36
def $bin_eqs(value*, value*) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:280.1-280.30
   clause 0(value*{value <- value*}, value'*{value' <- value'*}) = true
      -- if value*{value <- value*} matches []
      -- if value'*{value' <- value'*} matches []

   ;; ../../../../spec-concrete/3-numerics.watsup:281.1-281.34
   clause 1(value*{value <- value*}, value'*{value' <- value'*}) = false
      -- if value*{value <- value*} matches []
      -- if value'*{value' <- value'*} matches _ :: _
      -- let _value :: _value'*{_value' <- _value'*} = value'*{value' <- value'*}

   ;; ../../../../spec-concrete/3-numerics.watsup:282.1-282.34
   clause 2(value*{value <- value*}, value'*{value' <- value'*}) = false
      -- if value*{value <- value*} matches _ :: _
      -- let _value :: _value'*{_value' <- _value'*} = value*{value <- value*}
      -- if value'*{value' <- value'*} matches []

   ;; ../../../../spec-concrete/3-numerics.watsup:283.1-284.70
   clause 3(value*{value <- value*}, value'*{value' <- value'*}) = ($bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*{value_a_t <- value_a_t*}, value_b_t*{value_b_t <- value_b_t*}))
      -- if value*{value <- value*} matches _ :: _
      -- let value_a_h :: value_a_t*{value_a_t <- value_a_t*} = value*{value <- value*}
      -- if value'*{value' <- value'*} matches _ :: _
      -- let value_b_h :: value_b_t*{value_b_t <- value_b_t*} = value'*{value' <- value'*}

;; ../../../../spec-concrete/3-numerics.watsup:240.1-240.55
def $bin_eqs_fields((value, id)*, (value, id)*) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:286.1-286.37
   clause 0((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = true
      -- if (value, id)*{(value, id) <- (value, id)*} matches []
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

   ;; ../../../../spec-concrete/3-numerics.watsup:287.1-287.41
   clause 1((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
      -- if (value, id)*{(value, id) <- (value, id)*} matches []
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
      -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)'*{(value, id)' <- (value, id)'*}

   ;; ../../../../spec-concrete/3-numerics.watsup:288.1-288.41
   clause 2((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
      -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
      -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)*{(value, id) <- (value, id)*}
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

   ;; ../../../../spec-concrete/3-numerics.watsup:289.1-293.67
   clause 3((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = (((id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)) /\ $bin_eqs_fields((value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*}, (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*}))
      -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
      -- let (value_a_h, id_a_h) :: (value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*} = (value, id)*{(value, id) <- (value, id)*}
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
      -- let (value_b_h, id_b_h) :: (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*} = (value, id)'*{(value, id)' <- (value, id)'*}

;; ../../../../spec-concrete/3-numerics.watsup:297.1-297.33
def $bin_ne(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:299.1-299.59
   clause 0(value_l, value_r) = ~$bin_eq(value_l, value_r)

;; ../../../../spec-concrete/3-numerics.watsup:303.1-303.36
def $bin_band(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:305.1-306.44
   clause 0(value, value') = w `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $band(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:308.1-311.46
   clause 1(value, value') = w `S` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $band(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:315.1-315.36
def $bin_bxor(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:317.1-318.44
   clause 0(value, value') = w `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $bxor(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:320.1-323.46
   clause 1(value, value') = w `S` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $bxor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:327.1-327.35
def $bin_bor(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:329.1-330.43
   clause 0(value, value') = w `W` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w' `W` i_r = number'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $bor(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:332.1-335.45
   clause 1(value, value') = w `S` i' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w' `S` i_r = number'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $bor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:339.1-339.38
def $bin_concat(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:341.1-345.35
   clause 0(value, value') = w `W` i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r `W` i_r = number'
      -- let i_l' = $shl(i_l, w_r as int)
      -- let i_l'' = (i_l' + i_r)
      -- let w = (w_l + w_r)
      -- let i'' = $to_bitstr(w as int, i_l'')

   ;; ../../../../spec-concrete/3-numerics.watsup:346.1-350.35
   clause 1(value, value') = w `W` i'' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w_l `W` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r `S` i_r = number'
      -- let i_l' = $shl(i_l, w_r as int)
      -- let i_l'' = (i_l' + i_r)
      -- let w = (w_l + w_r)
      -- let i'' = $to_bitstr(w as int, i_l'')

   ;; ../../../../spec-concrete/3-numerics.watsup:352.1-357.37
   clause 2(value, value') = w `S` i''' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%W%`
      -- let w_r `W` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_l'' = $shl(i_l', w_r as int)
      -- let i_l''' = (i_l'' + i_r)
      -- let w = (w_l + w_r)
      -- let i''' = $to_bitstr(w as int, i_l''')

   ;; ../../../../spec-concrete/3-numerics.watsup:358.1-363.37
   clause 3(value, value') = w `S` i''' as value
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w_l `S` i_l = number
      -- if value' <: number
      -- let number' = value' as number
      -- if number' matches `%S%`
      -- let w_r `S` i_r = number'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_l'' = $shl(i_l', w_r as int)
      -- let i_l''' = (i_l'' + i_r)
      -- let w = (w_l + w_r)
      -- let i''' = $to_bitstr(w as int, i_l''')

;; ../../../../spec-concrete/3-numerics.watsup:367.1-367.36
def $bin_land(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:369.1-369.45
   clause 0(value, value') = `B` (b_l /\ b_r) as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b_l = primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue' = value' as primitiveValue
      -- if primitiveValue' matches `B%`
      -- let `B` b_r = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:373.1-373.35
def $bin_lor(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:375.1-375.44
   clause 0(value, value') = `B` (b_l \/ b_r) as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b_l = primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue' = value' as primitiveValue
      -- if primitiveValue' matches `B%`
      -- let `B` b_r = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:381.1-381.36
def $cast_op(typeIR, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:398.1-398.50
   clause 0(typeIR, value) = $cast_bool(typeIR, b)
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b = primitiveValue

   ;; ../../../../spec-concrete/3-numerics.watsup:414.1-414.52
   clause 1(typeIR, value) = $cast_arbint(typeIR, i)
      -- if value <: number
      -- let number = value as number
      -- if number matches `D%`
      -- let `D` i = number

   ;; ../../../../spec-concrete/3-numerics.watsup:432.1-432.57
   clause 2(typeIR, value) = $cast_fixbit(typeIR, w, i)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` i = number

   ;; ../../../../spec-concrete/3-numerics.watsup:449.1-449.57
   clause 3(typeIR, value) = $cast_fixint(typeIR, w, i)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%S%`
      -- let w `S` i = number

   ;; ../../../../spec-concrete/3-numerics.watsup:462.1-463.48
   clause 4(typeIR, value) = $cast_struct(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if value <: structValue
      -- let `STRUCT` tid `{` value_f id_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = value as structValue

   ;; ../../../../spec-concrete/3-numerics.watsup:476.1-477.48
   clause 5(typeIR, value) = $cast_header(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if value <: headerValue
      -- let `HEADER` tid `{` value_f id_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = value as headerValue

   ;; ../../../../spec-concrete/3-numerics.watsup:481.1-481.64
   clause 6(typeIR, value') = $cast_op(typeIR, value)
      -- if value' <: enumValue
      -- let enumValue = value' as enumValue
      -- if enumValue matches `%.%#%`
      -- let _tid `.` _id `#` value = enumValue

   ;; ../../../../spec-concrete/3-numerics.watsup:510.1-510.71
   clause 7(typeIR, value') = $cast_sequence(typeIR, value*{value <- value*})
      -- if value' <: sequenceValue
      -- let sequenceValue = value' as sequenceValue
      -- if sequenceValue matches `SEQ(%)`
      -- let `SEQ(` value*{value <- value*} `)` = sequenceValue

   ;; ../../../../spec-concrete/3-numerics.watsup:538.1-539.39
   clause 8(typeIR, value') = $cast_record(typeIR, (value, id)*{id <- id*, value <- value*})
      -- if value' <: recordValue
      -- let recordValue = value' as recordValue
      -- if recordValue matches `RECORD{%}`
      -- let `RECORD{` value id `;`*{id <- id*, value <- value*} `}` = recordValue

   ;; ../../../../spec-concrete/3-numerics.watsup:545.1-545.49
   clause 9(typeIR, value) = $default(typeIR)
      -- if (value = `DEFAULT` as value)

   ;; ../../../../spec-concrete/3-numerics.watsup:582.1-583.39
   clause 10(typeIR, value') = $cast_set_singleton(typeIR, value)
      -- if value' <: setValue
      -- let setValue = value' as setValue
      -- if setValue matches `SET{%}`
      -- let `SET{` value `}` = setValue

   ;; ../../../../spec-concrete/3-numerics.watsup:584.1-585.45
   clause 11(typeIR, value) = $cast_set_mask(typeIR, value_b, value_m)
      -- if value <: setValue
      -- let setValue = value as setValue
      -- if setValue matches `SET{%&&&%}`
      -- let `SET{` value_b `&&&` value_m `}` = setValue

   ;; ../../../../spec-concrete/3-numerics.watsup:586.1-587.46
   clause 12(typeIR, value) = $cast_set_range(typeIR, value_l, value_u)
      -- if value <: setValue
      -- let setValue = value as setValue
      -- if setValue matches `SET{%..%}`
      -- let `SET{` value_l `..` value_u `}` = setValue

;; ../../../../spec-concrete/3-numerics.watsup:383.1-383.29
def $default(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:594.1-594.49
   clause 0(typeIR) = $default'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:384.1-384.30
def $default'(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:596.1-596.30
   clause 0(typeIR) = `B` false as value
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:597.1-597.42
   clause 1(typeIR) = `ERROR.` "NoError" as value
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:598.1-599.24
   clause 2(typeIR) = `"` text_empty `"` as value
      -- if (typeIR = `STRING` as typeIR)
      -- let text_empty = ""

   ;; ../../../../spec-concrete/3-numerics.watsup:601.1-601.25
   clause 3(typeIR) = `D` 0 as int as value
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:602.1-602.34
   clause 4(typeIR) = w `W` 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:603.1-603.34
   clause 5(typeIR) = w `S` 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:604.1-604.42
   clause 6(typeIR) = w `V` 0 as int `#` 0 as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:606.1-606.59
   clause 7(typeIR') = `[` $default(typeIR)*{typeIR <- typeIR*} `]` as value
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:608.1-609.56
   clause 8(typeIR') = `[` value*{value <- value*} `#(` 0 `;` n_s `)]` as value
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_s `]` = typeIR' as headerStackTypeIR
      -- let value*{value <- value*} = $repeat_<value>($default(typeIR), n_s)

   ;; ../../../../spec-concrete/3-numerics.watsup:611.1-612.50
   clause 9(typeIR) = `STRUCT` tid `{` $default(typeIR_f) id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` as value
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:614.1-615.50
   clause 10(typeIR) = `HEADER` tid `{` $default(typeIR_f) id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` as value
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:617.1-618.56
   clause 11(typeIR) = `HEADER_UNION` tid `{` $default(typeIR_f) id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` as value
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:620.1-620.57
   clause 12(typeIR) = tid `.` id_f_h as value
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` tid `{` id*{id <- id*} `}` = enumTypeIR
      -- if id*{id <- id*} matches _ :: _
      -- let id_f_h :: _id*{_id <- _id*} = id*{id <- id*}

   ;; ../../../../spec-concrete/3-numerics.watsup:622.1-625.67
   clause 13(typeIR') = tid `.` id_zero `#` value_zero as value
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` typeIR `{` id_f `=` value_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = enumTypeIR
      -- let value_zero = $cast_arbint(typeIR, 0 as int)
      -- let id?{id <- id?} = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if id?{id <- id?} matches (_)
      -- let ?(id_zero) = id?{id <- id?}

   ;; ../../../../spec-concrete/3-numerics.watsup:627.1-631.34
   clause 14(typeIR') = tid `.` id_zero `#` value_zero as value
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` typeIR `{` id_f `=` value_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = enumTypeIR
      -- let value_zero = $cast_arbint(typeIR, 0 as int)
      -- if (?() = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}))
      -- let id_zero = "__UNSPECIFIED"

;; ../../../../spec-concrete/3-numerics.watsup:388.1-388.37
def $cast_bool(typeIR, bool) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:391.1-391.59
   clause 0(typeIR, b) = $cast_bool'($canon(typeIR), b)

;; ../../../../spec-concrete/3-numerics.watsup:389.1-389.38
def $cast_bool'(typeIR, bool) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:393.1-393.31
   clause 0(typeIR, b) = `B` b as value
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:394.1-394.42
   clause 1(typeIR, bool) = w `W` 1 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if (bool = true)

   ;; ../../../../spec-concrete/3-numerics.watsup:395.1-395.43
   clause 2(typeIR, bool) = w `W` 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if (bool = false)

   ;; ../../../../spec-concrete/3-numerics.watsup:396.1-396.58
   clause 3(typeIR', b) = $cast_bool(typeIR, b)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:402.1-402.38
def $cast_arbint(typeIR, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:405.1-405.63
   clause 0(typeIR, i) = $cast_arbint'($canon(typeIR), i)

;; ../../../../spec-concrete/3-numerics.watsup:403.1-403.39
def $cast_arbint'(typeIR, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:407.1-407.39
   clause 0(typeIR, i) = `B` (i = 0 as int) as value
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:408.1-408.32
   clause 1(typeIR, i) = `D` i as value
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:409.1-409.58
   clause 2(typeIR, i) = w `W` $to_bitstr(w as int, i) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:410.1-410.58
   clause 3(typeIR, i) = w `S` $to_bitstr(w as int, i) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:411.1-411.62
   clause 4(typeIR', i) = $cast_arbint(typeIR, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:412.1-412.73
   clause 5(typeIR'', i) = `SET{` $cast_arbint(typeIR, i) `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:418.1-418.43
def $cast_fixbit(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:421.1-421.69
   clause 0(typeIR, w, i) = $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:419.1-419.44
def $cast_fixbit'(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:423.1-423.42
   clause 0(typeIR, w, i) = `B` (i = 1 as int) as value
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:424.1-424.35
   clause 1(typeIR, _nat, i) = `D` i as value
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:425.1-426.33
   clause 2(typeIR, _nat, i) = w_to `W` i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w_to `>` = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, i)

   ;; ../../../../spec-concrete/3-numerics.watsup:427.1-428.33
   clause 3(typeIR, _nat, i) = w_to `S` i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w_to `>` = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, i)

   ;; ../../../../spec-concrete/3-numerics.watsup:429.1-429.68
   clause 4(typeIR', w, i) = $cast_fixbit(typeIR, w, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:430.1-430.79
   clause 5(typeIR'', w, i) = `SET{` $cast_fixbit(typeIR, w, i) `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:436.1-436.43
def $cast_fixint(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:439.1-439.69
   clause 0(typeIR, w, i) = $cast_fixint'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:437.1-437.44
def $cast_fixint'(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:441.1-441.47
   clause 0(typeIR, w, i) = `D` $to_int(w as int, i) as value
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:442.1-443.50
   clause 1(typeIR, w_from, i) = w_to `W` i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w_to `>` = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

   ;; ../../../../spec-concrete/3-numerics.watsup:444.1-445.50
   clause 2(typeIR, w_from, i) = w_to `S` i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w_to `>` = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

   ;; ../../../../spec-concrete/3-numerics.watsup:446.1-446.68
   clause 3(typeIR', w, i) = $cast_fixint(typeIR, w, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:447.1-447.79
   clause 4(typeIR'', w, i) = `SET{` $cast_fixint(typeIR, w, i) `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:453.1-453.52
def $cast_struct(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:456.1-457.57
   clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_struct'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:454.1-454.53
def $cast_struct'(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:459.1-460.39
   clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `STRUCT` tid `{` value_f id_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` as value
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR
      -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:467.1-467.52
def $cast_header(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:470.1-471.57
   clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_header'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:468.1-468.53
def $cast_header'(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:473.1-474.39
   clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `HEADER` tid `{` value_f id_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` as value
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR
      -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:485.1-485.43
def $cast_sequence(typeIR, value*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:488.1-489.44
   clause 0(typeIR, value*{value <- value*}) = $cast_sequence'($canon(typeIR), value*{value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:486.1-486.44
def $cast_sequence'(typeIR, value*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:491.1-492.34
   clause 0(typeIR', value*{value <- value*}) = `[` $cast_op(typeIR, value)*{value <- value*} `]` as value
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR `>` = typeIR' as listTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:494.1-495.34
   clause 1(typeIR', value*{value <- value*}) = `(` $cast_op(typeIR, value)*{typeIR <- typeIR*, value <- value*} `)` as value
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:497.1-500.25
   clause 2(typeIR', value*{value <- value*}) = `[` value_cast*{value_cast <- value_cast*} `#(` n_idx `;` n_s `)]` as value
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_s `]` = typeIR' as headerStackTypeIR
      -- (let value_cast = $cast_op(typeIR, value))*{value <- value*, value_cast <- value_cast*}
      -- let n_idx = |value*{value <- value*}|

   ;; ../../../../spec-concrete/3-numerics.watsup:502.1-504.50
   clause 3(typeIR, value*{value <- value*}) = `STRUCT` tid `{` value_cast id_f `;`*{id_f <- id_f*, value_cast <- value_cast*} `}` as value
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as structTypeIR
      -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

   ;; ../../../../spec-concrete/3-numerics.watsup:506.1-508.50
   clause 4(typeIR, value*{value <- value*}) = `HEADER` tid `{` value_cast id_f `;`*{id_f <- id_f*, value_cast <- value_cast*} `}` as value
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerTypeIR
      -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:516.1-516.47
def $cast_record(typeIR, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:519.1-520.48
   clause 0(typeIR, (value, id)*{id <- id*, value <- value*}) = $cast_record'($canon(typeIR), (value, id)*{id <- id*, value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:517.1-517.48
def $cast_record'(typeIR, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:522.1-528.57
   clause 0(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `STRUCT` tid `{` value_f_cast id_f `;`*{id_f <- id_f*, value_f_cast <- value_f_cast*} `}` as value
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_t_f id_t_f `;`*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} `}` = typeIR as structTypeIR
      -- (let value?{value <- value?} = $find_map<id, value>(`{` id_f `:` value_f*{id_f <- id_f*, value_f <- value_f*} `}`, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
      -- (if value?{value <- value?} matches (_))*{value? <- value?*}
      -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
      -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

   ;; ../../../../spec-concrete/3-numerics.watsup:530.1-536.57
   clause 1(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `HEADER` tid `{` value_f_cast id_f `;`*{id_f <- id_f*, value_f_cast <- value_f_cast*} `}` as value
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_t_f id_t_f `;`*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} `}` = typeIR as headerTypeIR
      -- (let value?{value <- value?} = $find_map<id, value>(`{` id_f `:` value_f*{id_f <- id_f*, value_f <- value_f*} `}`, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
      -- (if value?{value <- value?} matches (_))*{value? <- value?*}
      -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
      -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:551.1-551.47
def $cast_set_singleton(typeIR, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:554.1-555.48
   clause 0(typeIR, value) = $cast_set_singleton'($canon(typeIR), value)

;; ../../../../spec-concrete/3-numerics.watsup:552.1-552.48
def $cast_set_singleton'(typeIR, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:557.1-558.37
   clause 0(typeIR'', value) = `SET{` $cast_op(typeIR, value) `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:560.1-560.49
def $cast_set_mask(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:563.1-564.54
   clause 0(typeIR, value_b, value_m) = $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:561.1-561.50
def $cast_set_mask'(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:566.1-569.49
   clause 0(typeIR'', value_b, value_m) = `SET{` value_b_cast `&&&` value_m_cast `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- let value_b_cast = $cast_op(typeIR, value_b)
      -- let value_m_cast = $cast_op(typeIR, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:571.1-571.50
def $cast_set_range(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:574.1-575.55
   clause 0(typeIR, value_l, value_u) = $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:572.1-572.51
def $cast_set_range'(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:577.1-580.49
   clause 0(typeIR'', value_l, value_u) = `SET{` value_l_cast `..` value_u_cast `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- let value_l_cast = $cast_op(typeIR, value_l)
      -- let value_u_cast = $cast_op(typeIR, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:637.1-637.44
def $bitacc_op(value, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:639.1-644.35
   clause 0(value_b, value_h, value_l) = w `W` i as value
      -- let i_b = $to_number(value_b)
      -- let i_h = $to_number(value_h)
      -- let i_l = $to_number(value_l)
      -- let int = ((i_h + 1 as int) - i_l)
      -- if int <: nat
      -- let w = int as nat
      -- let i = $bitacc(i_b, i_h, i_l)

;; ../../../../spec-concrete/3-numerics.watsup:650.1-650.32
def $sizeof(typeIR, id) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:681.1-681.69
   clause 0(typeIR, text) = $sizeof_minSizeInBits(typeIR)
      -- if (text = "minSizeInBits")

   ;; ../../../../spec-concrete/3-numerics.watsup:688.1-688.71
   clause 1(typeIR, text) = $sizeof_minSizeInBytes(typeIR)
      -- if (text = "minSizeInBytes")

   ;; ../../../../spec-concrete/3-numerics.watsup:707.1-707.69
   clause 2(typeIR, text) = $sizeof_maxSizeInBits(typeIR)
      -- if (text = "maxSizeInBits")

   ;; ../../../../spec-concrete/3-numerics.watsup:714.1-714.71
   clause 3(typeIR, text) = $sizeof_maxSizeInBytes(typeIR)
      -- if (text = "maxSizeInBytes")

;; ../../../../spec-concrete/3-numerics.watsup:652.1-652.42
def $sizeof_minSizeInBits(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:666.1-666.69
   clause 0(typeIR) = `D` $sizeof_minSizeInBits'(typeIR) as int as value

;; ../../../../spec-concrete/3-numerics.watsup:653.1-653.41
def $sizeof_minSizeInBits'(typeIR) : nat =

   ;; ../../../../spec-concrete/3-numerics.watsup:667.1-667.77
   clause 0(typeIR) = $sizeof_minSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:654.1-654.42
def $sizeof_minSizeInBits''(typeIR) : nat =

   ;; ../../../../spec-concrete/3-numerics.watsup:669.1-669.38
   clause 0(typeIR) = 1
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:670.1-670.44
   clause 1(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:671.1-671.44
   clause 2(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:672.1-672.47
   clause 3(typeIR) = 0
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:673.1-673.76
   clause 4(typeIR') = $sizeof_minSizeInBits'(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:674.1-674.86
   clause 5(typeIR') = $sizeof_minSizeInBits'(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:675.1-675.88
   clause 6(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:676.1-676.93
   clause 7(typeIR') = ($sizeof_minSizeInBits'(typeIR) * n_size)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:677.1-677.98
   clause 8(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:678.1-678.98
   clause 9(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:679.1-679.104
   clause 10(typeIR') = $min($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerUnionTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:656.1-656.43
def $sizeof_minSizeInBytes(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:685.1-686.48
   clause 0(typeIR) = `D` (n_size / 8) as int as value
      -- let n_size = $sizeof_minSizeInBits'(typeIR)

;; ../../../../spec-concrete/3-numerics.watsup:658.1-658.42
def $sizeof_maxSizeInBits(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:692.1-692.69
   clause 0(typeIR) = `D` $sizeof_maxSizeInBits'(typeIR) as int as value

;; ../../../../spec-concrete/3-numerics.watsup:659.1-659.41
def $sizeof_maxSizeInBits'(typeIR) : nat =

   ;; ../../../../spec-concrete/3-numerics.watsup:693.1-693.77
   clause 0(typeIR) = $sizeof_maxSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:660.1-660.42
def $sizeof_maxSizeInBits''(typeIR) : nat =

   ;; ../../../../spec-concrete/3-numerics.watsup:695.1-695.38
   clause 0(typeIR) = 1
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:696.1-696.44
   clause 1(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:697.1-697.44
   clause 2(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:698.1-698.47
   clause 3(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:699.1-699.76
   clause 4(typeIR') = $sizeof_maxSizeInBits'(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:700.1-700.86
   clause 5(typeIR') = $sizeof_maxSizeInBits'(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:701.1-701.88
   clause 6(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:702.1-702.93
   clause 7(typeIR') = ($sizeof_maxSizeInBits'(typeIR) * n_size)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:703.1-703.98
   clause 8(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:704.1-704.98
   clause 9(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:705.1-705.104
   clause 10(typeIR') = $max($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerUnionTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:662.1-662.43
def $sizeof_maxSizeInBytes(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:711.1-712.48
   clause 0(typeIR) = `D` (n_size / 8) as int as value
      -- let n_size = $sizeof_maxSizeInBits'(typeIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:6.1-7.14
syntax prefixedNameIR = 
   | ``` nameIR
   | `.` nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:9.1-9.63
def $prefixedNonTypeName(prefixedNonTypeName) : prefixedNameIR =

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:10.1-10.62
   clause 0(prefixedNonTypeName) = ``` $name(nonTypeName as name)
      -- if prefixedNonTypeName <: nonTypeName
      -- let nonTypeName = prefixedNonTypeName as nonTypeName

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:11.1-11.69
   clause 1(prefixedNonTypeName) = `.` $name(nonTypeName as name)
      -- if prefixedNonTypeName matches ``ID.%`
      -- let ``ID.` nonTypeName = prefixedNonTypeName

;; ../../../../spec-concrete/4-ir-syntax.watsup:13.1-13.57
def $prefixedTypeName(prefixedTypeName) : prefixedNameIR =

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:14.1-14.53
   clause 0(prefixedTypeName) = ``` $name(typeName as name)
      -- if prefixedTypeName <: typeName
      -- let typeName = prefixedTypeName as typeName

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:15.1-15.61
   clause 1(prefixedTypeName) = `.` $name(typeName as name)
      -- if prefixedTypeName matches ``TID.%`
      -- let ``TID.` typeName = prefixedTypeName

;; ../../../../spec-concrete/4-ir-syntax.watsup:17.1-17.53
def $flatten_prefixedNameIR(prefixedNameIR) : nameIR =

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:18.1-18.48
   clause 0(prefixedNameIR) = nameIR
      -- if prefixedNameIR matches ``%`
      -- let ``` nameIR = prefixedNameIR

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:19.1-19.55
   clause 1(prefixedNameIR) = "." ++ nameIR
      -- if prefixedNameIR matches `.%`
      -- let `.` nameIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:21.21-21.28
syntax nameListIR = nameIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:27.26-27.29
syntax typeParameterIR = tid

;; ../../../../spec-concrete/4-ir-syntax.watsup:29.30-29.46
syntax typeParameterListIR = typeParameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:38.3-38.66
syntax parameterIR = 
   | annotationList direction typeIR nameIR constantInitializerOptIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:40.26-40.38
syntax parameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:46.33-46.44
syntax constructorParameterIR = parameterIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:48.37-48.49
syntax constructorParameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:56.28-56.55
syntax namedExpressionIR = 
   | nameIR `=` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:58.32-58.50
syntax namedExpressionListIR = namedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:68.30-68.47
syntax literalExpressionIR = literalExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:74.32-74.46
syntax referenceExpressionIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:80.30-80.47
syntax defaultExpressionIR = defaultExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:86.28-86.50
syntax unaryExpressionIR = 
   | unop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:89.3-89.44
syntax binaryExpressionIR = 
   | typedExpressionIR binop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:92.3-92.62
syntax ternaryExpressionIR = 
   | typedExpressionIR `?` typedExpressionIR `:` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:98.27-98.56
syntax castExpressionIR = 
   | `(` typeIR `)` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:107.1-111.46
syntax dataExpressionIR = 
   | `{#}`
   | `SEQ{` typedExpressionListIR `}`
   | `SEQ{` typedExpressionListIR `,...}`
   | `RECORD{` namedExpressionListIR `}`
   | `RECORD{` namedExpressionListIR `,...}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:120.3-120.18
syntax errorAccessExpressionIR = 
   | `ERROR.` nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:123.3-123.31
syntax memberAccessExpressionIR = 
   | memberAccessBaseIR `.` nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:126.1-127.66
syntax indexAccessExpressionIR = 
   | typedExpressionIR `[` typedExpressionIR `]`
   | typedExpressionIR `[` typedExpressionIR `:` typedExpressionIR `]`

;; ../../../../spec-concrete/4-ir-syntax.watsup:130.1-132.28
syntax accessExpressionIR = 
   | `ERROR.` nameIR
   | memberAccessBaseIR `.` nameIR
   | typedExpressionIR `[` typedExpressionIR `]`
   | typedExpressionIR `[` typedExpressionIR `:` typedExpressionIR `]`

;; ../../../../spec-concrete/4-ir-syntax.watsup:143.1-146.25
syntax routineTargetIR = 
   | ``` nameIR
   | `.` nameIR
   | typedExpressionIR `.` nameIR
   | `TYPE` prefixedNameIR `.` nameIR
   | `(` routineTargetIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:148.30-148.68
syntax constructorTargetIR = 
   | prefixedNameIR `<` typeArgumentListIR `>`

;; ../../../../spec-concrete/4-ir-syntax.watsup:151.1-152.64
syntax callExpressionIR = 
   | constructorTargetIR `(` argumentListIR `)`
   | routineTargetIR `<` typeArgumentListIR `>(` argumentListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:158.36-158.58
syntax parenthesizedExpressionIR = 
   | `(` typedExpressionIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:165.1-175.30
syntax expressionIR = 
   | `TRUE`
   | `FALSE`
   | `D` int hint(print %)
   | nat `W` int hint(print %#W#%)
   | nat `S` int hint(print %#S#%)
   | `"` text `"` hint(print "#%#")
   | ``` nameIR
   | `.` nameIR
   | `...`
   | unop typedExpressionIR
   | typedExpressionIR binop typedExpressionIR
   | typedExpressionIR `?` typedExpressionIR `:` typedExpressionIR
   | `(` typeIR `)` typedExpressionIR
   | `{#}`
   | `SEQ{` typedExpressionListIR `}`
   | `SEQ{` typedExpressionListIR `,...}`
   | `RECORD{` namedExpressionListIR `}`
   | `RECORD{` namedExpressionListIR `,...}`
   | `ERROR.` nameIR
   | memberAccessBaseIR `.` nameIR
   | typedExpressionIR `[` typedExpressionIR `]`
   | typedExpressionIR `[` typedExpressionIR `:` typedExpressionIR `]`
   | constructorTargetIR `(` argumentListIR `)`
   | routineTargetIR `<` typeArgumentListIR `>(` argumentListIR `)`
   | `(` typedExpressionIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:177.27-177.42
syntax expressionNoteIR = 
   | `(` typeIR ctk `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:180.3-180.35
syntax typedExpressionIR = 
   | expressionIR `#` expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:182.32-182.50
syntax typedExpressionListIR = typedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:185.1-186.22
syntax memberAccessBaseIR = 
   | `TYPE` prefixedNameIR
   | expressionIR `#` expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:193.1-197.7
syntax simpleKeysetExpressionIR = 
   | expressionIR `#` expressionNoteIR
   | typedExpressionIR `&&&` typedExpressionIR
   | typedExpressionIR `..` typedExpressionIR
   | `DEFAULT`
   | `_`

;; ../../../../spec-concrete/4-ir-syntax.watsup:199.39-199.64
syntax simpleKeysetExpressionListIR = simpleKeysetExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:201.34-201.67
syntax tupleKeysetExpressionIR = 
   | `(` simpleKeysetExpressionListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:204.1-205.28
syntax keysetExpressionIR = 
   | expressionIR `#` expressionNoteIR
   | typedExpressionIR `&&&` typedExpressionIR
   | typedExpressionIR `..` typedExpressionIR
   | `DEFAULT`
   | `_`
   | `(` simpleKeysetExpressionListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:211.25-211.31
syntax typeArgumentIR = typeIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:213.29-213.44
syntax typeArgumentListIR = typeArgumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:220.1-223.7
syntax argumentIR = 
   | expressionIR `#` expressionNoteIR
   | nameIR `=` typedExpressionIR
   | nameIR `=_`
   | `_`

;; ../../../../spec-concrete/4-ir-syntax.watsup:225.25-225.36
syntax argumentListIR = argumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:232.1-236.23
syntax lvalueIR = 
   | ``` nameIR
   | `.` nameIR
   | typedLvalueIR `.` nameIR
   | typedLvalueIR `[` typedExpressionIR `]`
   | typedLvalueIR `[` typedExpressionIR `:` typedExpressionIR `]`
   | `(` typedLvalueIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:238.24-238.47
syntax typedLvalueIR = 
   | lvalueIR `#(` typeIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:248.27-248.41
syntax emptyStatementIR = emptyStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:255.3-255.46
syntax assignmentStatementIR = 
   | typedLvalueIR assignop typedExpressionIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:262.3-262.65
syntax callStatementIR = 
   | routineTargetIR `<` typeArgumentListIR `>(` argumentListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:269.3-269.49
syntax directApplicationStatementIR = 
   | prefixedNameIR `.APPLY(` argumentListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:276.1-277.32
syntax returnStatementIR = 
   | `RETURN;`
   | `RETURN` typedExpressionIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:283.26-283.39
syntax exitStatementIR = exitStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:292.3-292.50
syntax blockStatementIR = 
   | annotationList `{` blockElementStatementListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:301.1-302.59
syntax conditionalStatementIR = 
   | `IF(` typedExpressionIR `)` statementIR
   | `IF(` typedExpressionIR `)` statementIR `ELSE` statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:311.1-314.35
syntax forInitStatementIR = 
   | annotationList typeIR nameIR initializerOptIR
   | lvalueIR `(` argumentListIR `)`
   | lvalueIR `<` typeArgumentListIR `>(` argumentListIR `)`
   | lvalueIR assignop expressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:316.33-316.52
syntax forInitStatementListIR = forInitStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:318.31-318.49
syntax forUpdateStatementIR = forInitStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:320.35-320.56
syntax forUpdateStatementListIR = forUpdateStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:323.1-324.44
syntax forCollectionExpressionIR = 
   | expressionIR `#` expressionNoteIR
   | typedExpressionIR `..` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:327.1-335.18
syntax forStatementIR = 
   | annotationList `FOR(` forInitStatementListIR `;` typedExpressionIR `;` forUpdateStatementListIR `)` statementIR
   | annotationList `FOR(` typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | annotationList `FOR(` annotationList typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:342.1-343.22
syntax switchLabelIR = 
   | `DEFAULT`
   | expressionIR `#` expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:346.1-347.21
syntax switchCaseIR = 
   | switchLabelIR `:` blockStatementIR
   | switchLabelIR `:`

;; ../../../../spec-concrete/4-ir-syntax.watsup:349.27-349.40
syntax switchCaseListIR = switchCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:352.3-352.54
syntax switchStatementIR = 
   | `SWITCH(` typedExpressionIR `){` switchCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:358.27-358.41
syntax breakStatementIR = breakStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:360.30-360.47
syntax continueStatementIR = continueStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:367.1-378.22
syntax statementIR = 
   | `;`
   | typedLvalueIR assignop typedExpressionIR `;`
   | routineTargetIR `<` typeArgumentListIR `>(` argumentListIR `);`
   | prefixedNameIR `.APPLY(` argumentListIR `);`
   | `RETURN;`
   | `RETURN` typedExpressionIR `;`
   | `EXIT;`
   | annotationList `{` blockElementStatementListIR `}`
   | `IF(` typedExpressionIR `)` statementIR
   | `IF(` typedExpressionIR `)` statementIR `ELSE` statementIR
   | annotationList `FOR(` forInitStatementListIR `;` typedExpressionIR `;` forUpdateStatementListIR `)` statementIR
   | annotationList `FOR(` typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | annotationList `FOR(` annotationList typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | `BREAK;`
   | `CONTINUE;`
   | `SWITCH(` typedExpressionIR `){` switchCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:388.32-388.40
syntax constantInitializerIR = 
   | `=` value

;; ../../../../spec-concrete/4-ir-syntax.watsup:390.35-390.57
syntax constantInitializerOptIR = constantInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:393.3-393.62
syntax constantDeclarationIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:395.24-395.44
syntax initializerIR = 
   | `=` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:397.27-397.41
syntax initializerOptIR = initializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:400.3-400.51
syntax variableDeclarationIR = 
   | annotationList typeIR nameIR initializerOptIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:403.1-405.16
syntax blockElementStatementIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList typeIR nameIR initializerOptIR `;`
   | `;`
   | typedLvalueIR assignop typedExpressionIR `;`
   | routineTargetIR `<` typeArgumentListIR `>(` argumentListIR `);`
   | prefixedNameIR `.APPLY(` argumentListIR `);`
   | `RETURN;`
   | `RETURN` typedExpressionIR `;`
   | `EXIT;`
   | annotationList `{` blockElementStatementListIR `}`
   | `IF(` typedExpressionIR `)` statementIR
   | `IF(` typedExpressionIR `)` statementIR `ELSE` statementIR
   | annotationList `FOR(` forInitStatementListIR `;` typedExpressionIR `;` forUpdateStatementListIR `)` statementIR
   | annotationList `FOR(` typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | annotationList `FOR(` annotationList typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | `BREAK;`
   | `CONTINUE;`
   | `SWITCH(` typedExpressionIR `){` switchCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:407.38-407.62
syntax blockElementStatementListIR = blockElementStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:414.3-415.73
syntax functionPrototypeIR = 
   | typeIR nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:418.3-418.54
syntax functionDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:425.3-425.69
syntax actionDeclarationIR = 
   | annotationList `ACTION` nameIR `(` parameterListIR `)` blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:433.30-433.61
syntax objectInitializerIR = 
   | `={` objectDeclarationListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:435.33-435.53
syntax objectInitializerOptIR = objectInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:438.3-440.30
syntax instantiationIR = 
   | annotationList prefixedNameIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:443.1-444.20
syntax objectDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList prefixedNameIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:446.34-446.54
syntax objectDeclarationListIR = objectDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:452.29-452.50
syntax errorDeclarationIR = 
   | `ERROR{` nameListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:458.33-458.59
syntax matchKindDeclarationIR = 
   | `MATCH_KIND{` nameListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:469.1-470.65
syntax enumTypeDeclarationIR = 
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:476.22-476.53
syntax typeFieldIR = 
   | annotationList typeIR nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:478.26-478.38
syntax typeFieldListIR = typeFieldIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:481.3-482.73
syntax structTypeDeclarationIR = 
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:485.3-486.73
syntax headerTypeDeclarationIR = 
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:489.3-490.73
syntax headerUnionTypeDeclarationIR = 
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:493.1-496.33
syntax derivedTypeDeclarationIR = 
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:503.1-504.29
syntax typedefTypeIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:507.1-508.41
syntax typedefDeclarationIR = 
   | annotationList `TYPEDEF` typedefTypeIR nameIR `;`
   | annotationList `TYPE` typeIR nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:515.3-515.47
syntax externFunctionDeclarationIR = 
   | annotationList `EXTERN` functionPrototypeIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:518.1-520.51
syntax methodPrototypeIR = 
   | annotationList nameIR `<,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList functionPrototypeIR `;`
   | annotationList `ABSTRACT` functionPrototypeIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:522.32-522.50
syntax methodPrototypeListIR = methodPrototypeIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:525.3-527.31
syntax externObjectDeclarationIR = 
   | annotationList `EXTERN` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` methodPrototypeListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:530.1-531.30
syntax externDeclarationIR = 
   | annotationList `EXTERN` functionPrototypeIR `;`
   | annotationList `EXTERN` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` methodPrototypeListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:541.23-541.54
syntax selectCaseIR = 
   | keysetExpressionIR `:` nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:543.27-543.40
syntax selectCaseListIR = selectCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:546.3-546.58
syntax selectExpressionIR = 
   | `SELECT(` typedExpressionListIR `){` selectCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:553.1-554.23
syntax stateExpressionIR = 
   | nameIR `;`
   | `SELECT(` typedExpressionListIR `){` selectCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:556.32-556.60
syntax transitionStatementIR = 
   | `TRANSITION` stateExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:563.3-563.72
syntax valueSetDeclarationIR = 
   | annotationList `VALUE_SET<` typeIR `>(` typedExpressionIR `)` nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:570.3-571.76
syntax parserTypeDeclarationIR = 
   | annotationList `PARSER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:580.3-580.44
syntax parserBlockStatementIR = 
   | annotationList `{` parserStatementListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:583.1-590.27
syntax parserStatementIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList typeIR nameIR initializerOptIR `;`
   | `;`
   | typedLvalueIR assignop typedExpressionIR `;`
   | routineTargetIR `<` typeArgumentListIR `>(` argumentListIR `);`
   | prefixedNameIR `.APPLY(` argumentListIR `);`
   | annotationList `{` parserStatementListIR `}`
   | `IF(` typedExpressionIR `)` statementIR
   | `IF(` typedExpressionIR `)` statementIR `ELSE` statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:592.32-592.50
syntax parserStatementListIR = parserStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:595.3-596.53
syntax parserStateIR = 
   | annotationList `STATE` nameIR `{` parserStatementListIR transitionStatementIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:598.28-598.42
syntax parserStateListIR = parserStateIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:601.1-604.26
syntax parserLocalDeclarationIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList prefixedNameIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`
   | annotationList typeIR nameIR initializerOptIR `;`
   | annotationList `VALUE_SET<` typeIR `>(` typedExpressionIR `)` nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:607.3-607.28
syntax parserLocalDeclarationListIR = parserLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:610.3-613.56
syntax parserDeclarationIR = 
   | annotationList `PARSER` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` parserLocalDeclarationListIR parserStateListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:623.18-623.23
syntax constIR = const

;; ../../../../spec-concrete/4-ir-syntax.watsup:625.21-625.29
syntax constOptIR = constIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:631.21-631.66
syntax tableKeyIR = 
   | typedExpressionIR `:` nameIR annotationList `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:633.25-633.36
syntax tableKeyListIR = tableKeyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:639.33-639.67
syntax tableActionReferenceIR = 
   | prefixedNameIR `(` argumentListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:641.24-641.64
syntax tableActionIR = 
   | annotationList tableActionReferenceIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:643.28-643.42
syntax tableActionListIR = tableActionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:650.1-651.42
syntax tableEntryPriorityIR = 
   | `PRIORITY=` number `:`
   | `PRIORITY=(` typedExpressionIR `):`

;; ../../../../spec-concrete/4-ir-syntax.watsup:653.34-653.55
syntax tableEntryPriorityOptIR = tableEntryPriorityIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:656.3-657.67
syntax tableEntryIR = 
   | constOptIR tableEntryPriorityOptIR keysetExpressionIR `:` tableActionReferenceIR annotationList `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:659.27-659.40
syntax tableEntryListIR = tableEntryIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:666.1-670.54
syntax tablePropertyIR = 
   | `KEY={` tableKeyListIR `}`
   | `ACTIONS={` tableActionListIR `}`
   | annotationList constOptIR `ENTRIES={` tableEntryListIR `}`
   | annotationList constOptIR `DEFAULT_ACTION=` tableActionReferenceIR `;`
   | annotationList constOptIR nameIR initializerIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:672.30-672.46
syntax tablePropertyListIR = tablePropertyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:675.3-675.55
syntax tableDeclarationIR = 
   | annotationList `TABLE` nameIR `{` tablePropertyListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:682.3-684.28
syntax controlTypeDeclarationIR = 
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:690.24-690.40
syntax controlBodyIR = blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:693.1-697.23
syntax controlLocalDeclarationIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList prefixedNameIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`
   | annotationList typeIR nameIR initializerOptIR `;`
   | annotationList `ACTION` nameIR `(` parameterListIR `)` blockStatementIR
   | annotationList `TABLE` nameIR `{` tablePropertyListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:700.3-700.29
syntax controlLocalDeclarationListIR = controlLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:703.3-706.59
syntax controlDeclarationIR = 
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` controlLocalDeclarationListIR `APPLY` controlBodyIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:713.3-715.28
syntax packageTypeDeclarationIR = 
   | annotationList `PACKAGE` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:722.1-726.29
syntax typeDeclarationIR = 
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `TYPEDEF` typedefTypeIR nameIR `;`
   | annotationList `TYPE` typeIR nameIR `;`
   | annotationList `PARSER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList `PACKAGE` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:733.1-742.22
syntax declarationIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList prefixedNameIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList `ACTION` nameIR `(` parameterListIR `)` blockStatementIR
   | `ERROR{` nameListIR `}`
   | `MATCH_KIND{` nameListIR `}`
   | annotationList `EXTERN` functionPrototypeIR `;`
   | annotationList `EXTERN` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` methodPrototypeListIR `}`
   | annotationList `PARSER` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` parserLocalDeclarationListIR parserStateListIR `}`
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` controlLocalDeclarationListIR `APPLY` controlBodyIR `}`
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `TYPEDEF` typedefTypeIR nameIR `;`
   | annotationList `TYPE` typeIR nameIR `;`
   | annotationList `PARSER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList `PACKAGE` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:748.22-748.39
syntax p4programIR = 
   | declarationIR* `;`

;; ../../../../spec-concrete/5.0-flow.watsup:5.15-5.25
syntax flow = 
   | `CONT`
   | `RET`

;; ../../../../spec-concrete/5.0-flow.watsup:9.1-9.34
def $join_flow(flow, flow) : flow =

   ;; ../../../../spec-concrete/5.0-flow.watsup:10.1-10.31
   clause 0(flow, flow') = `RET`
      -- if flow matches `RET`
      -- if flow' matches `RET`

   ;; ../../../../spec-concrete/5.0-flow.watsup:11.1-12.15
   clause 1(f_a, f_b) = `CONT`
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:5.20-5.47
syntax varTypeIR = 
   | direction typeIR ctk value?

;; ../../../../spec-concrete/5.01-env.watsup:12.16-12.34
syntax frame = map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:14.1-14.27
def $empty_frame : frame =

   ;; ../../../../spec-concrete/5.01-env.watsup:15.1-15.47
   clause 0 = $empty_map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:18.16-18.35
syntax tdenv = map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:20.1-20.27
def $empty_tdenv : tdenv =

   ;; ../../../../spec-concrete/5.01-env.watsup:21.1-21.48
   clause 0 = $empty_map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:24.16-24.42
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:26.1-26.27
def $empty_rdenv : rdenv =

   ;; ../../../../spec-concrete/5.01-env.watsup:27.1-27.55
   clause 0 = $empty_map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:30.16-30.46
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:32.1-32.27
def $empty_cdenv : cdenv =

   ;; ../../../../spec-concrete/5.01-env.watsup:33.1-33.59
   clause 0 = $empty_map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:39.1-39.39
def $check_routine_name(id, id) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:40.1-40.50
   clause 0(id_l, id_r) = (id_l = id_r)

;; ../../../../spec-concrete/5.01-env.watsup:42.1-42.37
def $check_arity(id?*, id*) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:43.1-43.72
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| = |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:45.1-45.42
def $check_arity_more(id?*, id*) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:46.1-46.77
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:48.1-48.42
def $check_arity_less(id?*, id*) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:49.1-49.77
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| < |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:51.1-51.44
def $get_missing_parameters(id*, id*) : id* =

   ;; ../../../../spec-concrete/5.01-env.watsup:53.1-53.48
   clause 0(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = []
      -- if id*{id <- id*} matches []

   ;; ../../../../spec-concrete/5.01-env.watsup:54.1-59.47
   clause 1(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = id_param_h :: $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
      -- if id*{id <- id*} matches _ :: _
      -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
      -- if ~$in_set<id>(id_param_h, `{` id_arg*{id_arg <- id_arg*} `}`)

   ;; ../../../../spec-concrete/5.01-env.watsup:60.1-65.15
   clause 2(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
      -- if id*{id <- id*} matches _ :: _
      -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:68.1-68.61
def $find_match_named<V>(rid, V, id*, pid*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:70.1-72.50
   clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param `#` bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, []))
      -- if $eq_set<id>(`{` id_arg*{id_arg <- id_arg*} `}`, `{` id_param*{id_param <- id_param*} `}`)

   ;; ../../../../spec-concrete/5.01-env.watsup:73.1-74.15
   clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:77.1-77.69
def $find_match_named_default<V>(rid, V, id*, pid*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:79.1-86.18
   clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param `#` bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, id_default*{id_default <- id_default*}))
      -- let id_default*{id_default <- id_default*} = $get_missing_parameters(id_param*{id_param <- id_param*}, id_arg*{id_arg <- id_arg*})
      -- if ($find_match_named<V>(rid, V, id_arg*{id_arg <- id_arg*} ++ id_default*{id_default <- id_default*}, id_param `#` bool_param*{bool_param <- bool_param*, id_param <- id_param*}) =/= ?())

   ;; ../../../../spec-concrete/5.01-env.watsup:87.1-88.15
   clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:91.1-91.74
def $find_match_unnamed_default<V>(rid, V, id?*, pid*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:93.1-95.74
   clause 0(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?((rid, V, id_default*{id_default <- id_default*}))
      -- let (_pid*{_pid <- _pid*}, id_default `#` bool*{bool <- bool*, id_default <- id_default*}) = $partition_<pid>(pid*{pid <- pid*}, |id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}|)
      -- (if (bool = true))*{bool <- bool*}

   ;; ../../../../spec-concrete/5.01-env.watsup:96.1-97.15
   clause 1(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:100.1-100.64
def $find_matching<V>(id, id?*, id*, rid, V) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:103.1-105.42
   clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' `(` pid_r'*{pid_r' <- pid_r'*} `)`, V) = ?()
      -- if ~$check_routine_name(id_r, id_r')

   ;; ../../../../spec-concrete/5.01-env.watsup:107.1-113.50
   clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = ?()
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_more(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:115.1-125.45
   clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = $find_match_named<V>(id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V, id_arg'*{id_arg' <- id_arg'*}, id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:127.1-133.45
   clause 3(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = ?((id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V, []))
      -- if id*{id <- id*} matches []
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:135.1-145.50
   clause 4(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = $find_match_named_default<V>(id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V, id_arg'*{id_arg' <- id_arg'*}, id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:147.1-156.50
   clause 5(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = $find_match_unnamed_default<V>(id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if id*{id <- id*} matches []
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

;; ../../../../spec-concrete/5.01-env.watsup:159.1-159.67
def $find_matchings<V>(id, id?*, id*, rid*, V*) : (rid, V, id*)* =

   ;; ../../../../spec-concrete/5.01-env.watsup:161.1-165.8
   clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = []
      -- if rid*{rid <- rid*} matches []
      -- if V*{V <- V*} matches []

   ;; ../../../../spec-concrete/5.01-env.watsup:166.1-171.72
   clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
      -- if rid*{rid <- rid*} matches _ :: _
      -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid*{rid <- rid*}
      -- if V*{V <- V*} matches _ :: _
      -- let V_h :: V_t*{V_t <- V_t*} = V*{V <- V*}
      -- if ($find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h) = ?())

   ;; ../../../../spec-concrete/5.01-env.watsup:172.1-178.66
   clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid'*{rid' <- rid'*}, V'*{V' <- V'*}) = (rid, V, id_default*{id_default <- id_default*}) :: $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
      -- if rid'*{rid' <- rid'*} matches _ :: _
      -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid'*{rid' <- rid'*}
      -- if V'*{V' <- V'*} matches _ :: _
      -- let V_h :: V_t*{V_t <- V_t*} = V'*{V' <- V'*}
      -- let (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} = $find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h)
      -- if (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} matches (_)
      -- let ?((rid, V, id_default*{id_default <- id_default*})) = (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?}

;; ../../../../spec-concrete/5.01-env.watsup:181.1-181.66
def $find_overloaded<V>(map<rid, V>, id, id?*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:184.1-190.71
   clause 0(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
      -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
      -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
      -- (if id?{id <- id?} matches (_))*{id? <- id?*}
      -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
      -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = [])

   ;; ../../../../spec-concrete/5.01-env.watsup:191.1-198.65
   clause 1(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
      -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
      -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
      -- (if id?{id <- id?} matches (_))*{id? <- id?*}
      -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
      -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*})
      -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
      -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

   ;; ../../../../spec-concrete/5.01-env.watsup:200.1-205.66
   clause 2(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
      -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
      -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*}) = [])

   ;; ../../../../spec-concrete/5.01-env.watsup:206.1-212.60
   clause 3(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
      -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
      -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*})
      -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
      -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

;; ../../../../spec-concrete/5.01-env.watsup:218.1-218.50
def $find_non_overloaded<V>(map<rid, V>, id) : V? =

   ;; ../../../../spec-concrete/5.01-env.watsup:221.1-222.60
   clause 0(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id) = ?(V')
      -- let V''*{V'' <- V''*} = $find_non_overloaded'<V>(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id)
      -- if V''*{V'' <- V''*} matches [ _/1 ]
      -- let [V'] = V''*{V'' <- V''*}

   ;; ../../../../spec-concrete/5.01-env.watsup:223.1-224.15
   clause 1(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:219.1-219.51
def $find_non_overloaded'<V>(map<rid, V>, id) : V* =

   ;; ../../../../spec-concrete/5.01-env.watsup:226.1-226.49
   clause 0(set<pair<rid, V>>, id) = []
      -- if (set<pair<rid, V>> = `{` [] `}`)

   ;; ../../../../spec-concrete/5.01-env.watsup:227.1-233.59
   clause 1(`{` pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} `}`, id) = V_h :: V_t_found*{V_t_found <- V_t_found*}
      -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
      -- let rid_h `:` V_h :: rid_t `:` V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
      -- let id' `(` _pid*{_pid <- _pid*} `)` = rid_h
      -- if (id' = id)
      -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>(`{` rid_t `:` V_t*{V_t <- V_t*, rid_t <- rid_t*} `}`, id)

   ;; ../../../../spec-concrete/5.01-env.watsup:234.1-241.59
   clause 2(`{` pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} `}`, id) = V_t_found*{V_t_found <- V_t_found*}
      -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
      -- let rid_h `:` V_h :: rid_t `:` V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
      -- let id_h `(` _pid*{_pid <- _pid*} `)` = rid_h
      -- if (id =/= id_h)
      -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>(`{` rid_t `:` V_t*{V_t <- V_t*, rid_t <- rid_t*} `}`, id)

;; ../../../../spec-concrete/5.02-context.watsup:5.17-5.39
syntax cursor = 
   | `GLOBAL`
   | `BLOCK`
   | `LOCAL`

;; ../../../../spec-concrete/5.02-context.watsup:16.3-19.18
syntax glayer = {`CDENV` cdenv, `TDENV` tdenv, `RDENV` rdenv, `FRAME` frame}

;; ../../../../spec-concrete/5.02-context.watsup:24.3-27.18
syntax blayer = {`ID` id, `TDENV` tdenv, `RDENV` rdenv, `FRAME` frame}

;; ../../../../spec-concrete/5.02-context.watsup:31.15-31.30
syntax lret = 
   | ``EMPTY`
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/5.02-context.watsup:34.3-37.20
syntax llayer = {`ID` id, `RET` lret, `TDENV` tdenv, `FRAMES` frame*}

;; ../../../../spec-concrete/5.02-context.watsup:44.3-46.19
syntax context = {`GLOBAL` glayer, `BLOCK` blayer, `LOCAL` llayer}

;; ../../../../spec-concrete/5.02-context.watsup:54.1-54.29
def $empty_context : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:56.1-72.58
   clause 0 = C
      -- let glayer = {CDENV $empty_cdenv, TDENV $empty_tdenv, RDENV $empty_rdenv, FRAME $empty_frame}
      -- let blayer = {ID "", TDENV $empty_tdenv, RDENV $empty_rdenv, FRAME $empty_frame}
      -- let llayer = {ID "", RET ``EMPTY`, TDENV $empty_tdenv, FRAMES [$empty_frame]}
      -- let C = {GLOBAL glayer, BLOCK blayer, LOCAL llayer}

;; ../../../../spec-concrete/5.02-context.watsup:78.1-78.36
def $bound(cursor, context) : bound =

   ;; ../../../../spec-concrete/5.02-context.watsup:80.1-80.33
   clause 0(cursor, C) = `{` [] `}`
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.02-context.watsup:81.1-81.63
   clause 1(cursor, C) = $dom_map<tid, typeDefIR>(C.BLOCK.TDENV)
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.02-context.watsup:82.1-84.62
   clause 2(cursor, C) = $union_set<tid>(bound_block, bound_local)
      -- if cursor matches `LOCAL`
      -- let bound_block = $bound(`BLOCK`, C)
      -- let bound_local = $dom_map<tid, typeDefIR>(C.LOCAL.TDENV)

;; ../../../../spec-concrete/5.02-context.watsup:90.1-90.30
def $enter(context) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:92.1-92.68
   clause 0(C) = C[LOCAL.FRAMES = $empty_frame :: C.LOCAL.FRAMES]

;; ../../../../spec-concrete/5.02-context.watsup:94.1-94.29
def $exit(context) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:96.1-97.45
   clause 0(C) = C[LOCAL.FRAMES = frame_t*{frame_t <- frame_t*}]
      -- let frame*{frame <- frame*} = C.LOCAL.FRAMES
      -- if frame*{frame <- frame*} matches _ :: _
      -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame*{frame <- frame*}

;; ../../../../spec-concrete/5.02-context.watsup:103.1-103.48
def $set_return_type(context, typeIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:105.1-106.33
   clause 0(C, typeIR_ret) = C[LOCAL.RET = typeIR_ret as lret]

;; ../../../../spec-concrete/5.02-context.watsup:108.1-108.40
def $get_return_type(context) : typeIR? =

   ;; ../../../../spec-concrete/5.02-context.watsup:110.1-111.33
   clause 0(C) = ?(typeIR_ret)
      -- let lret = C.LOCAL.RET
      -- if lret <: typeIR
      -- let typeIR_ret = lret as typeIR

   ;; ../../../../spec-concrete/5.02-context.watsup:112.1-113.15
   clause 1(C) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:121.1-121.55
def $add_var(cursor, context, id, varTypeIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:124.1-125.71
   clause 0(cursor, C, id, varTypeIR) = C[GLOBAL.FRAME = frame]
      -- if cursor matches `GLOBAL`
      -- let frame = $add_map<id, varTypeIR>(C.GLOBAL.FRAME, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02-context.watsup:126.1-127.70
   clause 1(cursor, C, id, varTypeIR) = C[BLOCK.FRAME = frame]
      -- if cursor matches `BLOCK`
      -- let frame = $add_map<id, varTypeIR>(C.BLOCK.FRAME, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02-context.watsup:128.1-131.44
   clause 2(cursor, C, id, varTypeIR) = C[LOCAL.FRAMES = frame*{frame <- frame*}]
      -- if cursor matches `LOCAL`
      -- let frame'*{frame' <- frame'*} = C.LOCAL.FRAMES
      -- if frame'*{frame' <- frame'*} matches _ :: _
      -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame'*{frame' <- frame'*}
      -- let frame_h_update = $add_map<id, varTypeIR>(frame_h, id, varTypeIR)
      -- let frame*{frame <- frame*} = frame_h_update :: frame_t*{frame_t <- frame_t*}

;; ../../../../spec-concrete/5.02-context.watsup:122.1-122.58
def $add_vars(cursor, context, id*, varTypeIR*) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:133.1-133.34
   clause 0(p, C, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = C
      -- if id*{id <- id*} matches []
      -- if varTypeIR*{varTypeIR <- varTypeIR*} matches []

   ;; ../../../../spec-concrete/5.02-context.watsup:134.1-136.52
   clause 1(p, C, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = C''
      -- if id*{id <- id*} matches _ :: _
      -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
      -- if varTypeIR*{varTypeIR <- varTypeIR*} matches _ :: _
      -- let varTypeIR_h :: varTypeIR_t*{varTypeIR_t <- varTypeIR_t*} = varTypeIR*{varTypeIR <- varTypeIR*}
      -- let C' = $add_var(p, C, id_h, varTypeIR_h)
      -- let C'' = $add_vars(p, C', id_t*{id_t <- id_t*}, varTypeIR_t*{varTypeIR_t <- varTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:140.1-140.63
def $add_parameter(cursor, context, parameterTypeIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:143.1-145.48
   clause 0(cursor, C, direction typeIR id value?{value <- value?}) = C'
      -- if direction matches ``EMPTY`
      -- let varTypeIR = ``EMPTY` typeIR `CTK` value?{value <- value?}
      -- let C' = $add_var(cursor, C, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02-context.watsup:146.1-149.48
   clause 1(cursor, C, direction typeIR id value?{value <- value?}) = C'
      -- if (((direction = `IN`) \/ (direction = `OUT`)) \/ (direction = `INOUT`))
      -- let varTypeIR = direction typeIR `DYN` value?{value <- value?}
      -- let C' = $add_var(cursor, C, id, varTypeIR)

;; ../../../../spec-concrete/5.02-context.watsup:141.1-141.65
def $add_parameters(cursor, context, parameterTypeIR*) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:151.1-151.40
   clause 0(cursor, C, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = C
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.02-context.watsup:152.1-154.62
   clause 1(cursor, C, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = C''
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let C' = $add_parameter(cursor, C, parameterTypeIR_h)
      -- let C'' = $add_parameters(cursor, C', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:158.1-158.66
def $add_constructorParameter(context, parameterTypeIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:161.1-163.47
   clause 0(C, direction typeIR id value?{value <- value?}) = C'
      -- if value?{value <- value?} matches ()
      -- let varTypeIR = direction typeIR `CTK` ?()
      -- let C' = $add_var(`BLOCK`, C, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02-context.watsup:164.1-166.47
   clause 1(C, direction typeIR id value'?{value' <- value'?}) = C'
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- let varTypeIR = direction typeIR `CTK` ?(value)
      -- let C' = $add_var(`BLOCK`, C, id, varTypeIR)

;; ../../../../spec-concrete/5.02-context.watsup:159.1-159.68
def $add_constructorParameters(context, parameterTypeIR*) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:168.1-168.43
   clause 0(C, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = C
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.02-context.watsup:169.1-171.65
   clause 1(C, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = C''
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let C' = $add_constructorParameter(C, parameterTypeIR_h)
      -- let C'' = $add_constructorParameters(C', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:175.1-175.57
def $add_type(cursor, context, tid, typeDefIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:176.1-180.48
   clause 0(cursor, C, tid, typeDefIR) = C'
      -- if cursor matches `GLOBAL`
      -- let tdenv = C.GLOBAL.TDENV
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let C' = C[GLOBAL.TDENV = tdenv_update]

   ;; ../../../../spec-concrete/5.02-context.watsup:181.1-185.47
   clause 1(cursor, C, tid, typeDefIR) = C'
      -- if cursor matches `BLOCK`
      -- let tdenv = C.BLOCK.TDENV
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let C' = C[BLOCK.TDENV = tdenv_update]

   ;; ../../../../spec-concrete/5.02-context.watsup:186.1-190.47
   clause 2(cursor, C, tid, typeDefIR) = C'
      -- if cursor matches `LOCAL`
      -- let tdenv = C.LOCAL.TDENV
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let C' = C[LOCAL.TDENV = tdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:192.1-192.60
def $add_types(cursor, context, tid*, typeDefIR*) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:193.1-193.35
   clause 0(p, C, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = C
      -- if tid*{tid <- tid*} matches []
      -- if typeDefIR*{typeDefIR <- typeDefIR*} matches []

   ;; ../../../../spec-concrete/5.02-context.watsup:194.1-196.54
   clause 1(p, C, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = C''
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if typeDefIR*{typeDefIR <- typeDefIR*} matches _ :: _
      -- let typeDefIR_h :: typeDefIR_t*{typeDefIR_t <- typeDefIR_t*} = typeDefIR*{typeDefIR <- typeDefIR*}
      -- let C' = $add_type(p, C, tid_h, typeDefIR_h)
      -- let C'' = $add_types(p, C', tid_t*{tid_t <- tid_t*}, typeDefIR_t*{typeDefIR_t <- typeDefIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:200.1-200.76
def $add_routine_overload(cursor, context, rid, routineTypeDefIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:202.1-206.48
   clause 0(cursor, C, rid, routineTypeDefIR) = C'
      -- if cursor matches `GLOBAL`
      -- let rdenv = C.GLOBAL.RDENV
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let C' = C[GLOBAL.RDENV = rdenv_update]

   ;; ../../../../spec-concrete/5.02-context.watsup:207.1-211.47
   clause 1(cursor, C, rid, routineTypeDefIR) = C'
      -- if cursor matches `BLOCK`
      -- let rdenv = C.BLOCK.RDENV
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let C' = C[BLOCK.RDENV = rdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:213.1-213.80
def $add_routine_non_overload(cursor, context, rid, routineTypeDefIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:215.1-219.48
   clause 0(cursor, C, rid, routineTypeDefIR) = C'
      -- if cursor matches `GLOBAL`
      -- let rdenv = C.GLOBAL.RDENV
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let C' = C[GLOBAL.RDENV = rdenv_update]

   ;; ../../../../spec-concrete/5.02-context.watsup:220.1-224.47
   clause 1(cursor, C, rid, routineTypeDefIR) = C'
      -- if cursor matches `BLOCK`
      -- let rdenv = C.BLOCK.RDENV
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let C' = C[BLOCK.RDENV = rdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:228.1-228.67
def $add_constructor(context, cid, constructorTypeDefIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:230.1-234.48
   clause 0(C, cid, constructorTypeDefIR) = C'
      -- let cdenv = C.GLOBAL.CDENV
      -- let cdenv_update = $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR)
      -- let C' = C[GLOBAL.CDENV = cdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:242.1-242.60
def $find_var(cursor, context, prefixedNameIR) : varTypeIR? =

   ;; ../../../../spec-concrete/5.02-context.watsup:244.1-245.31
   clause 0(p, C, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR
      -- let frame = C.GLOBAL.FRAME

   ;; ../../../../spec-concrete/5.02-context.watsup:246.1-247.31
   clause 1(cursor, C, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.GLOBAL.FRAME

   ;; ../../../../spec-concrete/5.02-context.watsup:248.1-250.56
   clause 2(cursor, C, prefixedNameIR) = ?(varTypeIR)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.BLOCK.FRAME
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:251.1-253.50
   clause 3(cursor, C, prefixedNameIR) = $find_var(`GLOBAL`, C, ``` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.BLOCK.FRAME
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../spec-concrete/5.02-context.watsup:254.1-256.58
   clause 4(cursor, C, prefixedNameIR) = ?(varTypeIR)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame*{frame <- frame*} = C.LOCAL.FRAMES
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:257.1-259.52
   clause 5(cursor, C, prefixedNameIR) = $find_var(`BLOCK`, C, ``` id)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame*{frame <- frame*} = C.LOCAL.FRAMES
      -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../spec-concrete/5.02-context.watsup:263.1-263.57
def $find_value(cursor, context, prefixedNameIR) : value =

   ;; ../../../../spec-concrete/5.02-context.watsup:265.1-267.58
   clause 0(p, C, prefixedNameIR) = value
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR
      -- let frame = C.GLOBAL.FRAME
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:268.1-270.58
   clause 1(cursor, C, prefixedNameIR) = value
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.GLOBAL.FRAME
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:271.1-273.58
   clause 2(cursor, C, prefixedNameIR) = value
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.BLOCK.FRAME
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:274.1-276.50
   clause 3(cursor, C, prefixedNameIR) = $find_value(`GLOBAL`, C, ``` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.BLOCK.FRAME
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../spec-concrete/5.02-context.watsup:277.1-279.60
   clause 4(cursor, C, prefixedNameIR) = value
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame*{frame <- frame*} = C.LOCAL.FRAMES
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:280.1-282.52
   clause 5(cursor, C, prefixedNameIR) = $find_value(`BLOCK`, C, ``` id)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame*{frame <- frame*} = C.LOCAL.FRAMES
      -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../spec-concrete/5.02-context.watsup:286.1-286.61
def $find_type(cursor, context, prefixedNameIR) : typeDefIR? =

   ;; ../../../../spec-concrete/5.02-context.watsup:288.1-290.31
   clause 0(p, C, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if prefixedNameIR matches `.%`
      -- let `.` tid = prefixedNameIR
      -- let tdenv = C.GLOBAL.TDENV

   ;; ../../../../spec-concrete/5.02-context.watsup:291.1-293.31
   clause 1(cursor, C, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv = C.GLOBAL.TDENV

   ;; ../../../../spec-concrete/5.02-context.watsup:294.1-296.58
   clause 2(cursor, C, prefixedNameIR) = ?(typeDefIR)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv = C.BLOCK.TDENV
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:297.1-299.52
   clause 3(cursor, C, prefixedNameIR) = $find_type(`GLOBAL`, C, ``` tid)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv = C.BLOCK.TDENV
      -- if (?() = $find_map<tid, typeDefIR>(tdenv, tid))

   ;; ../../../../spec-concrete/5.02-context.watsup:300.1-302.60
   clause 4(cursor, C, prefixedNameIR) = ?(typeDefIR)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv*{tdenv <- tdenv*} = [C.LOCAL.TDENV]
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:303.1-305.54
   clause 5(cursor, C, prefixedNameIR) = $find_type(`BLOCK`, C, ``` tid)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv*{tdenv <- tdenv*} = [C.LOCAL.TDENV]
      -- if (?() = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid))

;; ../../../../spec-concrete/5.02-context.watsup:309.1-309.39
def $ids_arguments(argument*) : id?* =

   ;; ../../../../spec-concrete/5.02-context.watsup:312.1-312.58
   clause 0(argument*{argument <- argument*}) = $id_argument(argument)*{argument <- argument*}

;; ../../../../spec-concrete/5.02-context.watsup:310.1-310.33
def $id_argument(argument) : id? =

   ;; ../../../../spec-concrete/5.02-context.watsup:313.1-313.35
   clause 0(argument) = ?()
      -- if argument <: expression
      -- let expression = argument as expression

   ;; ../../../../spec-concrete/5.02-context.watsup:314.1-314.42
   clause 1(argument) = ?($name(name))
      -- if argument matches `%=%`
      -- let name `=` _expression = argument

   ;; ../../../../spec-concrete/5.02-context.watsup:315.1-315.43
   clause 2(argument) = ?($name(name))
      -- if argument matches `%=_`
      -- let name `=_` = argument

   ;; ../../../../spec-concrete/5.02-context.watsup:316.1-316.27
   clause 3(argument) = ?()
      -- if argument matches `_`

;; ../../../../spec-concrete/5.02-context.watsup:318.1-319.34
def $find_routine_overloaded(cursor, context, prefixedNameIR, argument*) : (rid, routineTypeDefIR, id*)? =

   ;; ../../../../spec-concrete/5.02-context.watsup:321.1-324.47
   clause 0(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR
      -- let rdenv = C.GLOBAL.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})

   ;; ../../../../spec-concrete/5.02-context.watsup:325.1-328.47
   clause 1(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let rdenv = C.GLOBAL.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})

   ;; ../../../../spec-concrete/5.02-context.watsup:329.1-334.66
   clause 2(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*}))
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let rdenv = C.BLOCK.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}

   ;; ../../../../spec-concrete/5.02-context.watsup:335.1-340.66
   clause 3(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = $find_routine_overloaded(`GLOBAL`, C, ``` id, argument*{argument <- argument*})
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let rdenv = C.BLOCK.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- if (?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

   ;; ../../../../spec-concrete/5.02-context.watsup:341.1-342.57
   clause 4(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = $find_routine_overloaded(`BLOCK`, C, ``` id, argument*{argument <- argument*})
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR

;; ../../../../spec-concrete/5.02-context.watsup:344.1-345.22
def $find_routine_non_overloaded(cursor, context, prefixedNameIR) : routineTypeDefIR? =

   ;; ../../../../spec-concrete/5.02-context.watsup:347.1-348.63
   clause 0(p, C, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(C.GLOBAL.RDENV, id)
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR

   ;; ../../../../spec-concrete/5.02-context.watsup:349.1-350.63
   clause 1(cursor, C, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(C.GLOBAL.RDENV, id)
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR

   ;; ../../../../spec-concrete/5.02-context.watsup:351.1-353.66
   clause 2(cursor, C, prefixedNameIR) = ?(routineTypeDefIR)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_non_overloaded<routineTypeDefIR>(C.BLOCK.RDENV, id)
      -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
      -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:354.1-357.66
   clause 3(cursor, C, prefixedNameIR) = $find_routine_non_overloaded(`GLOBAL`, C, ``` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- if (?() = $find_non_overloaded<routineTypeDefIR>(C.BLOCK.RDENV, id))

   ;; ../../../../spec-concrete/5.02-context.watsup:358.1-359.50
   clause 4(cursor, C, prefixedNameIR) = $find_routine_non_overloaded(`BLOCK`, C, ``` id)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR

;; ../../../../spec-concrete/5.02-context.watsup:363.1-364.38
def $find_constructor_overloaded(context, prefixedNameIR, argument*) : (rid, constructorTypeDefIR, id*)? =

   ;; ../../../../spec-concrete/5.02-context.watsup:366.1-369.47
   clause 0(C, prefixedNameIR, argument*{argument <- argument*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR
      -- let cdenv = C.GLOBAL.CDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})

   ;; ../../../../spec-concrete/5.02-context.watsup:370.1-373.47
   clause 1(C, prefixedNameIR, argument*{argument <- argument*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let cdenv = C.GLOBAL.CDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})

;; ../../../../spec-concrete/5.03-table-context.watsup:5.19-5.31
syntax matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:7.22-7.72
syntax matchAction = (prefixedNameIR, parameterTypeIR*, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:10.3-13.24
syntax matchPriority = {`VALUES` nat*, `INIT` bool, `DELTA` nat, `LARGEST_WINS` bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:16.3-17.17
syntax matchEntry = {`SIZE` nat, `CONST` bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:21.1-27.11
syntax matchMode = 
   | `NOPRI`
   | `NOPRILPM` nat
   | `PRI`
   | `PRILPM`

;; ../../../../spec-concrete/5.03-table-context.watsup:30.3-34.21
syntax tablecontext = {`KEYS` matchKey*, `ACTIONS` matchAction*, `PRIORITIES` matchPriority, `ENTRIES` matchEntry, `MODE` matchMode}

;; ../../../../spec-concrete/5.03-table-context.watsup:44.1-46.10
syntax tableEntryState = 
   | `LPM` nat
   | `NOLPM`

;; ../../../../spec-concrete/5.03-table-context.watsup:54.1-54.38
def $empty_tablecontext : tablecontext =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:55.1-68.25
   clause 0 = {KEYS [], ACTIONS [], PRIORITIES matchPriority, ENTRIES matchEntry, MODE `NOPRI`}
      -- let matchPriority = {VALUES [], INIT false, DELTA 1, LARGEST_WINS true}
      -- let matchEntry = {SIZE 0, CONST true}

;; ../../../../spec-concrete/5.03-table-context.watsup:76.1-76.54
def $add_key(tablecontext, id, typeIR) : tablecontext =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:78.1-80.32
   clause 0(TC, id, typeIR) = TC[KEYS = TC.KEYS ++ [matchKey]]
      -- let matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:84.1-84.95
def $add_action(tablecontext, prefixedNameIR, parameterTypeIR*, argumentListIR) : tablecontext =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:86.1-88.73
   clause 0(TC, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = TC[ACTIONS = TC.ACTIONS ++ [matchAction]]
      -- let matchAction = (prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:92.1-92.58
def $add_table_priority(tablecontext, nat) : tablecontext =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:94.1-95.61
   clause 0(TC, n) = TC[PRIORITIES.VALUES = TC.PRIORITIES.VALUES ++ [n]]

;; ../../../../spec-concrete/5.03-table-context.watsup:103.1-103.58
def $update_mode(tablecontext, id, typeIR) : tablecontext =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:106.1-106.73
   clause 0(TC, id, typeIR) = $update_mode'(TC, id, $canon(typeIR))

;; ../../../../spec-concrete/5.03-table-context.watsup:104.1-104.59
def $update_mode'(tablecontext, id, typeIR) : tablecontext =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:107.1-108.24
   clause 0(TC, text, typeIR) = TC[MODE = `NOPRILPM` n]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` n `>` = numberTypeIR
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:109.1-110.24
   clause 1(TC, text, typeIR) = TC[MODE = `NOPRILPM` n]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` n `>` = numberTypeIR
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:111.1-112.24
   clause 2(TC, text, typeIR) = TC[MODE = `NOPRILPM` n]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` n `>` = numberTypeIR
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:113.1-114.36
   clause 3(TC, text, typeIR') = $update_mode(TC, "lpm", typeIR)
      -- if (text = "lpm")
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-table-context.watsup:115.1-116.22
   clause 4(TC, text, _typeIR) = TC[MODE = `PRILPM`]
      -- if (text = "lpm")
      -- if (TC.MODE = `PRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:117.1-118.24
   clause 5(TC, text, _typeIR) = TC[MODE = `PRI`]
      -- if (text = "range")
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:119.1-120.24
   clause 6(TC, text, _typeIR) = TC[MODE = `PRI`]
      -- if (text = "ternary")
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:121.1-122.24
   clause 7(TC, text, _typeIR) = TC[MODE = `PRI`]
      -- if (text = "optional")
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:123.1-124.29
   clause 8(TC, text, _typeIR) = TC[MODE = `PRILPM`]
      -- if (text = "range")
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` _nat = matchMode

   ;; ../../../../spec-concrete/5.03-table-context.watsup:125.1-126.29
   clause 9(TC, text, _typeIR) = TC[MODE = `PRILPM`]
      -- if (text = "ternary")
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` _nat = matchMode

   ;; ../../../../spec-concrete/5.03-table-context.watsup:127.1-128.29
   clause 10(TC, text, _typeIR) = TC[MODE = `PRILPM`]
      -- if (text = "optional")
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` _nat = matchMode

   ;; ../../../../spec-concrete/5.03-table-context.watsup:129.1-130.15
   clause 11(TC, _id, _typeIR) = TC
      -- otherwise

;; ../../../../spec-concrete/5.03-table-context.watsup:138.1-138.85
def $find_action(tablecontext, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:141.1-141.81
   clause 0(TC, prefixedNameIR) = $find_action'(TC.ACTIONS, prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:139.1-139.86
def $find_action'(matchAction*, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:143.1-143.45
   clause 0(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?()
      -- if matchAction*{matchAction <- matchAction*} matches []

   ;; ../../../../spec-concrete/5.03-table-context.watsup:145.1-147.75
   clause 1(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?((parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR))
      -- if matchAction*{matchAction <- matchAction*} matches _ :: _
      -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
      -- let (prefixedNameIR', parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = matchAction_h
      -- if (prefixedNameIR' = prefixedNameIR)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:149.1-152.44
   clause 2(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = $find_action'(matchAction_t*{matchAction_t <- matchAction_t*}, prefixedNameIR)
      -- if matchAction*{matchAction <- matchAction*} matches _ :: _
      -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
      -- let (prefixedNameIR_h, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR) = matchAction_h
      -- if (prefixedNameIR_h =/= prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:156.1-156.50
def $find_table_priority_last(tablecontext) : nat =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:158.1-159.34
   clause 0(TC) = n*{n <- n*}[(|n*{n <- n*}| - 1)]
      -- let n*{n <- n*} = TC.PRIORITIES.VALUES

;; ../../../../spec-concrete/5.03-table-context.watsup:165.1-165.78
def $join_tableEntryState(tableEntryState, tableEntryState) : tableEntryState =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:167.1-167.48
   clause 0(tableEntryState, tableEntryState') = `LPM` n
      -- if tableEntryState matches `NOLPM`
      -- if tableEntryState' matches `LPM%`
      -- let `LPM` n = tableEntryState'

   ;; ../../../../spec-concrete/5.03-table-context.watsup:168.1-168.48
   clause 1(tableEntryState, tableEntryState') = `LPM` n
      -- if tableEntryState matches `LPM%`
      -- let `LPM` n = tableEntryState
      -- if tableEntryState' matches `NOLPM`

   ;; ../../../../spec-concrete/5.03-table-context.watsup:169.1-169.48
   clause 2(tableEntryState, tableEntryState') = `NOLPM`
      -- if tableEntryState matches `NOLPM`
      -- if tableEntryState' matches `NOLPM`

;; ../../../../spec-concrete/5.03-table-context.watsup:171.1-171.40
def $tableEntry_lpm_prefix(value) : nat =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:174.1-174.70
   clause 0(value) = $tableEntry_lpm_prefix'(value, 0)

;; ../../../../spec-concrete/5.03-table-context.watsup:172.1-172.46
def $tableEntry_lpm_prefix'(value, nat) : nat =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:175.1-175.56
   clause 0(value, n_prefix) = n_prefix
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let nat `W` _int = number
      -- if (nat = 0)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:176.1-180.43
   clause 1(value, n_prefix) = $tableEntry_lpm_prefix'(value', (n_prefix + 1))
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` int = number
      -- if int <: nat
      -- let n = int as nat
      -- if (w > 0)
      -- if ((n \ 2) =/= 0)
      -- let value' = (w - 1) `W` ((n - 1) / 2) as int as value

   ;; ../../../../spec-concrete/5.03-table-context.watsup:181.1-185.37
   clause 2(value, nat) = $tableEntry_lpm_prefix'(value', 0)
      -- if value <: number
      -- let number = value as number
      -- if number matches `%W%`
      -- let w `W` int = number
      -- if int <: nat
      -- let n = int as nat
      -- if (nat = 0)
      -- if (w > 0)
      -- if ((n \ 2) = 0)
      -- let value' = (w - 1) `W` (n / 2) as int as value

;; ../../../../spec-concrete/5.03-wellformed.watsup:5.1-7.20
relation Type_wf: bound `|-` typeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:82.1-83.22
   rule basetype: bound `|-` typeIR
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:87.1-89.33
   rule tid: bound `|-` typeIR
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR
      -- if $in_set<tid>(tid, bound)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:91.1-94.30
   rule spectype: bound `|-` typeIR'
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR
      -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:112.1-115.30
   rule typedeftype: bound `|-` typeIR'
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR = aliasTypeIR
      -- if $nestable_typedef(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:129.1-132.30
   rule newtype: bound `|-` typeIR'
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR
      -- if $nestable_new(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:151.1-154.30
   rule listttype: bound `|-` typeIR'
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR `>` = typeIR' as listTypeIR
      -- if $nestable_list(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:177.1-180.33
   rule tupletype: bound `|-` typeIR'
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $nestable_tuple(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:192.1-195.30
   rule stacktype: bound `|-` typeIR'
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR
      -- if $nestable_stack(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:218.1-222.33
   rule structtype: bound `|-` typeIR'
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_struct(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:255.1-259.33
   rule headertype: bound `|-` typeIR'
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `}` = typeIR' as headerTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_header(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:272.1-276.33
   rule headeruniontype: bound `|-` typeIR'
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `}` = typeIR' as headerUnionTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_headerunion(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:278.1-280.28
   rule enumtype: bound `|-` typeIR
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` id*{id <- id*} `}` = enumTypeIR
      -- if $distinct_<id>(id*{id <- id*})

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:306.1-310.30
   rule serenumtype: bound `|-` typeIR'
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` id `=` _value `;`*{_value <- _value*, id <- id*} `}` = enumTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- if $nestable_serenum(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:314.1-316.53
   rule externtype: bound `|-` typeIR
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid `{` _rid `:` routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} `}` = typeIR as externObjectTypeIR
      -- (if RoutineTypeDef_wf: bound `|-` routineTypeDefIR holds)*{routineTypeDefIR <- routineTypeDefIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:318.1-320.50
   rule parsertype: bound `|-` typeIR
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as parserObjectTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:322.1-324.50
   rule controltype: bound `|-` typeIR
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as controlObjectTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:326.1-328.33
   rule packagetype: bound `|-` typeIR'
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as packageObjectTypeIR
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:330.1-333.30
   rule tabletype: bound `|-` typeIR'
      -- if typeIR' <: tableObjectTypeIR
      -- let `TABLE` _tid `#` typeIR = typeIR' as tableObjectTypeIR
      -- let typeIR'' = $canon(typeIR)
      -- if typeIR'' <: tableTypeIR
      -- let tableTypeIR = typeIR'' as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid' `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:337.1-338.19
   rule defaulttype: bound `|-` typeIR
      -- if (typeIR = `DEFAULT` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:340.1-342.33
   rule sequencetype: bound `|-` typeIR'
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:344.1-346.33
   rule sequencedefaulttype: bound `|-` typeIR'
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `,...>` = sequenceTypeIR
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:348.1-351.33
   rule recordtype: bound `|-` typeIR'
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `}` = recordTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:353.1-356.33
   rule recorddefaulttype: bound `|-` typeIR'
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `,...}` = recordTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:358.1-359.26
   rule invalidtype: bound `|-` typeIR
      -- if (typeIR = `HEADER_INVALID` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:414.1-417.30
   rule settype: bound `|-` typeIR''
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- if $nestable_set(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:419.1-421.28
   rule tableenumtype: bound `|-` typeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` _tid `{` id*{id <- id*} `}` = tableTypeIR
      -- if $distinct_<id>(id*{id <- id*})

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:423.1-424.33
   rule tablestructtype: bound `|-` typeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:9.1-11.20
relation TypeDef_wf: bound `|-` typeDefIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:440.1-443.30
   rule mono: bound `|-` typeDefIR
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- if $definable_type_mono(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:459.1-465.36
   rule poly: bound `|-` typeDefIR
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` = typeDefIR as polyTypeDefIR
      -- if $definable_type_poly(typeIR)
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, `{` tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} `}`)
      -- if Type_wf: bound_inner `|-` typeIR holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:13.1-15.20
relation ParameterType_wf: bound `|-` parameterTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:49.1-52.41
   rule default-empty-extern: bound `|-` direction typeIR _id value?{value <- value?}
      -- if direction matches ``EMPTY`
      -- if value?{value <- value?} matches ()
      -- if Type_wf: bound `|-` typeIR holds
      -- if $is_extern_object_typeIR(typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:54.1-57.42
   rule default-none-not-extern: bound `|-` direction typeIR _id value?{value <- value?}
      -- if value?{value <- value?} matches ()
      -- if Type_wf: bound `|-` typeIR holds
      -- if ~$is_extern_object_typeIR(typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:59.1-62.41
   rule default-some-extern: bound `|-` direction typeIR _id value'?{value' <- value'?}
      -- if direction matches ``EMPTY`
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- if Type_wf: bound `|-` typeIR holds
      -- if $is_extern_object_typeIR(typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:64.1-68.45
   rule default-some-not-extern: bound `|-` direction typeIR _id value'?{value' <- value'?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- if Type_wf: bound `|-` typeIR holds
      -- if ~$is_extern_object_typeIR(typeIR)
      -- if ((direction = `IN`) \/ (direction = ``EMPTY`))

;; ../../../../spec-concrete/5.03-wellformed.watsup:17.1-19.20
relation ParameterTypes_wf: bound `|-` parameterTypeIR*

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:70.1-74.51
   rule : bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- if $distinct_<id>(id*{id <- id*})
      -- (if ParameterType_wf: bound `|-` parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}

;; ../../../../spec-concrete/5.03-wellformed.watsup:21.1-23.20
relation RoutineType_wf: bound `|-` routineTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:473.1-476.34
   rule builtinfunction: bound `|-` routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:491.1-496.34
   rule functiontype: bound `|-` routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_function(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:524.1-529.45
   rule actiontype: bound `|-` routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- if $directionless_trailing(direction*{direction <- direction*})
      -- (if $nestable_action(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:547.1-552.34
   rule externfunctiontype: bound `|-` routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externfunction(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:556.1-559.34
   rule builtinmethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:577.1-582.34
   rule externmethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:600.1-605.34
   rule externabstractmethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externabstractmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:622.1-626.56
   rule parserapplymethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_parserapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:643.1-647.57
   rule controlapplymethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_controlapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:649.1-650.51
   rule tableapplymethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR = methodTypeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:25.1-27.20
relation RoutineTypeDef_wf: bound `|-` routineTypeDefIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:667.1-670.44
   rule mono: bound `|-` routineTypeDefIR
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR
      -- if $definable_routine_mono(routineTypeIR)
      -- if RoutineType_wf: bound `|-` routineTypeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:681.1-687.50
   rule poly: bound `|-` routineTypeDefIR
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- if $definable_routine_poly(routineTypeIR)
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, `{` tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} `}`)
      -- if RoutineType_wf: bound_inner `|-` routineTypeIR holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:29.1-31.20
relation ConstructorParameterType_wf: bound `|-` parameterTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:693.1-695.30
   rule : bound `|-` direction typeIR _id _value?{_value <- _value?}
      -- if direction matches ``EMPTY`
      -- if Type_wf: bound `|-` typeIR holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:33.1-35.20
relation ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:697.1-701.62
   rule : bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- if $distinct_<id>(id*{id <- id*})
      -- (if ConstructorParameterType_wf: bound `|-` parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}

;; ../../../../spec-concrete/5.03-wellformed.watsup:37.1-39.20
relation ConstructorType_wf: bound `|-` constructorTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:719.1-725.46
   rule externtype: bound `|-` `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object
      -- if ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR' as externObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_extern(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:738.1-744.46
   rule parsertype: bound `|-` `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object
      -- if ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR' as parserObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_parser(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:757.1-763.47
   rule controltype: bound `|-` `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object
      -- if ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR' as controlObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_control(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:774.1-780.47
   rule packagetype: bound `|-` `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object
      -- if ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR' as packageObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_package(typeIR))*{typeIR <- typeIR*}

;; ../../../../spec-concrete/5.03-wellformed.watsup:41.1-43.20
relation ConstructorTypeDef_wf: bound `|-` constructorTypeDefIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:798.1-805.58
   rule : bound `|-` constructorTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>`
      -- let `CONSTRUCTOR(` _constructorParameterTypeIR*{_constructorParameterTypeIR <- _constructorParameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- if $definable_constructor(typeIR_object)
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, `{` tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} `}`)
      -- if ConstructorType_wf: bound_inner `|-` constructorTypeIR holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:98.1-98.37
def $nestable_typedef(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:101.1-101.67
   clause 0(typeIR) = $nestable'_typedef($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:99.1-99.38
def $nestable'_typedef(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:102.1-102.36
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:103.1-103.37
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:104.1-104.38
   clause 2(typeIR) = true
      -- if (typeIR = `STRING` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:105.1-105.44
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:106.1-106.37
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:107.1-107.40
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:108.1-108.42
   clause 6(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:109.1-110.15
   clause 7(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:117.1-117.33
def $nestable_new(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:120.1-120.59
   clause 0(typeIR) = $nestable'_new($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:118.1-118.34
def $nestable'_new(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:121.1-121.32
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:122.1-122.38
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:123.1-123.38
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:124.1-124.33
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:125.1-125.36
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:126.1-127.15
   clause 5(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:136.1-136.34
def $nestable_list(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:139.1-139.61
   clause 0(typeIR) = $nestable'_list($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:137.1-137.35
def $nestable'_list(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:140.1-140.33
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:141.1-141.34
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:142.1-142.39
   clause 2(typeIR) = true
      -- if (typeIR = `MATCH_KIND` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:143.1-143.35
   clause 3(typeIR) = true
      -- if (typeIR = `STRING` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:144.1-144.41
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:145.1-145.34
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:146.1-146.37
   clause 6(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:147.1-147.39
   clause 7(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:148.1-149.15
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:156.1-156.35
def $nestable_tuple(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:159.1-159.63
   clause 0(typeIR) = $nestable'_tuple($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:157.1-157.36
def $nestable'_tuple(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:160.1-160.34
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:161.1-161.35
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:162.1-162.40
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:163.1-163.40
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:164.1-164.43
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:165.1-165.35
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:166.1-166.38
   clause 6(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:167.1-167.42
   clause 7(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as tupleTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:168.1-168.43
   clause 8(typeIR') = true
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:169.1-169.45
   clause 9(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:170.1-170.51
   clause 10(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:171.1-171.45
   clause 11(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:172.1-172.43
   clause 12(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:173.1-173.48
   clause 13(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:174.1-175.15
   clause 14(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:182.1-182.35
def $nestable_stack(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:185.1-185.63
   clause 0(typeIR) = $nestable'_stack($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:183.1-183.36
def $nestable'_stack(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:186.1-186.35
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:187.1-187.45
   clause 1(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:188.1-188.51
   clause 2(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:189.1-190.15
   clause 3(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:197.1-197.36
def $nestable_struct(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:200.1-200.65
   clause 0(typeIR) = $nestable'_struct($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:198.1-198.37
def $nestable'_struct(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:201.1-201.35
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:202.1-202.36
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:203.1-203.41
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:204.1-204.41
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:205.1-205.44
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:206.1-206.36
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:207.1-207.39
   clause 6(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:208.1-208.43
   clause 7(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as tupleTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:209.1-209.44
   clause 8(typeIR') = true
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:210.1-210.46
   clause 9(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:211.1-211.46
   clause 10(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:212.1-212.52
   clause 11(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:213.1-213.44
   clause 12(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:214.1-214.49
   clause 13(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:215.1-216.15
   clause 14(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:224.1-224.36
def $nestable_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:229.1-229.65
   clause 0(typeIR) = $nestable'_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:225.1-225.37
def $nestable'_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:230.1-230.35
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:231.1-231.41
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:232.1-232.41
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:233.1-233.44
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:234.1-234.36
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:235.1-235.39
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:236.1-236.49
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:237.1-238.44
   clause 7(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR
      -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:239.1-240.15
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:226.1-226.46
def $nestable_struct_in_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:242.1-243.48
   clause 0(typeIR) = $nestable'_struct_in_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:227.1-227.47
def $nestable'_struct_in_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:244.1-244.45
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:245.1-245.51
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:246.1-246.51
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:247.1-247.46
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:248.1-248.49
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:249.1-249.59
   clause 5(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:250.1-251.44
   clause 6(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR
      -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:252.1-253.15
   clause 7(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:261.1-261.41
def $nestable_headerunion(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:264.1-265.43
   clause 0(typeIR) = $nestable'_headerunion($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:262.1-262.42
def $nestable'_headerunion(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:266.1-266.41
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:267.1-267.44
   clause 1(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:268.1-268.51
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:269.1-270.15
   clause 3(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:282.1-282.37
def $nestable_serenum(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:287.1-288.39
   clause 0(typeIR) = $nestable'_serenum($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:283.1-283.38
def $nestable'_serenum(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:289.1-289.42
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:290.1-290.42
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:291.1-291.37
   clause 2(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:292.1-293.37
   clause 3(typeIR') = $nestable_new_in_serenum(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:294.1-295.15
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:284.1-284.44
def $nestable_new_in_serenum(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:297.1-298.46
   clause 0(typeIR) = $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:285.1-285.45
def $nestable_new_in_serenum'(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:299.1-299.49
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:300.1-300.49
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:301.1-301.44
   clause 2(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:302.1-302.47
   clause 3(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:303.1-304.15
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:361.1-361.33
def $nestable_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:368.1-368.59
   clause 0(typeIR) = $nestable'_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:362.1-362.34
def $nestable'_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:369.1-369.32
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:370.1-370.33
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:371.1-371.38
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:372.1-372.38
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:373.1-373.33
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:374.1-374.36
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:375.1-376.40
   clause 6(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:377.1-377.41
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:378.1-378.46
   clause 8(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:379.1-380.43
   clause 9(typeIR') = true
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:381.1-382.15
   clause 10(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:363.1-363.42
def $nestable_tuple_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:384.1-385.44
   clause 0(typeIR) = $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:364.1-364.43
def $nestable'_tuple_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:386.1-386.41
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:387.1-387.47
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:388.1-388.47
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:389.1-389.42
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:390.1-390.45
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:391.1-392.40
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:393.1-393.50
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:394.1-394.55
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:395.1-396.15
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:365.1-365.45
def $nestable_sequence_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:398.1-399.47
   clause 0(typeIR) = $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:366.1-366.46
def $nestable'_sequence_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:400.1-400.44
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:401.1-401.50
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:402.1-402.50
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:403.1-403.45
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:404.1-404.48
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:405.1-406.43
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:407.1-407.53
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:408.1-408.58
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:409.1-410.43
   clause 8(typeIR') = true
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:411.1-412.15
   clause 9(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:430.1-430.40
def $definable_type_mono(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:432.1-432.39
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:433.1-433.45
   clause 1(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:434.1-434.47
   clause 2(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:435.1-435.52
   clause 3(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:436.1-436.46
   clause 4(typeIR) = true
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:437.1-438.15
   clause 5(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:445.1-445.40
def $definable_type_poly(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:447.1-447.46
   clause 0(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as tupleTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:448.1-448.42
   clause 1(typeIR) = true
      -- if typeIR <: headerStackTypeIR
      -- let _typeIR `[` _nat `]` = typeIR as headerStackTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:449.1-449.49
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:450.1-450.55
   clause 3(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:451.1-451.49
   clause 4(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:452.1-452.44
   clause 5(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:453.1-453.47
   clause 6(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:454.1-454.48
   clause 7(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:455.1-455.48
   clause 8(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:456.1-457.15
   clause 9(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:478.1-478.49
def $nestable_function(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:481.1-482.51
   clause 0(direction, typeIR) = $nestable_function'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:479.1-479.50
def $nestable_function'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:483.1-484.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:485.1-486.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:487.1-487.57
   clause 2(direction, typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:488.1-489.15
   clause 3(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:498.1-498.47
def $directionless_trailing(direction*) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:501.1-502.65
   clause 0(direction*{direction <- direction*}) = $directionless_trailing'(true, $rev_<direction>(direction*{direction <- direction*}))

;; ../../../../spec-concrete/5.03-wellformed.watsup:499.1-499.54
def $directionless_trailing'(bool, direction*) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:504.1-504.44
   clause 0(_bool, direction*{direction <- direction*}) = true
      -- if direction*{direction <- direction*} matches []

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:505.1-506.49
   clause 1(bool, direction'*{direction' <- direction'*}) = $directionless_trailing'(true, direction_t*{direction_t <- direction_t*})
      -- if (bool = true)
      -- if direction'*{direction' <- direction'*} matches _ :: _
      -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
      -- if direction matches ``EMPTY`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:507.1-507.68
   clause 2(bool, direction'*{direction' <- direction'*}) = false
      -- if (bool = false)
      -- if direction'*{direction' <- direction'*} matches _ :: _
      -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
      -- if direction matches ``EMPTY`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:508.1-510.31
   clause 3(_bool, direction*{direction <- direction*}) = $directionless_trailing'(false, direction_t*{direction_t <- direction_t*})
      -- if direction*{direction <- direction*} matches _ :: _
      -- let direction_h :: direction_t*{direction_t <- direction_t*} = direction*{direction <- direction*}
      -- if (direction_h =/= ``EMPTY`)

;; ../../../../spec-concrete/5.03-wellformed.watsup:512.1-512.47
def $nestable_action(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:515.1-516.49
   clause 0(direction, typeIR) = $nestable_action'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:513.1-513.48
def $nestable_action'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:517.1-518.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:519.1-519.38
   clause 1(_direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:520.1-520.47
   clause 2(_direction, typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:521.1-522.15
   clause 3(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:531.1-531.55
def $nestable_externfunction(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:534.1-535.57
   clause 0(direction, typeIR) = $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:532.1-532.56
def $nestable_externfunction'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:536.1-537.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:538.1-539.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:540.1-540.64
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:541.1-541.65
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:542.1-542.65
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:543.1-543.63
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:544.1-545.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:561.1-561.53
def $nestable_externmethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:564.1-565.55
   clause 0(direction, typeIR) = $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:562.1-562.54
def $nestable_externmethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:566.1-567.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:568.1-569.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:570.1-570.62
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:571.1-571.63
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:572.1-572.63
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:573.1-573.61
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:574.1-575.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:584.1-584.61
def $nestable_externabstractmethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:587.1-588.63
   clause 0(direction, typeIR) = $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:585.1-585.62
def $nestable_externabstractmethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:589.1-590.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:591.1-592.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:593.1-593.70
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:594.1-594.71
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:595.1-595.71
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:596.1-596.69
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:597.1-598.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:607.1-607.58
def $nestable_parserapplymethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:610.1-611.60
   clause 0(direction, typeIR) = $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:608.1-608.59
def $nestable_parserapplymethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:612.1-613.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:614.1-615.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:616.1-616.68
   clause 2(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:617.1-617.68
   clause 3(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:618.1-618.66
   clause 4(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:619.1-620.15
   clause 5(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:628.1-628.59
def $nestable_controlapplymethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:631.1-632.61
   clause 0(direction, typeIR) = $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:629.1-629.60
def $nestable_controlapplymethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:633.1-634.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:635.1-636.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:637.1-637.68
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:638.1-638.69
   clause 3(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:639.1-639.67
   clause 4(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:640.1-641.15
   clause 5(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:656.1-656.50
def $definable_routine_mono(routineTypeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:658.1-658.66
   clause 0(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = functionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:659.1-659.50
   clause 1(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = functionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:660.1-660.64
   clause 2(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:661.1-661.56
   clause 3(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:662.1-662.57
   clause 4(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:663.1-663.54
   clause 5(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:664.1-665.15
   clause 6(_routineTypeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:672.1-672.50
def $definable_routine_poly(routineTypeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:674.1-674.58
   clause 0(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = functionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:675.1-675.65
   clause 1(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = functionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:676.1-676.63
   clause 2(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:677.1-677.72
   clause 3(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:678.1-679.15
   clause 4(_routineTypeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:707.1-707.48
def $nestable_constructor_extern(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:710.1-711.50
   clause 0(typeIR) = $nestable'_constructor_extern($canon(typeIR))

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:712.1-712.56
   clause 1(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:708.1-708.49
def $nestable'_constructor_extern(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:713.1-713.58
   clause 0(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:714.1-714.58
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:715.1-715.56
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:716.1-717.15
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:727.1-727.48
def $nestable_constructor_parser(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:730.1-731.50
   clause 0(typeIR) = $nestable'_constructor_parser($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:728.1-728.49
def $nestable'_constructor_parser(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:732.1-732.58
   clause 0(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:733.1-733.58
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:734.1-734.56
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:735.1-736.15
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:746.1-746.49
def $nestable_constructor_control(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:749.1-750.51
   clause 0(typeIR) = $nestable'_constructor_control($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:747.1-747.50
def $nestable'_constructor_control(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:751.1-751.58
   clause 0(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:752.1-752.59
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:753.1-753.57
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:754.1-755.15
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:765.1-765.49
def $nestable_constructor_package(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:768.1-769.51
   clause 0(typeIR) = $nestable'_constructor_package($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:766.1-766.50
def $nestable'_constructor_package(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:770.1-770.57
   clause 0(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:771.1-772.15
   clause 1(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:786.1-786.42
def $definable_constructor(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:789.1-790.44
   clause 0(typeIR) = $definable'_constructor($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:787.1-787.43
def $definable'_constructor(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:791.1-791.47
   clause 0(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:792.1-792.50
   clause 1(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:793.1-793.51
   clause 2(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:794.1-794.51
   clause 3(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:795.1-796.15
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.04-typing-relation.watsup:6.1-8.23
relation Eval_static: cursor context `|-` typedExpressionIR `~>` value

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:16.1-17.36
   rule literalExpressionIR-true: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` true as value
      -- if (expressionIR = `TRUE` as expressionIR)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:19.1-20.38
   rule literalExpressionIR-false: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` false as value
      -- if (expressionIR = `FALSE` as expressionIR)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:24.1-25.34
   rule literalExpressionIR-number-arbint: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `D` i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `D%`
      -- let `D` i = number

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:27.1-28.38
   rule literalExpressionIR-number-fixbit: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` n `W` i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%W%`
      -- let n `W` i = number

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:30.1-31.38
   rule literalExpressionIR-number-fixint: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` n `S` i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%S%`
      -- let n `S` i = number

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:35.1-36.48
   rule literalExpressionIR-stringliteral: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `"` text `"` as value
      -- if expressionIR <: stringLiteral
      -- let `"` text `"` = expressionIR as stringLiteral

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:41.1-43.50
   rule referenceExpression: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` value
      -- if expressionIR <: prefixedNameIR
      -- let prefixedNameIR = expressionIR as prefixedNameIR
      -- let value = $find_value(p, C, prefixedNameIR)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:48.1-49.37
   rule defaultExpressionIR: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `DEFAULT` as value
      -- if (expressionIR = `...` as expressionIR)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:54.1-56.52
   rule unaryExpressionIR-bnot: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $un_bnot(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `~`
      -- Eval_static: p C `|-` typedExpressionIR `~>` value

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:58.1-60.52
   rule unaryExpressionIR-lnot: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $un_lnot(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `!`
      -- Eval_static: p C `|-` typedExpressionIR `~>` value

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:62.1-64.52
   rule unaryExpressionIR-plus: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $un_plus(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `+`
      -- Eval_static: p C `|-` typedExpressionIR `~>` value

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:66.1-68.52
   rule unaryExpressionIR-minus: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $un_minus(value)
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `-`
      -- Eval_static: p C `|-` typedExpressionIR `~>` value

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:74.1-78.56
   rule binaryExpressionIR-plus: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_plus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `+`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:80.1-84.56
   rule binaryExpressionIR-satplus: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_satplus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|+|`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:86.1-90.56
   rule binaryExpressionIR-minus: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_minus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `-`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:92.1-96.56
   rule binaryExpressionIR-satminus: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_satminus(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|-|`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:98.1-102.56
   rule binaryExpressionIR-mul: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_mul(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `*`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:104.1-108.56
   rule binaryExpressionIR-div: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_div(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `/`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:110.1-114.56
   rule binaryExpressionIR-shl: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_shl(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<<`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:116.1-120.56
   rule binaryExpressionIR-shr: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_shr(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>>`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:122.1-126.56
   rule binaryExpressionIR-le: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` $bin_le(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<=`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:128.1-132.56
   rule binaryExpressionIR-ge: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` $bin_ge(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>=`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:134.1-138.56
   rule binaryExpressionIR-lt: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` $bin_lt(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:140.1-144.56
   rule binaryExpressionIR-gt: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` $bin_gt(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:146.1-150.56
   rule binaryExpressionIR-eq: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` $bin_eq(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `==`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:152.1-156.56
   rule binaryExpressionIR-ne: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` $bin_ne(value_l, value_r) as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `!=`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:158.1-162.56
   rule binaryExpressionIR-band: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_band(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `&`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:164.1-168.56
   rule binaryExpressionIR-bxor: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_bxor(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `^`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:170.1-174.56
   rule binaryExpressionIR-bor: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_bor(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:176.1-180.56
   rule binaryExpressionIR-concat: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_concat(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `++`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:182.1-186.56
   rule binaryExpressionIR-land: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_land(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `&&`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:188.1-192.56
   rule binaryExpressionIR-lor: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bin_lor(value_l, value_r)
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `||`
      -- Eval_static: p C `|-` typedExpressionIR_l `~>` value_l
      -- Eval_static: p C `|-` typedExpressionIR_r `~>` value_r

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:198.1-203.62
   rule ternaryExpressionIR-true: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` value_true
      -- if expressionIR <: ternaryExpressionIR
      -- let typedExpressionIR_cond `?` typedExpressionIR_true `:` typedExpressionIR_false = expressionIR as ternaryExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR_cond `~>` value
      -- if (value = `B` true as value)
      -- Eval_static: p C `|-` typedExpressionIR_true `~>` value_true

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:205.1-210.64
   rule ternaryExpressionIR-false: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` value_false
      -- if expressionIR <: ternaryExpressionIR
      -- let typedExpressionIR_cond `?` typedExpressionIR_true `:` typedExpressionIR_false = expressionIR as ternaryExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR_cond `~>` value
      -- if (value = `B` false as value)
      -- Eval_static: p C `|-` typedExpressionIR_false `~>` value_false

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:215.1-218.45
   rule castExpression: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` value_cast
      -- if expressionIR <: castExpressionIR
      -- let `(` typeIR `)` typedExpressionIR = expressionIR as castExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR `~>` value
      -- let value_cast = $cast_op(typeIR, value)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:225.1-226.34
   rule dataExpressionIR-invalid: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `{#}` as value
      -- if (expressionIR = `{#}` as expressionIR)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:230.1-232.55
   rule dataExpressionIR-sequence: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `SEQ(` value*{value <- value*} `)` as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SEQ{%}`
      -- let `SEQ{` typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} `}` = dataExpressionIR
      -- (Eval_static: p C `|-` typedExpressionIR `~>` value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:236.1-238.55
   rule dataExpressionIR-sequence-default: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `SEQ(` value*{value <- value*} `,...)` as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SEQ{%,...}`
      -- let `SEQ{` typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} `,...}` = dataExpressionIR
      -- (Eval_static: p C `|-` typedExpressionIR `~>` value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:242.1-245.55
   rule dataExpressionIR-record: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `RECORD{` value nameIR `;`*{nameIR <- nameIR*, value <- value*} `}` as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RECORD{%}`
      -- let `RECORD{` nameIR `=` typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} `}` = dataExpressionIR
      -- (Eval_static: p C `|-` typedExpressionIR `~>` value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:249.1-252.55
   rule dataExpressionIR-record-default: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `RECORD{` value nameIR `;`*{nameIR <- nameIR*, value <- value*} `,...}` as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RECORD{%,...}`
      -- let `RECORD{` nameIR `=` typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} `,...}` = dataExpressionIR
      -- (Eval_static: p C `|-` typedExpressionIR `~>` value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:260.1-263.57
   rule errorAccessExpressionIR: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` value_error
      -- if expressionIR <: errorAccessExpressionIR
      -- let `ERROR.` nameIR = expressionIR as errorAccessExpressionIR
      -- let nameIR_error = "error." ++ nameIR
      -- let value_error = $find_value(p, C, ``` nameIR_error)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:271.1-275.29
   rule memberAccessExpressionIR-prefixedNameIR-enum: p C `|-` expressionIR `#` `(` typeIR_base _ctk `)` `~>` tid `.` nameIR as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR `.` nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR matches `TYPE%`
      -- let `TYPE` prefixedNameIR = memberAccessBaseIR
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: enumTypeIR
      -- let enumTypeIR = typeDefIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` tid `{` id_member*{id_member <- id_member*} `}` = enumTypeIR
      -- if nameIR <- id_member*{id_member <- id_member*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:277.1-283.63
   rule memberAccessExpressionIR-prefixedNameIR-serenum: p C `|-` expressionIR `#` `(` typeIR_base _ctk `)` `~>` tid `.` nameIR `#` value as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR `.` nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR matches `TYPE%`
      -- let `TYPE` prefixedNameIR = memberAccessBaseIR
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: enumTypeIR
      -- let enumTypeIR = typeDefIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` typeIR `{` id_member `=` value_member `;`*{id_member <- id_member*, value_member <- value_member*} `}` = enumTypeIR
      -- let value'?{value' <- value'?} = $assoc_<id, value>(nameIR, (id_member, value_member)*{id_member <- id_member*, value_member <- value_member*})
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:288.1-291.36
   rule memberAccessExpressionIR-typedExpressionIR-stack-size: p C `|-` expressionIR `#` `(` typeIR_base _ctk `)` `~>` `D` n_size as int as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR `.` text = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR <: typedExpressionIR
      -- let typedExpressionIR_base = memberAccessBaseIR as typedExpressionIR
      -- if (text = "size")
      -- let typeIR = typeIR_base
      -- if typeIR <: headerStackTypeIR
      -- let _typeIR `[` n_size `]` = typeIR as headerStackTypeIR

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:301.1-307.58
   rule indexAccessExpressionIR-bitslice: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $bitacc_op(value_base, value_hi, value_lo)
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `%[%:%]`
      -- let typedExpressionIR_base `[` typedExpressionIR_hi `:` typedExpressionIR_lo `]` = indexAccessExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR_base `~>` value_base
      -- Eval_static: p C `|-` typedExpressionIR_hi `~>` value_hi
      -- Eval_static: p C `|-` typedExpressionIR_lo `~>` value_lo

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:323.1-327.91
   rule callExpressionIR-typedLvalueIR-size: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $sizeof(typeIR_base, nameIR)
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` = callExpressionIR
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let _expressionIR `#` `(` typeIR_base _ctk' `)` = typedExpressionIR_base
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:331.1-335.91
   rule callExpressionIR-type-size-mono: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $sizeof(typeIR_base, nameIR)
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` = callExpressionIR
      -- if routineTargetIR matches `TYPE%.%`
      -- let `TYPE` prefixedNameIR `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR_base = typeDefIR as typeIR
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:337.1-341.91
   rule callExpressionIR-type-size-poly: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` $sizeof(typeIR_base, nameIR)
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` = callExpressionIR
      -- if routineTargetIR matches `TYPE%.%`
      -- let `TYPE` prefixedNameIR `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base `<` tid*{tid <- tid*} `,` tid'*{tid' <- tid'*} `>` = typeDefIR as polyTypeDefIR
      -- if tid*{tid <- tid*} matches []
      -- if tid'*{tid' <- tid'*} matches []
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:345.1-352.19
   rule callExpressionIR-parenthesized: p C `|-` expressionIR `#` `(` typeIR ctk `)` `~>` value
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR' `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` = callExpressionIR
      -- if routineTargetIR' matches `(%)`
      -- let `(` routineTargetIR `)` = routineTargetIR'
      -- Eval_static: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` as expressionIR `#` `(` typeIR ctk `)` `~>` value

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:357.1-359.52
   rule parenthesizedExpressionIR: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` value
      -- if expressionIR <: parenthesizedExpressionIR
      -- let `(` typedExpressionIR `)` = expressionIR as parenthesizedExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR `~>` value

;; ../../../../spec-concrete/5.04-typing-relation.watsup:14.1-16.23
relation Type_ok: cursor context `|-` typeOrVoid `:` typeIR `#` tid*

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:11.1-12.28
   rule boolean: p C `|-` typeOrVoid `:` `BOOL` as typeIR `#` []
      -- if (typeOrVoid = `BOOL` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:16.1-17.30
   rule error: p C `|-` typeOrVoid `:` `ERROR` as typeIR `#` []
      -- if (typeOrVoid = `ERROR` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:21.1-22.40
   rule matchkind: p C `|-` typeOrVoid `:` `MATCH_KIND` as typeIR `#` []
      -- if (typeOrVoid = `MATCH_KIND` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:26.1-27.32
   rule string: p C `|-` typeOrVoid `:` `STRING` as typeIR `#` []
      -- if (typeOrVoid = `STRING` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:31.1-32.26
   rule arbint: p C `|-` typeOrVoid `:` `INT` as typeIR `#` []
      -- if (typeOrVoid = `INT` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:37.1-38.42
   rule fixint: p C `|-` typeOrVoid `:` `INT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `INT<%>`
      -- let `INT<` int `>` = baseType
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:40.1-44.30
   rule fixint-expr: p C `|-` typeOrVoid `:` `INT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `INT<(%)>`
      -- let `INT<(` expression `)>` = baseType
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:50.1-51.35
   rule bit: p C `|-` typeOrVoid `:` `BIT<` 1 `>` as typeIR `#` []
      -- if (typeOrVoid = `BIT` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:53.1-54.42
   rule fixbit: p C `|-` typeOrVoid `:` `BIT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `BIT<%>`
      -- let `BIT<` int `>` = baseType
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:56.1-60.30
   rule fixbit-expr: p C `|-` typeOrVoid `:` `BIT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `BIT<(%)>`
      -- let `BIT<(` expression `)>` = baseType
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:65.1-66.48
   rule varbit: p C `|-` typeOrVoid `:` `VARBIT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `VARBIT<%>`
      -- let `VARBIT<` int `>` = baseType
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:68.1-72.30
   rule varbit-expr: p C `|-` typeOrVoid `:` `VARBIT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `VARBIT<(%)>`
      -- let `VARBIT<(` expression `)>` = baseType
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:79.1-82.50
   rule prefixedTypeName-mono: p C `|-` typeOrVoid `:` typeIR `#` []
      -- if typeOrVoid <: prefixedTypeName
      -- let prefixedTypeName = typeOrVoid as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:84.1-87.57
   rule prefixedTypeName-poly: p C `|-` typeOrVoid `:` polyTypeDefIR `<` [] `>` as typeIR `#` []
      -- if typeOrVoid <: prefixedTypeName
      -- let prefixedTypeName = typeOrVoid as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR as polyTypeDefIR

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:92.1-95.50
   rule specializedType-mono: p C `|-` typeOrVoid `:` typeIR `#` []
      -- if typeOrVoid <: specializedType
      -- let prefixedTypeName `<` typeArgumentList `>` = typeOrVoid as specializedType
      -- if typeArgumentList matches ``EMPTY`
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:97.1-104.72
   rule specializedType-poly: p C `|-` typeOrVoid `:` polyTypeDefIR `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` as typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: specializedType
      -- let prefixedTypeName `<` typeArgumentList `>` = typeOrVoid as specializedType
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR as polyTypeDefIR
      -- let typeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` = polyTypeDefIR
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeIR_arg*{typeIR_arg <- typeIR_arg*} `#` tid_fresh*{tid_fresh <- tid_fresh*}

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:109.1-120.59
   rule headerStackType-typeName-expression: p C `|-` typeOrVoid `:` polyTypeDefIR_stack `<` [typeIR_base] `>` as typeIR `#` []
      -- if typeOrVoid <: headerStackType
      -- let namedType `[` expression_size `]` = typeOrVoid as headerStackType
      -- if namedType <: typeName
      -- let typeName = namedType as typeName
      -- Type_ok: p C `|-` typeName as typeOrVoid `:` typeIR_base `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- Expr_ok: p C `|-` expression_size `:` typedExpressionIR_size
      -- Eval_static: p C `|-` typedExpressionIR_size `~>` value_size
      -- let int = $to_number(value_size)
      -- if int <: nat
      -- let n_size = int as nat
      -- let typeIR_stack = `TID` "T" as typeIR `[` n_size `]` as typeIR
      -- let polyTypeDefIR_stack = typeIR_stack `<` ["T"] `,` [] `>`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:122.1-133.59
   rule headerStackType-specializedType-expression: p C `|-` typeOrVoid `:` polyTypeDefIR_stack `<` [typeIR_base] `>` as typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: headerStackType
      -- let namedType `[` expression_size `]` = typeOrVoid as headerStackType
      -- if namedType <: specializedType
      -- let specializedType = namedType as specializedType
      -- Type_ok: p C `|-` specializedType as typeOrVoid `:` typeIR_base `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- Expr_ok: p C `|-` expression_size `:` typedExpressionIR_size
      -- Eval_static: p C `|-` typedExpressionIR_size `~>` value_size
      -- let int = $to_number(value_size)
      -- if int <: nat
      -- let n_size = int as nat
      -- let typeIR_stack = `TID` "T" as typeIR `[` n_size `]` as typeIR
      -- let polyTypeDefIR_stack = typeIR_stack `<` ["T"] `,` [] `>`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:138.1-145.57
   rule listType: p C `|-` typeOrVoid `:` polyTypeDefIR_list `<` [typeIR_arg] `>` as typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: listType
      -- let `LIST<` typeArgument `>` = typeOrVoid as listType
      -- TypeArgument_ok: p C `|-` typeArgument `:` typeIR_arg `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- let typeIR_list = `LIST<` `TID` "T" as typeIR `>` as typeIR
      -- let polyTypeDefIR_list = typeIR_list `<` ["T"] `,` [] `>`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:150.1-160.67
   rule tupleType: p C `|-` typeOrVoid `:` polyTypeDefIR_tuple `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` as typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: tupleType
      -- let `TUPLE<` typeArgumentList `>` = typeOrVoid as tupleType
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeIR_arg*{typeIR_arg <- typeIR_arg*} `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- let i_idx*{i_idx <- i_idx*} = $init_(|typeIR_arg*{typeIR_arg <- typeIR_arg*}|) as int*
      -- (let tid_tparam = "T" ++ $int_to_text(i_idx))*{i_idx <- i_idx*, tid_tparam <- tid_tparam*}
      -- let typeIR_tuple = `TUPLE<` `TID` tid_tparam as typeIR*{tid_tparam <- tid_tparam*} `>` as typeIR
      -- let polyTypeDefIR_tuple = typeIR_tuple `<` tid_tparam*{tid_tparam <- tid_tparam*} `,` [] `>`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:164.1-165.28
   rule void: p C `|-` typeOrVoid `:` `VOID` as typeIR `#` []
      -- if typeOrVoid matches `VOID`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:18.1-20.23
relation TypeArgument_ok: cursor context `|-` typeArgument `:` typeArgumentIR `#` tid*

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:12.1-14.48
   rule type: p C `|-` typeArgument `:` typeIR `#` tid_impl*{tid_impl <- tid_impl*}
      -- if typeArgument <: type
      -- let type = typeArgument as type
      -- Type_ok: p C `|-` type as typeOrVoid `:` typeIR `#` tid_impl*{tid_impl <- tid_impl*}

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:18.1-19.28
   rule void: p C `|-` typeArgument `:` `VOID` as typeArgumentIR `#` []
      -- if (typeArgument = `VOID` as typeArgument)

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:23.1-25.32
   rule dontcare: p C `|-` typeArgument `:` `TID` tid_impl as typeArgumentIR `#` [tid_impl]
      -- if (typeArgument = `_` as typeArgument)
      -- let tid_impl = $fresh_tid

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:29.1-31.33
   rule nonTypeName: p C `|-` typeArgument `:` `TID` tid as typeArgumentIR `#` []
      -- if typeArgument <: nonTypeName
      -- let nonTypeName = typeArgument as nonTypeName
      -- let tid = $name(nonTypeName as name)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:22.1-24.23
relation TypeArguments_ok: cursor context `|-` typeArgument* `:` typeArgumentListIR `#` tid*

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:39.1-40.26
   rule : p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` [] `#` []
      -- if typeArgument*{typeArgument <- typeArgument*} matches []

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:42.1-49.47
   rule : p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeArgumentIR_h :: typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- if typeArgument*{typeArgument <- typeArgument*} matches _ :: _
      -- let typeArgument_h :: typeArgument_t*{typeArgument_t <- typeArgument_t*} = typeArgument*{typeArgument <- typeArgument*}
      -- TypeArgument_ok: p C `|-` typeArgument_h `:` typeArgumentIR_h `#` tid_impl_h*{tid_impl_h <- tid_impl_h*}
      -- TypeArguments_ok: p C `|-` typeArgument_t*{typeArgument_t <- typeArgument_t*} `:` typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} `#` tid_impl_t*{tid_impl_t <- tid_impl_t*}
      -- let tid_impl*{tid_impl <- tid_impl*} = tid_impl_h*{tid_impl_h <- tid_impl_h*} ++ tid_impl_t*{tid_impl_t <- tid_impl_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:30.1-30.54
relation Sub_expl: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:5.1-9.54
   rule : typeIR_a `<:` typeIR_b
      -- let typeIR_a_canon = $canon(typeIR_a)
      -- let typeIR_b_canon = $canon(typeIR_b)
      -- if Sub_expl_canon: typeIR_a_canon `<:` typeIR_b_canon holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:31.1-31.60
relation Sub_expl_canon: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:11.1-13.38
   rule equals: typeIR_a `<:` typeIR_b
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:15.1-18.46
   rule not-equals: typeIR_a `<:` typeIR_b
      -- if ~Type_alpha: typeIR_a `~~` typeIR_b holds
      -- if Sub_expl_canon_neq: typeIR_a `<:` typeIR_b holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:32.1-32.64
relation Sub_expl_canon_neq: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:20.1-21.21
   rule fixbit-boolean: typeIR `<:` typeIR'
      -- if (typeIR = `BIT<` 1 `>` as typeIR)
      -- if (typeIR' = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:23.1-24.21
   rule boolean-fixbit: typeIR `<:` typeIR'
      -- if (typeIR = `BOOL` as typeIR)
      -- if (typeIR' = `BIT<` 1 `>` as typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:26.1-27.14
   rule arbint-boolean: typeIR `<:` typeIR'
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:29.1-30.20
   rule arbint-fixint: typeIR `<:` typeIR'
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:32.1-33.20
   rule arbint-fixbit: typeIR `<:` typeIR'
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:35.1-36.20
   rule fixint-fixint: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:38.1-39.31
   rule fixint-fixint: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w_a `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w_b `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:41.1-42.27
   rule fixint-fixbit: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:44.1-45.20
   rule fixbit-arbint: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:47.1-48.27
   rule fixbit-fixint: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:50.1-51.31
   rule fixbit-fixbit: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w_a `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w_b `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:53.1-55.36
   rule newtype-left: typeIR `<:` typeIR_b
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR_a = aliasTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:57.1-59.36
   rule newtype-right: typeIR_a `<:` typeIR
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR_b = aliasTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:61.1-63.36
   rule serenum-left: typeIR `<:` typeIR_b
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_a `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:65.1-67.36
   rule serenum-right: typeIR_a `<:` typeIR
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_b `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:69.1-71.41
   rule default: typeIR `<:` typeIR_b
      -- if (typeIR = `DEFAULT` as typeIR)
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:73.1-74.36
   rule invalidheader-header: typeIR `<:` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:76.1-77.42
   rule invalidheader-headerunion: typeIR `<:` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR' as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:79.1-81.39
   rule seq-list: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR_b `>` = typeIR' as listTypeIR
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:83.1-85.39
   rule seq-tuple: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:87.1-90.39
   rule seq-stack: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:92.1-94.39
   rule seq-struct: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:96.1-98.39
   rule seq-header: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:100.1-106.50
   rule seqdefault-tuple: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:108.1-112.41
   rule seqdefault-stack: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:114.1-120.50
   rule seqdefault-struct: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:122.1-128.50
   rule seqdefault-header: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:130.1-137.55
   rule record-struct: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if $eq_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_expl: typeIR_a_aligned `<:` typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:139.1-146.55
   rule record-header: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if $eq_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_expl: typeIR_a_aligned `<:` typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:148.1-161.50
   rule recorddefault-struct: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if $sub_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_expl: typeIR_a_aligned `<:` typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{` id_default*{id_default <- id_default*} `}` = $diff_set<id>(`{` id_b*{id_b <- id_b*} `}`, `{` id_a*{id_a <- id_a*} `}`)
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:163.1-176.50
   rule recorddefault-header: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if $sub_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_expl: typeIR_a_aligned `<:` typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{` id_default*{id_default <- id_default*} `}` = $diff_set<id>(`{` id_b*{id_b <- id_b*} `}`, `{` id_a*{id_a <- id_a*} `}`)
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:178.1-180.36
   rule set-set: typeIR' `<:` typeIR'''
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_a] = typeIR*{typeIR <- typeIR*}
      -- if typeIR''' <: setTypeIR
      -- let `SET<` typeIR''*{typeIR'' <- typeIR''*} `>` = typeIR''' as setTypeIR
      -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
      -- let [typeIR_b] = typeIR''*{typeIR'' <- typeIR''*}
      -- if Sub_expl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:182.1-185.36
   rule non-set-set: typeIR_a `<:` typeIR'
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_b] = typeIR*{typeIR <- typeIR*}
      -- if ~$is_set_typeIR(typeIR_a)
      -- if Sub_expl: typeIR_a `<:` typeIR_b holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:34.1-34.54
relation Sub_impl: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:191.1-195.54
   rule : typeIR_a `<:` typeIR_b
      -- let typeIR_a_canon = $canon(typeIR_a)
      -- let typeIR_b_canon = $canon(typeIR_b)
      -- if Sub_impl_canon: typeIR_a_canon `<:` typeIR_b_canon holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:35.1-35.60
relation Sub_impl_canon: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:197.1-199.38
   rule equals: typeIR_a `<:` typeIR_b
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:201.1-204.46
   rule not-equals: typeIR_a `<:` typeIR_b
      -- if ~Type_alpha: typeIR_a `~~` typeIR_b holds
      -- if Sub_impl_canon_neq: typeIR_a `<:` typeIR_b holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:36.1-36.64
relation Sub_impl_canon_neq: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:206.1-207.20
   rule arbint-fixint: typeIR `<:` typeIR'
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:209.1-210.20
   rule arbint-fixbit: typeIR `<:` typeIR'
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:212.1-214.36
   rule serenum-left: typeIR `<:` typeIR_b
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_a `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:216.1-218.36
   rule serenum-right: typeIR_a `<:` typeIR
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_b `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:220.1-222.41
   rule default: typeIR `<:` typeIR_b
      -- if (typeIR = `DEFAULT` as typeIR)
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:224.1-225.36
   rule invalidheader-header: typeIR `<:` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:227.1-228.42
   rule invalidheader-headerunion: typeIR `<:` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR' as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:230.1-232.39
   rule seq-list: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR_b `>` = typeIR' as listTypeIR
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:234.1-236.39
   rule seq-tuple: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:238.1-241.39
   rule seq-stack: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:243.1-245.39
   rule seq-struct: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:247.1-249.39
   rule seq-header: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:251.1-253.39
   rule seq-seq: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SEQ<%>`
      -- let `SEQ<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = sequenceTypeIR'
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:255.1-261.50
   rule seqdefault-tuple: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:263.1-267.41
   rule seqdefault-stack: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:269.1-275.50
   rule seqdefault-struct: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:277.1-283.50
   rule seqdefault-header: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:285.1-292.55
   rule record-struct: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if $eq_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_impl: typeIR_a_aligned `<:` typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:294.1-301.55
   rule record-header: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if $eq_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_impl: typeIR_a_aligned `<:` typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:303.1-316.50
   rule recorddefault-struct: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if $sub_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_impl: typeIR_a_aligned `<:` typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{` id_default*{id_default <- id_default*} `}` = $diff_set<id>(`{` id_b*{id_b <- id_b*} `}`, `{` id_a*{id_a <- id_a*} `}`)
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:318.1-331.50
   rule recorddefault-header: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if $sub_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_impl: typeIR_a_aligned `<:` typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{` id_default*{id_default <- id_default*} `}` = $diff_set<id>(`{` id_b*{id_b <- id_b*} `}`, `{` id_a*{id_a <- id_a*} `}`)
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:42.1-44.23
relation Expr_ok: cursor context `|-` expression `:` typedExpressionIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:12.1-14.42
   rule literalExpression-true: p C `|-` expression `:` `TRUE` as expressionIR `#` expressionNoteIR
      -- if (expression = `TRUE` as expression)
      -- let expressionNoteIR = `(` `BOOL` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:16.1-18.42
   rule literalExpression-false: p C `|-` expression `:` `FALSE` as expressionIR `#` expressionNoteIR
      -- if (expression = `FALSE` as expression)
      -- let expressionNoteIR = `(` `BOOL` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:22.1-24.41
   rule literalExpression-number-arbint: p C `|-` expression `:` `D` i as expressionIR `#` expressionNoteIR
      -- if expression <: number
      -- let number = expression as number
      -- if number matches `D%`
      -- let `D` i = number
      -- let expressionNoteIR = `(` `INT` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:26.1-28.50
   rule literalExpression-number-fixint: p C `|-` expression `:` n `S` i as expressionIR `#` expressionNoteIR
      -- if expression <: number
      -- let number = expression as number
      -- if number matches `%S%`
      -- let n `S` i = number
      -- let expressionNoteIR = `(` `INT<` n `>` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:30.1-32.50
   rule literalExpression-number-fixbit: p C `|-` expression `:` n `W` i as expressionIR `#` expressionNoteIR
      -- if expression <: number
      -- let number = expression as number
      -- if number matches `%W%`
      -- let n `W` i = number
      -- let expressionNoteIR = `(` `BIT<` n `>` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:36.1-38.44
   rule literalExpression-stringliteral: p C `|-` expression `:` `"` text `"` as expressionIR `#` expressionNoteIR
      -- if expression <: stringLiteral
      -- let `"` text `"` = expression as stringLiteral
      -- let expressionNoteIR = `(` `STRING` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:45.1-49.43
   rule referenceExpression-prefixedNonTypeName: p C `|-` expression `:` prefixedNameIR as expressionIR `#` expressionNoteIR
      -- if expression <: prefixedNonTypeName
      -- let prefixedNonTypeName = expression as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, C, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:53.1-57.43
   rule referenceExpression-this: p C `|-` expression `:` prefixedNameIR as expressionIR `#` expressionNoteIR
      -- if (expression = `THIS` as expression)
      -- let prefixedNameIR = ``` "this"
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, C, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:61.1-63.45
   rule defaultExpression: p C `|-` expression `:` `...` as expressionIR `#` expressionNoteIR
      -- if (expression = `...` as expression)
      -- let expressionNoteIR = `(` `DEFAULT` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:77.1-86.58
   rule unaryExpression-lnot: p C `|-` expression' `:` `!` typedExpressionIR_reduced as expressionIR `#` expressionNoteIR
      -- if expression' <: unaryExpression
      -- let unop expression = expression' as unaryExpression
      -- if unop matches `!`
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_lnot)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR `#` expressionNoteIR = typedExpressionIR_reduced

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:99.1-108.58
   rule unaryExpression-bnot: p C `|-` expression' `:` `~` typedExpressionIR_reduced as expressionIR `#` expressionNoteIR
      -- if expression' <: unaryExpression
      -- let unop expression = expression' as unaryExpression
      -- if unop matches `~`
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_bnot)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR `#` expressionNoteIR = typedExpressionIR_reduced

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:122.1-132.58
   rule unaryExpression-uplusminus: p C `|-` expression' `:` unop typedExpressionIR_reduced as expressionIR `#` expressionNoteIR
      -- if expression' <: unaryExpression
      -- let unop expression = expression' as unaryExpression
      -- if ((unop = `+`) \/ (unop = `-`))
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR `#` expressionNoteIR = typedExpressionIR_reduced

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:149.1-171.59
   rule binaryExpression-plusminusmult: p C `|-` expression `:` typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`+`, `-`, `*`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmult)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` _typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:185.1-207.59
   rule binaryExpression-satplusminus: p C `|-` expression `:` typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`|+|`, `|-|`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` _typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:220.1-247.59
   rule binaryExpression-divmod-lctk: p C `|-` expression `:` typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`/`, `%`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` _typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_r_reduced `~>` value_r
      -- let int = $to_number(value_r)
      -- if int <: nat
      -- let n_r = int as nat
      -- if (n_r > 0)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:249.1-274.59
   rule binaryExpression-divmod-non-lctk: p C `|-` expression `:` typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`/`, `%`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` _typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced =/= `LCTK`)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:295.1-317.61
   rule binaryExpression-shift-fixbit: p C `|-` expression `:` typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`<<`, `>>`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR `#` `(` typeIR_l_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR_r_reduced ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if $is_fixed_bit_typeIR(typeIR_r_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_l_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:319.1-343.61
   rule binaryExpression-shift-integer: p C `|-` expression `:` typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`<<`, `>>`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR `#` `(` typeIR_l_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR_r_reduced ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced = `LCTK`)
      -- if ($is_arbitrary_int_typeIR(typeIR_r_reduced) \/ $is_fixed_int_typeIR(typeIR_r_reduced))
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_l_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:347.1-365.46
   rule binaryExpression-eq: p C `|-` expression `:` typedExpressionIR_l_cast binop typedExpressionIR_r_cast as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`==`, `!=`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR `#` `(` typeIR_cast ctk_l_cast `)` = typedExpressionIR_l_cast
      -- let _expressionIR' `#` `(` _typeIR ctk_r_cast `)` = typedExpressionIR_r_cast
      -- if $is_equalable_typeIR(typeIR_cast)
      -- let ctk_cast = $join_ctk(ctk_l_cast, ctk_r_cast)
      -- let expressionNoteIR = `(` `BOOL` as typeIR ctk_cast `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:380.1-402.49
   rule binaryExpression-compare: p C `|-` expression `:` typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`<=`, `>=`, `<`, `>`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` _typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` `BOOL` as typeIR ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:416.1-438.59
   rule binaryExpression-bitwise: p C `|-` expression `:` typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`&`, `^`, `|`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` _typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:466.1-488.59
   rule binaryExpression-concat: p C `|-` expression `:` typedExpressionIR_l_reduced `++` typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop matches `++`
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_concat)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR `#` `(` typeIR_l_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR_r_reduced ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- let typeIR?{typeIR <- typeIR?} = $result_concat(typeIR_l_reduced, typeIR_r_reduced)
      -- if typeIR?{typeIR <- typeIR?} matches (_)
      -- let ?(typeIR_reduced) = typeIR?{typeIR <- typeIR?}
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:501.1-523.59
   rule binaryExpression-logical: p C `|-` expression `:` typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`&&`, `||`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` _typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:529.1-550.48
   rule ternaryExpression: p C `|-` expression `:` typedExpressionIR_cond `?` typedExpressionIR_true_cast `:` typedExpressionIR_false_cast as expressionIR `#` expressionNoteIR
      -- if expression <: ternaryExpression
      -- let expression_cond `?` expression_true `:` expression_false = expression as ternaryExpression
      -- Expr_ok: p C `|-` expression_cond `:` typedExpressionIR_cond
      -- let _expressionIR `#` `(` typeIR ctk_cond `)` = typedExpressionIR_cond
      -- if (typeIR = `BOOL` as typeIR)
      -- Expr_ok: p C `|-` expression_true `:` typedExpressionIR_true
      -- Expr_ok: p C `|-` expression_false `:` typedExpressionIR_false
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_true, typedExpressionIR_false)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR' `#` `(` typeIR_cast ctk_true_cast `)` = typedExpressionIR_true_cast
      -- let _expressionIR'' `#` `(` _typeIR ctk_false_cast `)` = typedExpressionIR_false_cast
      -- if ($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= `DYN`))
      -- let ctk = $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast])
      -- let expressionNoteIR = `(` typeIR_cast ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:555.1-568.45
   rule castExpression: p C `|-` expression' `:` `(` typeIR_t `)` typedExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression' <: castExpression
      -- let `(` type_t `)` expression = expression' as castExpression
      -- Type_ok: p C `|-` type_t as typeOrVoid `:` typeIR_t `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(p, C) `|-` typeIR_t holds
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR ctk `)` = typedExpressionIR
      -- if Sub_expl: typeIR `<:` typeIR_t holds
      -- let expressionNoteIR = `(` typeIR_t ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:575.1-577.52
   rule dataExpression-invalid: p C `|-` expression `:` `{#}` as expressionIR `#` expressionNoteIR
      -- if (expression = `{#}` as expression)
      -- let expressionNoteIR = `(` `HEADER_INVALID` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:585.1-599.43
   rule dataExpression-sequenceElementExpression-non-default: p C `|-` expression `:` `SEQ{` typedExpressionIR_e*{typedExpressionIR_e <- typedExpressionIR_e*} `}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: expressionList
      -- let expressionList = dataElementExpression as expressionList
      -- let expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList)
      -- if ~`...` as expression <- expression_e*{expression_e <- expression_e*}
      -- if (expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList))
      -- (Expr_ok: p C `|-` expression_e `:` typedExpressionIR_e)*{expression_e <- expression_e*, typedExpressionIR_e <- typedExpressionIR_e*}
      -- (let _expressionIR `#` `(` typeIR_e ctk_e `)` = typedExpressionIR_e)*{_expressionIR <- _expressionIR*, ctk_e <- ctk_e*, typeIR_e <- typeIR_e*, typedExpressionIR_e <- typedExpressionIR_e*}
      -- let typeIR = `SEQ<` typeIR_e*{typeIR_e <- typeIR_e*} `>` as typeIR
      -- let ctk = $joins_ctk(ctk_e*{ctk_e <- ctk_e*})
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:601.1-617.43
   rule dataExpression-sequenceElementExpression-default: p C `|-` expression `:` `SEQ{` typedExpressionIR_e_h*{typedExpressionIR_e_h <- typedExpressionIR_e_h*} `,...}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: expressionList
      -- let expressionList = dataElementExpression as expressionList
      -- let expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList)
      -- if `...` as expression <- expression_e*{expression_e <- expression_e*}
      -- let expression''*{expression'' <- expression''*} = $rev_<expression>(expression_e*{expression_e <- expression_e*})
      -- if expression''*{expression'' <- expression''*} matches _ :: _
      -- let expression' :: expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*} = expression''*{expression'' <- expression''*}
      -- if (expression' = `...` as expression)
      -- let expression_e_h*{expression_e_h <- expression_e_h*} = $rev_<expression>(expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*})
      -- if ~`...` as expression <- expression_e_h*{expression_e_h <- expression_e_h*}
      -- (Expr_ok: p C `|-` expression_e_h `:` typedExpressionIR_e_h)*{expression_e_h <- expression_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
      -- (let _expressionIR `#` `(` typeIR_e_h ctk_e_h `)` = typedExpressionIR_e_h)*{_expressionIR <- _expressionIR*, ctk_e_h <- ctk_e_h*, typeIR_e_h <- typeIR_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
      -- let typeIR = `SEQ<` typeIR_e_h*{typeIR_e_h <- typeIR_e_h*} `,...>` as typeIR
      -- let ctk = $joins_ctk(ctk_e_h*{ctk_e_h <- ctk_e_h*})
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:624.1-635.45
   rule dataExpression-recordElementExpression-single: p C `|-` expression `:` `RECORD{` [nameIR_f `=` typedExpressionIR_f] `}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%`
      -- let name_f `=` expression_f = recordElementExpression
      -- let nameIR_f = $name(name_f)
      -- Expr_ok: p C `|-` expression_f `:` typedExpressionIR_f
      -- let _expressionIR `#` `(` typeIR_f ctk_f `)` = typedExpressionIR_f
      -- let typeIR = `RECORD{` [typeIR_f nameIR_f `;`] `}` as typeIR
      -- let expressionNoteIR = `(` typeIR ctk_f `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:639.1-650.45
   rule dataExpression-recordElementExpression-single-default: p C `|-` expression `:` `RECORD{` [nameIR_f `=` typedExpressionIR_f] `,...}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%,...`
      -- let name_f `=` expression_f `,...` = recordElementExpression
      -- let nameIR_f = $name(name_f)
      -- Expr_ok: p C `|-` expression_f `:` typedExpressionIR_f
      -- let _expressionIR `#` `(` typeIR_f ctk_f `)` = typedExpressionIR_f
      -- let typeIR = `RECORD{` [typeIR_f nameIR_f `;`] `,...}` as typeIR
      -- let expressionNoteIR = `(` typeIR ctk_f `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:654.1-670.43
   rule dataExpression-recordElementExpression-multiple: p C `|-` expression `:` `RECORD{` nameIR_f `=` typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} `}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%,%`
      -- let name_f_h `=` expression_f_h `,` namedExpressionList_t = recordElementExpression
      -- let name_f_t `=` expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
      -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
      -- (Expr_ok: p C `|-` expression_f `:` typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- (let _expressionIR `#` `(` typeIR_f ctk_f `)` = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- let typeIR = `RECORD{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` as typeIR
      -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:674.1-690.43
   rule dataExpression-recordElementExpression-multiple-default: p C `|-` expression `:` `RECORD{` nameIR_f `=` typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} `,...}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%,%,...`
      -- let name_f_h `=` expression_f_h `,` namedExpressionList_t `,...` = recordElementExpression
      -- let name_f_t `=` expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
      -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
      -- (Expr_ok: p C `|-` expression_f `:` typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- (let _expressionIR `#` `(` typeIR_f ctk_f `)` = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- let typeIR = `RECORD{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `,...}` as typeIR
      -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:698.1-705.43
   rule accessExpression-errorAccessExpression: p C `|-` expression `:` `ERROR.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: errorAccessExpression
      -- let `ERROR.` member = expression as errorAccessExpression
      -- let nameIR = $name(member)
      -- let nameIR_error = "error." ++ nameIR
      -- if (`ERROR.` nameIR as value = $find_value(p, C, ``` nameIR_error))
      -- let expressionNoteIR = `(` `ERROR` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:713.1-725.49
   rule accessExpression-memberAccessExpression-prefixedType-enum: p C `|-` expression `:` `TYPE` prefixedNameIR_base `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: prefixedTypeName
      -- let prefixedTypeName_base = memberAccessBase as prefixedTypeName
      -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR_base)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR_base = typeDefIR as typeIR
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` nameIR_f*{nameIR_f <- nameIR_f*} `}` = enumTypeIR
      -- let nameIR = $name(member)
      -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
      -- let expressionNoteIR = `(` typeIR_base `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:727.1-739.49
   rule accessExpression-memberAccessExpression-prefixedType-serenum: p C `|-` expression `:` `TYPE` prefixedNameIR_base `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: prefixedTypeName
      -- let prefixedTypeName_base = memberAccessBase as prefixedTypeName
      -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR_base)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR_base = typeDefIR as typeIR
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` nameIR_f `=` _value `;`*{_value <- _value*, nameIR_f <- nameIR_f*} `}` = enumTypeIR
      -- let nameIR = $name(member)
      -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
      -- let expressionNoteIR = `(` typeIR_base `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:743.1-755.51
   rule accessExpression-memberAccessExpression-expression-stack-size: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` "size" as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("size" = $name(member))
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(` `BIT<` 32 `>` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:757.1-769.50
   rule accessExpression-memberAccessExpression-expression-stack-lastIndex: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` "lastIndex" as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("lastIndex" = $name(member))
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(` `BIT<` 32 `>` as typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:771.1-783.43
   rule accessExpression-memberAccessExpression-expression-stack-last: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` "last" as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("last" = $name(member))
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:785.1-797.43
   rule accessExpression-memberAccessExpression-expression-stack-next: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` "next" as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("next" = $name(member))
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:799.1-812.43
   rule accessExpression-memberAccessExpression-expression-struct: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as structTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:814.1-827.43
   rule accessExpression-memberAccessExpression-expression-header: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as headerTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:829.1-842.43
   rule accessExpression-memberAccessExpression-expression-headerunion: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as headerUnionTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:844.1-857.43
   rule accessExpression-memberAccessExpression-expression-tablestruct: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR = typeIR' as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = tableTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:875.1-900.55
   rule indexAccessExpression-tuple: p C `|-` expression `:` typedExpressionIR_base `[` typedExpressionIR_index_reduced `]` as expressionIR `#` expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%]`
      -- let expression_base `[` expression_index `]` = indexAccessExpression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- Expr_ok: p C `|-` expression_index `:` typedExpressionIR_index
      -- let _expressionIR `#` `(` typeIR_base ctk_base `)` = typedExpressionIR_base
      -- let _expressionIR' `#` `(` typeIR_index ctk_index `)` = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` typeIR_e*{typeIR_e <- typeIR_e*} `>` = typeIR as tupleTypeIR
      -- if (ctk_index = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_index_reduced `~>` value_index
      -- let int = $to_number(value_index)
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < |typeIR_e*{typeIR_e <- typeIR_e*}|)
      -- let expressionNoteIR = `(` typeIR_e*{typeIR_e <- typeIR_e*}[n_index] `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:902.1-927.43
   rule indexAccessExpression-stack-lctk: p C `|-` expression `:` typedExpressionIR_base `[` typedExpressionIR_index_reduced `]` as expressionIR `#` expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%]`
      -- let expression_base `[` expression_index `]` = indexAccessExpression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- Expr_ok: p C `|-` expression_index `:` typedExpressionIR_index
      -- let _expressionIR `#` `(` typeIR_base ctk_base `)` = typedExpressionIR_base
      -- let _expressionIR' `#` `(` typeIR_index ctk_index `)` = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (ctk_index = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_index_reduced `~>` value_index
      -- let int = $to_number(value_index)
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < n_size)
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:929.1-951.43
   rule indexAccessExpression-stack-non-lctk: p C `|-` expression `:` typedExpressionIR_base `[` typedExpressionIR_index_reduced `]` as expressionIR `#` expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%]`
      -- let expression_base `[` expression_index `]` = indexAccessExpression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- Expr_ok: p C `|-` expression_index `:` typedExpressionIR_index
      -- let _expressionIR `#` `(` typeIR_base ctk_base `)` = typedExpressionIR_base
      -- let _expressionIR' `#` `(` typeIR_index ctk_index `)` = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (ctk_index =/= `LCTK`)
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:992.1-1039.56
   rule indexAccessExpression-bitslice: p C `|-` expression `:` typedExpressionIR_base `[` typedExpressionIR_hi_reduced `:` typedExpressionIR_lo_reduced `]` as expressionIR `#` expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%:%]`
      -- let expression_base `[` expression_hi `:` expression_lo `]` = indexAccessExpression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- Expr_ok: p C `|-` expression_hi `:` typedExpressionIR_hi
      -- Expr_ok: p C `|-` expression_lo `:` typedExpressionIR_lo
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_base_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let _expressionIR `#` `(` typeIR_base_reduced ctk_base_reduced `)` = typedExpressionIR_base_reduced
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
      -- if typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} matches (_)
      -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?}
      -- let _expressionIR' `#` `(` typeIR_hi_reduced ctk_hi_reduced `)` = typedExpressionIR_hi_reduced
      -- let _expressionIR'' `#` `(` typeIR_lo_reduced ctk_lo_reduced `)` = typedExpressionIR_lo_reduced
      -- if (ctk_hi_reduced = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_hi_reduced `~>` value_hi
      -- let int = $to_number(value_hi)
      -- if int <: nat
      -- let n_hi = int as nat
      -- if (ctk_lo_reduced = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_lo_reduced `~>` value_lo
      -- let int' = $to_number(value_lo)
      -- if int' <: nat
      -- let n_lo = int' as nat
      -- if $is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)
      -- let typeIR = `BIT<` ((n_hi - n_lo) + 1) `>` as typeIR
      -- let expressionNoteIR = `(` typeIR ctk_base_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1047.1-1068.47
   rule callExpression-routineTarget-no-typeArgumentList: p C `|-` expression `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget `(` argumentList `)` = callExpression
      -- if callTarget <: routineTarget
      -- let routineTarget = callTarget as routineTarget
      -- RoutineTarget_ok: p C `|-` routineTarget `:` routineTargetIR
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- RoutineType_ok: p C `|-` routineTargetIR `<` [] `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_inserted*{tid_inserted <- tid_inserted*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_inserted*{tid_inserted <- tid_inserted*}
      -- Call_ok: p C `|-` routineTypeIR `<` [] `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if (typeIR_ret =/= `VOID` as typeIR)
      -- let callExpressionIR = routineTargetIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let expressionNoteIR = `(` typeIR_ret `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1070.1-1096.47
   rule callExpression-routineTarget-typeArgumentList: p C `|-` expression `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%<%>(%)`
      -- let routineTarget `<` realTypeArgumentList `>(` argumentList `)` = callExpression
      -- RoutineTarget_ok: p C `|-` routineTarget `:` routineTargetIR
      -- let realTypeArgument*{realTypeArgument <- realTypeArgument*} = $flatten_realTypeArgumentList(realTypeArgumentList)
      -- TypeArguments_ok: p C `|-` realTypeArgument*{realTypeArgument <- realTypeArgument*} as typeArgument* `:` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- RoutineType_ok: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_inserted*{tid_inserted <- tid_inserted*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Call_ok: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if (typeIR_ret =/= `VOID` as typeIR)
      -- let callExpressionIR = routineTargetIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let expressionNoteIR = `(` typeIR_ret `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1128.1-1146.50
   rule callExpression-constructorTarget-prefixedTypeName: p C `|-` expression `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget `(` argumentList `)` = callExpression
      -- if callTarget <: prefixedTypeName
      -- let prefixedTypeName = callTarget as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- ConstructorType_ok: p C `|-` prefixedNameIR `<` [] `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Inst_ok: p C `|-` constructorTypeIR `<` [] `#` tid_impl*{tid_impl <- tid_impl*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if $is_concrete_extern_object(typeIR_object)
      -- let callExpressionIR = prefixedNameIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>` `(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let expressionNoteIR = `(` typeIR_object `CTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1150.1-1174.50
   rule callExpression-constructorTarget-specializedType: p C `|-` expression `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget `(` argumentList `)` = callExpression
      -- if callTarget <: specializedType
      -- let prefixedTypeName `<` typeArgumentList `>` = callTarget as specializedType
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- ConstructorType_ok: p C `|-` prefixedNameIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_inserted*{tid_inserted <- tid_inserted*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Inst_ok: p C `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if $is_concrete_extern_object(typeIR_object)
      -- let callExpressionIR = prefixedNameIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>` `(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let expressionNoteIR = `(` typeIR_object `CTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1179.1-1182.50
   rule parenthesizedExpression: p C `|-` expression' `:` `(` typedExpressionIR `)` as expressionIR `#` expressionNoteIR
      -- if expression' <: parenthesizedExpression
      -- let `(` expression `)` = expression' as parenthesizedExpression
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` expressionNoteIR = typedExpressionIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:50.1-52.23
relation Argument_ok: cursor context `|-` argument `:` argumentIR

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:9.1-11.52
   rule expression: p C `|-` argument `:` typedExpressionIR as argumentIR
      -- if argument <: expression
      -- let expression = argument as expression
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:15.1-18.52
   rule name-expression: p C `|-` argument `:` nameIR `=` typedExpressionIR
      -- if argument matches `%=%`
      -- let name `=` expression = argument
      -- let nameIR = $name(name)
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:22.1-24.29
   rule name-dontcare: p C `|-` argument `:` nameIR `=_`
      -- if argument matches `%=_`
      -- let name `=_` = argument
      -- let nameIR = $name(name)

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:28.1-29.17
   rule dontcare: p C `|-` argument `:` `_`
      -- if argument matches `_`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:58.1-60.23
relation Lvalue_ok: cursor context `|-` lvalue `:` typedLvalueIR

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:12.1-16.45
   rule referenceExpression-prefixedNonTypeName-assign: p C `|-` lvalue `:` prefixedNameIR as lvalueIR `#(` typeIR `)`
      -- if lvalue <: prefixedNonTypeName
      -- let prefixedNonTypeName = lvalue as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, C, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(direction typeIR ctk value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if ctk matches `DYN`
      -- if value?{value <- value?} matches ()
      -- if ((direction = `OUT`) \/ (direction = `INOUT`))

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:23.1-34.54
   rule lvalue-member-stack-next: p C `|-` lvalue `:` typedLvalueIR
      -- if lvalue matches `%.%`
      -- let lvalue_base `.` member = lvalue
      -- Lvalue_ok: p C `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR
      -- if ("next" = $name(member))
      -- let typedLvalueIR = typedLvalueIR_base `.` "next" `#(` typeIR `)`

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:36.1-48.54
   rule lvalue-member-struct: p C `|-` lvalue `:` typedLvalueIR
      -- if lvalue matches `%.%`
      -- let lvalue_base `.` member = lvalue
      -- Lvalue_ok: p C `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as structTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = typedLvalueIR_base `.` nameIR `#(` typeIR `)`

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:50.1-62.54
   rule lvalue-member-header: p C `|-` lvalue `:` typedLvalueIR
      -- if lvalue matches `%.%`
      -- let lvalue_base `.` member = lvalue
      -- Lvalue_ok: p C `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as headerTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = typedLvalueIR_base `.` nameIR `#(` typeIR `)`

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:64.1-76.54
   rule lvalue-member-union: p C `|-` lvalue `:` typedLvalueIR
      -- if lvalue matches `%.%`
      -- let lvalue_base `.` member = lvalue
      -- Lvalue_ok: p C `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as headerUnionTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = typedLvalueIR_base `.` nameIR `#(` typeIR `)`

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:80.1-105.25
   rule lvalue-expression-lctk: p C `|-` lvalue `:` typedLvalueIR
      -- if lvalue matches `%[%]`
      -- let lvalue_base `[` expression_index `]` = lvalue
      -- Lvalue_ok: p C `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- Expr_ok: p C `|-` expression_index `:` typedExpressionIR_index
      -- let _expressionIR `#` `(` typeIR_index ctk_index `)` = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- if (ctk_index = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_index_reduced `~>` value_index
      -- let int = $to_number(value_index)
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < n_size)
      -- let typedLvalueIR = typedLvalueIR_base `[` typedExpressionIR_index_reduced `]` `#(` typeIR `)`

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:107.1-129.25
   rule lvalue-expression-non-lctk: p C `|-` lvalue `:` typedLvalueIR
      -- if lvalue matches `%[%]`
      -- let lvalue_base `[` expression_index `]` = lvalue
      -- Lvalue_ok: p C `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- Expr_ok: p C `|-` expression_index `:` typedExpressionIR_index
      -- let _expressionIR `#` `(` typeIR_index ctk_index `)` = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- if (ctk_index =/= `LCTK`)
      -- let typedLvalueIR = typedLvalueIR_base `[` typedExpressionIR_index_reduced `]` `#(` typeIR `)`

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:133.1-174.25
   rule lvalue-expression-expression: p C `|-` lvalue `:` typedLvalueIR
      -- if lvalue matches `%[%:%]`
      -- let lvalue_base `[` expression_hi `:` expression_lo `]` = lvalue
      -- Lvalue_ok: p C `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- if $compat_bitslice_base(typeIR_base)
      -- Expr_ok: p C `|-` expression_hi `:` typedExpressionIR_hi
      -- Expr_ok: p C `|-` expression_lo `:` typedExpressionIR_lo
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR `#` `(` typeIR_hi_reduced ctk_hi_reduced `)` = typedExpressionIR_hi_reduced
      -- let _expressionIR' `#` `(` typeIR_lo_reduced ctk_lo_reduced `)` = typedExpressionIR_lo_reduced
      -- if (ctk_hi_reduced = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_hi_reduced `~>` value_hi
      -- let int = $to_number(value_hi)
      -- if int <: nat
      -- let n_hi = int as nat
      -- if (ctk_lo_reduced = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_lo_reduced `~>` value_lo
      -- let int' = $to_number(value_lo)
      -- if int' <: nat
      -- let n_lo = int' as nat
      -- if $is_valid_bitslice(typeIR_base, n_lo, n_hi)
      -- let typeIR = `BIT<` ((n_hi - n_lo) + 1) `>` as typeIR
      -- let typedLvalueIR = typedLvalueIR_base `[` typedExpressionIR_hi_reduced `:` typedExpressionIR_lo_reduced `]` `#(` typeIR `)`

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:178.1-185.54
   rule parenthesized: p C `|-` lvalue `:` typedLvalueIR
      -- if lvalue matches `(%)`
      -- let `(` lvalue_base `)` = lvalue
      -- Lvalue_ok: p C `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typedLvalueIR = `(` typedLvalueIR_base `)` `#(` typeIR_base `)`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:66.1-68.26
relation Stmt_ok: cursor context flow `|-` statement `:` context flow statementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:10.1-11.23
   rule emptyStatement: p C f `|-` statement `:` C f `;` as statementIR
      -- if (statement = `;` as statement)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:19.1-31.76
   rule assignmentStatement-eq: p C f `|-` statement `:` C f typedLvalueIR `=` typedExpressionIR `;` as statementIR
      -- if statement <: assignmentStatement
      -- let lvalue assignop expression `;` = statement as assignmentStatement
      -- if assignop matches `=`
      -- Lvalue_ok: p C `|-` lvalue `:` typedLvalueIR
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let _lvalueIR `#(` typeIR_l `)` = typedLvalueIR
      -- let _expressionIR `#` `(` typeIR_r _ctk `)` = typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_l)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:41.1-58.79
   rule callStatement-no-typeArgumentList: p C f `|-` statement `:` C f callStatementIR as statementIR
      -- if statement <: callStatement
      -- let callStatement = statement as callStatement
      -- if callStatement matches `%(%);`
      -- let lvalue_routine `(` argumentList `);` = callStatement
      -- RoutineTarget_lvalue_ok: p C `|-` lvalue_routine `:` routineTargetIR
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- RoutineType_ok: p C `|-` routineTargetIR `<` [] `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_ok: p C `|-` routineTypeIR `<` [] `#` tid_impl*{tid_impl <- tid_impl*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let callStatementIR = routineTargetIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `);`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:62.1-83.79
   rule callStatement-typeArgumentList: p C f `|-` statement `:` C f callStatementIR as statementIR
      -- if statement <: callStatement
      -- let callStatement = statement as callStatement
      -- if callStatement matches `%<%>(%);`
      -- let lvalue_routine `<` typeArgumentList `>(` argumentList `);` = callStatement
      -- RoutineTarget_lvalue_ok: p C `|-` lvalue_routine `:` routineTargetIR
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- RoutineType_ok: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_inserted*{tid_inserted <- tid_inserted*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Call_ok: p C `|-` routineTypeIR `<` [] `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let callStatementIR = routineTargetIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `);`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:98.1-118.57
   rule directApplicationStatement-prefixedTypeName: p C_0 f `|-` statement `:` C_0 f directApplicationStatementIR as statementIR
      -- if statement <: directApplicationStatement
      -- let namedType `.APPLY(` argumentList `);` = statement as directApplicationStatement
      -- Expr_ok: p C_0 `|-` namedType as callTarget `(` ``EMPTY` `)` as expression `:` expressionIR `#` `(` typeIR_object _ctk `)`
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%(%)`
      -- let prefixedNameIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>` `(` argumentIR*{argumentIR <- argumentIR*} `)` = callExpressionIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if $compat_direct_application(typeIR_object)
      -- let nameIR_object = "__direct_application"
      -- let C_1 = $add_var(p, C_0, nameIR_object, ``EMPTY` typeIR_object `CTK` ?())
      -- let lvalue = ``ID` nameIR_object as lvalue `.` ``ID` "apply" as member
      -- Stmt_ok: p C_1 f `|-` lvalue `(` argumentList `);` as statement `:` _context _flow statementIR
      -- if statementIR <: callStatementIR
      -- let callStatementIR = statementIR as callStatementIR
      -- let routineTargetIR `<` typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `);` = callStatementIR
      -- if (routineTargetIR = ``` nameIR_object as expressionIR `#` `(` typeIR_object `CTK` `)` `.` "apply")
      -- if typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} matches []
      -- let directApplicationStatementIR = prefixedNameIR `.APPLY(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `);`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:125.1-129.35
   rule returnStatement-empty: cursor C f `|-` statement `:` C `RET` `RETURN;` as statementIR
      -- if cursor matches `LOCAL`
      -- if (statement = `RETURN;` as statement)
      -- if (?(`VOID` as typeIR) = $get_return_type(C))

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:133.1-144.78
   rule returnStatement-expression: cursor C f `|-` statement `:` C `RET` `RETURN` typedExpressionIR_cast `;` as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: returnStatement
      -- let returnStatement = statement as returnStatement
      -- if returnStatement matches `RETURN%;`
      -- let `RETURN` expression `;` = returnStatement
      -- Expr_ok: `LOCAL` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- let typeIR'?{typeIR' <- typeIR'?} = $get_return_type(C)
      -- if typeIR'?{typeIR' <- typeIR'?} matches (_)
      -- let ?(typeIR_ret) = typeIR'?{typeIR' <- typeIR'?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_ret)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:149.1-150.35
   rule exitStatement: p C f `|-` statement `:` C f `EXIT;` as statementIR
      -- if (statement = `EXIT;` as statement)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:154.1-157.51
   rule blockStatement: cursor C_0 f_0 `|-` statement `:` C_1 f_1 blockStatementIR as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: blockStatement
      -- let blockStatement = statement as blockStatement
      -- Block_ok: C_0 f_0 `|-` blockStatement `:` C_1 f_1 blockStatementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:164.1-173.71
   rule conditionalStatement-non-else: p C f `|-` statement `:` C f `IF(` typedExpressionIR_cond `)` statementIR_then as statementIR
      -- if statement <: conditionalStatement
      -- let conditionalStatement = statement as conditionalStatement
      -- if conditionalStatement matches `IF(%)%`
      -- let `IF(` expression_cond `)` statement_then = conditionalStatement
      -- Expr_ok: p C `|-` expression_cond `:` typedExpressionIR_cond
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR_cond
      -- if (typeIR = `BOOL` as typeIR)
      -- Stmt_ok: p C f `|-` statement_then `:` C_then f_then statementIR_then

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:177.1-189.44
   rule conditionalStatement-else: p C f `|-` statement `:` C f_post `IF(` typedExpressionIR_cond `)` statementIR_then `ELSE` statementIR_else as statementIR
      -- if statement <: conditionalStatement
      -- let conditionalStatement = statement as conditionalStatement
      -- if conditionalStatement matches `IF(%)%ELSE%`
      -- let `IF(` expression_cond `)` statement_then `ELSE` statement_else = conditionalStatement
      -- Expr_ok: p C `|-` expression_cond `:` typedExpressionIR_cond
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR_cond
      -- if (typeIR = `BOOL` as typeIR)
      -- Stmt_ok: p C f `|-` statement_then `:` C_then f_then statementIR_then
      -- Stmt_ok: p C f `|-` statement_else `:` C_else f_else statementIR_else
      -- let f_post = $join_flow(f_then, f_else)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:277.1-294.64
   rule switch-table-apply: cursor C f `|-` statement `:` C f_post switchStatementIR as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: switchStatement
      -- let `SWITCH(` expression_switch `){` switchCaseList `}` = statement as switchStatement
      -- Expr_ok: `LOCAL` C `|-` expression_switch `:` typedExpressionIR_switch
      -- let _expressionIR `#` `(` typeIR_switch _ctk `)` = typedExpressionIR_switch
      -- let typeIR = $canon(typeIR_switch)
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` tid_table_enum `{` _id*{_id <- _id*} `}` = tableTypeIR
      -- let tid_table = $strip_prefix($strip_suffix(tid_table_enum, ")"), "action_list(")
      -- let switchCase*{switchCase <- switchCase*} = $flatten_switchCaseList(switchCaseList)
      -- SwitchCases_table_ok: C f tid_table `|-` switchCase*{switchCase <- switchCase*} `:` f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} `#` switchLabel*{switchLabel <- switchLabel*}
      -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
      -- let switchStatementIR = `SWITCH(` typedExpressionIR_switch `){` switchCaseIR*{switchCaseIR <- switchCaseIR*} `}`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:380.1-396.64
   rule switch-general: cursor C f `|-` statement `:` C f_post switchStatementIR as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: switchStatement
      -- let `SWITCH(` expression_switch `){` switchCaseList `}` = statement as switchStatement
      -- Expr_ok: `LOCAL` C `|-` expression_switch `:` typedExpressionIR_switch
      -- let _expressionIR `#` `(` typeIR_switch _ctk `)` = typedExpressionIR_switch
      -- if $compat_switch(typeIR_switch)
      -- let switchCase*{switchCase <- switchCase*} = $flatten_switchCaseList(switchCaseList)
      -- SwitchCases_general_ok: C f typeIR_switch `|-` switchCase*{switchCase <- switchCase*} `:` f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} `#` switchLabel*{switchLabel <- switchLabel*}
      -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
      -- let switchStatementIR = `SWITCH(` typedExpressionIR_switch `){` switchCaseIR*{switchCaseIR <- switchCaseIR*} `}`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:70.1-72.26
relation Stmts_ok: cursor context flow `|-` statement* `:` context flow statementIR*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:74.1-77.23
relation BlockElementStmt_ok: context flow `|-` blockElementStatement `:` context flow blockElementStatementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:404.1-406.75
   rule constantDeclaration: C_0 f `|-` blockElementStatement `:` C_1 f constantDeclarationIR as blockElementStatementIR
      -- if blockElementStatement <: constantDeclaration
      -- let constantDeclaration = blockElementStatement as constantDeclaration
      -- Decl_ok: `LOCAL` C_0 `|-` constantDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:412.1-423.44
   rule variableDeclaration-empty: C_0 f `|-` blockElementStatement `:` C_1 f variableDeclarationIR as blockElementStatementIR
      -- if blockElementStatement <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = blockElementStatement as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: `LOCAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`LOCAL`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`LOCAL`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() `;`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:425.1-442.73
   rule variableDeclaration-initializer: C_0 f `|-` blockElementStatement `:` C_1 f variableDeclarationIR as blockElementStatementIR
      -- if blockElementStatement <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = blockElementStatement as variableDeclaration
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: `LOCAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`LOCAL`, C_0) `|-` typeIR holds
      -- Expr_ok: `LOCAL` C_0 `|-` expression_init `:` typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`LOCAL`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(`=` typedExpressionIR_init_cast) `;`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:446.1-448.64
   rule statement: C_0 f `|-` blockElementStatement `:` C_1 f_post statementIR as blockElementStatementIR
      -- if blockElementStatement <: statement
      -- let statement = blockElementStatement as statement
      -- Stmt_ok: `LOCAL` C_0 f `|-` statement `:` C_1 f_post statementIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:79.1-82.23
relation BlockElementStmts_ok: context flow `|-` blockElementStatement* `:` context flow blockElementStatementIR*

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:454.1-455.23
   rule nil: C f `|-` blockElementStatement*{blockElementStatement <- blockElementStatement*} `:` C f []
      -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches []

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:457.1-463.73
   rule cons: C_0 f_0 `|-` blockElementStatement*{blockElementStatement <- blockElementStatement*} `:` C_2 f_2 blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}
      -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches _ :: _
      -- let blockElementStatement_h :: blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} = blockElementStatement*{blockElementStatement <- blockElementStatement*}
      -- BlockElementStmt_ok: C_0 f_0 `|-` blockElementStatement_h `:` C_1 f_1 blockElementStatementIR_h
      -- BlockElementStmts_ok: C_1 f_1 `|-` blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} `:` C_2 f_2 blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:84.1-87.23
relation Block_ok: context flow `|-` blockStatement `:` context flow blockStatementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:471.1-482.72
   rule : C_0 f `|-` annotationList `{` blockElementStatementList `}` `:` C_3 f_post blockStatementIR
      -- let blockElementStatement*{blockElementStatement <- blockElementStatement*} = $flatten_blockElementStatementList(blockElementStatementList)
      -- let C_1 = $enter(C_0)
      -- BlockElementStmts_ok: C_1 f `|-` blockElementStatement*{blockElementStatement <- blockElementStatement*} `:` C_2 f_post blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
      -- let C_3 = $exit(C_2)
      -- let blockStatementIR = annotationList `{` blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} `}`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:94.1-96.23
relation Parameter_ok: cursor context `|-` parameter `:` parameterIR `#` tid*

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:12.1-19.29
   rule empty: p C `|-` annotationList direction type name initializerOpt `:` annotationList direction typeIR nameIR ?() `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: p C `|-` type as typeOrVoid `:` typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- let bound = $union_set<tid>($bound(p, C), `{` tid_fresh*{tid_fresh <- tid_fresh*} `}`)
      -- if Type_wf: bound `|-` typeIR holds
      -- let nameIR = $name(name)

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:23.1-41.67
   rule empty: p C `|-` annotationList direction type name initializerOpt `:` annotationList direction typeIR nameIR ?(`=` value_init) `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: p C `|-` type as typeOrVoid `:` typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- let bound = $union_set<tid>($bound(p, C), `{` tid_fresh*{tid_fresh <- tid_fresh*} `}`)
      -- if Type_wf: bound `|-` typeIR holds
      -- Expr_ok: p C `|-` expression_init `:` typedExpressionIR_init
      -- let _expressionIR `#` `(` typeIR_init ctk `)` = typedExpressionIR_init
      -- if ctk matches `LCTK`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- Eval_static: p C `|-` typedExpressionIR_init_cast `~>` value_init

;; ../../../../spec-concrete/5.04-typing-relation.watsup:98.1-100.23
relation Parameters_ok: cursor context `|-` parameter* `:` parameterListIR `#` tid*

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:49.1-50.26
   rule nil: p C `|-` parameter*{parameter <- parameter*} `:` [] `#` []
      -- if parameter*{parameter <- parameter*} matches []

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:52.1-56.73
   rule cons: p C `|-` parameter*{parameter <- parameter*} `:` parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} `#` tid_fresh_h*{tid_fresh_h <- tid_fresh_h*} ++ tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}
      -- if parameter*{parameter <- parameter*} matches _ :: _
      -- let parameter_h :: parameter_t*{parameter_t <- parameter_t*} = parameter*{parameter <- parameter*}
      -- Parameter_ok: p C `|-` parameter_h `:` parameterIR_h `#` tid_fresh_h*{tid_fresh_h <- tid_fresh_h*}
      -- Parameters_ok: p C `|-` parameter_t*{parameter_t <- parameter_t*} `:` parameterIR_t*{parameterIR_t <- parameterIR_t*} `#` tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:102.1-102.48
def $parameterIR(parameterIR) : parameterTypeIR =

   ;; ../../../../spec-concrete/5.04-typing-relation.watsup:103.1-104.32
   clause 0(_annotationList direction typeIR nameIR constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}) = direction typeIR nameIR ?()
      -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

   ;; ../../../../spec-concrete/5.04-typing-relation.watsup:105.1-106.34
   clause 1(_annotationList direction typeIR nameIR constantInitializerOptIR) = direction typeIR nameIR ?(value)
      -- if constantInitializerOptIR matches (_)
      -- let ?(`=` value) = constantInitializerOptIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:108.1-111.23
relation ConstructorParameter_ok: cursor context `|-` constructorParameter `:` constructorParameterIR `#` tid*

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:64.1-67.63
   rule : p C `|-` constructorParameter `:` constructorParameterIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- Parameter_ok: p C `|-` constructorParameter `:` constructorParameterIR `#` tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:113.1-116.23
relation ConstructorParameters_ok: cursor context `|-` constructorParameter* `:` constructorParameterListIR `#` tid*

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:75.1-78.65
   rule : p C `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- Parameters_ok: p C `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:118.1-118.81
def $constructorParameterIR(constructorParameterIR) : constructorParameterTypeIR =

   ;; ../../../../spec-concrete/5.04-typing-relation.watsup:119.1-120.41
   clause 0(constructorParameterIR) = $parameterIR(constructorParameterIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:126.1-128.23
relation ExternMethod_ok: context tid `|-` methodPrototype `:` context methodPrototypeIR

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:9.1-37.79
   rule non-abstract: C_0 tid_extern `|-` methodPrototype `:` C_3 methodPrototypeIR
      -- if methodPrototype matches `%%;`
      -- let annotationList typeOrVoid name typeParameterListOpt `(` parameterList `)` `;` = methodPrototype
      -- let nameIR = $name(name)
      -- if (nameIR =/= tid_extern)
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`LOCAL`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `LOCAL` C_1 `|-` typeOrVoid `:` typeIR_ret `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `LOCAL` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`LOCAL`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameterList)
      -- let methodTypeIR = `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(`BLOCK`, C_0) `|-` routineTypeDefIR holds
      -- let C_3 = $add_routine_overload(`BLOCK`, C_0, rid, routineTypeDefIR)
      -- let methodPrototypeIR = annotationList typeIR_ret nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `)` `;`

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:41.1-69.79
   rule abstract: C_0 tid_extern `|-` methodPrototype `:` C_3 methodPrototypeIR
      -- if methodPrototype matches `%ABSTRACT%;`
      -- let annotationList `ABSTRACT` typeOrVoid name typeParameterListOpt `(` parameterList `)` `;` = methodPrototype
      -- let nameIR = $name(name)
      -- if (nameIR =/= tid_extern)
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`LOCAL`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `LOCAL` C_1 `|-` typeOrVoid `:` typeIR_ret `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `LOCAL` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`LOCAL`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameterList)
      -- let methodTypeIR = `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(`BLOCK`, C_0) `|-` routineTypeDefIR holds
      -- let C_3 = $add_routine_overload(`BLOCK`, C_0, rid, routineTypeDefIR)
      -- let methodPrototypeIR = annotationList `ABSTRACT` typeIR_ret nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `)` `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:130.1-132.23
relation ExternMethods_ok: context tid `|-` methodPrototype* `:` context methodPrototypeIR*

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:77.1-78.30
   rule nil: C tid_extern `|-` methodPrototype*{methodPrototype <- methodPrototype*} `:` C []
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:80.1-86.66
   rule cons: C_0 tid_extern `|-` methodPrototype*{methodPrototype <- methodPrototype*} `:` C_2 methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- ExternMethod_ok: C_0 tid_extern `|-` methodPrototype_h `:` C_1 methodPrototypeIR_h
      -- ExternMethods_ok: C_1 tid_extern `|-` methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} `:` C_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:134.1-136.23
relation ExternConstructor_ok: context tid `|-` methodPrototype `:` context methodPrototypeIR

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:96.1-122.80
   rule : C_0 tid_extern `|-` methodPrototype `:` C_1 methodPrototypeIR
      -- if methodPrototype matches `%%(%);`
      -- let annotationList typeIdentifier `(` parameterList `);` = methodPrototype
      -- let nameIR = $name(typeIdentifier as name)
      -- if (nameIR = tid_extern)
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
      -- ConstructorParameters_ok: `BLOCK` C_0 `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(`GLOBAL`, C_0, ``` nameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_extern `<` tid_expl*{tid_expl <- tid_expl*} `,` tid*{tid <- tid*} `>` = typeDefIR as polyTypeDefIR
      -- if tid*{tid <- tid*} matches []
      -- let cid = $cid(typeIdentifier as name, `(` parameterList `)`)
      -- let typeIR_extern_spec = typeIR_extern `<` tid_expl*{tid_expl <- tid_expl*} `,` [] `>` `<` `TID` tid_expl as typeIR*{tid_expl <- tid_expl*} `>` as typeIR
      -- let constructorTypeIR = `CONSTRUCTOR(` constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} `)->` typeIR_extern_spec
      -- let constructorTypeDefIR = constructorTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>`
      -- if ConstructorTypeDef_wf: $bound(`BLOCK`, C_0) `|-` constructorTypeDefIR holds
      -- let C_1 = $add_constructor(C_0, cid, constructorTypeDefIR)
      -- let methodPrototypeIR = annotationList nameIR `<,` tid_impl*{tid_impl <- tid_impl*} `>(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `);`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:138.1-140.23
relation ExternConstructors_ok: context tid `|-` methodPrototype* `:` context methodPrototypeIR*

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:130.1-131.30
   rule nil: C tid_extern `|-` methodPrototype*{methodPrototype <- methodPrototype*} `:` C []
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:133.1-139.71
   rule cons: C_0 tid_extern `|-` methodPrototype*{methodPrototype <- methodPrototype*} `:` C_2 methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- ExternConstructor_ok: C_0 tid_extern `|-` methodPrototype_h `:` C_1 methodPrototypeIR_h
      -- ExternConstructors_ok: C_1 tid_extern `|-` methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} `:` C_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:146.1-148.23
relation ParserTransition_ok: context nameIR* `|-` transitionStatement `:` transitionStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:11.1-15.7
   rule empty: C_0 nameIR_state*{nameIR_state <- nameIR_state*} `|-` transitionStatement `:` `TRANSITION` "reject" `;`
      -- if transitionStatement matches ``EMPTY`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:19.1-26.55
   rule name: C_0 nameIR_state*{nameIR_state <- nameIR_state*} `|-` transitionStatement `:` transitionStatementIR
      -- if transitionStatement matches `TRANSITION%`
      -- let `TRANSITION` stateExpression = transitionStatement
      -- if stateExpression matches `%;`
      -- let name `;` = stateExpression
      -- let nameIR = $name(name)
      -- if nameIR <- nameIR_state*{nameIR_state <- nameIR_state*}
      -- let transitionStatementIR = `TRANSITION` nameIR `;`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:292.1-306.75
   rule switch: C_0 nameIR_state*{nameIR_state <- nameIR_state*} `|-` transitionStatement `:` transitionStatementIR
      -- if transitionStatement matches `TRANSITION%`
      -- let `TRANSITION` stateExpression = transitionStatement
      -- if stateExpression <: selectExpression
      -- let `SELECT(` expressionList_key `){` selectCaseList `}` = stateExpression as selectExpression
      -- let expression_key*{expression_key <- expression_key*} = $flatten_expressionList(expressionList_key)
      -- (Expr_ok: `LOCAL` C_0 `|-` expression_key `:` typedExpressionIR_key)*{expression_key <- expression_key*, typedExpressionIR_key <- typedExpressionIR_key*}
      -- (let _expressionIR `#` `(` typeIR_key _ctk `)` = typedExpressionIR_key)*{_ctk <- _ctk*, _expressionIR <- _expressionIR*, typeIR_key <- typeIR_key*, typedExpressionIR_key <- typedExpressionIR_key*}
      -- (if Type_wf: $bound(`LOCAL`, C_0) `|-` `SET<` [typeIR_key] `>` as typeIR holds)*{typeIR_key <- typeIR_key*}
      -- let selectCase*{selectCase <- selectCase*} = $flatten_selectCaseList(selectCaseList)
      -- (SelectCase_ok: C_0 nameIR_state*{nameIR_state <- nameIR_state*} typeIR_key*{typeIR_key <- typeIR_key*} `|-` selectCase `:` selectCaseIR)*{selectCase <- selectCase*, selectCaseIR <- selectCaseIR*}
      -- let transitionStatementIR = `TRANSITION` `SELECT(` typedExpressionIR_key*{typedExpressionIR_key <- typedExpressionIR_key*} `){` selectCaseIR*{selectCaseIR <- selectCaseIR*} `}` as stateExpressionIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:150.1-152.20
relation ParserStmt_ok: context `|-` parserStatement `:` context parserStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:316.1-320.53
   rule constantDeclaration: C_0 `|-` parserStatement `:` C_1 constantDeclarationIR as parserStatementIR
      -- if parserStatement <: constantDeclaration
      -- let constantDeclaration = parserStatement as constantDeclaration
      -- Decl_ok: `LOCAL` C_0 `|-` constantDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:326.1-337.44
   rule variableDeclaration-empty: C_0 `|-` parserStatement `:` C_1 variableDeclarationIR as parserStatementIR
      -- if parserStatement <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = parserStatement as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: `LOCAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`LOCAL`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`LOCAL`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() `;`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:339.1-356.73
   rule variableDeclaration-initializer: C_0 `|-` parserStatement `:` C_1 variableDeclarationIR as parserStatementIR
      -- if parserStatement <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = parserStatement as variableDeclaration
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: `LOCAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`LOCAL`, C_0) `|-` typeIR holds
      -- Expr_ok: `LOCAL` C_0 `|-` expression_init `:` typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`LOCAL`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(`=` typedExpressionIR_init_cast) `;`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:360.1-364.54
   rule emptyStatement: C `|-` parserStatement `:` C emptyStatementIR as parserStatementIR
      -- if parserStatement <: emptyStatement
      -- let emptyStatement = parserStatement as emptyStatement
      -- Stmt_ok: `LOCAL` C `CONT` `|-` emptyStatement as statement `:` context flow statementIR
      -- if (context = C)
      -- if flow matches `CONT`
      -- if statementIR <: emptyStatementIR
      -- let emptyStatementIR = statementIR as emptyStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:368.1-372.63
   rule assignmentStatement: C_0 `|-` parserStatement `:` C_1 assignmentStatementIR as parserStatementIR
      -- if parserStatement <: assignmentStatement
      -- let assignmentStatement = parserStatement as assignmentStatement
      -- Stmt_ok: `LOCAL` C_0 `CONT` `|-` assignmentStatement as statement `:` C_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: assignmentStatementIR
      -- let assignmentStatementIR = statementIR as assignmentStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:376.1-380.57
   rule callStatement: C_0 `|-` parserStatement `:` C_1 callStatementIR as parserStatementIR
      -- if parserStatement <: callStatement
      -- let callStatement = parserStatement as callStatement
      -- Stmt_ok: `LOCAL` C_0 `CONT` `|-` callStatement as statement `:` C_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: callStatementIR
      -- let callStatementIR = statementIR as callStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:384.1-388.70
   rule directApplicationStatement: C_0 `|-` parserStatement `:` C_1 directApplicationStatementIR as parserStatementIR
      -- if parserStatement <: directApplicationStatement
      -- let directApplicationStatement = parserStatement as directApplicationStatement
      -- Stmt_ok: `LOCAL` C_0 `CONT` `|-` directApplicationStatement as statement `:` C_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: directApplicationStatementIR
      -- let directApplicationStatementIR = statementIR as directApplicationStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:393.1-403.72
   rule parserBlockStatement: C_0 `|-` parserStatement' `:` C_1 parserBlockStatementIR as parserStatementIR
      -- if parserStatement' <: parserBlockStatement
      -- let annotationList `{` parserStatementList `}` = parserStatement' as parserBlockStatement
      -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
      -- let C_1 = $enter(C_0)
      -- ParserStmts_ok: C_1 `|-` parserStatement*{parserStatement <- parserStatement*} `:` C_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
      -- let C_3 = $exit(C_2)
      -- let parserBlockStatementIR = annotationList `{` parserStatementIR*{parserStatementIR <- parserStatementIR*} `}`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:407.1-411.64
   rule conditionalStatement: C_0 `|-` parserStatement `:` C_1 conditionalStatementIR as parserStatementIR
      -- if parserStatement <: conditionalStatement
      -- let conditionalStatement = parserStatement as conditionalStatement
      -- Stmt_ok: `LOCAL` C_0 `CONT` `|-` conditionalStatement as statement `:` C_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: conditionalStatementIR
      -- let conditionalStatementIR = statementIR as conditionalStatementIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:154.1-156.20
relation ParserStmts_ok: context `|-` parserStatement* `:` context parserStatementIR*

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:419.1-420.19
   rule nil: C `|-` parserStatement*{parserStatement <- parserStatement*} `:` C []
      -- if parserStatement*{parserStatement <- parserStatement*} matches []

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:422.1-428.53
   rule cons: C_0 `|-` parserStatement*{parserStatement <- parserStatement*} `:` C_2 parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}
      -- if parserStatement*{parserStatement <- parserStatement*} matches _ :: _
      -- let parserStatement_h :: parserStatement_t*{parserStatement_t <- parserStatement_t*} = parserStatement*{parserStatement <- parserStatement*}
      -- ParserStmt_ok: C_0 `|-` parserStatement_h `:` C_1 parserStatementIR_h
      -- ParserStmts_ok: C_1 `|-` parserStatement_t*{parserStatement_t <- parserStatement_t*} `:` C_2 parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:158.1-160.23
relation ParserState_ok: context nameIR* `|-` parserState `:` parserStateIR

   ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:8.1-26.82
   rule : C_0 nameIR_state*{nameIR_state <- nameIR_state*} `|-` annotationList `STATE` name `{` parserStatementList transitionStatement `}` `:` parserStateIR
      -- let nameIR = $name(name)
      -- let C_1 = $enter(C_0)
      -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
      -- ParserStmts_ok: C_1 `|-` parserStatement*{parserStatement <- parserStatement*} `:` C_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
      -- ParserTransition_ok: C_2 nameIR_state*{nameIR_state <- nameIR_state*} `|-` transitionStatement `:` transitionStatementIR
      -- let C_3 = $exit(C_2)
      -- let parserStateIR = annotationList `STATE` nameIR `{` parserStatementIR*{parserStatementIR <- parserStatementIR*} transitionStatementIR `}`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:162.1-164.20
relation ParserStates_ok: context `|-` parserState* `:` parserStateIR*

   ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:34.1-46.76
   rule : C `|-` parserState*{parserState <- parserState*} `:` parserStateIR*{parserStateIR <- parserStateIR*}
      -- (let _annotationList `STATE` name_state `{` _parserStatementList _transitionStatement `}` = parserState)*{_annotationList <- _annotationList*, _parserStatementList <- _parserStatementList*, _transitionStatement <- _transitionStatement*, name_state <- name_state*, parserState <- parserState*}
      -- (let nameIR_state = $name(name_state))*{nameIR_state <- nameIR_state*, name_state <- name_state*}
      -- if $distinct_<nameIR>(nameIR_state*{nameIR_state <- nameIR_state*})
      -- if "start" <- nameIR_state*{nameIR_state <- nameIR_state*}
      -- if (~"accept" <- nameIR_state*{nameIR_state <- nameIR_state*} /\ ~"reject" <- nameIR_state*{nameIR_state <- nameIR_state*})
      -- let nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} = "accept" :: "reject" :: nameIR_state*{nameIR_state <- nameIR_state*}
      -- (ParserState_ok: C nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} `|-` parserState `:` parserStateIR)*{parserState <- parserState*, parserStateIR <- parserStateIR*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:166.1-169.20
relation ParserLocalDecl_ok: context `|-` parserLocalDeclaration `:` context parserLocalDeclarationIR

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:9.1-13.53
   rule constantDeclaration: C_0 `|-` parserLocalDeclaration `:` C_1 constantDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: constantDeclaration
      -- let constantDeclaration = parserLocalDeclaration as constantDeclaration
      -- Decl_ok: `BLOCK` C_0 `|-` constantDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:17.1-21.47
   rule instantiation: C_0 `|-` parserLocalDeclaration `:` C_1 instantiationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: instantiation
      -- let instantiation = parserLocalDeclaration as instantiation
      -- Decl_ok: `BLOCK` C_0 `|-` instantiation as declaration `:` C_1 declarationIR
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:27.1-38.44
   rule variableDeclaration-empty: C_0 `|-` parserLocalDeclaration `:` C_1 variableDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = parserLocalDeclaration as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: `BLOCK` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`BLOCK`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() `;`

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:40.1-57.73
   rule variableDeclaration-initializer: C_0 `|-` parserLocalDeclaration `:` C_1 variableDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = parserLocalDeclaration as variableDeclaration
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: `BLOCK` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`BLOCK`, C_0) `|-` typeIR holds
      -- Expr_ok: `BLOCK` C_0 `|-` expression_init `:` typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(`=` typedExpressionIR_init_cast) `;`

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:63.1-80.78
   rule valueSetDeclaration: C_0 `|-` parserLocalDeclaration `:` C_1 valueSetDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: valueSetDeclaration
      -- let annotationList `VALUE_SET<` valueSetType `>(` expression `)` name `;` = parserLocalDeclaration as valueSetDeclaration
      -- Type_ok: `BLOCK` C_0 `|-` valueSetType as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`BLOCK`, C_0) `|-` `SET<` [typeIR] `>` as typeIR holds
      -- Expr_ok: `BLOCK` C_0 `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` _typeIR ctk `)` = typedExpressionIR
      -- if (ctk =/= `DYN`)
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, ``EMPTY` `SET<` [typeIR] `>` as typeIR `CTK` ?())
      -- let valueSetDeclarationIR = annotationList `VALUE_SET<` typeIR `>(` typedExpressionIR `)` nameIR `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:171.1-174.20
relation ParserLocalDecls_ok: context `|-` parserLocalDeclaration* `:` context parserLocalDeclarationIR*

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:88.1-89.19
   rule nil: C `|-` parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} `:` C []
      -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches []

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:91.1-97.65
   rule cons: C_0 `|-` parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} `:` C_2 parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}
      -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches _ :: _
      -- let parserLocalDeclaration_h :: parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} = parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}
      -- ParserLocalDecl_ok: C_0 `|-` parserLocalDeclaration_h `:` C_1 parserLocalDeclarationIR_h
      -- ParserLocalDecls_ok: C_1 `|-` parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} `:` C_2 parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:180.1-182.23
relation TableKey_ok: context tablecontext `|-` tableKey `:` tablecontext tableKeyIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:47.1-64.77
   rule : C TC_0 `|-` expression `:` name_matchkind annotationList `;` `:` TC_2 tableKeyIR
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if Type_wf: $bound(`BLOCK`, C) `|-` `SET<` [typeIR] `>` as typeIR holds
      -- let nameIR_matchkind = $name(name_matchkind)
      -- if (`MATCH_KIND.` nameIR_matchkind as value = $find_value(`BLOCK`, C, ``` nameIR_matchkind))
      -- if $compat_table_key(nameIR_matchkind, typeIR)
      -- let TC_1 = $update_mode(TC_0, nameIR_matchkind, typeIR)
      -- let TC_2 = $add_key(TC_1, nameIR_matchkind, typeIR)
      -- let tableKeyIR = typedExpressionIR `:` nameIR_matchkind annotationList `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:184.1-186.23
relation TableKeys_ok: context tablecontext `|-` tableKey* `:` tablecontext tableKeyListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:72.1-73.23
   rule nil: C TC `|-` tableKey*{tableKey <- tableKey*} `:` TC []
      -- if tableKey*{tableKey <- tableKey*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:75.1-79.62
   rule cons: C TC_0 `|-` tableKey*{tableKey <- tableKey*} `:` TC_2 tableKeyIR_h :: tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}
      -- if tableKey*{tableKey <- tableKey*} matches _ :: _
      -- let tableKey_h :: tableKey_t*{tableKey_t <- tableKey_t*} = tableKey*{tableKey <- tableKey*}
      -- TableKey_ok: C TC_0 `|-` tableKey_h `:` TC_1 tableKeyIR_h
      -- TableKeys_ok: C TC_1 `|-` tableKey_t*{tableKey_t <- tableKey_t*} `:` TC_2 tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:188.1-191.23
relation Call_action_partial_ok: context `|-` parameterTypeIR* `@` argumentListIR `:` parameterTypeIR* `,` parameterTypeIR* `@` argumentListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:103.1-115.41
   rule : C `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `,` parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} `@` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- if (|parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- Call_convention_ok: `BLOCK` C `ACTION` `|-` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:193.1-195.23
relation TableAction_ok: context tablecontext `|-` tableAction `:` tablecontext tableActionIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:122.1-136.68
   rule prefixedNonTypeName: C TC_0 `|-` annotationList tableActionReference `;` `:` TC_1 tableActionIR
      -- if tableActionReference <: prefixedNonTypeName
      -- let prefixedNonTypeName = tableActionReference as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(`BLOCK`, C, prefixedNameIR)
      -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
      -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
      -- if routineTypeDefIR <: functionTypeIR
      -- let functionTypeIR = routineTypeDefIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- Call_action_partial_ok: C `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` [] `:` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `,` parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} `@` argumentIR*{argumentIR <- argumentIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let TC_1 = $add_action(TC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, [])
      -- let tableActionIR = annotationList prefixedNameIR `(` [] `)` `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:140.1-157.81
   rule prefixedNonTypeName-argumentList: C TC_0 `|-` annotationList tableActionReference `;` `:` TC_1 tableActionIR
      -- if tableActionReference matches `%(%)`
      -- let prefixedNonTypeName `(` argumentList `)` = tableActionReference
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(`BLOCK`, C, prefixedNameIR)
      -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
      -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
      -- if routineTypeDefIR <: functionTypeIR
      -- let functionTypeIR = routineTypeDefIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: `BLOCK` C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_partial_ok: C `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `,` parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} `@` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let TC_1 = $add_action(TC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let tableActionIR = annotationList prefixedNameIR `(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)` `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:197.1-199.23
relation TableActions_ok: context tablecontext `|-` tableAction* `:` tablecontext tableActionListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:165.1-166.23
   rule nil: C TC `|-` tableAction*{tableAction <- tableAction*} `:` TC []
      -- if tableAction*{tableAction <- tableAction*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:168.1-172.71
   rule cons: C TC_0 `|-` tableAction*{tableAction <- tableAction*} `:` TC_2 tableActionIR_h :: tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}
      -- if tableAction*{tableAction <- tableAction*} matches _ :: _
      -- let tableAction_h :: tableAction_t*{tableAction_t <- tableAction_t*} = tableAction*{tableAction <- tableAction*}
      -- TableAction_ok: C TC_0 `|-` tableAction_h `:` TC_1 tableActionIR_h
      -- TableActions_ok: C TC_1 `|-` tableAction_t*{tableAction_t <- tableAction_t*} `:` TC_2 tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:201.1-204.23
relation Call_action_default_ok: context `|-` parameterTypeIR* `@` argumentListIR `:` parameterTypeIR* `,` parameterTypeIR* `@` argumentListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:180.1-190.41
   rule : C `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `,` parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} `@` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- Call_convention_ok: `BLOCK` C `ACTION` `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:206.1-208.23
relation TableDefaultAction_ok: context tablecontext `|-` initializer `:` tableActionReferenceIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:194.1-199.54
   rule prefixedNonTypeName: C TC `|-` `=` expression `:` prefixedNameIR `(` [] `)`
      -- if expression <: prefixedNonTypeName
      -- let prefixedNonTypeName = expression as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- if (?(([], [])) = $find_action(TC, prefixedNameIR))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:203.1-224.57
   rule prefixedNonTypeName-argumentList: C TC `|-` `=` expression `:` prefixedNameIR `(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget `(` argumentList `)` = callExpression
      -- if callTarget <: prefixedNonTypeName
      -- let prefixedNonTypeName = callTarget as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} = $find_action(TC, prefixedNameIR)
      -- if (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} matches (_)
      -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: `BLOCK` C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_default_ok: C `|-` parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} `@` argumentIR*{argumentIR <- argumentIR*} `:` parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} `,` parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} `@` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:210.1-212.23
relation TableEntry_keyset_ok: context tablecontext `|-` keysetExpression `:` tableEntryState keysetExpressionIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:411.1-418.49
   rule simpleKeysetExpression-expression: C TC `|-` keysetExpression `:` TES simpleKeysetExpressionIR as keysetExpressionIR
      -- if keysetExpression <: expression
      -- let expression = keysetExpression as expression
      -- if (|TC.KEYS| = 1)
      -- TableEntry_keysets_simple_ok: C TC `NOLPM` `|-` TC.KEYS `@` [expression as simpleKeysetExpression] `:` TES simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:422.1-429.49
   rule simpleKeysetExpression-mask: C TC `|-` keysetExpression `:` TES simpleKeysetExpressionIR as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l `&&&` expression_r = simpleKeysetExpression
      -- if (|TC.KEYS| = 1)
      -- TableEntry_keysets_simple_ok: C TC `NOLPM` `|-` TC.KEYS `@` [expression_l `&&&` expression_r] `:` TES simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:433.1-440.49
   rule simpleKeysetExpression-range: C TC `|-` keysetExpression `:` TES simpleKeysetExpressionIR as keysetExpressionIR
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `%..%`
      -- let expression_l `..` expression_r = simpleKeysetExpression
      -- if (|TC.KEYS| = 1)
      -- TableEntry_keysets_simple_ok: C TC `NOLPM` `|-` TC.KEYS `@` [expression_l `..` expression_r] `:` TES simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:444.1-447.20
   rule simpleKeysetExpression-default-noprilpm: C TC `|-` keysetExpression `:` TES `DEFAULT` as keysetExpressionIR
      -- if (keysetExpression = `DEFAULT` as keysetExpression)
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` n = matchMode
      -- let TES = `LPM` n

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:449.1-452.20
   rule simpleKeysetExpression-default-else: C TC `|-` keysetExpression `:` TES `DEFAULT` as keysetExpressionIR
      -- if (keysetExpression = `DEFAULT` as keysetExpression)
      -- if (((TC.MODE = `NOPRI`) \/ (TC.MODE = `PRI`)) \/ (TC.MODE = `PRILPM`))
      -- let TES = `NOLPM`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:456.1-459.20
   rule simpleKeysetExpression-dontcare-noprilpm: C TC `|-` keysetExpression `:` TES `_` as keysetExpressionIR
      -- if (keysetExpression = `_` as keysetExpression)
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` n = matchMode
      -- let TES = `LPM` 0

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:461.1-464.20
   rule simpleKeysetExpression-dontcare-else: C TC `|-` keysetExpression `:` TES `_` as keysetExpressionIR
      -- if (keysetExpression = `_` as keysetExpression)
      -- if (((TC.MODE = `NOPRI`) \/ (TC.MODE = `PRI`)) \/ (TC.MODE = `PRILPM`))
      -- let TES = `NOLPM`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:471.1-479.49
   rule tupleKeysetExpression-mask: C TC `|-` keysetExpression `:` TES `(` [simpleKeysetExpressionIR] `)` as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%&&&%)`
      -- let `(` expression_l `&&&` expression_r `)` = tupleKeysetExpression
      -- if (|TC.KEYS| = 1)
      -- TableEntry_keysets_simple_ok: C TC `NOLPM` `|-` TC.KEYS `@` [expression_l `&&&` expression_r] `:` TES simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:483.1-491.49
   rule tupleKeysetExpression-range: C TC `|-` keysetExpression `:` TES `(` [simpleKeysetExpressionIR] `)` as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%..%)`
      -- let `(` expression_l `..` expression_r `)` = tupleKeysetExpression
      -- if (|TC.KEYS| = 1)
      -- TableEntry_keysets_simple_ok: C TC `NOLPM` `|-` TC.KEYS `@` [expression_l `..` expression_r] `:` TES simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
      -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
      -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:495.1-498.20
   rule tupleKeysetExpression-default-noprilpm: C TC `|-` keysetExpression `:` TES `(` [`DEFAULT`] `)` as keysetExpressionIR
      -- if (keysetExpression = `(DEFAULT)` as keysetExpression)
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` n = matchMode
      -- let TES = `LPM` n

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:500.1-503.20
   rule tupleKeysetExpression-default-else: C TC `|-` keysetExpression `:` TES `(` [`DEFAULT`] `)` as keysetExpressionIR
      -- if (keysetExpression = `(DEFAULT)` as keysetExpression)
      -- if (((TC.MODE = `NOPRI`) \/ (TC.MODE = `PRI`)) \/ (TC.MODE = `PRILPM`))
      -- let TES = `NOLPM`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:507.1-510.20
   rule tupleKeysetExpression-dontcare-noprilpm: C TC `|-` keysetExpression `:` TES `(` [`_`] `)` as keysetExpressionIR
      -- if (keysetExpression = `(_)` as keysetExpression)
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` n = matchMode
      -- let TES = `LPM` 0

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:512.1-515.20
   rule simpleKeysetExpression-dontcare-else: C TC `|-` keysetExpression `:` TES `(` [`_`] `)` as keysetExpressionIR
      -- if (keysetExpression = `(_)` as keysetExpression)
      -- if (((TC.MODE = `NOPRI`) \/ (TC.MODE = `PRI`)) \/ (TC.MODE = `PRILPM`))
      -- let TES = `NOLPM`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:519.1-531.50
   rule tupleKeysetExpression-list: C TC `|-` keysetExpression `:` TES `(` simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*} `)` as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%,%)`
      -- let `(` simpleKeysetExpression_h `,` simpleKeysetExpressionList_t `)` = tupleKeysetExpression
      -- let simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t)
      -- let simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} = simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*}
      -- if (|TC.KEYS| = |simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}|)
      -- TableEntry_keysets_simple_ok: C TC `NOLPM` `|-` TC.KEYS `@` simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} `:` TES simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:214.1-216.23
relation TableEntry_action_ok: context tablecontext `|-` tableActionReference `:` tableActionReferenceIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:541.1-545.54
   rule prefixedNonTypeName: C TC `|-` tableActionReference `:` prefixedNameIR `(` [] `)`
      -- if tableActionReference <: prefixedNonTypeName
      -- let prefixedNonTypeName = tableActionReference as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- if (?(([], [])) = $find_action(TC, prefixedNameIR))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:549.1-570.57
   rule prefixedNonTypeName-argumentList: C TC `|-` tableActionReference `:` prefixedNameIR `(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if tableActionReference matches `%(%)`
      -- let prefixedNonTypeName `(` argumentList `)` = tableActionReference
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} = $find_action(TC, prefixedNameIR)
      -- if (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} matches (_)
      -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: `BLOCK` C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_default_ok: C `|-` parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} `@` argumentIR*{argumentIR <- argumentIR*} `:` parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} `,` parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} `@` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:218.1-221.26
relation TableEntry_priority_ok: context tablecontext tableEntryState `|-` tableEntryPriority? `:` tablecontext tableEntryPriorityOptIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:580.1-582.24
   rule nopri: C TC TES `|-` tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} `:` TC ?()
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:584.1-587.27
   rule noprilpm: C TC TES `|-` tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} `:` TC ?()
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` n = matchMode
      -- let tableEntryState = TES
      -- if tableEntryState matches `LPM%`
      -- let `LPM` n_prefix = tableEntryState

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:589.1-601.44
   rule pri-prilpm-number-init-largest-wins: C TC_0 TES `|-` tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} `:` TC_1 ?(`PRIORITY=` `D` n as int `:`)
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TC_0.MODE = `PRI`) \/ (TC_0.MODE = `PRILPM`))
      -- if (TC_0.PRIORITIES.VALUES = [])
      -- if TC_0.PRIORITIES.LARGEST_WINS
      -- let n_size = TC_0.ENTRIES.SIZE
      -- let n_delta = TC_0.PRIORITIES.DELTA
      -- let n = (((n_size - 1) * n_delta) + 1)
      -- let TC_1 = $add_table_priority(TC_0, n)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:603.1-612.44
   rule pri-prilpm-number-init-non-largest-wins: C TC_0 TES `|-` tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} `:` TC_1 ?(`PRIORITY=` `D` 1 as int `:`)
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TC_0.MODE = `PRI`) \/ (TC_0.MODE = `PRILPM`))
      -- if (TC_0.PRIORITIES.VALUES = [])
      -- if ~TC_0.PRIORITIES.LARGEST_WINS
      -- let TC_1 = $add_table_priority(TC_0, 1)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:614.1-626.44
   rule pri-prilpm-number-non-init-largest-wins: C TC_0 TES `|-` tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} `:` TC_1 ?(`PRIORITY=` `D` n as int `:`)
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TC_0.MODE = `PRI`) \/ (TC_0.MODE = `PRILPM`))
      -- if (TC_0.PRIORITIES.VALUES =/= [])
      -- if TC_0.PRIORITIES.LARGEST_WINS
      -- let n_last = $find_table_priority_last(TC_0)
      -- let n_delta = TC_0.PRIORITIES.DELTA
      -- let n = (n_last - n_delta)
      -- let TC_1 = $add_table_priority(TC_0, n)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:628.1-640.44
   rule pri-prilpm-number-non-init-non-largest-wins: C TC_0 TES `|-` tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} `:` TC_1 ?(`PRIORITY=` `D` n as int `:`)
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TC_0.MODE = `PRI`) \/ (TC_0.MODE = `PRILPM`))
      -- if (TC_0.PRIORITIES.VALUES =/= [])
      -- if ~TC_0.PRIORITIES.LARGEST_WINS
      -- let n_last = $find_table_priority_last(TC_0)
      -- let n_delta = TC_0.PRIORITIES.DELTA
      -- let n = (n_last + n_delta)
      -- let TC_1 = $add_table_priority(TC_0, n)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:644.1-655.44
   rule pri-prilpm-number-init: C TC_0 TES `|-` tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} `:` TC_2 ?(`PRIORITY=` number `:`)
      -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
      -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
      -- if tableEntryPriority matches `PRIORITY=%:`
      -- let `PRIORITY=` number `:` = tableEntryPriority
      -- if ((TC_0.MODE = `PRI`) \/ (TC_0.MODE = `PRILPM`))
      -- if ~TC_0.ENTRIES.CONST
      -- if (TC_0.PRIORITIES.VALUES = [])
      -- let int = $to_number(number as value)
      -- if int <: nat
      -- let n = int as nat
      -- let TC_1 = TC_0[PRIORITIES.INIT = true]
      -- let TC_2 = $add_table_priority(TC_1, n)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:657.1-668.44
   rule pri-prilpm-number-non-init: C TC_0 TES `|-` tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} `:` TC_1 ?(`PRIORITY=` number `:`)
      -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
      -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
      -- if tableEntryPriority matches `PRIORITY=%:`
      -- let `PRIORITY=` number `:` = tableEntryPriority
      -- if ((TC_0.MODE = `PRI`) \/ (TC_0.MODE = `PRILPM`))
      -- if ~TC_0.ENTRIES.CONST
      -- if (TC_0.PRIORITIES.VALUES =/= [])
      -- if TC_0.PRIORITIES.INIT
      -- let int = $to_number(number as value)
      -- if int <: nat
      -- let n = int as nat
      -- let TC_1 = $add_table_priority(TC_0, n)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:672.1-686.44
   rule pri-prilpm-expression-init: C TC_0 TES `|-` tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} `:` TC_2 ?(`PRIORITY=(` typedExpressionIR `):`)
      -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
      -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
      -- if tableEntryPriority matches `PRIORITY=(%):`
      -- let `PRIORITY=(` expression `):` = tableEntryPriority
      -- if ((TC_0.MODE = `PRI`) \/ (TC_0.MODE = `PRILPM`))
      -- if ~TC_0.ENTRIES.CONST
      -- if (TC_0.PRIORITIES.VALUES = [])
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` _typeIR ctk `)` = typedExpressionIR
      -- if ctk matches `LCTK`
      -- Eval_static: `BLOCK` C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat
      -- let TC_1 = TC_0[PRIORITIES.INIT = true]
      -- let TC_2 = $add_table_priority(TC_1, n)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:688.1-702.44
   rule pri-prilpm-expression-non-init: C TC_0 TES `|-` tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} `:` TC_1 ?(`PRIORITY=(` typedExpressionIR `):`)
      -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
      -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
      -- if tableEntryPriority matches `PRIORITY=(%):`
      -- let `PRIORITY=(` expression `):` = tableEntryPriority
      -- if ((TC_0.MODE = `PRI`) \/ (TC_0.MODE = `PRILPM`))
      -- if ~TC_0.ENTRIES.CONST
      -- if (TC_0.PRIORITIES.VALUES =/= [])
      -- if TC_0.PRIORITIES.INIT
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` _typeIR ctk `)` = typedExpressionIR
      -- if ctk matches `LCTK`
      -- Eval_static: `BLOCK` C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat
      -- let TC_1 = $add_table_priority(TC_0, n)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:223.1-225.23
relation TableEntry_ok: context tablecontext `|-` tableEntry `:` tablecontext tableEntryIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:707.1-721.73
   rule priority: C TC_0 `|-` tableEntry `:` TC_1 tableEntryIR
      -- if tableEntry matches `%%%:%%;`
      -- let constOpt tableEntryPriority keysetExpression `:` tableActionReference annotationList `;` = tableEntry
      -- TableEntry_keyset_ok: C TC_0 `|-` keysetExpression `:` TES keysetExpressionIR
      -- TableEntry_action_ok: C TC_0 `|-` tableActionReference `:` tableActionReferenceIR
      -- TableEntry_priority_ok: C TC_0 TES `|-` ?(tableEntryPriority) `:` TC_1 tableEntryPriorityOptIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tableEntryIR = constOptIR tableEntryPriorityOptIR keysetExpressionIR `:` tableActionReferenceIR annotationList `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:725.1-739.73
   rule non-priority: C TC_0 `|-` tableEntry `:` TC_1 tableEntryIR
      -- if tableEntry matches `%%:%%;`
      -- let constOpt keysetExpression `:` tableActionReference annotationList `;` = tableEntry
      -- TableEntry_keyset_ok: C TC_0 `|-` keysetExpression `:` TES keysetExpressionIR
      -- TableEntry_action_ok: C TC_0 `|-` tableActionReference `:` tableActionReferenceIR
      -- TableEntry_priority_ok: C TC_0 TES `|-` ?() `:` TC_1 tableEntryPriorityOptIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tableEntryIR = constOptIR tableEntryPriorityOptIR keysetExpressionIR `:` tableActionReferenceIR annotationList `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:227.1-229.23
relation TableEntries_ok: context tablecontext `|-` tableEntry* `:` tablecontext tableEntryListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:747.1-748.23
   rule nil: C TC `|-` tableEntry*{tableEntry <- tableEntry*} `:` TC []
      -- if tableEntry*{tableEntry <- tableEntry*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:750.1-754.69
   rule cons: C TC_0 `|-` tableEntry*{tableEntry <- tableEntry*} `:` TC_2 tableEntryIR_h :: tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*}
      -- if tableEntry*{tableEntry <- tableEntry*} matches _ :: _
      -- let tableEntry_h :: tableEntry_t*{tableEntry_t <- tableEntry_t*} = tableEntry*{tableEntry <- tableEntry*}
      -- TableEntry_ok: C TC_0 `|-` tableEntry_h `:` TC_1 tableEntryIR_h
      -- TableEntries_ok: C TC_1 `|-` tableEntry_t*{tableEntry_t <- tableEntry_t*} `:` TC_2 tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:231.1-233.23
relation TableProperty_ok: context tablecontext `|-` tableProperty `:` tablecontext tablePropertyIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:764.1-768.58
   rule key: C TC_0 `|-` tableProperty `:` TC_1 `KEY={` tableKeyIR*{tableKeyIR <- tableKeyIR*} `}`
      -- if tableProperty matches `KEY={%}`
      -- let `KEY={` tableKeyList `}` = tableProperty
      -- let tableKey*{tableKey <- tableKey*} = $flatten_tableKeyList(tableKeyList)
      -- TableKeys_ok: C TC_0 `|-` tableKey*{tableKey <- tableKey*} `:` TC_1 tableKeyIR*{tableKeyIR <- tableKeyIR*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:772.1-776.67
   rule actions: C TC_0 `|-` tableProperty `:` TC_1 `ACTIONS={` tableActionIR*{tableActionIR <- tableActionIR*} `}`
      -- if tableProperty matches `ACTIONS={%}`
      -- let `ACTIONS={` tableActionList `}` = tableProperty
      -- let tableAction*{tableAction <- tableAction*} = $flatten_tableActionList(tableActionList)
      -- TableActions_ok: C TC_0 `|-` tableAction*{tableAction <- tableAction*} `:` TC_1 tableActionIR*{tableActionIR <- tableActionIR*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:780.1-792.65
   rule entries: C TC_0 `|-` tableProperty `:` TC_3 annotationList constOptIR `ENTRIES={` tableEntryIR*{tableEntryIR <- tableEntryIR*} `}`
      -- if tableProperty matches `%%ENTRIES={%}`
      -- let annotationList constOpt `ENTRIES={` tableEntryList `}` = tableProperty
      -- let tableEntry*{tableEntry <- tableEntry*} = $flatten_tableEntryList(tableEntryList)
      -- if ((|TC_0.KEYS| = 0) => (|tableEntry*{tableEntry <- tableEntry*}| = 0))
      -- let TC_1 = TC_0[ENTRIES.SIZE = |tableEntry*{tableEntry <- tableEntry*}|]
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let TC_2 = TC_1[ENTRIES.CONST = (constOptIR = ?(`CONST`))]
      -- TableEntries_ok: C TC_2 `|-` tableEntry*{tableEntry <- tableEntry*} `:` TC_3 tableEntryIR*{tableEntryIR <- tableEntryIR*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:796.1-806.78
   rule custom-default-action: C TC `|-` tableProperty `:` TC tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName initializer `;` = tableProperty
      -- if ("default_action" = $tableCustomName(tableCustomName))
      -- TableDefaultAction_ok: C TC `|-` initializer `:` tableActionReferenceIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR `DEFAULT_ACTION=` tableActionReferenceIR `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:808.1-822.67
   rule custom-size: C TC `|-` tableProperty `:` TC tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName `=` expression `;` = tableProperty
      -- if ("size" = $tableCustomName(tableCustomName))
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR "size" `=` typedExpressionIR `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:824.1-838.84
   rule custom-largest-priority-wins: C TC_0 `|-` tableProperty `:` TC_1 tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName `=` expression `;` = tableProperty
      -- if ("largest_priority_wins" = $tableCustomName(tableCustomName))
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if (typeIR = `BOOL` as typeIR)
      -- Eval_static: `BLOCK` C `|-` typedExpressionIR `~>` value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b_largest_priority_wins = primitiveValue
      -- let TC_1 = TC_0[PRIORITIES.LARGEST_WINS = b_largest_priority_wins]
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR "largest_priority_wins" `=` typedExpressionIR `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:840.1-859.77
   rule custom-priority-delta: C TC_0 `|-` tableProperty `:` TC_1 tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName `=` expression `;` = tableProperty
      -- if ("priority_delta" = $tableCustomName(tableCustomName))
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
      -- Eval_static: `BLOCK` C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n_delta = int as nat
      -- if (n_delta > 0)
      -- let TC_1 = TC_0[PRIORITIES.DELTA = n_delta]
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR "priority_delta" `=` typedExpressionIR `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:861.1-874.67
   rule custom: C TC `|-` tableProperty `:` TC tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName `=` expression `;` = tableProperty
      -- let nameIR = $tableCustomName(tableCustomName)
      -- if (((nameIR =/= "size") /\ (nameIR =/= "largest_priority_wins")) /\ (nameIR =/= "priority_delta"))
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR nameIR `=` typedExpressionIR `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:235.1-237.23
relation TableProperties_ok: context tablecontext `|-` tableProperty* `:` tablecontext tablePropertyListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:882.1-883.23
   rule nil: C TC `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC []
      -- if tableProperty*{tableProperty <- tableProperty*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:885.1-889.78
   rule cons: C TC_0 `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC_2 tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}
      -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
      -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
      -- TableProperty_ok: C TC_0 `|-` tableProperty_h `:` TC_1 tablePropertyIR_h
      -- TableProperties_ok: C TC_1 `|-` tableProperty_t*{tableProperty_t <- tableProperty_t*} `:` TC_2 tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:239.1-241.20
relation Table_ok: context `|-` tableProperty* `:` tablecontext tablePropertyListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:897.1-900.74
   rule : C `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
      -- let TC_0 = $empty_tablecontext
      -- TableProperties_ok: C TC_0 `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:243.1-245.23
relation TableType_ok: context tablecontext `|-` name `:` context typeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:902.1-928.59
   rule : C_0 TC `|-` name `:` C_1 typeIR_table
      -- let nameIR = $name(name)
      -- let tid_enum = "action_list(" ++ nameIR ++ ")"
      -- let (prefixedNameIR_action, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR)*{_argumentListIR <- _argumentListIR*, _parameterTypeIR* <- _parameterTypeIR**, prefixedNameIR_action <- prefixedNameIR_action*} = TC.ACTIONS
      -- (let id_enum_field = $flatten_prefixedNameIR(prefixedNameIR_action))*{id_enum_field <- id_enum_field*, prefixedNameIR_action <- prefixedNameIR_action*}
      -- let typeIR_table_enum = `TABLE_ENUM` tid_enum `{` id_enum_field*{id_enum_field <- id_enum_field*} `}` as typeIR
      -- (let value_enum_field = `TABLE_ENUM` tid_enum `.` id_enum_field as value)*{id_enum_field <- id_enum_field*, value_enum_field <- value_enum_field*}
      -- (let varTypeIR_enum_field = ``EMPTY` typeIR_table_enum `LCTK` ?(value_enum_field))*{value_enum_field <- value_enum_field*, varTypeIR_enum_field <- varTypeIR_enum_field*}
      -- let C_1 = $add_vars(`BLOCK`, C_0, tid_enum ++ "." ++ id_enum_field*{id_enum_field <- id_enum_field*}, varTypeIR_enum_field*{varTypeIR_enum_field <- varTypeIR_enum_field*})
      -- let tid_struct = "apply_result(" ++ nameIR ++ ")"
      -- let typeIR_table_struct = `TABLE_STRUCT` tid_struct `{` [`BOOL` as typeIR "hit" `;`, `BOOL` as typeIR "miss" `;`, typeIR_table_enum "action_run" `;`] `}` as typeIR
      -- let typeIR_table = `TABLE` nameIR `#` typeIR_table_struct as typeIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:247.1-250.20
relation ControlLocalDecl_ok: context `|-` controlLocalDeclaration `:` context controlLocalDeclarationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:9.1-11.75
   rule constantDeclaration: C_0 `|-` controlLocalDeclaration `:` C_1 constantDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: constantDeclaration
      -- let constantDeclaration = controlLocalDeclaration as constantDeclaration
      -- Decl_ok: `BLOCK` C_0 `|-` constantDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:15.1-17.63
   rule instantiation: C_0 `|-` controlLocalDeclaration `:` C_1 instantiationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: instantiation
      -- let instantiation = controlLocalDeclaration as instantiation
      -- Decl_ok: `BLOCK` C_0 `|-` instantiation as declaration `:` C_1 declarationIR
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:23.1-34.44
   rule variableDeclaration-empty: C_0 `|-` controlLocalDeclaration `:` C_1 variableDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = controlLocalDeclaration as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: `BLOCK` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`BLOCK`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() `;`

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:36.1-53.73
   rule variableDeclaration-initializer: C_0 `|-` controlLocalDeclaration `:` C_1 variableDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = controlLocalDeclaration as variableDeclaration
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: `BLOCK` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`BLOCK`, C_0) `|-` typeIR holds
      -- Expr_ok: `BLOCK` C_0 `|-` expression_init `:` typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(`=` typedExpressionIR_init_cast) `;`

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:57.1-59.71
   rule actionDeclaration: C_0 `|-` controlLocalDeclaration `:` C_1 actionDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: actionDeclaration
      -- let actionDeclaration = controlLocalDeclaration as actionDeclaration
      -- Decl_ok: `BLOCK` C_0 `|-` actionDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: actionDeclarationIR
      -- let actionDeclarationIR = declarationIR as actionDeclarationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:65.1-77.58
   rule tableDeclaration: C_0 `|-` controlLocalDeclaration `:` C_2 tableDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: tableDeclaration
      -- let annotationList `TABLE` name `{` tablePropertyList `}` = controlLocalDeclaration as tableDeclaration
      -- let tableProperty*{tableProperty <- tableProperty*} = $flatten_tablePropertyList(tablePropertyList)
      -- Table_ok: C_0 `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
      -- let nameIR = $name(name)
      -- TableType_ok: C_0 TC `|-` name `:` C_1 typeIR_table
      -- let C_2 = $add_var(`BLOCK`, C_1, nameIR, ``EMPTY` typeIR_table `DYN` ?())
      -- let tableDeclarationIR = annotationList `TABLE` nameIR `{` tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} `}`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:252.1-255.20
relation ControlLocalDecls_ok: context `|-` controlLocalDeclaration* `:` context controlLocalDeclarationIR*

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:85.1-86.19
   rule nil: C `|-` controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} `:` C []
      -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches []

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:88.1-94.59
   rule cons: C_0 `|-` controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} `:` C_2 controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}
      -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches _ :: _
      -- let controlLocalDeclaration_h :: controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} = controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}
      -- ControlLocalDecl_ok: C_0 `|-` controlLocalDeclaration_h `:` C_1 controlLocalDeclarationIR_h
      -- ControlLocalDecls_ok: C_1 `|-` controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} `:` C_2 controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:261.1-263.23
relation Decl_ok: cursor context `|-` declaration `:` context declarationIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:9.1-29.57
   rule constantDeclaration: p C_0 `|-` declaration `:` C_1 constantDeclarationIR as declarationIR
      -- if declaration <: constantDeclaration
      -- let annotationList `CONST` type name `=` expression_value `;` = declaration as constantDeclaration
      -- Type_ok: p C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(p, C_0) `|-` typeIR holds
      -- Expr_ok: p C_0 `|-` expression_value `:` typedExpressionIR_value
      -- let _expressionIR `#` `(` _typeIR ctk `)` = typedExpressionIR_value
      -- if ctk matches `LCTK`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_value, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_value_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- Eval_static: p C_0 `|-` typedExpressionIR_value_cast `~>` value
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(p, C_0, nameIR, ``EMPTY` typeIR `LCTK` ?(value))
      -- let constantDeclarationIR = annotationList `CONST` typeIR nameIR `=` value `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:36.1-55.71
   rule instantiation-prefixedTypeName-non-objectInitializer: p C_0 `|-` declaration `:` C_1 instantiationIR as declarationIR
      -- if declaration <: instantiation
      -- let instantiation = declaration as instantiation
      -- if instantiation matches `%%(%)%;`
      -- let annotationList type `(` argumentList `)` name `;` = instantiation
      -- if type <: prefixedTypeName
      -- let prefixedTypeName = type as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- ConstructorType_ok: p C_0 `|-` prefixedNameIR `<` [] `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C_0 `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Inst_ok: p C_0 `|-` constructorTypeIR `<` [] `#` tid_impl*{tid_impl <- tid_impl*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(p, C_0, nameIR, ``EMPTY` typeIR_object `CTK` ?())
      -- let instantiationIR = annotationList prefixedNameIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` nameIR ?() `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:57.1-83.71
   rule instantiation-specializedType-non-objectInitializer: p C_0 `|-` declaration `:` C_1 instantiationIR as declarationIR
      -- if declaration <: instantiation
      -- let instantiation = declaration as instantiation
      -- if instantiation matches `%%(%)%;`
      -- let annotationList type `(` argumentList `)` name `;` = instantiation
      -- if type <: specializedType
      -- let prefixedTypeName `<` typeArgumentList `>` = type as specializedType
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p C_0 `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- ConstructorType_ok: p C_0 `|-` prefixedNameIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_inserted*{tid_inserted <- tid_inserted*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C_0 `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Inst_ok: p C_0 `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(p, C_0, nameIR, ``EMPTY` typeIR_object `CTK` ?())
      -- let instantiationIR = annotationList prefixedNameIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` nameIR ?() `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:184.1-225.98
   rule instantiation-prefixedTypeName-objectInitializer: p C_0 `|-` declaration `:` C_2 instantiationIR as declarationIR
      -- if declaration <: instantiation
      -- let instantiation = declaration as instantiation
      -- if instantiation matches `%%(%)%%;`
      -- let annotationList type `(` argumentList `)` name `={` objectDeclarationList `}` `;` = instantiation
      -- if type <: prefixedTypeName
      -- let prefixedTypeName = type as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- ConstructorType_ok: p C_0 `|-` prefixedNameIR `<` [] `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C_0 `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Inst_ok: p C_0 `|-` constructorTypeIR `<` [] `#` tid_impl*{tid_impl <- tid_impl*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if $is_extern_object_typeIR($canon(typeIR_object))
      -- let typeIR' = typeIR_object
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let typeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid'*{tid' <- tid'*} `>` `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` tid_extern rdenv_extern = typeIR as externObjectTypeIR
      -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
      -- let C_1 = $add_var(`LOCAL`, C_0, "this", ``EMPTY` typeIR_object `CTK` ?())
      -- let objectDeclaration*{objectDeclaration <- objectDeclaration*} = $flatten_objectDeclarationList(objectDeclarationList)
      -- Decls_object_ok: p C_1 `{` [] `}` `{` [] `}` `|-` objectDeclaration*{objectDeclaration <- objectDeclaration*} `:` frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}
      -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
      -- let theta = `{` tid `:` typeIR_arg*{tid <- tid*, typeIR_arg <- typeIR_arg*} `}`
      -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
      -- let typeIR_object_init = `EXTERN` tid_extern rdenv_init_subst as typeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` as typeIR
      -- if $is_concrete_extern_object(typeIR_object_init)
      -- let nameIR = $name(name)
      -- let C_2 = $add_var(p, C_0, nameIR, ``EMPTY` typeIR_object_init `CTK` ?())
      -- let instantiationIR = annotationList prefixedNameIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` nameIR ?(`={` objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*} `}`) `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:227.1-274.98
   rule instantiation-specializedType-objectInitializer: p C_0 `|-` declaration `:` C_2 instantiationIR as declarationIR
      -- if declaration <: instantiation
      -- let instantiation = declaration as instantiation
      -- if instantiation matches `%%(%)%%;`
      -- let annotationList type `(` argumentList `)` name `={` objectDeclarationList `}` `;` = instantiation
      -- if type <: specializedType
      -- let prefixedTypeName `<` typeArgumentList `>` = type as specializedType
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p C_0 `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- ConstructorType_ok: p C_0 `|-` prefixedNameIR `<` [] `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_inserted*{tid_inserted <- tid_inserted*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C_0 `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Inst_ok: p C_0 `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if $is_extern_object_typeIR($canon(typeIR_object))
      -- let typeIR' = typeIR_object
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let typeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid'*{tid' <- tid'*} `>` `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` tid_extern rdenv_extern = typeIR as externObjectTypeIR
      -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
      -- let C_1 = $add_var(`LOCAL`, C_0, "this", ``EMPTY` typeIR_object `CTK` ?())
      -- let objectDeclaration*{objectDeclaration <- objectDeclaration*} = $flatten_objectDeclarationList(objectDeclarationList)
      -- Decls_object_ok: p C_1 `{` [] `}` `{` [] `}` `|-` objectDeclaration*{objectDeclaration <- objectDeclaration*} `:` frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}
      -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
      -- let theta = `{` tid `:` typeIR_arg*{tid <- tid*, typeIR_arg <- typeIR_arg*} `}`
      -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
      -- let typeIR_object_init = `EXTERN` tid_extern rdenv_init_subst as typeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` as typeIR
      -- if $is_concrete_extern_object(typeIR_object_init)
      -- let nameIR = $name(name)
      -- let C_2 = $add_var(p, C_0, nameIR, ``EMPTY` typeIR_object_init `CTK` ?())
      -- let instantiationIR = annotationList prefixedNameIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` nameIR ?(`={` objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*} `}`) `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:282.1-311.27
   rule functionDeclaration: p C_0 `|-` declaration `:` C_4 functionDeclarationIR as declarationIR
      -- if declaration <: functionDeclaration
      -- let annotationList typeOrVoid name typeParameterListOpt `(` parameterList `)` blockStatement = declaration as functionDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`LOCAL`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `LOCAL` C_1 `|-` typeOrVoid `:` typeIR_ret `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `LOCAL` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`LOCAL`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let C_3 = $set_return_type(C_2, typeIR_ret)
      -- Block_ok: C_3 `CONT` `|-` blockStatement `:` _context _flow blockStatementIR
      -- let rid = $rid(name, parameterList)
      -- let functionTypeIR = `FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret
      -- let routineTypeDefIR = functionTypeIR as routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(p, C_0) `|-` routineTypeDefIR holds
      -- let C_4 = $add_routine_overload(p, C_0, rid, routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let functionDeclarationIR = annotationList typeIR_ret nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `)` blockStatementIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:317.1-337.72
   rule actionDeclaration: p C_0 `|-` declaration `:` C_3 actionDeclarationIR as declarationIR
      -- if declaration <: actionDeclaration
      -- let annotationList `ACTION` name `(` parameterList `)` blockStatement = declaration as actionDeclaration
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: p C_0 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_1 = $add_parameters(`LOCAL`, C_0, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let C_2 = $set_return_type(C_1, `VOID` as typeIR)
      -- Block_ok: C_2 `CONT` `|-` blockStatement `:` _context _flow blockStatementIR
      -- let rid = $rid(name, parameterList)
      -- let functionTypeIR = `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- if RoutineTypeDef_wf: $bound(p, C_0) `|-` functionTypeIR as routineTypeDefIR holds
      -- let C_3 = $add_routine_non_overload(p, C_0, rid, functionTypeIR as routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let actionDeclarationIR = annotationList `ACTION` nameIR `(` parameterIR*{parameterIR <- parameterIR*} `)` blockStatementIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:342.1-352.86
   rule errorDeclaration: cursor C_0 `|-` declaration `:` C_1 `ERROR{` nameIR*{nameIR <- nameIR*} `}` as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: errorDeclaration
      -- let `ERROR{` nameList `}` = declaration as errorDeclaration
      -- let name*{name <- name*} = $flatten_nameList(nameList)
      -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
      -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
      -- (let nameIR_error = "error." ++ nameIR)*{nameIR <- nameIR*, nameIR_error <- nameIR_error*}
      -- (let value_error = `ERROR.` nameIR as value)*{nameIR <- nameIR*, value_error <- value_error*}
      -- let C_1 = $add_vars(`GLOBAL`, C_0, nameIR_error*{nameIR_error <- nameIR_error*}, ``EMPTY` `ERROR` as typeIR `LCTK` ?(value_error)*{value_error <- value_error*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:357.1-366.90
   rule matchKindDeclaration: cursor C_0 `|-` declaration `:` C_1 `MATCH_KIND{` nameIR*{nameIR <- nameIR*} `}` as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: matchKindDeclaration
      -- let `MATCH_KIND{` nameList _trailingCommaOpt `}` = declaration as matchKindDeclaration
      -- let name*{name <- name*} = $flatten_nameList(nameList)
      -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
      -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
      -- (let value_match_kind = `MATCH_KIND.` nameIR as value)*{nameIR <- nameIR*, value_match_kind <- value_match_kind*}
      -- let C_1 = $add_vars(`GLOBAL`, C_0, nameIR*{nameIR <- nameIR*}, ``EMPTY` `MATCH_KIND` as typeIR `LCTK` ?(value_match_kind)*{value_match_kind <- value_match_kind*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:375.1-400.79
   rule externDeclaration-externFunctionDeclaration: cursor C_0 `|-` declaration `:` C_3 externFunctionDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: externFunctionDeclaration
      -- let annotationList `EXTERN` typeOrVoid name typeParameterListOpt `(` parameterList `)` `;` = declaration as externFunctionDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`LOCAL`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `LOCAL` C_1 `|-` typeOrVoid `:` typeIR_ret `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `LOCAL` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`LOCAL`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameterList)
      -- let functionTypeIR = `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret
      -- let routineTypeDefIR = functionTypeIR as routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` routineTypeDefIR holds
      -- let C_3 = $add_routine_overload(`GLOBAL`, C_0, rid, routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let externFunctionDeclarationIR = annotationList `EXTERN` typeIR_ret nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `)` `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:428.1-456.73
   rule externDeclaration-externObjectDeclaration: cursor C_0 `|-` declaration `:` C_6 externObjectDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: externObjectDeclaration
      -- let annotationList `EXTERN` nonTypeName typeParameterListOpt `{` methodPrototypeList `}` = declaration as externObjectDeclaration
      -- let methodPrototype*{methodPrototype <- methodPrototype*} = $flatten_methodPrototypeList(methodPrototypeList)
      -- let (methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*}, methodPrototype_method*{methodPrototype_method <- methodPrototype_method*}) = $split_constructors(methodPrototype*{methodPrototype <- methodPrototype*})
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let nameIR = $name(nonTypeName as name)
      -- ExternMethods_ok: C_1 nameIR `|-` methodPrototype_method*{methodPrototype_method <- methodPrototype_method*} `:` C_2 methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}
      -- let typeIR_extern = `EXTERN` nameIR C_2.BLOCK.RDENV as typeIR
      -- let typeDefIR_extern = typeIR_extern `<` tid_expl*{tid_expl <- tid_expl*} `,` [] `>` as typeDefIR
      -- let C_3 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_extern)
      -- let C_4 = $add_types(`BLOCK`, C_3, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- ExternConstructors_ok: C_4 nameIR `|-` methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*} `:` C_5 methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*}
      -- let C_6 = C_3[GLOBAL.CDENV = C_5.GLOBAL.CDENV]
      -- let externObjectDeclarationIR = annotationList `EXTERN` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` [] `>{` methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*} ++ methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:464.1-507.56
   rule parserDeclaration: cursor C_0 `|-` declaration `:` C_4 parserDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: parserDeclaration
      -- let annotationList `PARSER` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` parserLocalDeclarationList parserStateList `}` = declaration as parserDeclaration
      -- if typeParameterListOpt matches ``EMPTY`
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
      -- ConstructorParameters_ok: `BLOCK` C_0 `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let C_1 = $add_parameters(`BLOCK`, C_0, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `BLOCK` C_0 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid'*{tid' <- tid'*}
      -- if tid'*{tid' <- tid'*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`BLOCK`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} = $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
      -- ParserLocalDecls_ok: C_2 `|-` parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} `:` C_3 parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
      -- let parserState*{parserState <- parserState*} = $flatten_parserStateList(parserStateList)
      -- ParserStates_ok: C_3 `|-` parserState*{parserState <- parserState*} `:` parserStateIR*{parserStateIR <- parserStateIR*}
      -- let methodTypeIR = `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- if RoutineTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` methodTypeIR as routineTypeDefIR holds
      -- let cid = $cid(name, constructorParameterListOpt)
      -- let typeIR_parser = `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeIR_parser_spec = typeIR_parser `<` [] `,` [] `>` `<` [] `>` as typeIR
      -- let constructorTypeIR = `CONSTRUCTOR(` constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} `)->` typeIR_parser_spec
      -- let constructorTypeDefIR = constructorTypeIR `<` [] `,` [] `>`
      -- if ConstructorTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` constructorTypeDefIR holds
      -- let C_4 = $add_constructor(C_0, cid, constructorTypeDefIR)
      -- let nameIR = $name(name)
      -- let parserDeclarationIR = annotationList `PARSER` nameIR `<` [] `>(` parameterIR*{parameterIR <- parameterIR*} `)(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:515.1-558.60
   rule controlDeclaration: cursor C_0 `|-` declaration `:` C_5 controlDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: controlDeclaration
      -- let annotationList `CONTROL` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` controlLocalDeclarationList `APPLY` controlBody `}` = declaration as controlDeclaration
      -- if typeParameterListOpt matches ``EMPTY`
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
      -- ConstructorParameters_ok: `BLOCK` C_0 `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let C_1 = $add_parameters(`BLOCK`, C_0, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `BLOCK` C_0 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid'*{tid' <- tid'*}
      -- if tid'*{tid' <- tid'*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`BLOCK`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} = $flatten_controlLocalDeclarationList(controlLocalDeclarationList)
      -- ControlLocalDecls_ok: C_2 `|-` controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} `:` C_3 controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
      -- let C_4 = $set_return_type(C_3, `VOID` as typeIR)
      -- Block_ok: C_4 `CONT` `|-` controlBody `:` _context _flow controlBodyIR
      -- let methodTypeIR = `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- if RoutineTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` methodTypeIR as routineTypeDefIR holds
      -- let cid = $cid(name, constructorParameterListOpt)
      -- let typeIR_control = `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeIR_control_spec = typeIR_control `<` [] `,` [] `>` `<` [] `>` as typeIR
      -- let constructorTypeIR = `CONSTRUCTOR(` constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} `)->` typeIR_control_spec
      -- let constructorTypeDefIR = constructorTypeIR `<` [] `,` [] `>`
      -- if ConstructorTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` constructorTypeDefIR holds
      -- let C_5 = $add_constructor(C_0, cid, constructorTypeDefIR)
      -- let nameIR = $name(name)
      -- let controlDeclarationIR = annotationList `CONTROL` nameIR `<` [] `>(` parameterIR*{parameterIR <- parameterIR*} `)(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} `APPLY` controlBodyIR `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:571.1-588.54
   rule typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 enumTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: enumTypeDeclaration
      -- let enumTypeDeclaration = declaration as enumTypeDeclaration
      -- if enumTypeDeclaration matches `%ENUM%{%%}`
      -- let annotationList `ENUM` name `{` nameList_field _trailingCommaOpt `}` = enumTypeDeclaration
      -- let nameIR = $name(name)
      -- let name_field*{name_field <- name_field*} = $flatten_nameList(nameList_field)
      -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
      -- let typeIR_enum = `ENUM` nameIR `{` nameIR_field*{nameIR_field <- nameIR_field*} `}` as typeIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeIR_enum as typeDefIR holds
      -- let C_1 = $add_type(`GLOBAL`, C_0, nameIR, typeIR_enum as typeDefIR)
      -- (let id_field = nameIR ++ "." ++ nameIR_field)*{id_field <- id_field*, nameIR_field <- nameIR_field*}
      -- (let value_field = nameIR `.` nameIR_field as value)*{nameIR_field <- nameIR_field*, value_field <- value_field*}
      -- let C_2 = $add_vars(`GLOBAL`, C_1, id_field*{id_field <- id_field*}, ``EMPTY` typeIR_enum `LCTK` ?(value_field)*{value_field <- value_field*})
      -- let enumTypeDeclarationIR = annotationList `ENUM` nameIR `{` nameIR_field*{nameIR_field <- nameIR_field*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:634.1-657.72
   rule typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable: cursor C_0 `|-` declaration `:` C_3 enumTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: enumTypeDeclaration
      -- let enumTypeDeclaration = declaration as enumTypeDeclaration
      -- if enumTypeDeclaration matches `%ENUM%%{%%}`
      -- let annotationList `ENUM` type name `{` namedExpressionList_field _trailingCommaOpt `}` = enumTypeDeclaration
      -- Type_ok: `GLOBAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`GLOBAL`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let namedExpression_field*{namedExpression_field <- namedExpression_field*} = $flatten_namedExpressionList(namedExpressionList_field)
      -- Enum_serializable_fields_ok: C_0 nameIR typeIR `|-` namedExpression_field*{namedExpression_field <- namedExpression_field*} `:` C_1 namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*} `#` value_field*{value_field <- value_field*}
      -- (let nameIR_field `=` _typedExpressionIR = namedExpressionIR_field)*{_typedExpressionIR <- _typedExpressionIR*, nameIR_field <- nameIR_field*, namedExpressionIR_field <- namedExpressionIR_field*}
      -- (let id_field = nameIR ++ "." ++ nameIR_field)*{id_field <- id_field*, nameIR_field <- nameIR_field*}
      -- let typeIR_enum = `ENUM` nameIR `#` typeIR `{` nameIR_field `=` value_field `;`*{nameIR_field <- nameIR_field*, value_field <- value_field*} `}` as typeIR
      -- let C_2 = $add_vars(`GLOBAL`, C_0, id_field*{id_field <- id_field*}, ``EMPTY` typeIR_enum `LCTK` ?(value_field)*{value_field <- value_field*})
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeIR_enum as typeDefIR holds
      -- let C_3 = $add_type(`GLOBAL`, C_2, nameIR, typeIR_enum as typeDefIR)
      -- let enumTypeDeclarationIR = annotationList `ENUM` typeIR nameIR `{` namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:663.1-685.66
   rule typeDeclaration-derivedTypeDeclaration-structTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 structTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: structTypeDeclaration
      -- let annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}` = declaration as structTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let annotationList_field type_field name_field `;`*{annotationList_field <- annotationList_field*, name_field <- name_field*, type_field <- type_field*} = $flatten_typeFieldList(typeFieldList)
      -- (Type_ok: `BLOCK` C_1 `|-` type_field as typeOrVoid `:` typeIR_field `#` tid_impl_field*{tid_impl_field <- tid_impl_field*})*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**})
      -- let nameIR = $name(name)
      -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
      -- let typeIR_struct = `STRUCT` nameIR `{` typeIR_field nameIR_field `;`*{nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} `}` as typeIR
      -- let typeDefIR_struct = typeIR_struct `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_struct holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_struct)
      -- let structTypeDeclarationIR = annotationList `STRUCT` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>{` annotationList_field typeIR_field nameIR_field `;`*{annotationList_field <- annotationList_field*, nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:691.1-713.54
   rule typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 headerTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: headerTypeDeclaration
      -- let annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}` = declaration as headerTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let annotationList_f type_f name_f `;`*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
      -- (Type_ok: `BLOCK` C_1 `|-` type_f as typeOrVoid `:` typeIR_f `#` tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
      -- let nameIR = $name(name)
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let typeIR_header = `HEADER` nameIR `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` as typeIR
      -- let typeDefIR_header = typeIR_header `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_header holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_header)
      -- let headerTypeDeclarationIR = annotationList `HEADER` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>{` annotationList_f typeIR_f nameIR_f `;`*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:719.1-741.54
   rule typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 headerUnionTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: headerUnionTypeDeclaration
      -- let annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}` = declaration as headerUnionTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let annotationList_f type_f name_f `;`*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
      -- (Type_ok: `BLOCK` C_1 `|-` type_f as typeOrVoid `:` typeIR_f `#` tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
      -- let nameIR = $name(name)
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let typeIR_union = `HEADER_UNION` nameIR `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` as typeIR
      -- let typeDefIR_union = typeIR_union `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_union holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_union)
      -- let headerUnionTypeDeclarationIR = annotationList `HEADER_UNION` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>{` annotationList_f typeIR_f nameIR_f `;`*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:751.1-764.48
   rule typeDeclaration-typedefDeclaration-typedef-type: cursor C_0 `|-` declaration `:` C_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPEDEF%%;`
      -- let annotationList `TYPEDEF` typedefType name `;` = typedefDeclaration
      -- if typedefType <: type
      -- let type = typedefType as type
      -- Type_ok: `GLOBAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`GLOBAL`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let typeIR_typedef = `TYPEDEF` nameIR typeIR as typeIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeIR_typedef as typeDefIR holds
      -- let C_1 = $add_type(`GLOBAL`, C_0, nameIR, typeIR_typedef as typeDefIR)
      -- let typedefDeclarationIR = annotationList `TYPEDEF` typeIR as typedefTypeIR nameIR `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:768.1-786.66
   rule typeDeclaration-typedefDeclaration-typedef-derivedTypeDeclaration-mono: cursor C_0 `|-` declaration `:` C_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPEDEF%%;`
      -- let annotationList `TYPEDEF` typedefType name `;` = typedefDeclaration
      -- if typedefType <: derivedTypeDeclaration
      -- let derivedTypeDeclaration = typedefType as derivedTypeDeclaration
      -- Decl_ok: `GLOBAL` C_0 `|-` derivedTypeDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
      -- let `{` tid'*{tid' <- tid'*} `}` = $diff_set<tid>($dom_map<tid, typeDefIR>(C_1.GLOBAL.TDENV), $dom_map<tid, typeDefIR>(C_0.GLOBAL.TDENV))
      -- if tid'*{tid' <- tid'*} matches [ _/1 ]
      -- let [tid] = tid'*{tid' <- tid'*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(`GLOBAL`, C_1, ``` tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- let nameIR = $name(name)
      -- let typeIR_typedef = `TYPEDEF` nameIR typeIR as typeIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeIR_typedef as typeDefIR holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeIR_typedef as typeDefIR)
      -- let typedefDeclarationIR = annotationList `TYPEDEF` derivedTypeDeclarationIR as typedefTypeIR nameIR `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:788.1-806.66
   rule typeDeclaration-typedefDeclaration-typedef-derivedTypeDeclaration-poly: cursor C_0 `|-` declaration `:` C_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPEDEF%%;`
      -- let annotationList `TYPEDEF` typedefType name `;` = typedefDeclaration
      -- if typedefType <: derivedTypeDeclaration
      -- let derivedTypeDeclaration = typedefType as derivedTypeDeclaration
      -- Decl_ok: `GLOBAL` C_0 `|-` derivedTypeDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
      -- let `{` tid'*{tid' <- tid'*} `}` = $diff_set<tid>($dom_map<tid, typeDefIR>(C_1.GLOBAL.TDENV), $dom_map<tid, typeDefIR>(C_0.GLOBAL.TDENV))
      -- if tid'*{tid' <- tid'*} matches [ _/1 ]
      -- let [tid] = tid'*{tid' <- tid'*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(`GLOBAL`, C_1, ``` tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR `<` tid''*{tid'' <- tid''*} `,` tid'''*{tid''' <- tid'''*} `>` = typeDefIR as polyTypeDefIR
      -- if tid''*{tid'' <- tid''*} matches []
      -- if tid'''*{tid''' <- tid'''*} matches []
      -- let nameIR = $name(name)
      -- let typeIR_typedef = `TYPEDEF` nameIR typeIR `<` [] `,` [] `>` `<` [] `>` as typeIR as typeIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeIR_typedef as typeDefIR holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeIR_typedef as typeDefIR)
      -- let typedefDeclarationIR = annotationList `TYPEDEF` derivedTypeDeclarationIR as typedefTypeIR nameIR `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:810.1-823.45
   rule typeDeclaration-typedefDeclaration-newtype: cursor C_0 `|-` declaration `:` C_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPE%%;`
      -- let annotationList `TYPE` type name `;` = typedefDeclaration
      -- Type_ok: `GLOBAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`GLOBAL`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let typeIR_newtype = `TYPE` nameIR typeIR as typeIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeIR_newtype as typeDefIR holds
      -- let C_1 = $add_type(`GLOBAL`, C_0, nameIR, typeIR_newtype as typeDefIR)
      -- let typedefDeclarationIR = annotationList `TYPE` typeIR nameIR `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:829.1-848.86
   rule typeDeclaration-parserTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 parserTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: parserTypeDeclaration
      -- let annotationList `PARSER` name typeParameterListOpt `(` parameterList `);` = declaration as parserTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `BLOCK` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let nameIR = $name(name)
      -- let typeIR_parser = `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeDefIR_parser = typeIR_parser `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_parser holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_parser)
      -- let parserTypeDeclarationIR = annotationList `PARSER` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `);`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:854.1-873.87
   rule typeDeclaration-controlTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 controlTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: controlTypeDeclaration
      -- let annotationList `CONTROL` name typeParameterListOpt `(` parameterList `);` = declaration as controlTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `BLOCK` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let nameIR = $name(name)
      -- let typeIR_control = `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeDefIR_control = typeIR_control `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_control holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_control)
      -- let controlTypeDeclarationIR = annotationList `CONTROL` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `);`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:879.1-911.40
   rule typeDeclaration-packageTypeDeclaration: cursor C_0 `|-` declaration `:` C_3 packageTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: packageTypeDeclaration
      -- let annotationList `PACKAGE` name typeParameterListOpt `(` parameterList `);` = declaration as packageTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
      -- ConstructorParameters_ok: `BLOCK` C_1 `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let nameIR = $name(name)
      -- (let _direction typeIR_package_inner _id _value?{_value <- _value?} = constructorParameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, constructorParameterTypeIR <- constructorParameterTypeIR*, typeIR_package_inner <- typeIR_package_inner*}
      -- let typeIR_package = `PACKAGE<` typeIR_package_inner*{typeIR_package_inner <- typeIR_package_inner*} `>` as typeIR
      -- let polyTypeDefIR_package = typeIR_package `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>`
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` polyTypeDefIR_package as typeDefIR holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, polyTypeDefIR_package as typeDefIR)
      -- let cid = $cid(name, `(` parameterList `)`)
      -- let typeIR_package_spec = polyTypeDefIR_package `<` `TID` tid_expl as typeIR*{tid_expl <- tid_expl*} ++ `TID` tid_impl as typeIR*{tid_impl <- tid_impl*} `>` as typeIR
      -- let constructorTypeIR = `CONSTRUCTOR(` constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} `)->` typeIR_package_spec
      -- let constructorTypeDefIR = constructorTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>`
      -- if ConstructorTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` constructorTypeDefIR holds
      -- let C_3 = $add_constructor(C_2, cid, constructorTypeDefIR)
      -- let packageTypeDeclarationIR = annotationList `PACKAGE` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `);`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:265.1-267.23
relation Decls_ok: cursor context `|-` declaration* `:` context declarationIR*

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:917.1-918.21
   rule nil: p C `|-` declaration*{declaration <- declaration*} `:` C []
      -- if declaration*{declaration <- declaration*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:920.1-924.62
   rule cons: p C_0 `|-` declaration*{declaration <- declaration*} `:` C_2 declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*}
      -- if declaration*{declaration <- declaration*} matches _ :: _
      -- let declaration_h :: declaration_t*{declaration_t <- declaration_t*} = declaration*{declaration <- declaration*}
      -- Decl_ok: p C_0 `|-` declaration_h `:` C_1 declarationIR_h
      -- Decls_ok: p C_1 `|-` declaration_t*{declaration_t <- declaration_t*} `:` C_2 declarationIR_t*{declarationIR_t <- declarationIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:269.1-271.17
relation Program_ok: `|-` p4program `:` context p4programIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:930.1-934.63
   rule : `|-` p4program `:` C_1 declarationIR*{declarationIR <- declarationIR*} `;`
      -- let declaration*{declaration <- declaration*} = $flatten_p4program(p4program)
      -- let C_0 = $empty_context
      -- Decls_ok: `GLOBAL` C_0 `|-` declaration*{declaration <- declaration*} `:` C_1 declarationIR*{declarationIR <- declarationIR*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:281.1-284.29
relation FunctionType_ok: cursor context `|-` prefixedNameIR `<` typeArgumentListIR `>(` argument* `):` functionTypeIR `<#` tid* `>(#` id* `)`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:290.1-293.32
relation MethodType_ok: cursor context `|-` typedExpressionIR `.` nameIR `<` typeArgumentListIR `>(` argument* `):` methodTypeIR `<#` tid* `>(#` id* `)`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:299.1-301.23
relation RoutineTarget_ok: cursor context `|-` routineTarget `:` routineTargetIR

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:12.1-14.67
   rule prefixedNonTypeName: p C `|-` routineTarget `:` prefixedNameIR as routineTargetIR
      -- if routineTarget <: prefixedNonTypeName
      -- let prefixedNonTypeName = routineTarget as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:18.1-19.28
   rule this: p C `|-` routineTarget `:` ``` "this" as routineTargetIR
      -- if (routineTarget = `THIS` as routineTarget)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:27.1-30.31
   rule memberAccessExpression-prefixedTypeName: p C `|-` routineTarget `:` `TYPE` prefixedNameIR `.` nameIR
      -- if routineTarget <: memberAccessExpression
      -- let memberAccessBase `.` member = routineTarget as memberAccessExpression
      -- if memberAccessBase <: prefixedTypeName
      -- let prefixedTypeName = memberAccessBase as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let nameIR = $name(member)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:34.1-37.62
   rule memberAccessExpression-expression: p C `|-` routineTarget `:` typedExpressionIR_base `.` nameIR
      -- if routineTarget <: memberAccessExpression
      -- let memberAccessBase `.` member = routineTarget as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- let nameIR = $name(member)
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:41.1-43.59
   rule parenthesizedExpression: p C `|-` routineTarget `:` `(` routineTargetIR `)`
      -- if routineTarget <: parenthesizedExpression
      -- let `(` expression `)` = routineTarget as parenthesizedExpression
      -- RoutineTarget_ok: p C `|-` expression `:` routineTargetIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:303.1-305.23
relation RoutineTarget_lvalue_ok: cursor context `|-` lvalue `:` routineTargetIR

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:65.1-68.59
   rule : p C `|-` lvalue `:` routineTargetIR
      -- let expression = $lvalue(lvalue)
      -- RoutineTarget_ok: p C `|-` expression `:` routineTargetIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:307.1-310.29
relation RoutineType_ok: cursor context `|-` routineTargetIR `<` typeArgumentListIR `>(` argument* `):` routineTypeIR `<#` tid* `>(#` id* `)`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:79.1-85.70
   rule referenceExpressionIR: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` functionTypeIR as routineTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- if routineTargetIR <: prefixedNameIR
      -- let prefixedNameIR = routineTargetIR as prefixedNameIR
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_routine_overloaded(p, C, prefixedNameIR, argument*{argument <- argument*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- if (routineTypeDefIR, tid*) <: (functionTypeIR, tid*)
      -- let (functionTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (functionTypeIR, tid*)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:89.1-95.55
   rule typedExpressionIR-nameIR-builtin-method-minmax-SizeIn-BitsBytes: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` [] `)`
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argument*{argument <- argument*} matches []
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
      -- let methodTypeIR = `BUILTIN_METHOD(` [] `)->` `INT` as typeIR

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:97.1-108.67
   rule typedExpressionIR-nameIR-builtin-method-stack-push-pop-front: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument'*{argument' <- argument'*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` [] `)`
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argument'*{argument' <- argument'*} matches [ _/1 ]
      -- let [argument] = argument'*{argument' <- argument'*}
      -- if nameIR <- ["push_front", "pop_front"]
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR
      -- let parameterTypeIR = ``EMPTY` `INT` as typeIR "count" ?()
      -- let methodTypeIR = `BUILTIN_METHOD(` [parameterTypeIR] `)->` `INT` as typeIR

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:110.1-119.56
   rule typedExpressionIR-nameIR-builtin-method-header-isValid: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` [] `)`
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argument*{argument <- argument*} matches []
      -- if nameIR <- ["isValid"]
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR
      -- let methodTypeIR = `BUILTIN_METHOD(` [] `)->` `BOOL` as typeIR

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:121.1-130.56
   rule typedExpressionIR-nameIR-builtin-method-union-isValid: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` [] `)`
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argument*{argument <- argument*} matches []
      -- if nameIR <- ["isValid"]
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR
      -- let methodTypeIR = `BUILTIN_METHOD(` [] `)->` `BOOL` as typeIR

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:132.1-141.56
   rule typedExpressionIR-nameIR-builtin-method-header-set-ValidInvalid: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` [] `)`
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argument*{argument <- argument*} matches []
      -- if nameIR <- ["setValid", "setInvalid"]
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR
      -- let methodTypeIR = `BUILTIN_METHOD(` [] `)->` `VOID` as typeIR

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:143.1-158.70
   rule typedExpressionIR-nameIR-extern-method: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` nameIR = routineTargetIR
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid `{` rid_f `:` routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} `}` = typeIR as externObjectTypeIR
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(`{` rid_f `:` routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} `}`, nameIR, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- if (routineTypeDefIR, tid*) <: (routineTypeIR, tid*)
      -- let (routineTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (routineTypeIR, tid*)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:160.1-178.22
   rule typedExpressionIR-nameIR-parser-apply-method: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` id_default*{id_default <- id_default*} `)`
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` text = routineTargetIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as parserObjectTypeIR
      -- let methodTypeIR = `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
      -- (let pid = id_param `#` (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
      -- let rid = "apply" `(` pid*{pid <- pid*} `)`
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>(`{` [rid `:` methodTypeIR as routineTypeDefIR] `}`, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
      -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
      -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
      -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
      -- if (rid' = rid)
      -- if (methodTypeIR' = methodTypeIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:180.1-198.22
   rule typedExpressionIR-nameIR-control-apply-method: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` id_default*{id_default <- id_default*} `)`
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` text = routineTargetIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as controlObjectTypeIR
      -- let methodTypeIR = `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
      -- (let pid = id_param `#` (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
      -- let rid = "apply" `(` pid*{pid <- pid*} `)`
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>(`{` [rid `:` methodTypeIR as routineTypeDefIR] `}`, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
      -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
      -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
      -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
      -- if (rid' = rid)
      -- if (methodTypeIR' = methodTypeIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:200.1-207.52
   rule typedExpressionIR-nameIR-table-apply-method: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` [] `)`
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR_base `.` text = routineTargetIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argument*{argument <- argument*} matches []
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` typeIR_table = typeIR as tableObjectTypeIR
      -- let methodTypeIR = `TABLE_APPLY->` typeIR_table

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:213.1-217.84
   rule parenthesized: p C `|-` routineTargetIR' `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_inserted*{tid_inserted <- tid_inserted*} `>(#` id_default*{id_default <- id_default*} `)`
      -- if routineTargetIR' matches `(%)`
      -- let `(` routineTargetIR `)` = routineTargetIR'
      -- RoutineType_ok: p C `|-` routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_inserted*{tid_inserted <- tid_inserted*} `>(#` id_default*{id_default <- id_default*} `)`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:320.1-323.29
relation ConstructorType_ok: cursor context `|-` prefixedNameIR `<` typeArgumentListIR `>(` argument* `):` constructorTypeIR `<#` tid* `>(#` id* `)`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:5.1-11.78
   rule : p C `|-` prefixedNameIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- let (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} = $find_constructor_overloaded(C, prefixedNameIR, argument*{argument <- argument*})
      -- if (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} matches (_)
      -- let ?((cid, constructorTypeDefIR, id_default*{id_default <- id_default*})) = (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?}
      -- let (constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}) = $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:333.18-333.35
syntax actctxt = 
   | `ACTION`
   | `NOACTION`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:335.1-338.29
relation Call_convention_expr_ok: cursor context actctxt `|-` parameterTypeIR `@` typedExpressionIR `:` typedExpressionIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:51.1-56.59
   rule in: p C actctxt `|-` direction typeIR_param _id _value?{_value <- _value?} `@` typedExpressionIR_arg `:` typedExpressionIR_arg_cast
      -- if direction matches `IN`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:60.1-68.7
   rule out-inout: p C actctxt `|-` direction typeIR_param _id _value?{_value <- _value?} `@` typedExpressionIR_arg `:` typedExpressionIR_arg
      -- if ((direction = `OUT`) \/ (direction = `INOUT`))
      -- let _expressionIR `#` `(` typeIR_arg _ctk `)` = typedExpressionIR_arg
      -- if Type_alpha: typeIR_param `~~` typeIR_arg holds

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:72.1-77.59
   rule empty-action: p C actctxt `|-` direction typeIR_param _id _value?{_value <- _value?} `@` typedExpressionIR_arg `:` typedExpressionIR_arg_cast
      -- if actctxt matches `ACTION`
      -- if direction matches ``EMPTY`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:79.1-86.24
   rule empty-not-action: p C actctxt `|-` direction typeIR_param _id _value?{_value <- _value?} `@` typedExpressionIR_arg `:` typedExpressionIR_arg
      -- if actctxt matches `NOACTION`
      -- if direction matches ``EMPTY`
      -- let _expressionIR `#` `(` typeIR_arg ctk_arg `)` = typedExpressionIR_arg
      -- if Type_alpha: typeIR_param `~~` typeIR_arg holds
      -- if (ctk_arg =/= `DYN`)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:340.1-343.29
relation Call_convention_argument_ok: cursor context actctxt `|-` parameterTypeIR `@` argumentIR `:` argumentIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:92.1-97.44
   rule typedExpression: p C actctxt `|-` parameterTypeIR `@` argumentIR `:` typedExpressionIR_cast as argumentIR
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR
      -- Call_convention_expr_ok: p C actctxt `|-` parameterTypeIR `@` typedExpressionIR `:` typedExpressionIR_cast

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:101.1-106.44
   rule nameIR-typedExpression: p C actctxt `|-` parameterTypeIR `@` argumentIR `:` nameIR `=` typedExpressionIR_cast
      -- if argumentIR matches `%=%`
      -- let nameIR `=` typedExpressionIR = argumentIR
      -- Call_convention_expr_ok: p C actctxt `|-` parameterTypeIR `@` typedExpressionIR `:` typedExpressionIR_cast

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:110.1-113.36
   rule nameIR-dontcare: p C actctxt `|-` parameterTypeIR `@` argumentIR `:` nameIR `=_`
      -- if argumentIR matches `%=_`
      -- let nameIR `=_` = argumentIR
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
      -- if direction matches `OUT`

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:117.1-119.36
   rule dontcare: p C actctxt `|-` parameterTypeIR `@` argumentIR `:` `_`
      -- if argumentIR matches `_`
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
      -- if direction matches `OUT`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:345.1-348.29
relation Call_convention_ok: cursor context actctxt `|-` parameterTypeIR* `@` argumentListIR `:` argumentListIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:125.1-126.34
   rule nil: p C actctxt `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` []
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:128.1-137.40
   rule cons: p C actctxt `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_h_cast :: argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
      -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
      -- Call_convention_argument_ok: p C actctxt `|-` parameterTypeIR_h `@` argumentIR_h `:` argumentIR_h_cast
      -- Call_convention_ok: p C actctxt `|-` parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} `@` argumentIR_t*{argumentIR_t <- argumentIR_t*} `:` argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:355.1-359.35
relation Call_ok: cursor context `|-` routineTypeIR `<` typeArgumentListIR `#` tid* `>(` argumentListIR `#` id* `):` typeIR `<` typeArgumentListIR `>(` argumentListIR `)`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:228.1-243.39
   rule builtin-function: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:247.1-262.39
   rule function-noinfer: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:264.1-292.39
   rule function-infer: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret_inferred `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let functionTypeIR_inferred = `FUNCTION(` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `)->` typeIR_ret_inferred
      -- if RoutineType_wf: $bound(p, C) `|-` functionTypeIR_inferred as routineTypeIR holds
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:296.1-310.37
   rule action: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` `VOID` as typeIR `<` [] `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `ACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:314.1-329.39
   rule externfunction-noinfer: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:331.1-359.39
   rule externfunction-infer: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret_inferred `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let functionTypeIR_inferred = `EXTERN_FUNCTION(` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `)->` typeIR_ret_inferred
      -- if RoutineType_wf: $bound(p, C) `|-` functionTypeIR_inferred as routineTypeIR holds
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:366.1-381.39
   rule builtin-method: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:385.1-413.39
   rule extern-method-infer: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret_inferred `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let methodTypeIR_inferred = `EXTERN_METHOD(` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `)->` typeIR_ret_inferred
      -- if RoutineType_wf: $bound(p, C) `|-` methodTypeIR_inferred as routineTypeIR holds
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:417.1-445.39
   rule extern-abstract-method-infer: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret_inferred `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let methodTypeIR_inferred = `EXTERN_METHODABSTRACT(` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `)->` typeIR_ret_inferred
      -- if RoutineType_wf: $bound(p, C) `|-` methodTypeIR_inferred as routineTypeIR holds
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:449.1-464.39
   rule parser-apply-method: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` `VOID` as typeIR `<` [] `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:468.1-483.39
   rule control-apply-method: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` `VOID` as typeIR `<` [] `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:487.1-489.41
   rule table-apply-method: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id*{id <- id*} `):` typeIR_table `<` [] `>(` [] `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_table = methodTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if id*{id <- id*} matches []

;; ../../../../spec-concrete/5.04-typing-relation.watsup:366.1-370.35
relation Inst_ok: cursor context `|-` constructorTypeIR `<` typeArgumentListIR `#` tid* `>(` argumentListIR `#` id* `):` typeIR `<` typeArgumentListIR `>(` argumentListIR `)`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:19.1-37.45
   rule package-no-infer: cursor C_0 `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if cursor matches `GLOBAL`
      -- if tid*{tid <- tid*} matches []
      -- let `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- let typeIR = $canon(typeIR_object)
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: `BLOCK` C_0 `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:39.1-71.43
   rule package-infer: cursor C `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object_inferred `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if cursor matches `GLOBAL`
      -- let `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- let typeIR = $canon(typeIR_object)
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR'?{typeIR' <- typeIR'?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR'? <- typeIR'?*}
      -- (if typeIR'?{typeIR' <- typeIR'?} matches (_))*{typeIR'? <- typeIR'?*}
      -- (let ?(typeIR_inferred) = typeIR'?{typeIR' <- typeIR'?})*{typeIR'? <- typeIR'?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
      -- let constructorTypeIR_inferred = `CONSTRUCTOR(` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `)->` typeIR_object_inferred
      -- if ConstructorType_wf: $bound(`GLOBAL`, C) `|-` constructorTypeIR_inferred holds
      -- Call_convention_ok: `BLOCK` C `NOACTION` `|-` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:75.1-93.39
   rule no-package-no-infer: p C `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if tid*{tid <- tid*} matches []
      -- let `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- if ~$is_package_object_typeIR($canon(typeIR_object))
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:95.1-126.39
   rule no-package-infer: p C `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- if ~$is_package_object_typeIR($canon(typeIR_object))
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
      -- let constructorTypeIR_inferred = `CONSTRUCTOR(` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `)->` typeIR_object_inferred
      -- if ConstructorType_wf: $bound(p, C) `|-` constructorTypeIR_inferred holds
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../spec-concrete/5.05.2-subtype.watsup:342.1-346.23
def $reduce_serenum_unary(typedExpressionIR, $check(typeIR) : bool) : typedExpressionIR? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:349.1-352.23
   clause 0(typedExpressionIR, $check) = ?(typedExpressionIR)
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if $check(typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:354.1-360.79
   clause 1(typedExpressionIR, $check) = $reduce_serenum_unary(typedExpressionIR_cast, $check)
      -- let _expressionIR `#` `(` typeIR ctk `)` = typedExpressionIR
      -- if ~$check(typeIR)
      -- let typeIR' = typeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_underlying `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- let typedExpressionIR_cast = `(` typeIR_underlying `)` typedExpressionIR as expressionIR `#` `(` typeIR_underlying ctk `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:362.1-363.15
   clause 2(typedExpressionIR, $check) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:367.1-372.44
def $reduce_serenum_binary(typedExpressionIR, typedExpressionIR, $check(typeIR, typeIR) : bool) : (typedExpressionIR, typedExpressionIR)? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:374.1-378.35
   clause 0(typedExpressionIR_l, typedExpressionIR_r, $check) = ?((typedExpressionIR_l, typedExpressionIR_r))
      -- let _expressionIR `#` `(` typeIR_l _ctk `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r _ctk' `)` = typedExpressionIR_r
      -- if $check(typeIR_l, typeIR_r)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:380.1-388.87
   clause 1(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)
      -- let _expressionIR `#` `(` typeIR_l ctk_l `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r _ctk `)` = typedExpressionIR_r
      -- if ~$check(typeIR_l, typeIR_r)
      -- let typeIR = typeIR_l
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_l_underlying `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- let typedExpressionIR_l_cast = `(` typeIR_l_underlying `)` typedExpressionIR_l as expressionIR `#` `(` typeIR_l_underlying ctk_l `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:390.1-398.87
   clause 2(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)
      -- let _expressionIR `#` `(` typeIR_l _ctk `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r ctk_r `)` = typedExpressionIR_r
      -- if ~$check(typeIR_l, typeIR_r)
      -- let typeIR = typeIR_r
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_r_underlying `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- let typedExpressionIR_r_cast = `(` typeIR_r_underlying `)` typedExpressionIR_r as expressionIR `#` `(` typeIR_r_underlying ctk_r `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:400.1-401.15
   clause 3(typedExpressionIR_l, typedExpressionIR_r, $check) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:412.1-412.66
def $coerce_unary(typedExpressionIR, typeIR) : typedExpressionIR? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:414.1-416.37
   clause 0(typedExpressionIR, typeIR_to) = ?(typedExpressionIR)
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if Type_alpha: typeIR `~~` typeIR_to holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:418.1-423.63
   clause 1(typedExpressionIR, typeIR_to) = ?(typedExpressionIR_cast)
      -- let _expressionIR `#` `(` typeIR ctk `)` = typedExpressionIR
      -- if ~Type_alpha: typeIR `~~` typeIR_to holds
      -- if Sub_impl: typeIR `<:` typeIR_to holds
      -- let typedExpressionIR_cast = `(` typeIR_to `)` typedExpressionIR as expressionIR `#` `(` typeIR_to ctk `)`

;; ../../../../spec-concrete/5.05.2-subtype.watsup:427.1-428.44
def $coerce_binary(typedExpressionIR, typedExpressionIR) : (typedExpressionIR, typedExpressionIR)? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:430.1-434.38
   clause 0(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r))
      -- let _expressionIR `#` `(` typeIR_l _ctk `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r _ctk' `)` = typedExpressionIR_r
      -- if Type_alpha: typeIR_l `~~` typeIR_r holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:436.1-443.65
   clause 1(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l_cast, typedExpressionIR_r))
      -- let _expressionIR `#` `(` typeIR_l ctk_l `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r _ctk `)` = typedExpressionIR_r
      -- if ~Type_alpha: typeIR_l `~~` typeIR_r holds
      -- if Sub_impl: typeIR_l `<:` typeIR_r holds
      -- let typedExpressionIR_l_cast = `(` typeIR_r `)` typedExpressionIR_l as expressionIR `#` `(` typeIR_r ctk_l `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:445.1-453.65
   clause 2(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r_cast))
      -- let _expressionIR `#` `(` typeIR_l _ctk `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r ctk_r `)` = typedExpressionIR_r
      -- if ~Type_alpha: typeIR_l `~~` typeIR_r holds
      -- if ~Sub_impl: typeIR_l `<:` typeIR_r holds
      -- if Sub_impl: typeIR_r `<:` typeIR_l holds
      -- let typedExpressionIR_r_cast = `(` typeIR_l `)` typedExpressionIR_r as expressionIR `#` `(` typeIR_l ctk_r `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:455.1-456.15
   clause 3(typedExpressionIR_l, typedExpressionIR_r) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:69.1-69.32
def $compat_lnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:72.1-72.57
   clause 0(typeIR) = $compat'_lnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:70.1-70.33
def $compat'_lnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:73.1-73.31
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:74.1-75.14
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:90.1-90.32
def $compat_bnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:93.1-93.57
   clause 0(typeIR) = $compat'_bnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:91.1-91.33
def $compat'_bnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:94.1-94.37
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:95.1-95.37
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:96.1-97.15
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:112.1-112.38
def $compat_uplusminus(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:115.1-115.69
   clause 0(typeIR) = $compat'_uplusminus($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:113.1-113.39
def $compat'_uplusminus(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:116.1-116.36
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:117.1-117.43
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:118.1-118.43
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:119.1-120.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:138.1-138.49
def $compat_plusminusmult(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:141.1-142.63
   clause 0(typeIR_l, typeIR_r) = $compat'_plusminusmult($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:139.1-139.50
def $compat'_plusminusmult(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:143.1-143.44
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:144.1-144.58
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:145.1-145.58
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:146.1-147.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:175.1-175.48
def $compat_satplusminus(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:178.1-179.62
   clause 0(typeIR_l, typeIR_r) = $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:176.1-176.49
def $compat'_satplusminus(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:180.1-180.57
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:181.1-181.57
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:182.1-183.15
   clause 2(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:211.1-211.42
def $compat_divmod(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:214.1-215.56
   clause 0(typeIR_l, typeIR_r) = $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:212.1-212.43
def $compat'_divmod(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:216.1-216.37
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:217.1-218.15
   clause 1(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:278.1-278.41
def $compat_shift(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:281.1-282.55
   clause 0(typeIR_l, typeIR_r) = $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:279.1-279.42
def $compat'_shift(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:283.1-283.36
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:284.1-284.43
   clause 1(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:285.1-285.43
   clause 2(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:286.1-286.43
   clause 3(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:287.1-287.50
   clause 4(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:288.1-288.50
   clause 5(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:289.1-289.43
   clause 6(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:290.1-290.50
   clause 7(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:291.1-291.50
   clause 8(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:292.1-293.15
   clause 9(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:369.1-369.43
def $compat_compare(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:372.1-373.57
   clause 0(typeIR_l, typeIR_r) = $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:370.1-370.44
def $compat'_compare(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:374.1-374.38
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:375.1-375.52
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:376.1-376.52
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:377.1-378.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:406.1-406.43
def $compat_bitwise(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:409.1-410.57
   clause 0(typeIR_l, typeIR_r) = $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:407.1-407.44
def $compat'_bitwise(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:411.1-411.52
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:412.1-412.52
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:413.1-414.15
   clause 2(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:442.1-442.42
def $compat_concat(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:445.1-446.56
   clause 0(typeIR_l, typeIR_r) = $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:443.1-443.43
def $compat'_concat(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:447.1-447.51
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:448.1-448.51
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:449.1-449.51
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:450.1-450.51
   clause 3(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:451.1-452.15
   clause 4(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:454.1-454.45
def $result_concat(typeIR, typeIR) : typeIR? =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:457.1-458.56
   clause 0(typeIR_l, typeIR_r) = $result'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:455.1-455.46
def $result'_concat(typeIR, typeIR) : typeIR? =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:459.1-459.72
   clause 0(typeIR, typeIR') = ?(`INT<` (w_a + w_b) `>` as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w_a `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w_b `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:460.1-460.72
   clause 1(typeIR, typeIR') = ?(`INT<` (w_a + w_b) `>` as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w_a `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w_b `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:461.1-461.72
   clause 2(typeIR, typeIR') = ?(`BIT<` (w_a + w_b) `>` as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w_a `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w_b `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:462.1-462.72
   clause 3(typeIR, typeIR') = ?(`BIT<` (w_a + w_b) `>` as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w_a `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w_b `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:463.1-464.15
   clause 4(typeIR_l, typeIR_r) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:492.1-492.43
def $compat_logical(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:495.1-496.57
   clause 0(typeIR_l, typeIR_r) = $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:493.1-493.44
def $compat'_logical(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:497.1-497.40
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `BOOL` as typeIR)
      -- if (typeIR' = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:498.1-499.15
   clause 1(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:864.1-864.39
def $compat_array_index(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:867.1-868.40
   clause 0(typeIR) = $compat'_arrayindex($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:865.1-865.39
def $compat'_arrayindex(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:869.1-869.36
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:870.1-870.43
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:871.1-871.43
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:872.1-873.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:955.1-955.41
def $compat_bitslice_base(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:958.1-959.43
   clause 0(typeIR) = $compat'_bitslice_base($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:956.1-956.42
def $compat'_bitslice_base(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:960.1-960.39
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:961.1-961.50
   clause 1(typeIR) = (w > 0)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:962.1-962.46
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:963.1-964.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:966.1-966.42
def $compat_bitslice_index(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:969.1-970.44
   clause 0(typeIR) = $compat'_bitslice_index($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:967.1-967.43
def $compat'_bitslice_index(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:971.1-971.40
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:972.1-972.47
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:973.1-973.47
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:974.1-975.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:977.1-977.48
def $is_valid_bitslice(typeIR, nat, nat) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:980.1-981.71
   clause 0(typeIR, n_lo, n_hi) = ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:978.1-978.49
def $is_valid_bitslice'(typeIR, nat, nat) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:982.1-982.42
   clause 0(typeIR, _nat, _nat') = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:983.1-985.37
   clause 1(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- let w_slice = ((n_hi - n_lo) + 1)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:986.1-988.37
   clause 2(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- let w_slice = ((n_hi - n_lo) + 1)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:989.1-990.15
   clause 3(_typeIR, _nat, _nat') = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1102.1-1102.46
def $is_concrete_extern_object(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1107.1-1108.50
   clause 0(typeIR) = $is_concrete_extern_object'($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1103.1-1103.47
def $is_concrete_extern_object'(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1110.1-1111.42
   clause 0(typeIR) = true
      -- if ~$is_extern_object_typeIR(typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1112.1-1113.58
   clause 1(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid `{` _rid `:` routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} `}` = typeIR as externObjectTypeIR
      -- (if $is_concrete_extern_object''(routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*}

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1114.1-1115.15
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1104.1-1104.58
def $is_concrete_extern_object''(routineTypeDefIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1117.1-1118.49
   clause 0(routineTypeDefIR) = $is_concrete_extern_object'''(routineTypeIR)
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1119.1-1120.50
   clause 1(routineTypeDefIR) = (true = $is_concrete_extern_object'''(routineTypeIR))
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` _tid*{_tid <- _tid*} `,` _tid'*{_tid' <- _tid'*} `>` = routineTypeDefIR as polyRoutineTypeDefIR

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1105.1-1105.56
def $is_concrete_extern_object'''(routineTypeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1122.1-1122.79
   clause 0(routineTypeIR) = false
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1123.1-1124.15
   clause 1(_routineTypeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.10-typing-statement.watsup:88.1-88.46
def $compat_direct_application(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:91.1-92.48
   clause 0(typeIR) = $compat'_direct_application($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:89.1-89.47
def $compat'_direct_application(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:93.1-93.54
   clause 0(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:94.1-94.55
   clause 1(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:95.1-96.15
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.10-typing-statement.watsup:204.1-206.26
relation SwitchLabel_table_ok: context tid bool `|-` switchLabel `:` switchLabelIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:210.1-211.40
   rule default: C tid_table bool `|-` switchLabel `:` `DEFAULT`
      -- if (bool = true)
      -- if switchLabel matches `DEFAULT`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:215.1-227.57
   rule expressionNonBrace-prefixedNonTypeName: C tid_table _bool `|-` switchLabel `:` typedExpressionIR_label as switchLabelIR
      -- if switchLabel <: prefixedNonTypeName
      -- let prefixedNonTypeName = switchLabel as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- if prefixedNameIR matches ``%`
      -- let ``` nameIR_label = prefixedNameIR
      -- let tid_table_enum = "action_list(" ++ tid_table ++ ")"
      -- let id_label = tid_table_enum ++ "." ++ nameIR_label
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(`LOCAL`, C, ``` id_label)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction typeIR_label ctk_label value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value?{value <- value?} matches (_)
      -- let ?(value_label) = value?{value <- value?}
      -- if (value_label = `TABLE_ENUM` tid_table_enum `.` nameIR_label as value)
      -- let typedExpressionIR_label = ``` nameIR_label as expressionIR `#` `(` typeIR_label ctk_label `)`

;; ../../../../spec-concrete/5.10-typing-statement.watsup:233.1-235.29
relation SwitchCase_table_ok: context flow tid bool `|-` switchCase `:` flow switchCaseIR `#` switchLabel

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:239.1-247.57
   rule switchLabel-blockStatement: C f tid_table b_last `|-` switchCase `:` f_post switchCaseIR `#` switchLabel
      -- if switchCase matches `%:%`
      -- let switchLabel `:` blockStatement = switchCase
      -- SwitchLabel_table_ok: C tid_table b_last `|-` switchLabel `:` switchLabelIR
      -- Block_ok: C f `|-` blockStatement `:` C_post f_post blockStatementIR
      -- let switchCaseIR = switchLabelIR `:` blockStatementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:251.1-257.40
   rule switchLabel: C f tid_table b_last `|-` switchCase `:` f switchCaseIR `#` switchLabel
      -- if switchCase matches `%:`
      -- let switchLabel `:` = switchCase
      -- SwitchLabel_table_ok: C tid_table b_last `|-` switchLabel `:` switchLabelIR
      -- let switchCaseIR = switchLabelIR `:`

;; ../../../../spec-concrete/5.10-typing-statement.watsup:261.1-263.26
relation SwitchCases_table_ok: context flow tid `|-` switchCase* `:` flow switchCaseListIR `#` switchLabel*

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:265.1-266.38
   rule nil: C f tid_table `|-` switchCase*{switchCase <- switchCase*} `:` f [] `#` []
      -- if switchCase*{switchCase <- switchCase*} matches []

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:268.1-275.79
   rule cons: C f tid_table `|-` switchCase*{switchCase <- switchCase*} `:` f_t switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} `#` switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}
      -- if switchCase*{switchCase <- switchCase*} matches _ :: _
      -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
      -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
      -- SwitchCase_table_ok: C f tid_table b_last `|-` switchCase_h `:` f_h switchCaseIR_h `#` switchLabel_h
      -- SwitchCases_table_ok: C f_h tid_table `|-` switchCase_t*{switchCase_t <- switchCase_t*} `:` f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} `#` switchLabel_t*{switchLabel_t <- switchLabel_t*}

;; ../../../../spec-concrete/5.10-typing-statement.watsup:300.1-302.26
relation SwitchLabel_general_ok: context typeIR bool `|-` switchLabel `:` switchLabelIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:306.1-307.32
   rule default: C _typeIR bool `|-` switchLabel `:` `DEFAULT`
      -- if (bool = true)
      -- if switchLabel matches `DEFAULT`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:311.1-319.56
   rule expressionNonBrace: C typeIR_switch _bool `|-` switchLabel `:` typedExpressionIR_label_cast as switchLabelIR
      -- if switchLabel <: expressionNonBrace
      -- let expressionNonBrace_label = switchLabel as expressionNonBrace
      -- let expression_label = $expressionNonBrace(expressionNonBrace_label)
      -- Expr_ok: `LOCAL` C `|-` expression_label `:` typedExpressionIR_label
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_label, typeIR_switch)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_label_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let _expressionIR `#` `(` _typeIR ctk `)` = typedExpressionIR_label_cast
      -- if ctk matches `LCTK`

;; ../../../../spec-concrete/5.10-typing-statement.watsup:323.1-325.29
relation SwitchCase_general_ok: context flow typeIR bool `|-` switchCase `:` flow switchCaseIR `#` switchLabel

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:329.1-337.57
   rule switchLabel-blockStatement: C f typeIR_switch b_last `|-` switchCase `:` f_post switchCaseIR `#` switchLabel
      -- if switchCase matches `%:%`
      -- let switchLabel `:` blockStatement = switchCase
      -- SwitchLabel_general_ok: C typeIR_switch b_last `|-` switchLabel `:` switchLabelIR
      -- Block_ok: C f `|-` blockStatement `:` C_post f_post blockStatementIR
      -- let switchCaseIR = switchLabelIR `:` blockStatementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:341.1-347.40
   rule switchLabel: C f typeIR_switch b_last `|-` switchCase `:` f switchCaseIR `#` switchLabel
      -- if switchCase matches `%:`
      -- let switchLabel `:` = switchCase
      -- SwitchLabel_general_ok: C typeIR_switch b_last `|-` switchLabel `:` switchLabelIR
      -- let switchCaseIR = switchLabelIR `:`

;; ../../../../spec-concrete/5.10-typing-statement.watsup:351.1-353.26
relation SwitchCases_general_ok: context flow typeIR `|-` switchCase* `:` flow switchCaseListIR `#` switchLabel*

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:355.1-356.42
   rule nil: C f typeIR_switch `|-` switchCase*{switchCase <- switchCase*} `:` f [] `#` []
      -- if switchCase*{switchCase <- switchCase*} matches []

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:358.1-365.83
   rule cons: C f typeIR_switch `|-` switchCase*{switchCase <- switchCase*} `:` f_t switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} `#` switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}
      -- if switchCase*{switchCase <- switchCase*} matches _ :: _
      -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
      -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
      -- SwitchCase_general_ok: C f typeIR_switch b_last `|-` switchCase_h `:` f_h switchCaseIR_h `#` switchLabel_h
      -- SwitchCases_general_ok: C f_h typeIR_switch `|-` switchCase_t*{switchCase_t <- switchCase_t*} `:` f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} `#` switchLabel_t*{switchLabel_t <- switchLabel_t*}

;; ../../../../spec-concrete/5.10-typing-statement.watsup:367.1-367.34
def $compat_switch(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:370.1-371.36
   clause 0(typeIR) = $compat'_switch($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:368.1-368.35
def $compat'_switch(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:372.1-372.34
   clause 0(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:373.1-373.39
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:374.1-374.39
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:375.1-375.42
   clause 3(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:376.1-376.47
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:377.1-378.15
   clause 5(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:87.1-89.29
relation Decl_object_ok: cursor context frame rdenv `|-` objectDeclaration `:` frame rdenv objectDeclarationIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:99.1-131.27
   rule functionDeclaration: p C_0 frame rdenv `|-` objectDeclaration `:` frame rdenv_init functionDeclarationIR as objectDeclarationIR
      -- if objectDeclaration <: functionDeclaration
      -- let annotationList typeOrVoid name typeParameterListOpt `(` parameterList `)` blockStatement = objectDeclaration as functionDeclaration
      -- let C_1 = C_0[BLOCK.FRAME = frame]
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_2 = $add_types(`LOCAL`, C_1, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `LOCAL` C_2 `|-` typeOrVoid `:` typeIR_ret `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `LOCAL` C_2 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_3 = $add_parameters(`LOCAL`, C_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let C_4 = $set_return_type(C_3, typeIR_ret)
      -- Block_ok: C_4 `CONT` `|-` blockStatement `:` _context _flow blockStatementIR
      -- let rid = $rid(name, parameterList)
      -- let methodTypeIR = `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(p, C_0) `|-` routineTypeDefIR holds
      -- let rdenv_init = $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let functionDeclarationIR = annotationList typeIR_ret nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `)` blockStatementIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:135.1-144.61
   rule instantiation: p C_0 frame rdenv `|-` objectDeclaration `:` frame_init rdenv instantiationIR as objectDeclarationIR
      -- if objectDeclaration <: instantiation
      -- let instantiation = objectDeclaration as instantiation
      -- Decl_ok: p C_0 `|-` instantiation as declaration `:` C_1 declarationIR
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR
      -- let _annotationList _prefixedNameIR `<` _typeArgumentListIR `>(` _argumentListIR `)` nameIR _objectInitializerOptIR `;` = instantiationIR
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_var(p, C_1, ``` nameIR)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}
      -- let frame_init = $update_map<id, varTypeIR>(frame, nameIR, varTypeIR)

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:146.1-148.29
relation Decls_object_ok: cursor context frame rdenv `|-` objectDeclaration* `:` frame rdenv objectDeclarationListIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:150.1-151.43
   rule nil: p C frame rdenv `|-` objectDeclaration*{objectDeclaration <- objectDeclaration*} `:` frame rdenv []
      -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:153.1-161.68
   rule cons: p C frame_0 rdenv_0 `|-` objectDeclaration*{objectDeclaration <- objectDeclaration*} `:` frame_2 rdenv_2 objectDeclarationIR_h :: objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*}
      -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches _ :: _
      -- let objectDeclaration_h :: objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} = objectDeclaration*{objectDeclaration <- objectDeclaration*}
      -- Decl_object_ok: p C frame_0 rdenv_0 `|-` objectDeclaration_h `:` frame_1 rdenv_1 objectDeclarationIR_h
      -- Decls_object_ok: p C frame_1 rdenv_1 `|-` objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} `:` frame_2 rdenv_2 objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*}

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:163.1-163.46
def $subst_rdenv(theta, rdenv, rdenv) : rdenv =

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:165.1-165.63
   clause 0(theta, rdenv_extern, set<pair<rid, routineTypeDefIR>>) = rdenv_extern
      -- if (set<pair<rid, routineTypeDefIR>> = `{` [] `}`)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:166.1-182.93
   clause 1(theta, rdenv_extern, `{` pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} `}`) = $subst_rdenv(theta, rdenv_extern_subst, `{` rid_init_t `:` routineTypeDefIR_init_t*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} `}`)
      -- if pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} matches _ :: _
      -- let rid_init_h `:` routineTypeDefIR_init_h :: rid_init_t `:` routineTypeDefIR_init_t*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} = pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*}
      -- let routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?} = $find_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h)
      -- if routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?} matches (_)
      -- let ?(routineTypeDefIR') = routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?}
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let routineTypeDefIR = `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret as routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as routineTypeDefIR
      -- let routineTypeDefIR_subst = $subst_routineTypeDef(theta, routineTypeDefIR)
      -- if RoutineTypeDef_alpha: routineTypeDefIR_subst `~~` routineTypeDefIR_init_h holds
      -- let rdenv_extern_subst = $update_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h, routineTypeDefIR_subst)

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:406.1-406.81
def $split_constructors(methodPrototype*) : (methodPrototype*, methodPrototype*) =

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:408.1-408.42
   clause 0(methodPrototype*{methodPrototype <- methodPrototype*}) = ([], [])
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:409.1-414.48
   clause 1(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_h :: methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `%%(%);`
      -- let _annotationList _typeIdentifier `(` _parameterList `);` = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:415.1-420.48
   clause 2(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `%%;`
      -- let _annotationList _functionPrototype `;` = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:421.1-426.48
   clause 3(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `%ABSTRACT%;`
      -- let _annotationList `ABSTRACT` _functionPrototype `;` = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:592.1-595.26
relation Enum_serializable_field_ok: context nameIR typeIR `|-` namedExpression `:` context namedExpressionIR `#` value

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:597.1-612.73
   rule : C_0 nameIR_enum typeIR `|-` name `=` expression `:` C_1 nameIR `=` typedExpressionIR_cast `#` value
      -- Expr_ok: `BLOCK` C_0 `|-` expression `:` typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR `#` `(` _typeIR ctk `)` = typedExpressionIR_cast
      -- if ctk matches `LCTK`
      -- Eval_static: `BLOCK` C_0 `|-` typedExpressionIR_cast `~>` value
      -- let nameIR = $name(name)
      -- let typeIR_enum = `ENUM` nameIR_enum `#` typeIR `{` [] `}` as typeIR
      -- let value_enum = nameIR_enum `.` nameIR `#` value as value
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, ``EMPTY` typeIR_enum `LCTK` ?(value_enum))

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:614.1-617.26
relation Enum_serializable_fields_ok: context nameIR typeIR `|-` namedExpression* `:` context namedExpressionIR* `#` value*

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:619.1-620.45
   rule nil: C nameIR_enum typeIR `|-` namedExpression*{namedExpression <- namedExpression*} `:` C [] `#` []
      -- if namedExpression*{namedExpression <- namedExpression*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:622.1-632.55
   rule cons: C_0 nameIR_enum typeIR `|-` namedExpression*{namedExpression <- namedExpression*} `:` C_2 namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} `#` value_field*{value_field <- value_field*}
      -- if namedExpression*{namedExpression <- namedExpression*} matches _ :: _
      -- let namedExpression_h :: namedExpression_t*{namedExpression_t <- namedExpression_t*} = namedExpression*{namedExpression <- namedExpression*}
      -- Enum_serializable_field_ok: C_0 nameIR_enum typeIR `|-` namedExpression_h `:` C_1 namedExpressionIR_h `#` value_field_h
      -- Enum_serializable_fields_ok: C_1 nameIR_enum typeIR `|-` namedExpression_t*{namedExpression_t <- namedExpression_t*} `:` C_2 namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*} `#` value_field_t*{value_field_t <- value_field_t*}
      -- let namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} = namedExpressionIR_h :: namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*}
      -- let value_field*{value_field <- value_field*} = value_field_h :: value_field_t*{value_field_t <- value_field_t*}

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:33.1-35.23
relation SelectCase_keyset_simple_ok: context typeIR `|-` simpleKeysetExpression `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:39.1-45.38
   rule expression-set-alpha: C typeIR_key `|-` simpleKeysetExpression `:` typedExpressionIR as simpleKeysetExpressionIR
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- Expr_ok: `LOCAL` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR'' _ctk `)` = typedExpressionIR
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- if Type_alpha: typeIR `~~` typeIR_key holds

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:47.1-58.69
   rule expression-set-subtype: C typeIR_key `|-` simpleKeysetExpression `:` typedExpressionIR_cast as simpleKeysetExpressionIR
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- Expr_ok: `LOCAL` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR'' _ctk `)` = typedExpressionIR
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- if ~Type_alpha: typeIR `~~` typeIR_key holds
      -- if Sub_impl: typeIR `<:` typeIR_key holds
      -- let typeIR_cast = `SET<` [typeIR_key] `>` as typeIR
      -- let typedExpressionIR_cast = `(` typeIR_cast `)` typedExpressionIR as expressionIR `#` `(` typeIR_cast `DYN` `)`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:60.1-72.69
   rule expression-non-set: C typeIR_key `|-` simpleKeysetExpression `:` typedExpressionIR_cast as simpleKeysetExpressionIR
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- Expr_ok: `LOCAL` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if ~$is_set_typeIR(typeIR)
      -- if Sub_impl: typeIR `<:` typeIR_key holds
      -- let typeIR_cast = `SET<` [typeIR_key] `>` as typeIR
      -- let typedExpressionIR_cast = `(` typeIR_cast `)` typedExpressionIR as expressionIR `#` `(` typeIR_cast `DYN` `)`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:87.1-109.63
   rule mask: C typeIR_key `|-` simpleKeysetExpression `:` typedExpressionIR_l_coerced `&&&` typedExpressionIR_r_coerced
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l `&&&` expression_r = simpleKeysetExpression
      -- Expr_ok: `LOCAL` C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: `LOCAL` C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced _ctk `)` = typedExpressionIR_l_reduced
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:124.1-147.63
   rule range: C typeIR_key `|-` simpleKeysetExpression `:` typedExpressionIR_l_coerced `..` typedExpressionIR_r_coerced
      -- if simpleKeysetExpression matches `%..%`
      -- let expression_l `..` expression_r = simpleKeysetExpression
      -- Expr_ok: `LOCAL` C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: `LOCAL` C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced _ctk `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR _ctk' `)` = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:151.1-152.36
   rule default: C typeIR_key `|-` simpleKeysetExpression `:` `DEFAULT`
      -- if simpleKeysetExpression matches `DEFAULT`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:156.1-157.26
   rule dontcare: C typeIR_key `|-` simpleKeysetExpression `:` `_`
      -- if simpleKeysetExpression matches `_`

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:76.1-76.40
def $compat_mask(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:79.1-80.54
   clause 0(typeIR_l, typeIR_r) = $compat'_mask($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:77.1-77.41
def $compat'_mask(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:81.1-81.35
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:82.1-82.49
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:83.1-83.49
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:84.1-85.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:113.1-113.41
def $compat_range(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:116.1-117.55
   clause 0(typeIR_l, typeIR_r) = $compat'_range($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:114.1-114.42
def $compat'_range(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:118.1-118.36
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:119.1-119.50
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:120.1-120.50
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:121.1-122.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:161.1-163.23
relation SelectCase_keyset_ok: context typeIR* `|-` keysetExpression `:` keysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:170.1-173.60
   rule simpleKeysetExpression-expression: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: expression
      -- let expression = keysetExpression as expression
      -- SelectCase_keyset_simple_ok: C typeIR_key `|-` expression as simpleKeysetExpression `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:177.1-180.80
   rule simpleKeysetExpression-mask: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l `&&&` expression_r = simpleKeysetExpression
      -- SelectCase_keyset_simple_ok: C typeIR_key `|-` expression_l `&&&` expression_r `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:184.1-187.79
   rule simpleKeysetExpression-range: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: simpleKeysetExpression
      -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
      -- if simpleKeysetExpression matches `%..%`
      -- let expression_l `..` expression_r = simpleKeysetExpression
      -- SelectCase_keyset_simple_ok: C typeIR_key `|-` expression_l `..` expression_r `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:191.1-192.29
   rule simpleKeysetExpression-default-zero-to-one: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` `DEFAULT` as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches []
      -- if (keysetExpression = `DEFAULT` as keysetExpression)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:194.1-197.57
   rule simpleKeysetExpression-default-one-to-one: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if (keysetExpression = `DEFAULT` as keysetExpression)
      -- SelectCase_keyset_simple_ok: C typeIR_key `|-` `DEFAULT` `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:199.1-203.69
   rule simpleKeysetExpression-default-many-to-one: C typeIR_key*{typeIR_key <- typeIR_key*} `|-` keysetExpression `:` simpleKeysetExpressionIR as keysetExpressionIR
      -- if (keysetExpression = `DEFAULT` as keysetExpression)
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_simple_ok: C `SEQ<` typeIR_key*{typeIR_key <- typeIR_key*} `>` as typeIR `|-` `DEFAULT` `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:207.1-210.52
   rule simpleKeysetExpression-dontcare-one-to-one: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` simpleKeysetExpressionIR as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if (keysetExpression = `_` as keysetExpression)
      -- SelectCase_keyset_simple_ok: C typeIR_key `|-` `_` `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:212.1-216.64
   rule simpleKeysetExpression-dontcare-many-to-one: C typeIR_key*{typeIR_key <- typeIR_key*} `|-` keysetExpression `:` simpleKeysetExpressionIR as keysetExpressionIR
      -- if (keysetExpression = `_` as keysetExpression)
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_simple_ok: C `SEQ<` typeIR_key*{typeIR_key <- typeIR_key*} `>` as typeIR `|-` `_` `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:223.1-226.80
   rule tupleKeysetExpression-mask: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` `(` [simpleKeysetExpressionIR] `)` as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%&&&%)`
      -- let `(` expression_l `&&&` expression_r `)` = tupleKeysetExpression
      -- SelectCase_keyset_simple_ok: C typeIR_key `|-` expression_l `&&&` expression_r `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:230.1-233.79
   rule tupleKeysetExpression-range: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` `(` [simpleKeysetExpressionIR] `)` as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%..%)`
      -- let `(` expression_l `..` expression_r `)` = tupleKeysetExpression
      -- SelectCase_keyset_simple_ok: C typeIR_key `|-` expression_l `..` expression_r `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:237.1-240.57
   rule tupleKeysetExpression-default-one-to-one: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` `(` [simpleKeysetExpressionIR] `)` as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if (keysetExpression = `(DEFAULT)` as keysetExpression)
      -- SelectCase_keyset_simple_ok: C typeIR_key `|-` `DEFAULT` `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:242.1-246.69
   rule tupleKeysetExpression-default-many-to-one: C typeIR_key*{typeIR_key <- typeIR_key*} `|-` keysetExpression `:` `(` [simpleKeysetExpressionIR] `)` as keysetExpressionIR
      -- if (keysetExpression = `(DEFAULT)` as keysetExpression)
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_simple_ok: C `SEQ<` typeIR_key*{typeIR_key <- typeIR_key*} `>` as typeIR `|-` `DEFAULT` `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:250.1-253.52
   rule tupleKeysetExpression-dontcare-one-to-one: C typeIR*{typeIR <- typeIR*} `|-` keysetExpression `:` `(` [simpleKeysetExpressionIR] `)` as keysetExpressionIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
      -- if (keysetExpression = `(_)` as keysetExpression)
      -- SelectCase_keyset_simple_ok: C typeIR_key `|-` `_` `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:255.1-259.64
   rule tupleKeysetExpression-dontcare-many-to-one: C typeIR_key*{typeIR_key <- typeIR_key*} `|-` keysetExpression `:` `(` [simpleKeysetExpressionIR] `)` as keysetExpressionIR
      -- if (keysetExpression = `(_)` as keysetExpression)
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_simple_ok: C `SEQ<` typeIR_key*{typeIR_key <- typeIR_key*} `>` as typeIR `|-` `_` `:` simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:263.1-274.74
   rule tupleKeysetExpression-list: C typeIR_key*{typeIR_key <- typeIR_key*} `|-` keysetExpression `:` `(` simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*} `)` as keysetExpressionIR
      -- if keysetExpression <: tupleKeysetExpression
      -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
      -- if tupleKeysetExpression matches `(%,%)`
      -- let `(` simpleKeysetExpression_h `,` simpleKeysetExpressionList_t `)` = tupleKeysetExpression
      -- let simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t)
      -- let simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} = simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*}
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| = |simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}|)
      -- (SelectCase_keyset_simple_ok: C typeIR_key `|-` simpleKeysetExpression `:` simpleKeysetExpressionIR)*{simpleKeysetExpression <- simpleKeysetExpression*, simpleKeysetExpressionIR <- simpleKeysetExpressionIR*, typeIR_key <- typeIR_key*}

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:278.1-280.26
relation SelectCase_ok: context nameIR* typeIR* `|-` selectCase `:` selectCaseIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:282.1-290.32
   rule : C nameIR_state*{nameIR_state <- nameIR_state*} typeIR_key*{typeIR_key <- typeIR_key*} `|-` keysetExpression `:` name `;` `:` keysetExpressionIR `:` nameIR `;`
      -- SelectCase_keyset_ok: C typeIR_key*{typeIR_key <- typeIR_key*} `|-` keysetExpression `:` keysetExpressionIR
      -- let nameIR = $name(name)
      -- if nameIR <- nameIR_state*{nameIR_state <- nameIR_state*}

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:7.1-7.52
def $compat_table_exact_optional_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:10.1-11.54
   clause 0(typeIR) = $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:8.1-8.53
def $compat'_table_exact_optional_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:12.1-12.51
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:13.1-13.52
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:14.1-14.59
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:15.1-16.45
   clause 3(typeIR') = $compat_table_exact_optional_key(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:17.1-17.60
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:18.1-19.45
   clause 5(typeIR') = $compat_table_exact_optional_key(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:21.1-21.55
def $compat_table_lpm_ternary_range_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:24.1-25.57
   clause 0(typeIR) = $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:22.1-22.56
def $compat'_table_lpm_ternary_range_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:26.1-26.53
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:27.1-27.60
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:28.1-28.60
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:29.1-30.48
   clause 3(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:31.1-32.48
   clause 4(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:34.1-34.45
def $compat_table_key(nameIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:36.1-38.49
   clause 0(nameIR, typeIR) = true
      -- if ((nameIR = "exact") \/ (nameIR = "optional"))
      -- if $compat_table_exact_optional_key(typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:40.1-42.52
   clause 1(nameIR, typeIR) = true
      -- if (((nameIR = "lpm") \/ (nameIR = "ternary")) \/ (nameIR = "range"))
      -- if $compat_table_lpm_ternary_range_key(typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:44.1-45.15
   clause 2(nameIR, typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:87.1-88.41
def $split_dataplane_parameters(parameterTypeIR*) : (parameterTypeIR*, parameterTypeIR*) =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:90.1-90.50
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = ([], [])
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:91.1-95.56
   clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_h :: parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
      -- if direction matches ``EMPTY`
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:96.1-101.56
   clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_h :: parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
      -- if (direction =/= ``EMPTY`)
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:238.1-241.26
relation TableEntry_keyset_simple_ok: context tablecontext `|-` matchKey `@` simpleKeysetExpression `:` tableEntryState simpleKeysetExpressionIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:245.1-258.67
   rule expression-lpm: C TC `|-` (typeIR_key, text) `@` simpleKeysetExpression `:` `LPM` n typedExpressionIR_set as simpleKeysetExpressionIR
      -- if (text = "lpm")
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` n = matchMode
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR ctk `)` = typedExpressionIR
      -- if Sub_impl: typeIR `<:` typeIR_key holds
      -- let typeIR_set = `SET<` [typeIR_key] `>` as typeIR
      -- let typedExpressionIR_set = `(` typeIR_set `)` typedExpressionIR as expressionIR `#` `(` typeIR_set ctk `)`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:260.1-273.67
   rule expression-non-lpm: C TC `|-` (typeIR_key, nameIR_matchkind) `@` simpleKeysetExpression `:` `NOLPM` typedExpressionIR_set as simpleKeysetExpressionIR
      -- if simpleKeysetExpression <: expression
      -- let expression = simpleKeysetExpression as expression
      -- if (nameIR_matchkind =/= "lpm")
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR ctk `)` = typedExpressionIR
      -- if Sub_impl: typeIR `<:` typeIR_key holds
      -- let typeIR_set = `SET<` [typeIR_key] `>` as typeIR
      -- let typedExpressionIR_set = `(` typeIR_set `)` typedExpressionIR as expressionIR `#` `(` typeIR_set ctk `)`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:277.1-304.66
   rule mask-lpm: C TC `|-` (typeIR_key, text) `@` simpleKeysetExpression `:` `LPM` n_prefix typedExpressionIR_l_reduced `&&&` typedExpressionIR_r_reduced
      -- if (text = "lpm")
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l `&&&` expression_r = simpleKeysetExpression
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` n = matchMode
      -- Expr_ok: `BLOCK` C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: `BLOCK` C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if Sub_impl: typeIR_reduced `<:` typeIR_key holds
      -- if (ctk_r_reduced = `LCTK`)
      -- Eval_static: `BLOCK` C `|-` typedExpressionIR_r_reduced `~>` value_r
      -- let i_r = $to_number(value_r)
      -- let n_prefix = $tableEntry_lpm_prefix(n `W` $to_bitstr(n as int, i_r) as value)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:306.1-325.44
   rule mask-ternary: C TC `|-` (typeIR_key, text) `@` simpleKeysetExpression `:` `NOLPM` typedExpressionIR_l_reduced `&&&` typedExpressionIR_r_reduced
      -- if (text = "ternary")
      -- if simpleKeysetExpression matches `%&&&%`
      -- let expression_l `&&&` expression_r = simpleKeysetExpression
      -- Expr_ok: `BLOCK` C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: `BLOCK` C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if Sub_impl: typeIR_reduced `<:` typeIR_key holds

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:329.1-348.44
   rule range-range: C TC `|-` (typeIR_key, text) `@` simpleKeysetExpression `:` `NOLPM` typedExpressionIR_l_reduced `..` typedExpressionIR_r_reduced
      -- if (text = "range")
      -- if simpleKeysetExpression matches `%..%`
      -- let expression_l `..` expression_r = simpleKeysetExpression
      -- Expr_ok: `BLOCK` C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: `BLOCK` C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if Sub_impl: typeIR_reduced `<:` typeIR_key holds

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:352.1-355.29
   rule default-lpm: C TC `|-` (typeIR_key, text) `@` simpleKeysetExpression `:` `LPM` n `DEFAULT`
      -- if (text = "lpm")
      -- if simpleKeysetExpression matches `DEFAULT`
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` n = matchMode

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:357.1-360.37
   rule default-else: C TC `|-` (typeIR_key, nameIR_matchkind) `@` simpleKeysetExpression `:` `NOLPM` `DEFAULT`
      -- if simpleKeysetExpression matches `DEFAULT`
      -- if (nameIR_matchkind =/= "exact")

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:364.1-367.29
   rule dontcare-lpm: C TC `|-` (typeIR_key, text) `@` simpleKeysetExpression `:` `LPM` 0 `_`
      -- if (text = "lpm")
      -- if simpleKeysetExpression matches `_`
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` _nat = matchMode

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:369.1-372.37
   rule dontcare-else: C TC `|-` (typeIR_key, nameIR_matchkind) `@` simpleKeysetExpression `:` `NOLPM` `_`
      -- if simpleKeysetExpression matches `_`
      -- if (nameIR_matchkind =/= "exact")

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:380.1-383.29
relation TableEntry_keysets_simple_ok: context tablecontext tableEntryState `|-` matchKey* `@` simpleKeysetExpression* `:` tableEntryState simpleKeysetExpressionIR*

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:385.1-386.35
   rule nil: C TC TES `|-` matchKey*{matchKey <- matchKey*} `@` simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} `:` TES []
      -- if matchKey*{matchKey <- matchKey*} matches []
      -- if simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:388.1-398.54
   rule cons: C TC TES_0 `|-` matchKey*{matchKey <- matchKey*} `@` simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} `:` TES_3 simpleKeysetExpressionIR_h :: simpleKeysetExpressionIR_t*{simpleKeysetExpressionIR_t <- simpleKeysetExpressionIR_t*}
      -- if matchKey*{matchKey <- matchKey*} matches _ :: _
      -- let matchKey_h :: matchKey_t*{matchKey_t <- matchKey_t*} = matchKey*{matchKey <- matchKey*}
      -- if simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} matches _ :: _
      -- let simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}
      -- TableEntry_keyset_simple_ok: C TC `|-` matchKey_h `@` simpleKeysetExpression_h `:` TES_1 simpleKeysetExpressionIR_h
      -- let TES_2 = $join_tableEntryState(TES_0, TES_1)
      -- TableEntry_keysets_simple_ok: C TC TES_2 `|-` matchKey_t*{matchKey_t <- matchKey_t*} `@` simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} `:` TES_3 simpleKeysetExpressionIR_t*{simpleKeysetExpressionIR_t <- simpleKeysetExpressionIR_t*}

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:7.1-7.73
def $filter_default_parameters(parameterTypeIR*, id*) : parameterTypeIR* =

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:9.1-9.55
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = []
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:10.1-16.28
   clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let _direction _typeIR id_h _value?{_value <- _value?} = parameterTypeIR_h
      -- if id_h <- id_default*{id_default <- id_default*}

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:17.1-22.15
   clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- otherwise

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:26.1-26.71
def $align_parameters(parameterTypeIR*, argumentIR*) : parameterTypeIR* =

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:29.1-32.90
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}
      -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- (let parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} = $align_parameters'(`{` id `:` parameterTypeIR*{id <- id*, parameterTypeIR <- parameterTypeIR*} `}`, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, parameterTypeIR <- parameterTypeIR*, parameterTypeIR'? <- parameterTypeIR'?*}
      -- (if parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} matches (_))*{parameterTypeIR'? <- parameterTypeIR'?*}
      -- (let ?(parameterTypeIR_aligned) = parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?})*{parameterTypeIR'? <- parameterTypeIR'?*, parameterTypeIR_aligned <- parameterTypeIR_aligned*}

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:27.1-27.96
def $align_parameters'(map<id, parameterTypeIR>, parameterTypeIR, argumentIR) : parameterTypeIR? =

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:34.1-35.20
   clause 0(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:36.1-37.80
   clause 1(`{` id_param `:` parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} `}`, _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>(`{` id_param `:` parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} `}`, nameIR)
      -- if argumentIR matches `%=%`
      -- let nameIR `=` _typedExpressionIR = argumentIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:38.1-39.80
   clause 2(`{` id_param `:` parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} `}`, _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>(`{` id_param `:` parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} `}`, nameIR)
      -- if argumentIR matches `%=_`
      -- let nameIR `=_` = argumentIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:40.1-41.20
   clause 3(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
      -- if argumentIR matches `_`

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:6.1-7.12
syntax infer = 
   | `KNOWNAS` typeIR
   | `UNKNOWN`

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:9.21-9.36
syntax constraint = map<tid, infer>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:11.1-11.41
def $empty_constraint(tid*) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:12.1-12.53
   clause 0(tid*{tid <- tid*}) = `{` tid `:` `UNKNOWN`*{tid <- tid*} `}`

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:14.20-14.36
syntax inference = map<tid, typeIR>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:20.1-20.60
def $infer(tid*, parameterTypeIR*, argumentIR*) : inference =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:44.1-52.61
   clause 0(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = inference
      -- let constraint_init = $empty_constraint(tid_infer*{tid_infer <- tid_infer*})
      -- (let constraint_pair = $infer'(constraint_init, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, constraint_pair <- constraint_pair*, parameterTypeIR <- parameterTypeIR*}
      -- let constraint_inferred = $merge_constraints(constraint_init, constraint_pair*{constraint_pair <- constraint_pair*})
      -- let inference = $resolve_constraint(constraint_inferred)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:21.1-21.66
def $infer'(constraint, parameterTypeIR, argumentIR) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:54.1-57.51
   clause 0(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR
      -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
      -- let _expressionIR `#` `(` typeIR_arg _ctk `)` = typedExpressionIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:59.1-62.51
   clause 1(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if argumentIR matches `%=%`
      -- let nameIR `=` typedExpressionIR = argumentIR
      -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
      -- let _expressionIR `#` `(` typeIR_arg _ctk `)` = typedExpressionIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:64.1-64.68
   clause 2(constraint, parameterTypeIR, argumentIR) = constraint
      -- if argumentIR matches `%=_`
      -- let nameIR `=_` = argumentIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:66.1-66.58
   clause 3(constraint, parameterTypeIR, argumentIR) = constraint
      -- if argumentIR matches `_`

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:23.1-23.66
def $gen_constraint_type(constraint, typeIR, typeIR) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:74.1-76.66
   clause 0(constraint, typeIR, typeIR_arg) = $update_map<tid, infer>(constraint, tid_param, `KNOWNAS` typeIR_arg)
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid_param = namedTypeIR
      -- if $in_set<tid>(tid_param, $dom_map<tid, infer>(constraint))

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:78.1-99.26
   clause 1(constraint_0, typeIR, typeIR') = constraint_2
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_param `<` typeIR_param*{typeIR_param <- typeIR_param*} `>` = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_arg `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR'
      -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
      -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if ($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))
      -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)
      -- let constraint_2 = $gen_constraint_types(constraint_1, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:101.1-117.26
   clause 2(constraint_0, typeIR, typeIR') = constraint_1
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_param `<` typeIR_param*{typeIR_param <- typeIR_param*} `>` = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_arg `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR'
      -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
      -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if (~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))
      -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:121.1-122.63
   clause 3(constraint, typeIR, typeIR_arg) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR_param = aliasTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:124.1-125.63
   clause 4(constraint, typeIR_param, typeIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR_arg = aliasTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:127.1-128.63
   clause 5(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` tid typeIR_param = aliasTypeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR' = typeIR' as aliasTypeIR
      -- if aliasTypeIR' matches `TYPE%%`
      -- let `TYPE` tid' typeIR_arg = aliasTypeIR'
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:132.1-137.63
   clause 6(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: listTypeIR
      -- let `LIST<` typeIR_param `>` = typeIR as listTypeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR_arg `>` = typeIR' as listTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:139.1-144.66
   clause 7(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` typeIR_param*{typeIR_param <- typeIR_param*} `>` = typeIR as tupleTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:146.1-151.63
   clause 8(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: headerStackTypeIR
      -- let typeIR_param `[` n_size `]` = typeIR as headerStackTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_arg `[` n_size' `]` = typeIR' as headerStackTypeIR
      -- if (n_size = n_size')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:153.1-158.66
   clause 9(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_param id_field `;`*{id_field <- id_field*, typeIR_param <- typeIR_param*} `}` = typeIR as structTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` tid' `{` typeIR_arg id_field' `;`*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} `}` = typeIR' as structTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:160.1-165.66
   clause 10(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_param id_field `;`*{id_field <- id_field*, typeIR_param <- typeIR_param*} `}` = typeIR as headerTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` tid' `{` typeIR_arg id_field' `;`*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} `}` = typeIR' as headerTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:167.1-172.66
   clause 11(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` tid `{` typeIR_param id_field `;`*{id_field <- id_field*, typeIR_param <- typeIR_param*} `}` = typeIR as headerUnionTypeIR
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` tid' `{` typeIR_arg id_field' `;`*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} `}` = typeIR' as headerUnionTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:176.1-185.6
   clause 12(constraint, typeIR, typeIR') = $gen_constraint_routines(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*})
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` tid `{` rid `:` routineTypeDefIR_param*{rid <- rid*, routineTypeDefIR_param <- routineTypeDefIR_param*} `}` = typeIR as externObjectTypeIR
      -- if typeIR' <: externObjectTypeIR
      -- let `EXTERN` tid' `{` rid' `:` routineTypeDefIR_arg*{rid' <- rid'*, routineTypeDefIR_arg <- routineTypeDefIR_arg*} `}` = typeIR' as externObjectTypeIR
      -- (if (rid = rid'))*{rid <- rid*, rid' <- rid'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:187.1-194.58
   clause 13(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} `)` = typeIR as parserObjectTypeIR
      -- if typeIR' <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} `)` = typeIR' as parserObjectTypeIR
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:196.1-203.58
   clause 14(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} `)` = typeIR as controlObjectTypeIR
      -- if typeIR' <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} `)` = typeIR' as controlObjectTypeIR
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:205.1-210.66
   clause 15(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR_param*{typeIR_param <- typeIR_param*} `>` = typeIR as packageObjectTypeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = typeIR' as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:214.1-216.15
   clause 16(constraint, typeIR_param, typeIR_arg) = constraint
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:24.1-24.69
def $gen_constraint_types(constraint, typeIR*, typeIR*) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:220.1-223.69
   clause 0(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
      -- (let constraint_pair = $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*{constraint_pair <- constraint_pair*, typeIR_arg <- typeIR_arg*, typeIR_param <- typeIR_param*}

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:25.1-28.15
def $gen_constraint_routine(constraint, routineTypeDefIR, routineTypeDefIR) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:227.1-238.77
   clause 0(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` _tid*{_tid <- _tid*} `,` _tid'*{_tid' <- _tid'*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} `)->` typeIR_ret_param = methodTypeIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR' `<` _tid''*{_tid'' <- _tid''*} `,` _tid'''*{_tid''' <- _tid'''*} `>` = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} `)->` typeIR_ret_arg = methodTypeIR'
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
      -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:240.1-251.77
   clause 1(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` _tid*{_tid <- _tid*} `,` _tid'*{_tid' <- _tid'*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} `)->` typeIR_ret_param = methodTypeIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR' `<` _tid''*{_tid'' <- _tid''*} `,` _tid'''*{_tid''' <- _tid'''*} `>` = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} `)->` typeIR_ret_arg = methodTypeIR'
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
      -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:29.1-32.15
def $gen_constraint_routines(constraint, routineTypeDefIR*, routineTypeDefIR*) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:255.1-266.12
   clause 0(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
      -- (let constraint_pair = $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*{constraint_pair <- constraint_pair*, routineTypeDefIR_arg <- routineTypeDefIR_arg*, routineTypeDefIR_param <- routineTypeDefIR_param*}

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:34.1-34.59
def $merge_constraint(constraint, constraint) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:272.1-276.52
   clause 0(constraint_pre, constraint_post) = $merge_constraint'(constraint_pre, constraint_post, tid_pre*{tid_pre <- tid_pre*}, `{` [] `}`)
      -- let `{` tid_pre*{tid_pre <- tid_pre*} `}` = $dom_map<tid, infer>(constraint_pre)
      -- let `{` tid_post*{tid_post <- tid_post*} `}` = $dom_map<tid, infer>(constraint_post)
      -- if $eq_set<tid>(`{` tid_pre*{tid_pre <- tid_pre*} `}`, `{` tid_post*{tid_post <- tid_post*} `}`)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:35.1-35.78
def $merge_constraint'(constraint, constraint, tid*, constraint) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:278.1-281.15
   clause 0(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = constraint
      -- if tid*{tid <- tid*} matches []

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:283.1-292.60
   clause 1(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if (?(`UNKNOWN`) = $find_map<tid, infer>(constraint_pre, tid_h))
      -- if (?(`UNKNOWN`) = $find_map<tid, infer>(constraint_post, tid_h))
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `UNKNOWN`)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:294.1-303.73
   clause 2(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if (?(`UNKNOWN`) = $find_map<tid, infer>(constraint_pre, tid_h))
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_post = infer
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWNAS` typeIR_post)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:305.1-314.72
   clause 3(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_pre = infer
      -- if (?(`UNKNOWN`) = $find_map<tid, infer>(constraint_post, tid_h))
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWNAS` typeIR_pre)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:316.1-326.73
   clause 4(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_pre = infer
      -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'''?{infer''' <- infer'''?} matches (_)
      -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
      -- if infer'' matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_post = infer''
      -- if Sub_impl: typeIR_pre `<:` typeIR_post holds
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWNAS` typeIR_post)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:328.1-339.72
   clause 5(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_pre = infer
      -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'''?{infer''' <- infer'''?} matches (_)
      -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
      -- if infer'' matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_post = infer''
      -- if ~Sub_impl: typeIR_pre `<:` typeIR_post holds
      -- if Sub_impl: typeIR_post `<:` typeIR_pre holds
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWNAS` typeIR_pre)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:36.1-36.61
def $merge_constraints(constraint, constraint*) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:341.1-341.61
   clause 0(constraint_pre, constraint*{constraint <- constraint*}) = constraint_pre
      -- if constraint*{constraint <- constraint*} matches []

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:343.1-351.65
   clause 1(constraint_pre_0, constraint*{constraint <- constraint*}) = constraint_pre_2
      -- if constraint*{constraint <- constraint*} matches _ :: _
      -- let constraint_post_h :: constraint_post_t*{constraint_post_t <- constraint_post_t*} = constraint*{constraint <- constraint*}
      -- let constraint_pre_1 = $merge_constraint(constraint_pre_0, constraint_post_h)
      -- let constraint_pre_2 = $merge_constraints(constraint_pre_1, constraint_post_t*{constraint_post_t <- constraint_post_t*})

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:38.1-38.48
def $resolve_constraint(constraint) : inference =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:357.1-359.35
   clause 0(`{` tid `:` infer*{infer <- infer*, tid <- tid*} `}`) = `{` tid `:` typeIR*{tid <- tid*, typeIR <- typeIR*} `}`
      -- (let infer' = infer)*{infer <- infer*, infer' <- infer'*}
      -- (if infer' matches `KNOWNAS%`)*{infer' <- infer'*}
      -- (let `KNOWNAS` typeIR = infer')*{infer' <- infer'*, typeIR <- typeIR*}

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:51.1-51.33
def $lvalue(lvalue) : expression =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:52.1-52.55
   clause 0(lvalue) = referenceExpression as expression
      -- if lvalue <: referenceExpression
      -- let referenceExpression = lvalue as referenceExpression

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:53.1-55.47
   clause 1(lvalue) = expression_base as memberAccessBase `.` member as expression
      -- if lvalue matches `%.%`
      -- let lvalue_base `.` member = lvalue
      -- let expression_base = $lvalue(lvalue_base)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:56.1-58.47
   clause 2(lvalue) = expression_base `[` expression_index `]` as expression
      -- if lvalue matches `%[%]`
      -- let lvalue_base `[` expression_index `]` = lvalue
      -- let expression_base = $lvalue(lvalue_base)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:59.1-61.47
   clause 3(lvalue) = expression_base `[` expression_hi `:` expression_lo `]` as expression
      -- if lvalue matches `%[%:%]`
      -- let lvalue_base `[` expression_hi `:` expression_lo `]` = lvalue
      -- let expression_base = $lvalue(lvalue_base)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:62.1-63.37
   clause 4(lvalue') = `(` expression `)` as expression
      -- if lvalue' matches `(%)`
      -- let `(` lvalue `)` = lvalue'
      -- let expression = $lvalue(lvalue)

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:5.1-5.27
def $empty_theta : theta =

   ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:6.1-6.47
   clause 0 = $empty_map<tid, typeIR>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:8.15-8.31
syntax venv = map<name, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:10.1-10.25
def $empty_venv : venv =

   ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:11.1-11.44
   clause 0 = $empty_map<name, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:13.19-13.35
syntax stateDyn = blockStatementIR

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:15.15-15.34
syntax senv = map<name, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:17.1-17.25
def $empty_senv : senv =

   ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:18.1-18.47
   clause 0 = $empty_map<name, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:25.1-28.34
syntax lvalueDyn = 
   | ``` nameIR
   | `.` nameIR
   | lvalueDyn `.` nameIR
   | lvalueDyn `[` value `]`
   | lvalueDyn `[` value `:` value `]`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:37.1-40.96
syntax funcDyn = 
   | `BUILTIN_FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementListIR `}`
   | `FUNCTION<` typeParameterListIR `>(` parameterListIR `)` blockStatementIR
   | `ACTION(` parameterListIR `){` blockStatementIR `}`
   | `EXTERN_FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementIR? `}`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:43.1-48.41
syntax methodDyn = 
   | `BUILTIN_METHOD(` parameterListIR `)#` lvalueDyn
   | `EXTERN_METHOD<` typeParameterListIR `>(` parameterListIR `)`
   | `EXTERN_METHODABSTRACT<` typeParameterListIR `>(` parameterListIR `)`
   | `PARSER_APPLY(` parameterListIR `){` parserLocalDeclarationListIR `;` senv `}`
   | `CONTROL_APPLY(` parameterListIR `){` controlLocalDeclarationListIR `;` renv `;` blockElementStatementListIR `}`
   | `TABLE_APPLY{` tablePropertyListIR `}`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:51.1-52.14
syntax routineDyn = 
   | `BUILTIN_FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementListIR `}`
   | `FUNCTION<` typeParameterListIR `>(` parameterListIR `)` blockStatementIR
   | `ACTION(` parameterListIR `){` blockStatementIR `}`
   | `EXTERN_FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementIR? `}`
   | `BUILTIN_METHOD(` parameterListIR `)#` lvalueDyn
   | `EXTERN_METHOD<` typeParameterListIR `>(` parameterListIR `)`
   | `EXTERN_METHODABSTRACT<` typeParameterListIR `>(` parameterListIR `)`
   | `PARSER_APPLY(` parameterListIR `){` parserLocalDeclarationListIR `;` senv `}`
   | `CONTROL_APPLY(` parameterListIR `){` controlLocalDeclarationListIR `;` renv `;` blockElementStatementListIR `}`
   | `TABLE_APPLY{` tablePropertyListIR `}`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:55.15-55.35
syntax renv = map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:57.1-57.25
def $empty_renv : renv =

   ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:58.1-58.48
   clause 0 = $empty_map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:65.1-69.42
syntax consDyn = 
   | `EXTERN` nameIR `<` typeParameterListIR `>(` constructorParameterListIR `){` methodPrototypeListIR `}`
   | `PARSER<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` parserLocalDeclarationListIR parserStateListIR `}`
   | `CONTROL<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` controlLocalDeclarationListIR `APPLY` controlBodyIR `}`
   | `PACKAGE<` typeParameterListIR `>(` constructorParameterListIR `)`
   | `TABLE` nameIR `{` tablePropertyListIR `}`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:72.15-72.32
syntax cenv = map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:74.1-74.25
def $empty_cenv : cenv =

   ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:75.1-75.45
   clause 0 = $empty_map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:82.1-86.44
syntax objDyn = 
   | `EXTERN{` tid theta venv renv `}`
   | `PARSER{` venv parameterListIR parserLocalDeclarationListIR senv `}`
   | `CONTROL{` venv parameterListIR controlLocalDeclarationListIR renv controlBodyIR `}`
   | `PACKAGE{` theta venv `}`
   | `TABLE{` tid venv tablePropertyListIR `}`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:89.14-89.30
syntax sto = map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:91.1-91.23
def $empty_sto : sto =

   ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:92.1-92.43
   clause 0 = $empty_map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:93.1-93.37
def $add_sto(sto, oid, objDyn) : sto =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:8.3-11.16
syntax glayerInst = {`CENV` cenv, `TDENV` tdenv, `RENV` renv, `VENV` venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:16.3-19.16
syntax blayerInst = {`THETA` theta, `RENV` renv, `SENV` senv, `VENV` venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:24.3-25.18
syntax llayerInst = {`THETA` theta, `VENVS` venv*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:32.3-35.23
syntax contextInst = {`PATH` oid, `GLOBAL` glayerInst, `BLOCK` blayerInst, `LOCAL` llayerInst}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:43.1-43.32
def $empty_block : blayerInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:45.1-49.23
   clause 0 = {THETA $empty_theta, RENV $empty_renv, SENV $empty_senv, VENV $empty_venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:51.1-51.32
def $empty_local : llayerInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:53.1-55.17
   clause 0 = {THETA $empty_theta, VENVS []}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:57.1-57.40
def $empty_context_inst : contextInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:59.1-67.82
   clause 0 = Ci
      -- let glayerInst = {CENV $empty_cenv, TDENV $empty_tdenv, RENV $empty_renv, VENV $empty_venv}
      -- let blayerInst = $empty_block
      -- let llayerInst = $empty_local
      -- let Ci = {PATH [], GLOBAL glayerInst, BLOCK blayerInst, LOCAL llayerInst}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:74.1-74.43
def $enter_inst(contextInst) : contextInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:76.1-76.73
   clause 0(Ci) = Ci[LOCAL.VENVS = $empty_venv :: Ci.LOCAL.VENVS]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:78.1-78.42
def $exit_inst(contextInst) : contextInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:80.1-81.43
   clause 0(Ci) = Ci[LOCAL.VENVS = venv_t*{venv_t <- venv_t*}]
      -- let venv*{venv <- venv*} = Ci.LOCAL.VENVS
      -- if venv*{venv <- venv*} matches _ :: _
      -- let venv_h :: venv_t*{venv_t <- venv_t*} = venv*{venv <- venv*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:87.1-87.47
def $enter_path(contextInst, id) : contextInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:89.1-89.54
   clause 0(Ci, id) = Ci[PATH = Ci.PATH ++ [id]]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:95.1-95.58
def $copy_context_inst(cursor, contextInst) : contextInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:97.1-97.90
   clause 0(cursor, Ci) = Ci[BLOCK = $empty_block][LOCAL = $empty_local]
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:98.1-98.64
   clause 1(cursor, Ci) = Ci[LOCAL = $empty_local]
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:99.1-99.39
   clause 2(cursor, Ci) = Ci
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:105.1-105.69
def $add_value_inst(cursor, contextInst, nameIR, value) : contextInst =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:106.1-106.72
def $add_values_inst(cursor, contextInst, nameIR*, value*) : contextInst =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:107.1-107.83
def $add_routine_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:108.1-108.87
def $add_routine_non_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:110.1-110.84
def $add_tparams_inst(cursor, contextInst, typeParameterIR*, typeIR*) : contextInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:114.1-114.44
   clause 0(p, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeIR*{typeIR <- typeIR*}) = Ci
      -- if typeParameterIR*{typeParameterIR <- typeParameterIR*} matches []
      -- if typeIR*{typeIR <- typeIR*} matches []

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:115.1-117.68
   clause 1(p, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeIR*{typeIR <- typeIR*}) = $add_tparams_inst(p, Ci', typeParameterIR_t*{typeParameterIR_t <- typeParameterIR_t*}, typeIR_t*{typeIR_t <- typeIR_t*})
      -- if typeParameterIR*{typeParameterIR <- typeParameterIR*} matches _ :: _
      -- let typeParameterIR_h :: typeParameterIR_t*{typeParameterIR_t <- typeParameterIR_t*} = typeParameterIR*{typeParameterIR <- typeParameterIR*}
      -- if typeIR*{typeIR <- typeIR*} matches _ :: _
      -- let typeIR_h :: typeIR_t*{typeIR_t <- typeIR_t*} = typeIR*{typeIR <- typeIR*}
      -- let Ci' = $add_tparams_inst(p, Ci, [typeParameterIR_h], [typeIR_h])

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:111.1-111.81
def $add_tparam_inst(cursor, contextInst, typeParameterIR, typeIR) : contextInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:119.1-120.79
   clause 0(cursor, Ci, typeParameterIR, typeIR) = Ci[BLOCK.THETA = theta]
      -- if cursor matches `BLOCK`
      -- let theta = $add_map<tid, typeIR>(Ci.BLOCK.THETA, typeParameterIR, typeIR)

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:121.1-122.79
   clause 1(cursor, Ci, typeParameterIR, typeIR) = Ci[LOCAL.THETA = theta]
      -- if cursor matches `LOCAL`
      -- let theta = $add_map<tid, typeIR>(Ci.LOCAL.THETA, typeParameterIR, typeIR)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:127.1-127.75
def $add_constructor_inst(cursor, contextInst, cid, consDyn) : contextInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:129.1-130.68
   clause 0(cursor, Ci, cid, consDyn) = Ci[GLOBAL.CENV = cenv]
      -- if cursor matches `GLOBAL`
      -- let cenv = $add_map<cid, consDyn>(Ci.GLOBAL.CENV, cid, consDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:133.1-133.73
def $add_typedef_inst(cursor, contextInst, tid, typeDefIR) : contextInst =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:135.1-136.74
   clause 0(cursor, Ci, tid, typeDefIR) = Ci[GLOBAL.TDENV = tdenv]
      -- if cursor matches `GLOBAL`
      -- let tdenv = $add_map<tid, typeDefIR>(Ci.GLOBAL.TDENV, tid, typeDefIR)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:144.1-144.59
def $find_value_inst(cursor, contextInst, nameIR) : value? =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:147.1-147.66
def $find_type_inst(cursor, contextInst, prefixedNameIR) : typeIR =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:151.1-151.65
def $find_typedef_inst(cursor, contextInst, nameIR) : typeDefIR? =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:155.1-155.44
def $ids_arguments_IR(argumentIR*) : id?* =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:158.1-158.68
   clause 0(argumentIR*{argumentIR <- argumentIR*}) = $id_argument_IR(argumentIR)*{argumentIR <- argumentIR*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:156.1-156.38
def $id_argument_IR(argumentIR) : id? =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:159.1-159.45
   clause 0(argumentIR) = ?()
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:160.1-160.42
   clause 1(argumentIR) = ?(nameIR)
      -- if argumentIR matches `%=%`
      -- let nameIR `=` _typedExpressionIR = argumentIR

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:161.1-161.43
   clause 2(argumentIR) = ?(nameIR)
      -- if argumentIR matches `%=_`
      -- let nameIR `=_` = argumentIR

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:162.1-162.30
   clause 3(argumentIR) = ?()
      -- if argumentIR matches `_`

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:164.1-164.103
def $find_constructor_overloaded_inst(contextInst, prefixedNameIR, argumentIR*) : (rid, consDyn, id*)? =

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:165.1-167.52
   clause 0(Ci, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<consDyn>(Ci.GLOBAL.CENV, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments_IR(argumentIR*{argumentIR <- argumentIR*})

   ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:169.1-171.52
   clause 1(Ci, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<consDyn>(Ci.GLOBAL.CENV, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments_IR(argumentIR*{argumentIR <- argumentIR*})

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:3.1-5.17
relation Program_inst: `|-` p4programIR `==>` cenv tdenv renv venv sto

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:344.1-348.72
   rule : `|-` declarationIR*{declarationIR <- declarationIR*} `;` `==>` Ci_1.GLOBAL.CENV Ci_1.GLOBAL.TDENV Ci_1.GLOBAL.RENV Ci_1.GLOBAL.VENV sto_1
      -- let Ci_0 = $empty_context_inst
      -- let sto_0 = $empty_sto
      -- Decls_inst: `GLOBAL` Ci_0 sto_0 `|-` declarationIR*{declarationIR <- declarationIR*} `==>` Ci_1 sto_1 declarationIR'*{declarationIR' <- declarationIR'*}
      -- if declarationIR'*{declarationIR' <- declarationIR'*} matches []

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:7.1-9.35
relation Constructor_inst: cursor contextInst sto `|-` consDyn `<` typeArgumentListIR `>(` argumentListIR `#` id* `)==>` sto objDyn

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:64.1-68.67
   rule extern: cursor Ci sto `|-` consDyn `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `)==>` sto' `EXTERN{` nameIR Ci'.BLOCK.THETA Ci'.BLOCK.VENV Ci'.BLOCK.RENV `}`
      -- if cursor matches `BLOCK`
      -- if consDyn matches `EXTERN%<%>(%){%}`
      -- let `EXTERN` nameIR `<` typeParameterIR*{typeParameterIR <- typeParameterIR*} `>(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} `}` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`BLOCK`, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, sto)
      -- Methods_inst: `BLOCK` Ci_callee `|-` methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} `==>` Ci'

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:70.1-75.85
   rule parser: cursor Ci sto `|-` consDyn `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `)==>` sto''' `PARSER{` Ci_callee.BLOCK.VENV parameterIR*{parameterIR <- parameterIR*} parserLocalDeclarationIR'*{parserLocalDeclarationIR' <- parserLocalDeclarationIR'*} Ci_state.BLOCK.SENV `}`
      -- if cursor matches `BLOCK`
      -- if consDyn matches `PARSER<%>(%)(%){%%}`
      -- let `PARSER<` typeParameterIR*{typeParameterIR <- typeParameterIR*} `>(` parameterIR*{parameterIR <- parameterIR*} `)(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} `}` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`BLOCK`, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, sto)
      -- ParserLocalDecls_inst: `BLOCK` Ci_callee sto' `|-` parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} `==>` Ci_local sto'' parserLocalDeclarationIR'*{parserLocalDeclarationIR' <- parserLocalDeclarationIR'*}
      -- ParserStates_inst: `BLOCK` Ci_local sto'' `|-` parserStateIR*{parserStateIR <- parserStateIR*} `==>` Ci_state sto'''

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:77.1-82.97
   rule control: cursor Ci sto `|-` consDyn `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `)==>` sto''' `CONTROL{` Ci_callee.BLOCK.VENV parameterIR*{parameterIR <- parameterIR*} controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*} Ci_local.BLOCK.RENV controlBodyIR' `}`
      -- if cursor matches `BLOCK`
      -- if consDyn matches `CONTROL<%>(%)(%){%APPLY%}`
      -- let `CONTROL<` typeParameterIR*{typeParameterIR <- typeParameterIR*} `>(` parameterIR*{parameterIR <- parameterIR*} `)(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} `APPLY` controlBodyIR `}` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`BLOCK`, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, sto)
      -- ControlLocalDecls_inst: `BLOCK` Ci_callee sto' `|-` controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} `==>` Ci_local sto'' controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*}
      -- Block_inst: `LOCAL` Ci_local sto'' true `|-` controlBodyIR `==>` Ci_block sto''' controlBodyIR'

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:84.1-87.160
   rule package: cursor Ci sto `|-` consDyn `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `)==>` sto' `PACKAGE{` Ci_callee.BLOCK.THETA Ci_callee.BLOCK.VENV `}`
      -- if cursor matches `BLOCK`
      -- if consDyn matches `PACKAGE<%>(%)`
      -- let `PACKAGE<` typeParameterIR*{typeParameterIR <- typeParameterIR*} `>(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `)` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`BLOCK`, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, sto)

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:91.1-98.43
   rule table: cursor Ci sto `|-` consDyn `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `)==>` sto' `TABLE{` nameIR venv tablePropertyListIR'' `}`
      -- if cursor matches `LOCAL`
      -- if consDyn matches `TABLE%{%}`
      -- let `TABLE` nameIR `{` tablePropertyListIR `}` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`LOCAL`, Ci, [], [], typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, sto)
      -- let Ci_frame = $enter_inst(Ci_callee)
      -- Table_inst: `LOCAL` Ci_frame sto' `|-` tablePropertyListIR `==>` Ci_table sto'' tablePropertyListIR'
      -- let tablePropertyListIR'' = $init_table(tablePropertyListIR')
      -- let venv'*{venv' <- venv'*} = Ci_table.LOCAL.VENVS
      -- if venv'*{venv' <- venv'*} matches _ :: _
      -- let venv :: _venv*{_venv <- _venv*} = venv'*{venv' <- venv'*}

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:19.1-21.26
relation Exprs_inst: cursor contextInst sto `|-` typedExpressionIR* `==>` sto value*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:23.1-25.26
relation Expr_inst: cursor contextInst sto `|-` typedExpressionIR `==>` sto value

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:8.1-9.41
   rule literalExpressionIR-true: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto `B` true as value
      -- if (expressionIR = `TRUE` as expressionIR)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:11.1-12.43
   rule literalExpressionIR-false: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto `B` false as value
      -- if (expressionIR = `FALSE` as expressionIR)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:15.1-16.39
   rule literalExpressionIR-number-arbint: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto `D` i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `D%`
      -- let `D` i = number

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:18.1-19.43
   rule literalExpressionIR-number-fixint: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto n `S` i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%S%`
      -- let n `S` i = number

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:21.1-22.43
   rule literalExpressionIR-number-fixbit: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto n `W` i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%W%`
      -- let n `W` i = number

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:26.1-27.53
   rule literalExpressionIR-stringLiteral: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto `"` text `"` as value
      -- if expressionIR <: stringLiteral
      -- let `"` text `"` = expressionIR as stringLiteral

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:34.1-36.48
   rule referenceExpressionIR-id: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto value
      -- if expressionIR <: prefixedNameIR
      -- let prefixedNameIR = expressionIR as prefixedNameIR
      -- if prefixedNameIR matches ``%`
      -- let ``` nameIR = prefixedNameIR
      -- let value'?{value' <- value'?} = $find_value_inst(p, Ci, nameIR)
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:40.1-42.48
   rule referenceExpressionIR-dotName: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto value
      -- if expressionIR <: prefixedNameIR
      -- let prefixedNameIR = expressionIR as prefixedNameIR
      -- if prefixedNameIR matches `.%`
      -- let `.` nameIR = prefixedNameIR
      -- let value'?{value' <- value'?} = $find_value_inst(p, Ci, nameIR)
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:46.1-47.40
   rule defaultExpressionIR: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto `DEFAULT` as value
      -- if (expressionIR = `...` as expressionIR)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:53.1-56.32
   rule unaryExpressionIR-lnot: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' value
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `!`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR `==>` sto' value
      -- if ($un_lnot(value) = value)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:60.1-63.32
   rule unaryExpressionIR-bnot: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' value
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `~`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR `==>` sto' value
      -- if ($un_bnot(value) = value)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:67.1-69.61
   rule unaryExpressionIR-plus: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' value
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `+`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR `==>` sto' value

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:73.1-76.33
   rule unaryExpressionIR-minus: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' value
      -- if expressionIR <: unaryExpressionIR
      -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
      -- if unop matches `-`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR `==>` sto' value
      -- if ($un_minus(value) = value)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:83.1-88.43
   rule binaryExpressionIR-mul: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `*`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_mul(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:92.1-97.43
   rule binaryExpressionIR-div: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `/`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_div(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:101.1-106.43
   rule binaryExpressionIR-mod: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `%`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_mod(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:110.1-115.44
   rule binaryExpressionIR-plus: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `+`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_plus(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:119.1-124.45
   rule binaryExpressionIR-minus: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `-`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_minus(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:128.1-133.47
   rule binaryExpressionIR-satplus: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|+|`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_satplus(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:137.1-142.48
   rule binaryExpressionIR-satminus: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|-|`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_satminus(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:146.1-151.43
   rule binaryExpressionIR-shl: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<<`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_shl(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:155.1-160.43
   rule binaryExpressionIR-shr: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>>`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_shr(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:164.1-169.41
   rule binaryExpressionIR-le: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' `B` bool as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<=`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let bool = $bin_le(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:173.1-178.41
   rule binaryExpressionIR-ge: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' `B` bool as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>=`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let bool = $bin_ge(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:182.1-187.41
   rule binaryExpressionIR-lt: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' `B` bool as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `<`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let bool = $bin_lt(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:191.1-196.41
   rule binaryExpressionIR-gt: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' `B` bool as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `>`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let bool = $bin_gt(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:200.1-205.41
   rule binaryExpressionIR-ne: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' `B` bool as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `!=`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let bool = $bin_ne(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:209.1-214.41
   rule binaryExpressionIR-eq: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' `B` bool as value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `==`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let bool = $bin_eq(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:218.1-223.44
   rule binaryExpressionIR-band: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `&`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_band(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:227.1-232.44
   rule binaryExpressionIR-bxor: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `^`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_bxor(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:236.1-241.43
   rule binaryExpressionIR-bor: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `|`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_bor(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:245.1-250.46
   rule binaryExpressionIR-concat: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `++`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_concat(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:254.1-259.44
   rule binaryExpressionIR-land: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `&&`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_land(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:262.1-267.43
   rule binaryExpressionIR-lor: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value
      -- if expressionIR <: binaryExpressionIR
      -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
      -- if binop matches `||`
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_l `==>` sto' value_l
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_r `==>` sto'' value_r
      -- let value = $bin_lor(value_l, value_r)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:274.1-279.67
   rule ternaryExpressionIR-then: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value_t
      -- if expressionIR <: ternaryExpressionIR
      -- let typedExpressionIR_c `?` typedExpressionIR_t `:` typedExpressionIR_e = expressionIR as ternaryExpressionIR
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_c `==>` sto' value_c
      -- if (value_c = `B` true as value)
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_t `==>` sto'' value_t

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:281.1-286.67
   rule ternaryExpressionIR-else: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' value_e
      -- if expressionIR <: ternaryExpressionIR
      -- let typedExpressionIR_c `?` typedExpressionIR_t `:` typedExpressionIR_e = expressionIR as ternaryExpressionIR
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_c `==>` sto' value_c
      -- if (value_c = `B` false as value)
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_e `==>` sto'' value_e

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:293.1-297.42
   rule castExpressionIR: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' value_c
      -- if expressionIR <: castExpressionIR
      -- let `(` typeIR `)` typedExpressionIR = expressionIR as castExpressionIR
      -- Expr_inst: p Ci sto `|-` typedExpressionIR `==>` sto' value
      -- let value_c = $cast_op(typeIR, value)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:305.1-307.17
   rule dataExpressionIR-invalid: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto `{#}` as value
      -- if (expressionIR = `{#}` as expressionIR)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:311.1-314.67
   rule dataExpressionIR-sequence: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' `SEQ(` value*{value <- value*} `)` as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SEQ{%}`
      -- let `SEQ{` typedExpressionListIR `}` = dataExpressionIR
      -- Exprs_inst: p Ci sto `|-` typedExpressionListIR `==>` sto' value*{value <- value*}

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:318.1-321.67
   rule dataExpressionIR-sequencedefault: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' `SEQ(` value*{value <- value*} `,...)` as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SEQ{%,...}`
      -- let `SEQ{` typedExpressionListIR `,...}` = dataExpressionIR
      -- Exprs_inst: p Ci sto `|-` typedExpressionListIR `==>` sto' value*{value <- value*}

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:325.1-328.64
   rule dataExpressionIR-record: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' `RECORD{` value nameIR `;`*{nameIR <- nameIR*, value <- value*} `}` as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RECORD{%}`
      -- let `RECORD{` nameIR `=` typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} `}` = dataExpressionIR
      -- Exprs_inst: p Ci sto `|-` typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} `==>` sto' value*{value <- value*}

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:332.1-335.64
   rule dataExpressionIR-recorddefault: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' `RECORD{` value nameIR `;`*{nameIR <- nameIR*, value <- value*} `,...}` as value
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RECORD{%,...}`
      -- let `RECORD{` nameIR `=` typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} `,...}` = dataExpressionIR
      -- Exprs_inst: p Ci sto `|-` typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} `==>` sto' value*{value <- value*}

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:346.1-350.49
   rule accessExpressionIR-errorAccessExpressionIR: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto value
      -- if expressionIR <: errorAccessExpressionIR
      -- let `ERROR.` nameIR = expressionIR as errorAccessExpressionIR
      -- let nameIR' = $concat_text(["error.", nameIR])
      -- let value'?{value' <- value'?} = $find_value_inst(p, Ci, nameIR')
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:359.1-364.41
   rule accessExpressionIR-memberAccessExpressionIR-typeaccess-enum: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto tid `.` nameIR as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR `.` nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR matches `TYPE%`
      -- let `TYPE` prefixedNameIR = memberAccessBaseIR
      -- let nameIR_type = $flatten_prefixedNameIR(prefixedNameIR)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, nameIR_type)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- let typeIR' = $canon(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:366.1-372.65
   rule accessExpressionIR-memberAccessExpressionIR-senum: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto tid `.` nameIR `#` value as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR `.` nameIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR matches `TYPE%`
      -- let `TYPE` prefixedNameIR = memberAccessBaseIR
      -- let nameIR_type = $flatten_prefixedNameIR(prefixedNameIR)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, nameIR_type)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- let typeIR' = $canon(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` _typeIR `{` id_f `=` value_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = enumTypeIR
      -- let value'?{value' <- value'?} = $assoc_<nameIR, value>(nameIR, (id_f, value_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:376.1-380.39
   rule accessExpressionIR-memberAccessExpressionIR-typedExpressionIR: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' `D` nat_s as int as value
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessBaseIR `.` text = expressionIR as memberAccessExpressionIR
      -- if memberAccessBaseIR <: typedExpressionIR
      -- let typedExpressionIR = memberAccessBaseIR as typedExpressionIR
      -- if (text = "size")
      -- Expr_inst: p Ci sto `|-` typedExpressionIR `==>` sto' value
      -- let value' = value
      -- if value' <: headerStackValue
      -- let `[` _value*{_value <- _value*} `#(` _nat `;` nat_s `)]` = value' as headerStackValue

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:388.1-394.54
   rule indexAccessExpressionIR-bitslice: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto''' value
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `%[%:%]`
      -- let typedExpressionIR_b `[` typedExpressionIR_l `:` typedExpressionIR_h `]` = indexAccessExpressionIR
      -- Expr_inst: p Ci sto `|-` typedExpressionIR_b `==>` sto' value_b
      -- Expr_inst: p Ci sto' `|-` typedExpressionIR_l `==>` sto'' value_l
      -- Expr_inst: p Ci sto'' `|-` typedExpressionIR_h `==>` sto''' value_h
      -- let value = $bitacc_op(value_b, value_l, value_h)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:400.1-405.48
   rule callExpressionIR-instantiation: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto'' `!` Ci.PATH as value
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%(%)`
      -- let prefixedNameIR `<` typeArgumentListIR `>` `(` argumentListIR `)` = callExpressionIR
      -- let (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentListIR)
      -- if (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} matches (_)
      -- let ?((_rid, consDyn, id_default*{id_default <- id_default*})) = (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?}
      -- Constructor_inst: p Ci sto `|-` consDyn `<` typeArgumentListIR `>(` argumentListIR `#` id_default*{id_default <- id_default*} `)==>` sto' objDyn
      -- let sto'' = $add_sto(sto', Ci.PATH, objDyn)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:410.1-415.38
   rule callExpressionIR-methodTarget-generic: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto value
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` = callExpressionIR
      -- if routineTargetIR matches `%.%`
      -- let typedExpressionIR `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
      -- let value = $size(typeIR, nameIR)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:417.1-422.38
   rule callExpressionIR-methodTarget-non-generic: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto value
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%<%>(%)`
      -- let routineTargetIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` = callExpressionIR
      -- if routineTargetIR matches `TYPE%.%`
      -- let `TYPE` prefixedNameIR `.` nameIR = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
      -- let typeIR = $find_type_inst(p, Ci, prefixedNameIR)
      -- let value = $size(typeIR, nameIR)

   ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:427.1-430.61
   rule parenthesizedExpressionIR: p Ci sto `|-` expressionIR `#` _expressionNoteIR `==>` sto' value
      -- if expressionIR <: parenthesizedExpressionIR
      -- let `(` typedExpressionIR `)` = expressionIR as parenthesizedExpressionIR
      -- Expr_inst: p Ci sto `|-` typedExpressionIR `==>` sto' value

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:27.1-29.26
relation Argument_inst: cursor contextInst sto `|-` argumentIR `==>` sto value

   ;; ../../../../spec-concrete/6.06-instantiation-argument.watsup:7.1-9.61
   rule expression: p Ci sto `|-` argumentIR `==>` sto' value
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR
      -- Expr_inst: p Ci sto `|-` typedExpressionIR `==>` sto' value

   ;; ../../../../spec-concrete/6.06-instantiation-argument.watsup:13.1-15.61
   rule namedexpression: p Ci sto `|-` argumentIR `==>` sto' value
      -- if argumentIR matches `%=%`
      -- let nameIR `=` typedExpressionIR = argumentIR
      -- Expr_inst: p Ci sto `|-` typedExpressionIR `==>` sto' value

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:35.1-37.26
relation Decls_inst: cursor contextInst sto `|-` declarationIR* `==>` contextInst sto declarationIR*

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:350.1-351.33
   rule nil: p Ci sto `|-` declarationIR*{declarationIR <- declarationIR*} `==>` Ci sto []
      -- if declarationIR*{declarationIR <- declarationIR*} matches []

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:353.1-357.83
   rule cons-none: p Ci_0 sto_0 `|-` declarationIR*{declarationIR <- declarationIR*} `==>` Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
      -- if declarationIR*{declarationIR <- declarationIR*} matches _ :: _
      -- let declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*} = declarationIR*{declarationIR <- declarationIR*}
      -- Decl_inst: p Ci_0 sto_0 `|-` declarationIR_h `==>` Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
      -- if declarationIR'?{declarationIR' <- declarationIR'?} matches ()
      -- Decls_inst: p Ci_1 sto_1 `|-` declarationIR_t*{declarationIR_t <- declarationIR_t*} `==>` Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:359.1-363.83
   rule cons-some: p Ci_0 sto_0 `|-` declarationIR*{declarationIR <- declarationIR*} `==>` Ci_2 sto_2 declarationIR_h' :: declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
      -- if declarationIR*{declarationIR <- declarationIR*} matches _ :: _
      -- let declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*} = declarationIR*{declarationIR <- declarationIR*}
      -- Decl_inst: p Ci_0 sto_0 `|-` declarationIR_h `==>` Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
      -- if declarationIR'?{declarationIR' <- declarationIR'?} matches (_)
      -- let ?(declarationIR_h') = declarationIR'?{declarationIR' <- declarationIR'?}
      -- Decls_inst: p Ci_1 sto_1 `|-` declarationIR_t*{declarationIR_t <- declarationIR_t*} `==>` Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:39.1-41.26
relation Decl_inst: cursor contextInst sto `|-` declarationIR `==>` contextInst sto declarationIR?

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:11.1-13.60
   rule constantDeclarationIR-global: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: constantDeclarationIR
      -- let _annotationList `CONST` typeIR nameIR `=` value `;` = declarationIR as constantDeclarationIR
      -- let Ci_1 = $add_value_inst(`GLOBAL`, Ci_0, nameIR, value)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:15.1-18.55
   rule constantDeclarationIR-non-global: p Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?(annotationList `CONST` typeIR nameIR `=` value `;` as declarationIR)
      -- if declarationIR <: constantDeclarationIR
      -- let annotationList `CONST` typeIR nameIR `=` value `;` = declarationIR as constantDeclarationIR
      -- let Ci_1 = $add_value_inst(p, Ci_0, nameIR, value)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:26.1-36.84
   rule instantiationIR-extern: p Ci_0 sto_0 `|-` declarationIR `==>` Ci_0 sto_2 ?()
      -- if declarationIR <: instantiationIR
      -- let _annotationList prefixedNameIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;` = declarationIR as instantiationIR
      -- let (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR)
      -- if (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} matches (_)
      -- let ?((_rid, consDyn, id_default*{id_default <- id_default*})) = (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?}
      -- let Ci_1 = $enter_path(Ci_0, nameIR)
      -- Constructor_inst: p Ci_1 sto_0 `|-` consDyn `<` typeArgumentListIR `>(` argumentListIR `#` id_default*{id_default <- id_default*} `)==>` sto_1 objDyn
      -- let objDyn' = objDyn
      -- if objDyn' matches `EXTERN{%%%%}`
      -- let `EXTERN{` tid theta venv renv `}` = objDyn'
      -- let Ci_2 = {PATH Ci_1.PATH ++ [nameIR], GLOBAL Ci_1.GLOBAL, BLOCK $empty_block, LOCAL $empty_local}
      -- let objectDeclarationListIR = $get_init_decls(objectInitializerOptIR)
      -- ObjectDecls_inst: `BLOCK` Ci_2 sto_1 `|-` objectDeclarationListIR `==>` Ci_3 sto_2 _objectDeclarationListIR

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:38.1-44.49
   rule instantiationIR-non-extern: p Ci_0 sto_0 `|-` declarationIR `==>` Ci_0 sto_1 ?()
      -- if declarationIR <: instantiationIR
      -- let _annotationList prefixedNameIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;` = declarationIR as instantiationIR
      -- let (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR)
      -- if (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} matches (_)
      -- let ?((_rid, consDyn, id_default*{id_default <- id_default*})) = (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?}
      -- let Ci_1 = $enter_path(Ci_0, nameIR)
      -- Constructor_inst: p Ci_1 sto_0 `|-` consDyn `<` typeArgumentListIR `>(` argumentListIR `#` id_default*{id_default <- id_default*} `)==>` sto_1 objDyn
      -- let objDyn' = objDyn
      -- if objDyn' matches `EXTERN{%%%%}`
      -- let `EXTERN{` tid theta venv renv `}` = objDyn'

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:64.1-72.65
   rule functionDeclarationIR: p Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if declarationIR <: functionDeclarationIR
      -- let _annotationList typeIR nameIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>(` parameterListIR `)` blockStatementIR = declarationIR as functionDeclarationIR
      -- let rid = $rid_IR(nameIR, parameterListIR)
      -- let funcDyn = `FUNCTION<` typeParameterListIR ++ typeParameterListIR_inferred `>(` parameterListIR `)` blockStatementIR
      -- let Ci_1 = $add_routine_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:78.1-82.69
   rule action: p Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if declarationIR <: actionDeclarationIR
      -- let _annotationList `ACTION` nameIR `(` parameterListIR `)` blockStatementIR = declarationIR as actionDeclarationIR
      -- let rid = $rid_IR(nameIR, parameterListIR)
      -- let funcDyn = `ACTION(` parameterListIR `){` blockStatementIR `}`
      -- let Ci_1 = $add_routine_non_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:88.1-91.81
   rule errorDeclarationIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: errorDeclarationIR
      -- let `ERROR{` nameIR*{nameIR <- nameIR*} `}` = declarationIR as errorDeclarationIR
      -- (let nameIR_field = $concat_text(["error.", nameIR]))*{nameIR <- nameIR*, nameIR_field <- nameIR_field*}
      -- let Ci_1 = $add_values_inst(`GLOBAL`, Ci_0, nameIR_field*{nameIR_field <- nameIR_field*}, `ERROR.` nameIR as value*{nameIR <- nameIR*})

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:97.1-99.80
   rule matchKindDeclarationIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: matchKindDeclarationIR
      -- let `MATCH_KIND{` nameIR*{nameIR <- nameIR*} `}` = declarationIR as matchKindDeclarationIR
      -- let Ci_1 = $add_values_inst(`GLOBAL`, Ci_0, nameIR*{nameIR <- nameIR*}, `MATCH_KIND.` nameIR as value*{nameIR <- nameIR*})

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:107.1-117.65
   rule externFunctionDeclarationIR: p Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if declarationIR <: externFunctionDeclarationIR
      -- let _annotationList `EXTERN` typeIR nameIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>(` parameterListIR `)` `;` = declarationIR as externFunctionDeclarationIR
      -- let rid = $rid_IR(nameIR, parameterListIR)
      -- let funcDyn = `EXTERN_FUNCTION<` typeParameterListIR ++ typeParameterListIR_inferred `>(` parameterListIR `){` ?() `}`
      -- let Ci_1 = $add_routine_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:133.1-143.60
   rule parserDeclarationIR: p Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if declarationIR <: parserDeclarationIR
      -- let _annotationList `PARSER` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` parserLocalDeclarationListIR parserStateListIR `}` = declarationIR as parserDeclarationIR
      -- let cid = $cid_IR(nameIR, constructorParameterListIR)
      -- let consDyn = `PARSER<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` parserLocalDeclarationListIR parserStateListIR `}`
      -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:152.1-162.60
   rule controlDeclarationIR: p Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if declarationIR <: controlDeclarationIR
      -- let _annotationList `CONTROL` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` controlLocalDeclarationListIR `APPLY` controlBodyIR `}` = declarationIR as controlDeclarationIR
      -- let cid = $cid_IR(nameIR, constructorParameterListIR)
      -- let consDyn = `CONTROL<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` controlLocalDeclarationListIR `APPLY` controlBodyIR `}`
      -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:175.1-179.85
   rule typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum: cursor Ci_0 sto `|-` declarationIR `==>` Ci_2 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: enumTypeDeclarationIR
      -- let enumTypeDeclarationIR = declarationIR as enumTypeDeclarationIR
      -- if enumTypeDeclarationIR matches `%ENUM%{%}`
      -- let _annotationList `ENUM` nameIR `{` nameIR_mem*{nameIR_mem <- nameIR_mem*} `}` = enumTypeDeclarationIR
      -- (let nameIR_path = $concat_text([nameIR, ".", nameIR_mem]))*{nameIR_mem <- nameIR_mem*, nameIR_path <- nameIR_path*}
      -- let Ci_1 = $add_values_inst(`GLOBAL`, Ci_0, nameIR_path*{nameIR_path <- nameIR_path*}, nameIR `.` nameIR_mem as value*{nameIR_mem <- nameIR_mem*})
      -- let Ci_2 = $add_typedef_inst(`GLOBAL`, Ci_1, nameIR, `ENUM` nameIR `{` nameIR_mem*{nameIR_mem <- nameIR_mem*} `}` as typeDefIR)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:184.1-189.113
   rule typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum: cursor Ci_0 sto_0 `|-` declarationIR `==>` Ci_2 sto_1 ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: enumTypeDeclarationIR
      -- let enumTypeDeclarationIR = declarationIR as enumTypeDeclarationIR
      -- if enumTypeDeclarationIR matches `%ENUM%%{%}`
      -- let _annotationList `ENUM` typeIR nameIR `{` nameIR_mem `=` typedExpressionIR*{nameIR_mem <- nameIR_mem*, typedExpressionIR <- typedExpressionIR*} `}` = enumTypeDeclarationIR
      -- (let nameIR_path = $concat_text([nameIR, ".", nameIR_mem]))*{nameIR_mem <- nameIR_mem*, nameIR_path <- nameIR_path*}
      -- Exprs_inst: `GLOBAL` Ci_0 sto_0 `|-` typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} `==>` sto_1 value_mem*{value_mem <- value_mem*}
      -- let Ci_1 = $add_values_inst(`GLOBAL`, Ci_0, nameIR_path*{nameIR_path <- nameIR_path*}, nameIR `.` nameIR_mem `#` value_mem as value*{nameIR_mem <- nameIR_mem*, value_mem <- value_mem*})
      -- let Ci_2 = $add_typedef_inst(`GLOBAL`, Ci_1, nameIR, `ENUM` nameIR `#` typeIR `{` nameIR_mem `=` value_mem `;`*{nameIR_mem <- nameIR_mem*, value_mem <- value_mem*} `}` as typeDefIR)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:197.1-206.66
   rule typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: structTypeDeclarationIR
      -- let _annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>{` typeFieldIR*{typeFieldIR <- typeFieldIR*} `}` = declarationIR as structTypeDeclarationIR
      -- (let _annotationList' typeIR nameIR_field `;` = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
      -- let typeDefIR = `STRUCT` nameIR `{` typeIR nameIR_field `;`*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} `}` as typeIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>` as typeDefIR
      -- let Ci_1 = $add_typedef_inst(`GLOBAL`, Ci_0, nameIR, typeDefIR)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:214.1-223.66
   rule typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: headerTypeDeclarationIR
      -- let _annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>{` typeFieldIR*{typeFieldIR <- typeFieldIR*} `}` = declarationIR as headerTypeDeclarationIR
      -- (let _annotationList' typeIR nameIR_field `;` = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
      -- let typeDefIR = `HEADER` nameIR `{` typeIR nameIR_field `;`*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} `}` as typeIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>` as typeDefIR
      -- let Ci_1 = $add_typedef_inst(`GLOBAL`, Ci_0, nameIR, typeDefIR)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:231.1-240.66
   rule typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: headerUnionTypeDeclarationIR
      -- let _annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>{` typeFieldIR*{typeFieldIR <- typeFieldIR*} `}` = declarationIR as headerUnionTypeDeclarationIR
      -- (let _annotationList' typeIR nameIR_field `;` = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
      -- let typeDefIR = `HEADER_UNION` nameIR `{` typeIR nameIR_field `;`*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} `}` as typeIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>` as typeDefIR
      -- let Ci_1 = $add_typedef_inst(`GLOBAL`, Ci_0, nameIR, typeDefIR)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:250.1-254.71
   rule typeDeclarationIR-typedefDeclarationIR-typedef-typeIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: typedefDeclarationIR
      -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
      -- if typedefDeclarationIR matches `%TYPEDEF%%;`
      -- let _annotationList `TYPEDEF` typedefTypeIR nameIR `;` = typedefDeclarationIR
      -- if typedefTypeIR <: typeIR
      -- let typeIR = typedefTypeIR as typeIR
      -- let typeIR_typedef = `TYPEDEF` nameIR typeIR as typeIR
      -- let Ci_1 = $add_typedef_inst(`GLOBAL`, Ci_0, nameIR, typeIR_typedef as typeDefIR)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:258.1-267.71
   rule typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: typedefDeclarationIR
      -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
      -- if typedefDeclarationIR matches `%TYPEDEF%%;`
      -- let _annotationList `TYPEDEF` typedefTypeIR nameIR `;` = typedefDeclarationIR
      -- if typedefTypeIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = typedefTypeIR as derivedTypeDeclarationIR
      -- Decl_inst: `GLOBAL` Ci_0 $empty_sto `|-` derivedTypeDeclarationIR as declarationIR `==>` Ci_local _sto _declarationIR?{_declarationIR <- _declarationIR?}
      -- let `{` tid*{tid <- tid*} `}` = $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_0.GLOBAL.TDENV), $dom_map<tid, typeDefIR>(Ci_local.GLOBAL.TDENV))
      -- if tid*{tid <- tid*} matches [ _/1 ]
      -- let [tid_newtype] = tid*{tid <- tid*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(`GLOBAL`, Ci_local, tid_newtype)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- let typeDefIR'' = typeDefIR
      -- if typeDefIR'' <: monoTypeDefIR
      -- let monoTypeDefIR = typeDefIR'' as monoTypeDefIR
      -- let typeIR_typedef = `TYPEDEF` nameIR monoTypeDefIR as typeIR
      -- let Ci_1 = $add_typedef_inst(`GLOBAL`, Ci_0, nameIR, typeIR_typedef as typeDefIR)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:269.1-278.71
   rule typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: typedefDeclarationIR
      -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
      -- if typedefDeclarationIR matches `%TYPEDEF%%;`
      -- let _annotationList `TYPEDEF` typedefTypeIR nameIR `;` = typedefDeclarationIR
      -- if typedefTypeIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = typedefTypeIR as derivedTypeDeclarationIR
      -- Decl_inst: `GLOBAL` Ci_0 $empty_sto `|-` derivedTypeDeclarationIR as declarationIR `==>` Ci_local _sto _declarationIR?{_declarationIR <- _declarationIR?}
      -- let `{` tid*{tid <- tid*} `}` = $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_0.GLOBAL.TDENV), $dom_map<tid, typeDefIR>(Ci_local.GLOBAL.TDENV))
      -- if tid*{tid <- tid*} matches [ _/1 ]
      -- let [tid_newtype] = tid*{tid <- tid*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(`GLOBAL`, Ci_local, tid_newtype)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- let typeDefIR'' = typeDefIR
      -- if typeDefIR'' <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR'' as polyTypeDefIR
      -- let typeIR_typedef = `TYPEDEF` nameIR polyTypeDefIR `<` [] `>` as typeIR as typeIR
      -- let Ci_1 = $add_typedef_inst(`GLOBAL`, Ci_0, nameIR, typeIR_typedef as typeDefIR)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:282.1-286.71
   rule typeDeclarationIR-typedefDeclarationIR-newtype: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: typedefDeclarationIR
      -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
      -- if typedefDeclarationIR matches `%TYPE%%;`
      -- let _annotationList `TYPE` typeIR nameIR `;` = typedefDeclarationIR
      -- let typeIR_newtype = `TYPE` nameIR typeIR as typeIR
      -- let Ci_1 = $add_typedef_inst(`GLOBAL`, Ci_0, nameIR, typeIR_newtype as typeDefIR)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:294.1-303.73
   rule typeDeclarationIR-parserTypeDeclarationIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: parserTypeDeclarationIR
      -- let _annotationList `PARSER` nameIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>(` parameterIR*{parameterIR <- parameterIR*} `);` = declarationIR as parserTypeDeclarationIR
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let typeIR_parser = `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeDefIR_parser = typeIR_parser `<` typeParameterListIR `,` typeParameterListIR_inferred `>` as typeDefIR
      -- let Ci_1 = $add_typedef_inst(`GLOBAL`, Ci_0, nameIR, typeDefIR_parser)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:311.1-320.73
   rule typeDeclarationIR-controlTypeDeclarationIR: cursor Ci_0 sto `|-` declarationIR `==>` Ci_1 sto ?()
      -- if cursor matches `GLOBAL`
      -- if declarationIR <: controlTypeDeclarationIR
      -- let _annotationList `CONTROL` nameIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>(` parameterIR*{parameterIR <- parameterIR*} `);` = declarationIR as controlTypeDeclarationIR
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let typeIR_parser = `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeDefIR_parser = typeIR_parser `<` typeParameterListIR `,` typeParameterListIR_inferred `>` as typeDefIR
      -- let Ci_1 = $add_typedef_inst(`GLOBAL`, Ci_0, nameIR, typeDefIR_parser)

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:329.1-342.73
   rule typeDeclarationIR-packageTypeDeclarationIR: p Ci_0 sto `|-` declarationIR `==>` Ci_2 sto ?()
      -- if declarationIR <: packageTypeDeclarationIR
      -- let _annotationList `PACKAGE` nameIR `<` typeParameterListIR `,` typeParameterListIR_inferred `>(` parameterIR*{parameterIR <- parameterIR*} `);` = declarationIR as packageTypeDeclarationIR
      -- (let _annotationList' _direction typeIR _nameIR _constantInitializerOptIR = parameterIR)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _nameIR <- _nameIR*, parameterIR <- parameterIR*, typeIR <- typeIR*}
      -- let typeIR_package = `PACKAGE<` typeIR*{typeIR <- typeIR*} `>` as typeIR
      -- let typeDefIR_package = typeIR_package `<` typeParameterListIR `,` typeParameterListIR_inferred `>` as typeDefIR
      -- let Ci_1 = $add_typedef_inst(p, Ci_0, nameIR, typeDefIR_package)
      -- let cid = $cid_IR(nameIR, parameterIR*{parameterIR <- parameterIR*})
      -- let consDyn_package = `PACKAGE<` typeParameterListIR ++ typeParameterListIR_inferred `>(` parameterIR*{parameterIR <- parameterIR*} `)`
      -- let Ci_2 = $add_constructor_inst(`GLOBAL`, Ci_1, cid, consDyn_package)

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:43.1-45.26
relation ParserLocalDecl_inst: cursor contextInst sto `|-` parserLocalDeclarationIR `==>` contextInst sto parserLocalDeclarationIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:47.1-49.26
relation ParserLocalDecls_inst: cursor contextInst sto `|-` parserLocalDeclarationListIR `==>` contextInst sto parserLocalDeclarationListIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:51.1-53.26
relation ControlLocalDecl_inst: cursor contextInst sto `|-` controlLocalDeclarationIR `==>` contextInst sto controlLocalDeclarationIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:55.1-57.26
relation ControlLocalDecls_inst: cursor contextInst sto `|-` controlLocalDeclarationListIR `==>` contextInst sto controlLocalDeclarationListIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:59.1-61.26
relation ObjectDecls_inst: cursor contextInst sto `|-` objectDeclarationListIR `==>` contextInst sto objectDeclarationListIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:66.1-68.23
relation Methods_inst: cursor contextInst `|-` methodPrototypeIR* `==>` contextInst

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:70.1-72.23
relation Method_inst: cursor contextInst `|-` methodPrototypeIR `==>` contextInst

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:78.1-80.26
relation Stmts_inst: cursor contextInst sto `|-` statementIR* `==>` contextInst sto statementIR*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:82.1-84.26
relation Stmt_inst: cursor contextInst sto `|-` statementIR `==>` contextInst sto statementIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:9.1-10.59
   rule emptyStatementIR: p Ci sto `|-` statementIR `==>` Ci sto emptyStatementIR as statementIR
      -- if statementIR <: emptyStatementIR
      -- let emptyStatementIR = statementIR as emptyStatementIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:14.1-15.69
   rule assignmentStatementIR: p Ci sto `|-` statementIR `==>` Ci sto assignmentStatementIR as statementIR
      -- if statementIR <: assignmentStatementIR
      -- let assignmentStatementIR = statementIR as assignmentStatementIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:25.1-39.82
   rule directApplicationStatementIR: p Ci sto_0 `|-` statementIR `==>` Ci sto_2 blockStatementIR as statementIR
      -- if statementIR <: directApplicationStatementIR
      -- let prefixedNameIR `.APPLY(` argumentListIR `);` = statementIR as directApplicationStatementIR
      -- let (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, [])
      -- if (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} matches (_)
      -- let ?((_rid, consDyn, _id*{_id <- _id*})) = (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?}
      -- Constructor_inst: p Ci sto_0 `|-` consDyn `<` [] `>(` [] `#` [] `)==>` sto_1 objDyn
      -- let tid_fresh = $fresh_tid
      -- let tid = $flatten_prefixedNameIR(prefixedNameIR)
      -- let typeIR = `TID` tid as typeIR
      -- let nameIR = $concat_text([tid, "_", tid_fresh])
      -- let oid = Ci.PATH ++ [nameIR]
      -- let sto_2 = $add_sto(sto_1, oid, objDyn)
      -- let constantDeclarationIR = ``EMPTY` `CONST` typeIR nameIR `=` `!` oid as value `;`
      -- let routineTargetIR = ``` tid as expressionIR `#` `(` typeIR `CTK` `)` `.` "apply"
      -- let callStatementIR = routineTargetIR `<` [] `>(` argumentListIR `);`
      -- let blockStatementIR = ``EMPTY` `{` [constantDeclarationIR as blockElementStatementIR, callStatementIR as blockElementStatementIR] `}`

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:43.1-44.61
   rule returnStatementIR: p Ci sto `|-` statementIR `==>` Ci sto returnStatementIR as statementIR
      -- if statementIR <: returnStatementIR
      -- let returnStatementIR = statementIR as returnStatementIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:48.1-49.57
   rule exitStatementIR: p Ci sto `|-` statementIR `==>` Ci sto exitStatementIR as statementIR
      -- if statementIR <: exitStatementIR
      -- let exitStatementIR = statementIR as exitStatementIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:54.1-57.111
   rule blockStatementIR: p Ci sto `|-` statementIR `==>` Ci' sto' annotationList `{` blockElementStatementListIR' `}` as statementIR
      -- if statementIR <: blockStatementIR
      -- let annotationList `{` blockElementStatementListIR `}` = statementIR as blockStatementIR
      -- BlockElementStmts_inst: p Ci sto `|-` blockElementStatementListIR `==>` Ci' sto' blockElementStatementListIR'

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:64.1-67.64
   rule conditionalStatementIR-non-else: p Ci sto `|-` statementIR'' `==>` Ci sto' `IF(` typedExpressionIR `)` statementIR' as statementIR
      -- if statementIR'' <: conditionalStatementIR
      -- let conditionalStatementIR = statementIR'' as conditionalStatementIR
      -- if conditionalStatementIR matches `IF(%)%`
      -- let `IF(` typedExpressionIR `)` statementIR = conditionalStatementIR
      -- Stmt_inst: p Ci sto `|-` statementIR `==>` _contextInst sto' statementIR'

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:71.1-75.76
   rule conditionalStatementIR-else: p Ci sto `|-` statementIR `==>` Ci sto'' `IF(` typedExpressionIR `)` statementIR_then' `ELSE` statementIR_else' as statementIR
      -- if statementIR <: conditionalStatementIR
      -- let conditionalStatementIR = statementIR as conditionalStatementIR
      -- if conditionalStatementIR matches `IF(%)%ELSE%`
      -- let `IF(` typedExpressionIR `)` statementIR_then `ELSE` statementIR_else = conditionalStatementIR
      -- Stmt_inst: p Ci sto `|-` statementIR_then `==>` _contextInst sto' statementIR_then'
      -- Stmt_inst: p Ci sto' `|-` statementIR_else `==>` _contextInst' sto'' statementIR_else'

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:81.1-82.59
   rule breakStatementIR: p Ci sto `|-` statementIR `==>` Ci sto breakStatementIR as statementIR
      -- if statementIR <: breakStatementIR
      -- let breakStatementIR = statementIR as breakStatementIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:86.1-87.65
   rule continueStatementIR: p Ci sto `|-` statementIR `==>` Ci sto continueStatementIR as statementIR
      -- if statementIR <: continueStatementIR
      -- let continueStatementIR = statementIR as continueStatementIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:92.1-95.83
   rule switchStatementIR: p Ci sto `|-` statementIR `==>` Ci' sto' `SWITCH(` typedExpressionIR `){` switchCaseListIR' `}` as statementIR
      -- if statementIR <: switchStatementIR
      -- let `SWITCH(` typedExpressionIR `){` switchCaseListIR `}` = statementIR as switchStatementIR
      -- SwitchCases_inst: p Ci sto `|-` switchCaseListIR `==>` Ci' sto' switchCaseListIR'

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:86.1-88.26
relation BlockElementStmt_inst: cursor contextInst sto `|-` blockElementStatementIR `==>` contextInst sto blockElementStatementIR?

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:110.1-112.86
   rule constantDeclarationIR: p Ci sto `|-` blockElementStatementIR `==>` Ci' sto' ?(constantDeclarationIR' as blockElementStatementIR)
      -- if blockElementStatementIR <: constantDeclarationIR
      -- let constantDeclarationIR = blockElementStatementIR as constantDeclarationIR
      -- Decl_inst: p Ci sto `|-` constantDeclarationIR as declarationIR `==>` Ci' sto' declarationIR'?{declarationIR' <- declarationIR'?}
      -- if declarationIR'?{declarationIR' <- declarationIR'?} matches (_)
      -- let ?(declarationIR) = declarationIR'?{declarationIR' <- declarationIR'?}
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR' = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:116.1-117.56
   rule variableDeclarationIR-global: cursor Ci sto `|-` blockElementStatementIR `==>` Ci sto ?()
      -- if cursor matches `GLOBAL`
      -- if blockElementStatementIR <: variableDeclarationIR
      -- let variableDeclarationIR = blockElementStatementIR as variableDeclarationIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:119.1-120.69
   rule variableDeclarationIR-non-global: p Ci sto `|-` blockElementStatementIR `==>` Ci sto ?(variableDeclarationIR as blockElementStatementIR)
      -- if blockElementStatementIR <: variableDeclarationIR
      -- let variableDeclarationIR = blockElementStatementIR as variableDeclarationIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:124.1-126.66
   rule statementIR: p Ci sto `|-` blockElementStatementIR `==>` Ci' sto' ?(statementIR' as blockElementStatementIR)
      -- if blockElementStatementIR <: statementIR
      -- let statementIR = blockElementStatementIR as statementIR
      -- Stmt_inst: p Ci sto `|-` statementIR `==>` Ci' sto' statementIR'

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:90.1-92.26
relation BlockElementStmts_inst: cursor contextInst sto `|-` blockElementStatementIR* `==>` contextInst sto blockElementStatementIR*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:94.1-96.26
relation SwitchCases_inst: cursor contextInst sto `|-` switchCaseIR* `==>` contextInst sto switchCaseIR*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:98.1-100.26
relation SwitchCase_inst: cursor contextInst sto `|-` switchCaseIR `==>` contextInst sto switchCaseIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:97.1-99.76
   rule match: p Ci sto `|-` switchCaseIR `==>` Ci' sto' switchLabelIR `:` blockStatementIR'
      -- if switchCaseIR matches `%:%`
      -- let switchLabelIR `:` blockStatementIR = switchCaseIR
      -- Stmt_inst: p Ci sto `|-` blockStatementIR as statementIR `==>` Ci' sto' statementIR
      -- if statementIR <: blockStatementIR
      -- let blockStatementIR' = statementIR as blockStatementIR

   ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:101.1-102.61
   rule fallthrough: p Ci sto `|-` switchCaseIR `==>` Ci sto switchLabelIR `:`
      -- if switchCaseIR matches `%:`
      -- let switchLabelIR `:` = switchCaseIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:106.1-108.26
relation ParserState_inst: cursor contextInst sto `|-` parserStateIR `==>` contextInst sto

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:110.1-112.26
relation ParserStates_inst: cursor contextInst sto `|-` parserStateIR* `==>` contextInst sto

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:115.1-117.29
relation Block_inst: cursor contextInst sto bool `|-` blockStatementIR `==>` contextInst sto blockStatementIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:119.1-121.26
relation Table_inst: cursor contextInst sto `|-` tablePropertyListIR `==>` contextInst sto tablePropertyListIR

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:1.1-1.84
def $partition_default_parameters(parameterIR*, id*) : (parameterIR*, parameterIR*) =

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:3.1-3.65
   clause 0(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = ([], [])
      -- if parameterIR*{parameterIR <- parameterIR*} matches []

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:4.1-12.28
   clause 1(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_h :: parameterIR_default*{parameterIR_default <- parameterIR_default*})
      -- if parameterIR*{parameterIR <- parameterIR*} matches _ :: _
      -- let parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} = parameterIR*{parameterIR <- parameterIR*}
      -- let _annotationList _direction _typeIR id_h _constantInitializerOptIR = parameterIR_h
      -- let (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*}) = $partition_default_parameters(parameterIR_t*{parameterIR_t <- parameterIR_t*}, id_default*{id_default <- id_default*})
      -- if id_h <- id_default*{id_default <- id_default*}

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:14.1-22.31
   clause 2(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = (parameterIR_h :: parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*})
      -- if parameterIR*{parameterIR <- parameterIR*} matches _ :: _
      -- let parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} = parameterIR*{parameterIR <- parameterIR*}
      -- let _annotationList _direction _typeIR id_h _constantInitializerOptIR = parameterIR_h
      -- let (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*}) = $partition_default_parameters(parameterIR_t*{parameterIR_t <- parameterIR_t*}, id_default*{id_default <- id_default*})
      -- if ~id_h <- id_default*{id_default <- id_default*}

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:24.1-24.146
def $align_cparams_with_args(constructorParameterIR*, argumentIR*, id*) : (constructorParameterIR*, argumentIR*, constructorParameterIR*, value*) =

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:27.1-34.71
   clause 0(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}) = (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*})
      -- let (constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}) = $partition_default_parameters(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, id_default*{id_default <- id_default*})
      -- (let _annotationList _direction _typeIR id _constantInitializerOptIR = constructorParameterIR_nondefault)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_nondefault <- constructorParameterIR_nondefault*, id <- id*}
      -- (let (constructorParameterIR*, argumentIR*) = $align_cparams_with_args'(`{` id `:` constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*, id <- id*} `}`, [constructorParameterIR], [argumentIR], [id_default]))*{(constructorParameterIR*, argumentIR*) <- (constructorParameterIR*, argumentIR*)*, argumentIR <- argumentIR*, constructorParameterIR <- constructorParameterIR*, id_default <- id_default*}
      -- (if (constructorParameterIR*, argumentIR*) <: (constructorParameterIR, argumentIR))*{(constructorParameterIR*, argumentIR*) <- (constructorParameterIR*, argumentIR*)*}
      -- (let (constructorParameterIR_aligned, argumentIR_aligned) = (constructorParameterIR*, argumentIR*) as (constructorParameterIR, argumentIR))*{(constructorParameterIR*, argumentIR*) <- (constructorParameterIR*, argumentIR*)*, argumentIR_aligned <- argumentIR_aligned*, constructorParameterIR_aligned <- constructorParameterIR_aligned*}
      -- (let _annotationList' _direction' _typeIR' _nameIR constantInitializerOptIR = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _direction' <- _direction'*, _nameIR <- _nameIR*, _typeIR' <- _typeIR'*, constantInitializerOptIR <- constantInitializerOptIR*, constructorParameterIR_default <- constructorParameterIR_default*}
      -- (if constantInitializerOptIR matches (_))*{constantInitializerOptIR <- constantInitializerOptIR*}
      -- (let ?(`=` value_default) = constantInitializerOptIR)*{constantInitializerOptIR <- constantInitializerOptIR*, value_default <- value_default*}

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:25.1-25.147
def $align_cparams_with_args'(map<id, constructorParameterIR>, constructorParameterIR*, argumentIR*, id*) : (constructorParameterIR*, argumentIR*) =

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:36.1-36.98
def $add_eval_args_to_ctx(contextInst, sto, constructorParameterIR*, value*) : (contextInst, sto) =

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:37.1-37.91
def $add_default_values_to_ctx(contextInst, constructorParameterIR*, value*) : contextInst =

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:39.1-39.157
def $add_params_and_args_to_ctx(cursor, contextInst, typeParameterIR*, constructorParameterIR*, typeArgumentIR*, argumentIR*, id*, sto) : (contextInst, sto) =

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:40.1-46.111
   clause 0(cursor, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, sto) = (Ci_callee_3, sto')
      -- if cursor matches `GLOBAL`
      -- let Ci_callee_0 = $empty_context_inst
      -- let Ci_callee_1 = $add_tparams_inst(`GLOBAL`, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let (constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, argumentIR'*{argumentIR' <- argumentIR'*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
      -- let (Ci_callee_2, sto') = $add_eval_args_to_ctx(Ci_callee_1, sto, constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, value_default*{value_default <- value_default*})
      -- let Ci_callee_3 = $add_default_values_to_ctx(Ci_callee_2, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*})

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:48.1-54.112
   clause 1(cursor, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, sto) = (Ci_callee''', sto')
      -- if cursor matches `BLOCK`
      -- let Ci_callee = $copy_context_inst(`GLOBAL`, Ci)
      -- let Ci_callee' = $add_tparams_inst(`BLOCK`, Ci_callee, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let (constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, argumentIR'*{argumentIR' <- argumentIR'*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
      -- let (Ci_callee'', sto') = $add_eval_args_to_ctx(Ci_callee', sto, constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, value_default*{value_default <- value_default*})
      -- let Ci_callee''' = $add_default_values_to_ctx(Ci_callee'', constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*})

   ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:56.1-62.112
   clause 2(cursor, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, sto) = (Ci_callee''', sto')
      -- if cursor matches `LOCAL`
      -- let Ci_callee = $copy_context_inst(`BLOCK`, Ci)
      -- let Ci_callee' = $add_tparams_inst(`LOCAL`, Ci_callee, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let (constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, argumentIR'*{argumentIR' <- argumentIR'*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
      -- let (Ci_callee'', sto') = $add_eval_args_to_ctx(Ci_callee', sto, constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, value_default*{value_default <- value_default*})
      -- let Ci_callee''' = $add_default_values_to_ctx(Ci_callee'', constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*})

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:89.1-89.59
def $init_table(tablePropertyListIR) : tablePropertyListIR =

;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:408.1-408.34
def $size(typeIR, nameIR) : value =

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:24.1-24.70
def $get_init_decls(objectInitializerOptIR) : objectDeclarationListIR =

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:50.1-50.43
def $rid_IR(nameIR, parameterListIR) : rid =

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:53.1-53.70
   clause 0(nameIR, parameterIR*{parameterIR <- parameterIR*}) = nameIR `(` $pid_IR(parameterIR)*{parameterIR <- parameterIR*} `)`

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:51.1-51.31
def $pid_IR(parameterIR) : pid =

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:55.1-55.48
   clause 0(_annotationList _direction _typeIR nameIR constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}) = nameIR `#` false
      -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:56.1-56.65
   clause 1(_annotationList _direction _typeIR nameIR constantInitializerOptIR) = nameIR `#` true
      -- if constantInitializerOptIR matches (_)
      -- let ?(constantInitializerIR) = constantInitializerOptIR

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:58.1-58.54
def $cid_IR(nameIR, constructorParameterListIR) : cid =

   ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:60.1-60.94
   clause 0(nameIR, constructorParameterListIR) = $rid_IR(nameIR, constructorParameterListIR)
