;; ../../../../spec-concrete/0-aux.watsup:18.1-18.21
def $sum(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:20.1-20.21
def $max(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:22.1-22.21
def $min(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:28.1-28.29
def $int_to_text(int) : text =

;; ../../../../spec-concrete/0-aux.watsup:30.1-30.31
def $concat_text(text*) : text =

   ;; ../../../../spec-concrete/0-aux.watsup:31.1-31.27
   clause 0(text*{text <- text*}) = ""
      -- if text*{text <- text*} matches []

   ;; ../../../../spec-concrete/0-aux.watsup:32.1-32.58
   clause 1(text*{text <- text*}) = t_h ++ $concat_text(t_t*{t_t <- t_t*})
      -- if text*{text <- text*} matches _ :: _
      -- let t_h :: t_t*{t_t <- t_t*} = text*{text <- text*}

;; ../../../../spec-concrete/0-aux.watsup:38.1-38.23
def $init_(nat) : nat* =

   ;; ../../../../spec-concrete/0-aux.watsup:39.1-39.20
   clause 0(nat) = []
      -- if (nat = 0)

   ;; ../../../../spec-concrete/0-aux.watsup:40.1-41.15
   clause 1(n) = (n - 1) :: $init_((n - 1))
      -- otherwise

;; ../../../../spec-concrete/0-aux.watsup:43.1-43.29
def $repeat_<X>(X, nat) : X* =

   ;; ../../../../spec-concrete/0-aux.watsup:44.1-44.28
   clause 0(X, nat) = []
      -- if (nat = 0)

   ;; ../../../../spec-concrete/0-aux.watsup:45.1-46.15
   clause 1(X, n) = [X] ++ $repeat_<X>(X, (n - 1))
      -- otherwise

;; ../../../../spec-concrete/0-aux.watsup:48.1-48.22
def $rev_<X>(X*) : X* =

;; ../../../../spec-concrete/0-aux.watsup:50.1-50.28
def $concat_<X>(X**) : X* =

;; ../../../../spec-concrete/0-aux.watsup:52.1-52.39
def $partition_<X>(X*, nat) : (X*, X*) =

;; ../../../../spec-concrete/0-aux.watsup:54.1-54.35
def $assoc_<X, Y>(X, (X, Y)*) : Y? =

;; ../../../../spec-concrete/0-aux.watsup:56.1-56.29
def $distinct_<K>(K*) : bool =

;; ../../../../spec-concrete/0-aux.watsup:62.17-62.24
syntax set<K> = 
   | `{` K* `}`

;; ../../../../spec-concrete/0-aux.watsup:64.1-64.27
def $empty_set<K> : set<K> =

   ;; ../../../../spec-concrete/0-aux.watsup:65.1-65.29
   clause 0 = `{` [] `}`

;; ../../../../spec-concrete/0-aux.watsup:67.1-67.33
def $in_set<K>(K, set<K>) : bool =

   ;; ../../../../spec-concrete/0-aux.watsup:68.1-68.41
   clause 0(K, `{` K_e*{K_e <- K_e*} `}`) = K <- K_e*{K_e <- K_e*}

;; ../../../../spec-concrete/0-aux.watsup:70.1-70.47
def $intersect_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:72.1-72.43
def $union_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:74.1-74.37
def $unions_set<K>(set<K>*) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:76.1-76.42
def $diff_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:78.1-78.39
def $sub_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:80.1-80.38
def $eq_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:86.21-86.27
syntax pair<K, V> = 
   | K `:` V

;; ../../../../spec-concrete/0-aux.watsup:88.20-88.35
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec-concrete/0-aux.watsup:90.1-90.33
def $empty_map<K, V> : map<K, V> =

   ;; ../../../../spec-concrete/0-aux.watsup:91.1-91.32
   clause 0 = `{` [] `}`

;; ../../../../spec-concrete/0-aux.watsup:93.1-93.39
def $dom_map<K, V>(map<K, V>) : set<K> =

   ;; ../../../../spec-concrete/0-aux.watsup:94.1-94.45
   clause 0(`{` K `:` V*{K <- K*, V <- V*} `}`) = `{` K*{K <- K*} `}`

;; ../../../../spec-concrete/0-aux.watsup:96.1-96.39
def $find_map<K, V>(map<K, V>, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:98.1-98.41
def $find_maps<K, V>(map<K, V>*, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:100.1-100.48
def $add_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:102.1-102.51
def $adds_map<K, V>(map<K, V>, K*, V*) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:104.1-104.51
def $update_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/1-syntax.watsup:6.1-7.7
syntax trailingCommaOpt = 
   | ``EMPTY`
   | `,`

;; ../../../../spec-concrete/1-syntax.watsup:14.1-16.14
syntax number = 
   | `D` int
   | nat `W` int
   | nat `S` int

;; ../../../../spec-concrete/1-syntax.watsup:22.24-22.34
syntax stringLiteral = 
   | `"` text `"`

;; ../../../../spec-concrete/1-syntax.watsup:35.21-35.29
syntax identifier = 
   | ``ID` text

;; ../../../../spec-concrete/1-syntax.watsup:36.25-36.34
syntax typeIdentifier = 
   | ``TID` text

;; ../../../../spec-concrete/1-syntax.watsup:43.1-45.30
syntax nonTypeName = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`

;; ../../../../spec-concrete/1-syntax.watsup:48.1-49.23
syntax prefixedNonTypeName = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName

;; ../../../../spec-concrete/1-syntax.watsup:55.19-55.33
syntax typeName = typeIdentifier

;; ../../../../spec-concrete/1-syntax.watsup:58.1-59.21
syntax prefixedTypeName = 
   | ``TID` text
   | ``TID.` typeName

;; ../../../../spec-concrete/1-syntax.watsup:66.1-68.36
syntax tableCustomName = 
   | ``ID` text
   | ``TID` text
   | `APPLY`
   | `STATE`
   | `TYPE`
   | `PRIORITY`

;; ../../../../spec-concrete/1-syntax.watsup:75.1-77.9
syntax name = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``TID` text
   | `LIST`

;; ../../../../spec-concrete/1-syntax.watsup:80.1-81.21
syntax nameList = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``TID` text
   | `LIST`
   | nameList `,` name

;; ../../../../spec-concrete/1-syntax.watsup:83.1-83.40
def $flatten_nameList(nameList) : name* =

   ;; ../../../../spec-concrete/1-syntax.watsup:84.1-84.35
   clause 0(nameList) = [name]
      -- if nameList <: name
      -- let name = nameList as name

   ;; ../../../../spec-concrete/1-syntax.watsup:85.1-86.42
   clause 1(nameList') = $flatten_nameList(nameList) ++ [name]
      -- if nameList' matches `%,%`
      -- let nameList `,` name = nameList'

;; ../../../../spec-concrete/1-syntax.watsup:88.17-88.21
syntax member = name

;; ../../../../spec-concrete/1-syntax.watsup:94.20-94.45
syntax direction = 
   | ``EMPTY`
   | `IN`
   | `OUT`
   | `INOUT`

;; ../../../../spec-concrete/1-syntax.watsup:107.1-118.32
syntax baseType = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`

;; ../../../../spec-concrete/1-syntax.watsup:126.26-126.64
syntax specializedType = 
   | prefixedTypeName `<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:129.1-130.20
syntax namedType = 
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:136.26-136.51
syntax headerStackType = 
   | namedType `[` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:144.19-144.41
syntax listType = 
   | `LIST<` typeArgument `>`

;; ../../../../spec-concrete/1-syntax.watsup:150.20-150.47
syntax tupleType = 
   | `TUPLE<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:157.1-161.14
syntax type = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:164.1-166.15
syntax typeOrVoid = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | ``ID` text

;; ../../../../spec-concrete/1-syntax.watsup:172.24-172.28
syntax typeParameter = name

;; ../../../../spec-concrete/1-syntax.watsup:175.1-176.39
syntax typeParameterList = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``TID` text
   | `LIST`
   | typeParameterList `,` typeParameter

;; ../../../../spec-concrete/1-syntax.watsup:178.1-178.67
def $flatten_typeParameterList(typeParameterList) : typeParameter* =

   ;; ../../../../spec-concrete/1-syntax.watsup:179.1-179.62
   clause 0(typeParameterList) = [typeParameter]
      -- if typeParameterList <: typeParameter
      -- let typeParameter = typeParameterList as typeParameter

   ;; ../../../../spec-concrete/1-syntax.watsup:180.1-181.69
   clause 1(typeParameterList') = $flatten_typeParameterList(typeParameterList) ++ [typeParameter]
      -- if typeParameterList' matches `%,%`
      -- let typeParameterList `,` typeParameter = typeParameterList'

;; ../../../../spec-concrete/1-syntax.watsup:184.1-185.27
syntax typeParameterListOpt = 
   | ``EMPTY`
   | `<` typeParameterList `>`

;; ../../../../spec-concrete/1-syntax.watsup:187.1-187.73
def $flatten_typeParameterListOpt(typeParameterListOpt) : typeParameter* =

   ;; ../../../../spec-concrete/1-syntax.watsup:188.1-188.48
   clause 0(typeParameterListOpt) = []
      -- if typeParameterListOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:189.1-190.50
   clause 1(typeParameterListOpt) = $flatten_typeParameterList(typeParameterList)
      -- if typeParameterListOpt matches `<%>`
      -- let `<` typeParameterList `>` = typeParameterListOpt

;; ../../../../spec-concrete/1-syntax.watsup:199.3-199.52
syntax parameter = 
   | annotationList direction type name initializerOpt

;; ../../../../spec-concrete/1-syntax.watsup:202.1-203.39
syntax nonEmptyParameterList = 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList `,` parameter

;; ../../../../spec-concrete/1-syntax.watsup:206.1-207.26
syntax parameterList = 
   | ``EMPTY`
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList `,` parameter

;; ../../../../spec-concrete/1-syntax.watsup:209.1-209.55
def $flatten_parameterList(parameterList) : parameter* =

   ;; ../../../../spec-concrete/1-syntax.watsup:210.1-210.41
   clause 0(parameterList) = []
      -- if parameterList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:211.1-211.50
   clause 1(parameterList) = [parameter]
      -- if parameterList <: parameter
      -- let parameter = parameterList as parameter

   ;; ../../../../spec-concrete/1-syntax.watsup:212.1-213.67
   clause 2(parameterList) = $flatten_parameterList(nonEmptyParameterList as parameterList) ++ [parameter]
      -- if parameterList <: nonEmptyParameterList
      -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
      -- if nonEmptyParameterList' matches `%,%`
      -- let nonEmptyParameterList `,` parameter = nonEmptyParameterList'

;; ../../../../spec-concrete/1-syntax.watsup:219.31-219.40
syntax constructorParameter = parameter

;; ../../../../spec-concrete/1-syntax.watsup:221.35-221.48
syntax constructorParameterList = parameterList

;; ../../../../spec-concrete/1-syntax.watsup:224.1-225.23
syntax constructorParameterListOpt = 
   | ``EMPTY`
   | `(` parameterList `)`

;; ../../../../spec-concrete/1-syntax.watsup:227.1-228.26
def $flatten_constructorParameterListOpt(constructorParameterListOpt) : constructorParameter* =

   ;; ../../../../spec-concrete/1-syntax.watsup:230.1-230.55
   clause 0(constructorParameterListOpt) = []
      -- if constructorParameterListOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:231.1-232.42
   clause 1(constructorParameterListOpt) = $flatten_parameterList(parameterList)
      -- if constructorParameterListOpt matches `(%)`
      -- let `(` parameterList `)` = constructorParameterListOpt

;; ../../../../spec-concrete/1-syntax.watsup:238.26-238.44
syntax namedExpression = 
   | name `=` expression

;; ../../../../spec-concrete/1-syntax.watsup:241.1-242.43
syntax namedExpressionList = 
   | name `=` expression
   | namedExpressionList `,` namedExpression

;; ../../../../spec-concrete/1-syntax.watsup:244.1-244.73
def $flatten_namedExpressionList(namedExpressionList) : namedExpression* =

   ;; ../../../../spec-concrete/1-syntax.watsup:245.1-245.68
   clause 0(namedExpressionList) = [namedExpression]
      -- if namedExpressionList <: namedExpression
      -- let namedExpression = namedExpressionList as namedExpression

   ;; ../../../../spec-concrete/1-syntax.watsup:246.1-247.75
   clause 1(namedExpressionList') = $flatten_namedExpressionList(namedExpressionList) ++ [namedExpression]
      -- if namedExpressionList' matches `%,%`
      -- let namedExpressionList `,` namedExpression = namedExpressionList'

;; ../../../../spec-concrete/1-syntax.watsup:258.1-260.18
syntax literalExpression = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`

;; ../../../../spec-concrete/1-syntax.watsup:267.1-268.9
syntax referenceExpression = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`

;; ../../../../spec-concrete/1-syntax.watsup:274.28-274.32
syntax defaultExpression = 
   | `...`

;; ../../../../spec-concrete/1-syntax.watsup:282.15-282.32
syntax unop = 
   | `!`
   | `~`
   | `-`
   | `+`

;; ../../../../spec-concrete/1-syntax.watsup:284.26-284.41
syntax unaryExpression = 
   | unop expression

;; ../../../../spec-concrete/1-syntax.watsup:287.1-289.35
syntax binop = 
   | `*`
   | `/`
   | `%`
   | `+`
   | `-`
   | `|+|`
   | `|-|`
   | `<<`
   | `>>`
   | `<=`
   | `>=`
   | `<`
   | `>`
   | `!=`
   | `==`
   | `&`
   | `^`
   | `|`
   | `++`
   | `&&`
   | `||`

;; ../../../../spec-concrete/1-syntax.watsup:291.27-291.54
syntax binaryExpression = 
   | expression binop expression

;; ../../../../spec-concrete/1-syntax.watsup:294.3-294.38
syntax binaryExpressionNonBrace = 
   | expressionNonBrace binop expression

;; ../../../../spec-concrete/1-syntax.watsup:297.3-297.41
syntax ternaryExpression = 
   | expression `?` expression `:` expression

;; ../../../../spec-concrete/1-syntax.watsup:300.3-300.49
syntax ternaryExpressionNonBrace = 
   | expressionNonBrace `?` expression `:` expression

;; ../../../../spec-concrete/1-syntax.watsup:306.25-306.45
syntax castExpression = 
   | `(` type `)` expression

;; ../../../../spec-concrete/1-syntax.watsup:315.1-316.48
syntax dataExpression = 
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`

;; ../../../../spec-concrete/1-syntax.watsup:325.3-325.18
syntax errorAccessExpression = 
   | `ERROR.` member

;; ../../../../spec-concrete/1-syntax.watsup:328.3-328.29
syntax memberAccessExpression = 
   | memberAccessBase `.` member

;; ../../../../spec-concrete/1-syntax.watsup:331.1-332.45
syntax indexAccessExpression = 
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:335.1-337.26
syntax accessExpression = 
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:340.3-340.37
syntax memberAccessExpressionNonBrace = 
   | memberAccessBaseNonBrace `.` member

;; ../../../../spec-concrete/1-syntax.watsup:343.1-344.53
syntax indexAccessExpressionNonBrace = 
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:347.1-349.34
syntax accessExpressionNonBrace = 
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`

;; ../../../../spec-concrete/1-syntax.watsup:362.25-362.44
syntax functionTarget = prefixedNonTypeName

;; ../../../../spec-concrete/1-syntax.watsup:363.23-363.45
syntax methodTarget = memberAccessExpression

;; ../../../../spec-concrete/1-syntax.watsup:364.28-364.37
syntax constructorTarget = namedType

;; ../../../../spec-concrete/1-syntax.watsup:367.1-368.62
syntax callExpression = 
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`

;; ../../../../spec-concrete/1-syntax.watsup:371.1-372.70
syntax callExpressionNonBrace = 
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`

;; ../../../../spec-concrete/1-syntax.watsup:378.34-378.49
syntax parenthesizedExpression = 
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:385.1-395.28
syntax expression = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:399.1-401.33
syntax expressionList = 
   | ``EMPTY`
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expressionList `,` expression

;; ../../../../spec-concrete/1-syntax.watsup:403.1-403.58
def $flatten_expressionList(expressionList) : expression* =

   ;; ../../../../spec-concrete/1-syntax.watsup:404.1-404.42
   clause 0(expressionList) = []
      -- if expressionList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:405.1-405.53
   clause 1(expressionList) = [expression]
      -- if expressionList <: expression
      -- let expression = expressionList as expression

   ;; ../../../../spec-concrete/1-syntax.watsup:406.1-407.60
   clause 2(expressionList') = $flatten_expressionList(expressionList) ++ [expression]
      -- if expressionList' matches `%,%`
      -- let expressionList `,` expression = expressionList'

;; ../../../../spec-concrete/1-syntax.watsup:410.1-411.15
syntax memberAccessBase = 
   | ``TID` text
   | ``TID.` typeName
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:413.36-413.50
syntax sequenceElementExpression = expressionList

;; ../../../../spec-concrete/1-syntax.watsup:416.1-419.54
syntax recordElementExpression = 
   | name `=` expression
   | name `=` expression `,...`
   | name `=` expression `,` namedExpressionList
   | name `=` expression `,` namedExpressionList `,...`

;; ../../../../spec-concrete/1-syntax.watsup:422.1-423.28
syntax dataElementExpression = 
   | ``EMPTY`
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expressionList `,` expression
   | name `=` expression
   | name `=` expression `,...`
   | name `=` expression `,` namedExpressionList
   | name `=` expression `,` namedExpressionList `,...`

;; ../../../../spec-concrete/1-syntax.watsup:425.24-425.34
syntax routineTarget = expression

;; ../../../../spec-concrete/1-syntax.watsup:428.1-429.22
syntax callTarget = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:436.1-444.28
syntax expressionNonBrace = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace `?` expression `:` expression
   | `(` type `)` expression
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:447.1-448.23
syntax memberAccessBaseNonBrace = 
   | ``TID` text
   | ``TID.` typeName
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace `?` expression `:` expression
   | `(` type `)` expression
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:450.32-450.50
syntax routineTargetNonBrace = expressionNonBrace

;; ../../../../spec-concrete/1-syntax.watsup:453.1-454.22
syntax callTargetNonBrace = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace `?` expression `:` expression
   | `(` type `)` expression
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`

;; ../../../../spec-concrete/1-syntax.watsup:461.1-465.7
syntax simpleKeysetExpression = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expression `&&&` expression
   | expression `..` expression
   | `DEFAULT`
   | `_`

;; ../../../../spec-concrete/1-syntax.watsup:468.1-469.57
syntax simpleKeysetExpressionList = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expression `&&&` expression
   | expression `..` expression
   | `DEFAULT`
   | `_`
   | simpleKeysetExpressionList `,` simpleKeysetExpression

;; ../../../../spec-concrete/1-syntax.watsup:472.1-476.62
syntax tupleKeysetExpression = 
   | `(` expression `&&&` expression `)`
   | `(` expression `..` expression `)`
   | `(DEFAULT)`
   | `(_)`
   | `(` simpleKeysetExpression `,` simpleKeysetExpressionList `)`

;; ../../../../spec-concrete/1-syntax.watsup:479.1-480.26
syntax keysetExpression = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expression `&&&` expression
   | expression `..` expression
   | `DEFAULT`
   | `_`
   | `(` expression `&&&` expression `)`
   | `(` expression `..` expression `)`
   | `(DEFAULT)`
   | `(_)`
   | `(` simpleKeysetExpression `,` simpleKeysetExpressionList `)`

;; ../../../../spec-concrete/1-syntax.watsup:487.1-489.7
syntax realTypeArgument = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | `_`

;; ../../../../spec-concrete/1-syntax.watsup:492.1-493.45
syntax realTypeArgumentList = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | `_`
   | realTypeArgumentList `,` realTypeArgument

;; ../../../../spec-concrete/1-syntax.watsup:495.1-495.76
def $flatten_realTypeArgumentList(realTypeArgumentList) : realTypeArgument* =

   ;; ../../../../spec-concrete/1-syntax.watsup:496.1-496.71
   clause 0(realTypeArgumentList) = [realTypeArgument]
      -- if realTypeArgumentList <: realTypeArgument
      -- let realTypeArgument = realTypeArgumentList as realTypeArgument

   ;; ../../../../spec-concrete/1-syntax.watsup:497.1-498.78
   clause 1(realTypeArgumentList') = $flatten_realTypeArgumentList(realTypeArgumentList) ++ [realTypeArgument]
      -- if realTypeArgumentList' matches `%,%`
      -- let realTypeArgumentList `,` realTypeArgument = realTypeArgumentList'

;; ../../../../spec-concrete/1-syntax.watsup:501.1-502.16
syntax typeArgument = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | `_`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`

;; ../../../../spec-concrete/1-syntax.watsup:506.1-508.37
syntax typeArgumentList = 
   | ``EMPTY`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | `VOID`
   | `_`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | typeArgumentList `,` typeArgument

;; ../../../../spec-concrete/1-syntax.watsup:510.1-510.64
def $flatten_typeArgumentList(typeArgumentList) : typeArgument* =

   ;; ../../../../spec-concrete/1-syntax.watsup:511.1-511.44
   clause 0(typeArgumentList) = []
      -- if typeArgumentList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:512.1-512.59
   clause 1(typeArgumentList) = [typeArgument]
      -- if typeArgumentList <: typeArgument
      -- let typeArgument = typeArgumentList as typeArgument

   ;; ../../../../spec-concrete/1-syntax.watsup:513.1-514.66
   clause 2(typeArgumentList') = $flatten_typeArgumentList(typeArgumentList) ++ [typeArgument]
      -- if typeArgumentList' matches `%,%`
      -- let typeArgumentList `,` typeArgument = typeArgumentList'

;; ../../../../spec-concrete/1-syntax.watsup:521.1-524.7
syntax argument = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | name `=` expression
   | name `=_`
   | `_`

;; ../../../../spec-concrete/1-syntax.watsup:527.1-528.37
syntax argumentListNonEmpty = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | name `=` expression
   | name `=_`
   | `_`
   | argumentListNonEmpty `,` argument

;; ../../../../spec-concrete/1-syntax.watsup:531.1-532.25
syntax argumentList = 
   | ``EMPTY`
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | name `=` expression
   | name `=_`
   | `_`
   | argumentListNonEmpty `,` argument

;; ../../../../spec-concrete/1-syntax.watsup:534.1-534.52
def $flatten_argumentList(argumentList) : argument* =

   ;; ../../../../spec-concrete/1-syntax.watsup:535.1-535.40
   clause 0(argumentList) = []
      -- if argumentList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:536.1-536.47
   clause 1(argumentList) = [argument]
      -- if argumentList <: argument
      -- let argument = argumentList as argument

   ;; ../../../../spec-concrete/1-syntax.watsup:537.1-538.62
   clause 2(argumentList) = $flatten_argumentList(argumentListNonEmpty as argumentList) ++ [argument]
      -- if argumentList <: argumentListNonEmpty
      -- let argumentListNonEmpty' = argumentList as argumentListNonEmpty
      -- if argumentListNonEmpty' matches `%,%`
      -- let argumentListNonEmpty `,` argument = argumentListNonEmpty'

;; ../../../../spec-concrete/1-syntax.watsup:545.1-549.16
syntax lvalue = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | lvalue `.` member
   | lvalue `[` expression `]`
   | lvalue `[` expression `:` expression `]`
   | `(` lvalue `)`

;; ../../../../spec-concrete/1-syntax.watsup:559.25-559.27
syntax emptyStatement = 
   | `;`

;; ../../../../spec-concrete/1-syntax.watsup:566.1-568.34
syntax assignop = 
   | `=`
   | `+=`
   | `-=`
   | `|+|=`
   | `|-|=`
   | `*=`
   | `/=`
   | `%=`
   | `<<=`
   | `>>=`
   | `&=`
   | `^=`
   | `|=`

;; ../../../../spec-concrete/1-syntax.watsup:570.30-570.59
syntax assignmentStatement = 
   | lvalue assignop expression `;`

;; ../../../../spec-concrete/1-syntax.watsup:577.1-578.54
syntax callStatement = 
   | lvalue `(` argumentList `);`
   | lvalue `<` typeArgumentList `>(` argumentList `);`

;; ../../../../spec-concrete/1-syntax.watsup:584.37-584.76
syntax directApplicationStatement = 
   | namedType `.APPLY(` argumentList `);`

;; ../../../../spec-concrete/1-syntax.watsup:591.1-592.25
syntax returnStatement = 
   | `RETURN;`
   | `RETURN` expression `;`

;; ../../../../spec-concrete/1-syntax.watsup:598.24-598.31
syntax exitStatement = 
   | `EXIT;`

;; ../../../../spec-concrete/1-syntax.watsup:606.25-606.70
syntax blockStatement = 
   | annotationList `{` blockElementStatementList `}`

;; ../../../../spec-concrete/1-syntax.watsup:615.1-616.48
syntax conditionalStatement = 
   | `IF(` expression `)` statement
   | `IF(` expression `)` statement `ELSE` statement

;; ../../../../spec-concrete/1-syntax.watsup:625.1-628.31
syntax forInitStatement = 
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression

;; ../../../../spec-concrete/1-syntax.watsup:631.1-632.53
syntax forInitStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression
   | forInitStatementListNonEmpty `,` forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:635.1-636.33
syntax forInitStatementList = 
   | ``EMPTY`
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression
   | forInitStatementListNonEmpty `,` forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:638.29-638.45
syntax forUpdateStatement = forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:641.1-642.57
syntax forUpdateStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty `,` forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:645.1-646.35
syntax forUpdateStatementList = 
   | ``EMPTY`
   | annotationList type name initializerOpt
   | lvalue `(` argumentList `)`
   | lvalue `<` typeArgumentList `>(` argumentList `)`
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty `,` forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:649.1-650.30
syntax forCollectionExpression = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | `...`
   | unop expression
   | expression binop expression
   | expression `?` expression `:` expression
   | `(` type `)` expression
   | `{#}`
   | `{` dataElementExpression trailingCommaOpt `}`
   | `ERROR.` member
   | memberAccessBase `.` member
   | expression `[` expression `]`
   | expression `[` expression `:` expression `]`
   | callTarget `(` argumentList `)`
   | routineTarget `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`
   | expression `..` expression

;; ../../../../spec-concrete/1-syntax.watsup:653.1-658.81
syntax forStatement = 
   | annotationList `FOR(` forInitStatementList `;` expression `;` forUpdateStatementList `)` statement
   | annotationList `FOR(` type name `IN` forCollectionExpression `)` statement
   | annotationList `FOR(` annotationListNonEmpty type name `IN` forCollectionExpression `)` statement

;; ../../../../spec-concrete/1-syntax.watsup:665.1-666.23
syntax switchLabel = 
   | `DEFAULT`
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | `THIS`
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace `?` expression `:` expression
   | `(` type `)` expression
   | `ERROR.` member
   | memberAccessBaseNonBrace `.` member
   | expressionNonBrace `[` expression `]`
   | expressionNonBrace `[` expression `:` expression `]`
   | callTargetNonBrace `(` argumentList `)`
   | routineTargetNonBrace `<` realTypeArgumentList `>(` argumentList `)`
   | `(` expression `)`

;; ../../../../spec-concrete/1-syntax.watsup:669.1-670.19
syntax switchCase = 
   | switchLabel `:` blockStatement
   | switchLabel `:`

;; ../../../../spec-concrete/1-syntax.watsup:673.1-674.30
syntax switchCaseList = 
   | ``EMPTY`
   | switchCaseList switchCase

;; ../../../../spec-concrete/1-syntax.watsup:676.26-676.68
syntax switchStatement = 
   | `SWITCH(` expression `){` switchCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:682.25-682.33
syntax breakStatement = 
   | `BREAK;`

;; ../../../../spec-concrete/1-syntax.watsup:684.28-684.39
syntax continueStatement = 
   | `CONTINUE;`

;; ../../../../spec-concrete/1-syntax.watsup:691.1-702.20
syntax statement = 
   | `;`
   | lvalue assignop expression `;`
   | lvalue `(` argumentList `);`
   | lvalue `<` typeArgumentList `>(` argumentList `);`
   | namedType `.APPLY(` argumentList `);`
   | `RETURN;`
   | `RETURN` expression `;`
   | `EXIT;`
   | annotationList `{` blockElementStatementList `}`
   | `IF(` expression `)` statement
   | `IF(` expression `)` statement `ELSE` statement
   | annotationList `FOR(` forInitStatementList `;` expression `;` forUpdateStatementList `)` statement
   | annotationList `FOR(` type name `IN` forCollectionExpression `)` statement
   | annotationList `FOR(` annotationListNonEmpty type name `IN` forCollectionExpression `)` statement
   | `BREAK;`
   | `CONTINUE;`
   | `SWITCH(` expression `){` switchCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:712.22-712.35
syntax initializer = 
   | `=` expression

;; ../../../../spec-concrete/1-syntax.watsup:715.3-715.48
syntax constantDeclaration = 
   | annotationList `CONST` type name initializer `;`

;; ../../../../spec-concrete/1-syntax.watsup:718.1-719.16
syntax initializerOpt = 
   | ``EMPTY`
   | `=` expression

;; ../../../../spec-concrete/1-syntax.watsup:722.3-722.45
syntax variableDeclaration = 
   | annotationList type name initializerOpt `;`

;; ../../../../spec-concrete/1-syntax.watsup:725.1-727.14
syntax blockElementStatement = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type name initializerOpt `;`
   | `;`
   | lvalue assignop expression `;`
   | lvalue `(` argumentList `);`
   | lvalue `<` typeArgumentList `>(` argumentList `);`
   | namedType `.APPLY(` argumentList `);`
   | `RETURN;`
   | `RETURN` expression `;`
   | `EXIT;`
   | annotationList `{` blockElementStatementList `}`
   | `IF(` expression `)` statement
   | `IF(` expression `)` statement `ELSE` statement
   | annotationList `FOR(` forInitStatementList `;` expression `;` forUpdateStatementList `)` statement
   | annotationList `FOR(` type name `IN` forCollectionExpression `)` statement
   | annotationList `FOR(` annotationListNonEmpty type name `IN` forCollectionExpression `)` statement
   | `BREAK;`
   | `CONTINUE;`
   | `SWITCH(` expression `){` switchCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:730.1-731.52
syntax blockElementStatementList = 
   | ``EMPTY`
   | blockElementStatementList blockElementStatement

;; ../../../../spec-concrete/1-syntax.watsup:733.1-734.27
def $flatten_blockElementStatementList(blockElementStatementList) : blockElementStatement* =

   ;; ../../../../spec-concrete/1-syntax.watsup:735.1-735.53
   clause 0(blockElementStatementList) = []
      -- if blockElementStatementList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:736.1-740.30
   clause 1(blockElementStatementList') = $flatten_blockElementStatementList(blockElementStatementList) ++ [blockElementStatement]
      -- if blockElementStatementList' matches `%%`
      -- let blockElementStatementList blockElementStatement = blockElementStatementList'

;; ../../../../spec-concrete/1-syntax.watsup:747.3-747.58
syntax functionPrototype = 
   | typeOrVoid name typeParameterListOpt `(` parameterList `)`

;; ../../../../spec-concrete/1-syntax.watsup:750.3-750.50
syntax functionDeclaration = 
   | annotationList functionPrototype blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:757.3-757.63
syntax actionDeclaration = 
   | annotationList `ACTION` name `(` parameterList `)` blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:765.28-765.57
syntax objectInitializer = 
   | `={` objectDeclarationList `}`

;; ../../../../spec-concrete/1-syntax.watsup:769.1-770.68
syntax instantiation = 
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`

;; ../../../../spec-concrete/1-syntax.watsup:773.1-774.18
syntax objectDeclaration = 
   | annotationList functionPrototype blockStatement
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`

;; ../../../../spec-concrete/1-syntax.watsup:777.1-778.44
syntax objectDeclarationList = 
   | ``EMPTY`
   | objectDeclarationList objectDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:784.27-784.46
syntax errorDeclaration = 
   | `ERROR{` nameList `}`

;; ../../../../spec-concrete/1-syntax.watsup:790.31-790.72
syntax matchKindDeclaration = 
   | `MATCH_KIND{` nameList trailingCommaOpt `}`

;; ../../../../spec-concrete/1-syntax.watsup:801.1-802.76
syntax enumTypeDeclaration = 
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`

;; ../../../../spec-concrete/1-syntax.watsup:808.20-808.47
syntax typeField = 
   | annotationList type name `;`

;; ../../../../spec-concrete/1-syntax.watsup:811.1-812.28
syntax typeFieldList = 
   | ``EMPTY`
   | typeFieldList typeField

;; ../../../../spec-concrete/1-syntax.watsup:814.1-814.55
def $flatten_typeFieldList(typeFieldList) : typeField* =

   ;; ../../../../spec-concrete/1-syntax.watsup:815.1-815.41
   clause 0(typeFieldList) = []
      -- if typeFieldList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:816.1-817.59
   clause 1(typeFieldList') = $flatten_typeFieldList(typeFieldList) ++ [typeField]
      -- if typeFieldList' matches `%%`
      -- let typeFieldList typeField = typeFieldList'

;; ../../../../spec-concrete/1-syntax.watsup:820.3-820.69
syntax structTypeDeclaration = 
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:823.3-823.69
syntax headerTypeDeclaration = 
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:826.3-826.75
syntax headerUnionTypeDeclaration = 
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:829.1-832.31
syntax derivedTypeDeclaration = 
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:839.1-840.27
syntax typedefType = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | ``TID` text
   | ``TID.` typeName
   | prefixedTypeName `<` typeArgumentList `>`
   | namedType `[` expression `]`
   | `LIST<` typeArgument `>`
   | `TUPLE<` typeArgumentList `>`
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`

;; ../../../../spec-concrete/1-syntax.watsup:843.1-844.37
syntax typedefDeclaration = 
   | annotationList `TYPEDEF` typedefType name `;`
   | annotationList `TYPE` type name `;`

;; ../../../../spec-concrete/1-syntax.watsup:851.3-851.45
syntax externFunctionDeclaration = 
   | annotationList `EXTERN` functionPrototype `;`

;; ../../../../spec-concrete/1-syntax.watsup:854.1-856.49
syntax methodPrototype = 
   | annotationList typeIdentifier `(` parameterList `);`
   | annotationList functionPrototype `;`
   | annotationList `ABSTRACT` functionPrototype `;`

;; ../../../../spec-concrete/1-syntax.watsup:859.1-860.40
syntax methodPrototypeList = 
   | ``EMPTY`
   | methodPrototypeList methodPrototype

;; ../../../../spec-concrete/1-syntax.watsup:862.1-862.73
def $flatten_methodPrototypeList(methodPrototypeList) : methodPrototype* =

   ;; ../../../../spec-concrete/1-syntax.watsup:863.1-863.47
   clause 0(methodPrototypeList) = []
      -- if methodPrototypeList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:864.1-867.77
   clause 1(methodPrototypeList') = $flatten_methodPrototypeList(methodPrototypeList) ++ [methodPrototype]
      -- if methodPrototypeList' matches `%%`
      -- let methodPrototypeList methodPrototype = methodPrototypeList'

;; ../../../../spec-concrete/1-syntax.watsup:870.3-870.82
syntax externObjectDeclaration = 
   | annotationList `EXTERN` nonTypeName typeParameterListOpt `{` methodPrototypeList `}`

;; ../../../../spec-concrete/1-syntax.watsup:873.1-874.28
syntax externDeclaration = 
   | annotationList `EXTERN` functionPrototype `;`
   | annotationList `EXTERN` nonTypeName typeParameterListOpt `{` methodPrototypeList `}`

;; ../../../../spec-concrete/1-syntax.watsup:884.21-884.48
syntax selectCase = 
   | keysetExpression `:` name `;`

;; ../../../../spec-concrete/1-syntax.watsup:887.1-888.30
syntax selectCaseList = 
   | ``EMPTY`
   | selectCaseList selectCase

;; ../../../../spec-concrete/1-syntax.watsup:890.27-890.73
syntax selectExpression = 
   | `SELECT(` expressionList `){` selectCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:897.1-898.21
syntax stateExpression = 
   | name `;`
   | `SELECT(` expressionList `){` selectCaseList `}`

;; ../../../../spec-concrete/1-syntax.watsup:900.30-900.56
syntax transitionStatement = 
   | `TRANSITION` stateExpression

;; ../../../../spec-concrete/1-syntax.watsup:907.1-909.21
syntax valueSetType = 
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` int `>`
   | `INT<(` expression `)>`
   | `BIT`
   | `BIT<` int `>`
   | `BIT<(` expression `)>`
   | `VARBIT<` int `>`
   | `VARBIT<(` expression `)>`
   | `TUPLE<` typeArgumentList `>`
   | ``TID` text
   | ``TID.` typeName

;; ../../../../spec-concrete/1-syntax.watsup:912.3-912.68
syntax valueSetDeclaration = 
   | annotationList `VALUESET<` valueSetType `>(` expression `)` name `;`

;; ../../../../spec-concrete/1-syntax.watsup:919.3-919.72
syntax parserTypeDeclaration = 
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:927.31-927.70
syntax parserBlockStatement = 
   | annotationList `{` parserStatementList `}`

;; ../../../../spec-concrete/1-syntax.watsup:930.1-937.25
syntax parserStatement = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type name initializerOpt `;`
   | `;`
   | lvalue assignop expression `;`
   | lvalue `(` argumentList `);`
   | lvalue `<` typeArgumentList `>(` argumentList `);`
   | namedType `.APPLY(` argumentList `);`
   | annotationList `{` parserStatementList `}`
   | `IF(` expression `)` statement
   | `IF(` expression `)` statement `ELSE` statement

;; ../../../../spec-concrete/1-syntax.watsup:940.1-941.40
syntax parserStatementList = 
   | ``EMPTY`
   | parserStatementList parserStatement

;; ../../../../spec-concrete/1-syntax.watsup:943.1-943.73
def $flatten_parserStatementList(parserStatementList) : parserStatement* =

   ;; ../../../../spec-concrete/1-syntax.watsup:944.1-944.47
   clause 0(parserStatementList) = []
      -- if parserStatementList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:945.1-946.77
   clause 1(parserStatementList') = $flatten_parserStatementList(parserStatementList) ++ [parserStatement]
      -- if parserStatementList' matches `%%`
      -- let parserStatementList parserStatement = parserStatementList'

;; ../../../../spec-concrete/1-syntax.watsup:949.3-949.73
syntax parserState = 
   | annotationList `STATE` name `{` parserStatementList transitionStatement `}`

;; ../../../../spec-concrete/1-syntax.watsup:952.1-953.32
syntax parserStateList = 
   | annotationList `STATE` name `{` parserStatementList transitionStatement `}`
   | parserStateList parserState

;; ../../../../spec-concrete/1-syntax.watsup:955.1-955.61
def $flatten_parserStateList(parserStateList) : parserState* =

   ;; ../../../../spec-concrete/1-syntax.watsup:956.1-956.56
   clause 0(parserStateList) = [parserState]
      -- if parserStateList <: parserState
      -- let parserState = parserStateList as parserState

   ;; ../../../../spec-concrete/1-syntax.watsup:957.1-958.65
   clause 1(parserStateList') = $flatten_parserStateList(parserStateList) ++ [parserState]
      -- if parserStateList' matches `%%`
      -- let parserStateList parserState = parserStateList'

;; ../../../../spec-concrete/1-syntax.watsup:961.1-964.24
syntax parserLocalDeclaration = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`
   | annotationList type name initializerOpt `;`
   | annotationList `VALUESET<` valueSetType `>(` expression `)` name `;`

;; ../../../../spec-concrete/1-syntax.watsup:967.1-968.54
syntax parserLocalDeclarationList = 
   | ``EMPTY`
   | parserLocalDeclarationList parserLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:970.1-971.28
def $flatten_parserLocalDeclarationList(parserLocalDeclarationList) : parserLocalDeclaration* =

   ;; ../../../../spec-concrete/1-syntax.watsup:972.1-972.54
   clause 0(parserLocalDeclarationList) = []
      -- if parserLocalDeclarationList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:973.1-977.34
   clause 1(parserLocalDeclarationList') = $flatten_parserLocalDeclarationList(parserLocalDeclarationList) ++ [parserLocalDeclaration]
      -- if parserLocalDeclarationList' matches `%%`
      -- let parserLocalDeclarationList parserLocalDeclaration = parserLocalDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:980.3-982.52
syntax parserDeclaration = 
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` parserLocalDeclarationList parserStateList `}`

;; ../../../../spec-concrete/1-syntax.watsup:992.16-992.21
syntax const = 
   | `CONST`

;; ../../../../spec-concrete/1-syntax.watsup:995.1-996.10
syntax constOpt = 
   | ``EMPTY`
   | `CONST`

;; ../../../../spec-concrete/1-syntax.watsup:998.1-998.41
def $flatten_constOpt(constOpt) : const? =

   ;; ../../../../spec-concrete/1-syntax.watsup:999.1-999.36
   clause 0(constOpt) = ?()
      -- if constOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1000.1-1000.37
   clause 1(constOpt) = ?(const)
      -- if constOpt <: const
      -- let const = constOpt as const

;; ../../../../spec-concrete/1-syntax.watsup:1006.19-1006.55
syntax tableKey = 
   | expression `:` name annotationList `;`

;; ../../../../spec-concrete/1-syntax.watsup:1009.1-1010.26
syntax tableKeyList = 
   | ``EMPTY`
   | tableKeyList tableKey

;; ../../../../spec-concrete/1-syntax.watsup:1012.1-1012.52
def $flatten_tableKeyList(tableKeyList) : tableKey* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1013.1-1013.40
   clause 0(tableKeyList) = []
      -- if tableKeyList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1014.1-1015.56
   clause 1(tableKeyList') = $flatten_tableKeyList(tableKeyList) ++ [tableKey]
      -- if tableKeyList' matches `%%`
      -- let tableKeyList tableKey = tableKeyList'

;; ../../../../spec-concrete/1-syntax.watsup:1022.1-1023.42
syntax tableActionReference = 
   | ``ID` text
   | `APPLY`
   | `KEY`
   | `ACTIONS`
   | `STATE`
   | `ENTRIES`
   | `TYPE`
   | `PRIORITY`
   | ``ID.` nonTypeName
   | prefixedNonTypeName `(` argumentList `)`

;; ../../../../spec-concrete/1-syntax.watsup:1025.22-1025.60
syntax tableAction = 
   | annotationList tableActionReference `;`

;; ../../../../spec-concrete/1-syntax.watsup:1028.1-1029.32
syntax tableActionList = 
   | ``EMPTY`
   | tableActionList tableAction

;; ../../../../spec-concrete/1-syntax.watsup:1031.1-1031.61
def $flatten_tableActionList(tableActionList) : tableAction* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1032.1-1032.43
   clause 0(tableActionList) = []
      -- if tableActionList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1033.1-1034.63
   clause 1(tableActionList') = $flatten_tableActionList(tableActionList) ++ [tableAction]
      -- if tableActionList' matches `%%`
      -- let tableActionList tableAction = tableActionList'

;; ../../../../spec-concrete/1-syntax.watsup:1041.1-1042.35
syntax tableEntryPriority = 
   | `PRIORITY=` number `:`
   | `PRIORITY=(` expression `):`

;; ../../../../spec-concrete/1-syntax.watsup:1045.1-1046.72
syntax tableEntry = 
   | constOpt tableEntryPriority keysetExpression `:` tableActionReference annotationList `;`
   | constOpt keysetExpression `:` tableActionReference annotationList `;`

;; ../../../../spec-concrete/1-syntax.watsup:1049.1-1050.30
syntax tableEntryList = 
   | ``EMPTY`
   | tableEntryList tableEntry

;; ../../../../spec-concrete/1-syntax.watsup:1057.1-1060.59
syntax tableProperty = 
   | `KEY={` tableKeyList `}`
   | `ACTIONS={` tableActionList `}`
   | annotationList constOpt `ENTRIES={` tableEntryList `}`
   | annotationList constOpt tableCustomName initializer `;`

;; ../../../../spec-concrete/1-syntax.watsup:1063.1-1064.36
syntax tablePropertyList = 
   | ``EMPTY`
   | tablePropertyList tableProperty

;; ../../../../spec-concrete/1-syntax.watsup:1066.1-1066.67
def $flatten_tablePropertyList(tablePropertyList) : tableProperty* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1067.1-1067.45
   clause 0(tablePropertyList) = []
      -- if tablePropertyList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1068.1-1069.69
   clause 1(tablePropertyList') = $flatten_tablePropertyList(tablePropertyList) ++ [tableProperty]
      -- if tablePropertyList' matches `%%`
      -- let tablePropertyList tableProperty = tablePropertyList'

;; ../../../../spec-concrete/1-syntax.watsup:1072.3-1072.51
syntax tableDeclaration = 
   | annotationList `TABLE` name `{` tablePropertyList `}`

;; ../../../../spec-concrete/1-syntax.watsup:1079.3-1079.73
syntax controlTypeDeclaration = 
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:1085.22-1085.36
syntax controlBody = blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:1088.1-1092.21
syntax controlLocalDeclaration = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`
   | annotationList type name initializerOpt `;`
   | annotationList `ACTION` name `(` parameterList `)` blockStatement
   | annotationList `TABLE` name `{` tablePropertyList `}`

;; ../../../../spec-concrete/1-syntax.watsup:1095.1-1096.56
syntax controlLocalDeclarationList = 
   | ``EMPTY`
   | controlLocalDeclarationList controlLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1098.1-1099.29
def $flatten_controlLocalDeclarationList(controlLocalDeclarationList) : controlLocalDeclaration* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1101.1-1101.55
   clause 0(controlLocalDeclarationList) = []
      -- if controlLocalDeclarationList matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1102.1-1106.32
   clause 1(controlLocalDeclarationList') = $flatten_controlLocalDeclarationList(controlLocalDeclarationList) ++ [controlLocalDeclaration]
      -- if controlLocalDeclarationList' matches `%%`
      -- let controlLocalDeclarationList controlLocalDeclaration = controlLocalDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:1109.3-1111.55
syntax controlDeclaration = 
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` controlLocalDeclarationList `APPLY` controlBody `}`

;; ../../../../spec-concrete/1-syntax.watsup:1118.3-1118.73
syntax packageTypeDeclaration = 
   | annotationList `PACKAGE` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:1125.1-1129.27
syntax typeDeclaration = 
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `TYPEDEF` typedefType name `;`
   | annotationList `TYPE` type name `;`
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `);`
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `);`
   | annotationList `PACKAGE` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:1136.1-1145.20
syntax declaration = 
   | annotationList `CONST` type name initializer `;`
   | annotationList type `(` argumentList `)` name `;`
   | annotationList type `(` argumentList `)` name objectInitializer `;`
   | annotationList functionPrototype blockStatement
   | annotationList `ACTION` name `(` parameterList `)` blockStatement
   | `ERROR{` nameList `}`
   | `MATCH_KIND{` nameList trailingCommaOpt `}`
   | annotationList `EXTERN` functionPrototype `;`
   | annotationList `EXTERN` nonTypeName typeParameterListOpt `{` methodPrototypeList `}`
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` parserLocalDeclarationList parserStateList `}`
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` controlLocalDeclarationList `APPLY` controlBody `}`
   | annotationList `ENUM` name `{` nameList trailingCommaOpt `}`
   | annotationList `ENUM` type name `{` namedExpressionList trailingCommaOpt `}`
   | annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}`
   | annotationList `TYPEDEF` typedefType name `;`
   | annotationList `TYPE` type name `;`
   | annotationList `PARSER` name typeParameterListOpt `(` parameterList `);`
   | annotationList `CONTROL` name typeParameterListOpt `(` parameterList `);`
   | annotationList `PACKAGE` name typeParameterListOpt `(` parameterList `);`

;; ../../../../spec-concrete/1-syntax.watsup:1152.1-1169.27
syntax annotationToken = 
   | `UNEXPECTED_TOKEN`
   | `ABSTRACT`
   | `ACTION`
   | `ACTIONS`
   | `APPLY`
   | `BOOL`
   | `BIT`
   | `BREAK`
   | `CONST`
   | `CONTINUE`
   | `CONTROL`
   | `DEFAULT`
   | `ELSE`
   | `ENTRIES`
   | `ENUM`
   | `ERROR`
   | `EXIT`
   | `EXTERN`
   | `FALSE`
   | `FOR`
   | `HEADER`
   | `HEADER_UNION`
   | `IF`
   | `IN`
   | `INOUT`
   | `INT`
   | `KEY`
   | `MATCH_KIND`
   | `TYPE`
   | `OUT`
   | `PARSER`
   | `PACKAGE`
   | `PRAGMA`
   | `RETURN`
   | `SELECT`
   | `STATE`
   | `STRING`
   | `STRUCT`
   | `SWITCH`
   | `TABLE`
   | `THIS`
   | `TRANSITION`
   | `TRUE`
   | `TUPLE`
   | `TYPEDEF`
   | `VARBIT`
   | `VALUESET`
   | `LIST`
   | `VOID`
   | `_`
   | ``ID` text
   | ``TID` text
   | `"` text `"`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `&&&`
   | `..`
   | `<<`
   | `&&`
   | `||`
   | `==`
   | `!=`
   | `>=`
   | `<=`
   | `++`
   | `+`
   | `|+|`
   | `-`
   | `|-|`
   | `*`
   | `/`
   | `%`
   | `|`
   | `&`
   | `^`
   | `~`
   | `[`
   | `]`
   | `{`
   | `}`
   | `<`
   | `>`
   | `!`
   | `:`
   | `,`
   | `?`
   | `.`
   | `=`
   | `;`
   | `@`

;; ../../../../spec-concrete/1-syntax.watsup:1172.1-1174.35
syntax annotationBody = 
   | ``EMPTY`
   | annotationBody `(` annotationBody `)`
   | annotationBody annotationToken

;; ../../../../spec-concrete/1-syntax.watsup:1177.3-1177.41
syntax structuredAnnotationBody = 
   | dataElementExpression trailingCommaOpt

;; ../../../../spec-concrete/1-syntax.watsup:1180.1-1182.42
syntax annotation = 
   | `@` name
   | `@` name `(` annotationBody `)`
   | `@` name `[` structuredAnnotationBody `]`

;; ../../../../spec-concrete/1-syntax.watsup:1185.1-1186.38
syntax annotationListNonEmpty = 
   | `@` name
   | `@` name `(` annotationBody `)`
   | `@` name `[` structuredAnnotationBody `]`
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1189.1-1190.27
syntax annotationList = 
   | ``EMPTY`
   | `@` name
   | `@` name `(` annotationBody `)`
   | `@` name `[` structuredAnnotationBody `]`
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1197.1-1199.17
syntax p4program = 
   | ``EMPTY`
   | p4program declaration
   | p4program `;`

;; ../../../../spec-concrete/1-syntax.watsup:1201.1-1201.49
def $flatten_p4program(p4program) : declaration* =

   ;; ../../../../spec-concrete/1-syntax.watsup:1202.1-1202.37
   clause 0(p4program) = []
      -- if p4program matches ``EMPTY`

   ;; ../../../../spec-concrete/1-syntax.watsup:1203.1-1204.53
   clause 1(p4program') = $flatten_p4program(p4program) ++ [declaration]
      -- if p4program' matches `%%`
      -- let p4program declaration = p4program'

   ;; ../../../../spec-concrete/1-syntax.watsup:1205.1-1206.34
   clause 2(p4program') = $flatten_p4program(p4program)
      -- if p4program' matches `%;`
      -- let p4program `;` = p4program'

;; ../../../../spec-concrete/2.0-domain.watsup:5.17-5.21
syntax nameIR = text

;; ../../../../spec-concrete/2.0-domain.watsup:7.1-7.25
def $name(name) : nameIR =

   ;; ../../../../spec-concrete/2.0-domain.watsup:9.1-9.21
   clause 0(name) = t
      -- if name <: identifier
      -- let ``ID` t = name as identifier

   ;; ../../../../spec-concrete/2.0-domain.watsup:10.1-10.22
   clause 1(name) = t
      -- if name <: typeIdentifier
      -- let ``TID` t = name as typeIdentifier

   ;; ../../../../spec-concrete/2.0-domain.watsup:11.1-11.27
   clause 2(name) = "apply"
      -- if (name = `APPLY` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:12.1-12.23
   clause 3(name) = "key"
      -- if (name = `KEY` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:13.1-13.31
   clause 4(name) = "actions"
      -- if (name = `ACTIONS` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:14.1-14.27
   clause 5(name) = "state"
      -- if (name = `STATE` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:15.1-15.31
   clause 6(name) = "entries"
      -- if (name = `ENTRIES` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:16.1-16.25
   clause 7(name) = "type"
      -- if (name = `TYPE` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:17.1-17.33
   clause 8(name) = "priority"
      -- if (name = `PRIORITY` as name)

   ;; ../../../../spec-concrete/2.0-domain.watsup:18.1-18.25
   clause 9(name) = "list"
      -- if name matches `LIST`

;; ../../../../spec-concrete/2.0-domain.watsup:20.1-20.47
def $tableCustomName(tableCustomName) : nameIR =

   ;; ../../../../spec-concrete/2.0-domain.watsup:22.1-22.32
   clause 0(tableCustomName) = t
      -- if tableCustomName <: identifier
      -- let ``ID` t = tableCustomName as identifier

   ;; ../../../../spec-concrete/2.0-domain.watsup:23.1-23.33
   clause 1(tableCustomName) = t
      -- if tableCustomName <: typeIdentifier
      -- let ``TID` t = tableCustomName as typeIdentifier

   ;; ../../../../spec-concrete/2.0-domain.watsup:24.1-24.38
   clause 2(tableCustomName) = "apply"
      -- if tableCustomName matches `APPLY`

   ;; ../../../../spec-concrete/2.0-domain.watsup:25.1-25.38
   clause 3(tableCustomName) = "state"
      -- if tableCustomName matches `STATE`

   ;; ../../../../spec-concrete/2.0-domain.watsup:26.1-26.36
   clause 4(tableCustomName) = "type"
      -- if tableCustomName matches `TYPE`

   ;; ../../../../spec-concrete/2.0-domain.watsup:27.1-27.44
   clause 5(tableCustomName) = "priority"
      -- if tableCustomName matches `PRIORITY`

;; ../../../../spec-concrete/2.0-domain.watsup:33.13-33.17
syntax id = text

;; ../../../../spec-concrete/2.0-domain.watsup:39.14-39.16
syntax tid = id

;; ../../../../spec-concrete/2.0-domain.watsup:41.1-41.23
def $fresh_tid : tid =

;; ../../../../spec-concrete/2.0-domain.watsup:42.1-42.28
def $fresh_tids(nat) : tid* =

   ;; ../../../../spec-concrete/2.0-domain.watsup:44.1-44.25
   clause 0(nat) = []
      -- if (nat = 0)

   ;; ../../../../spec-concrete/2.0-domain.watsup:45.1-46.15
   clause 1(n) = $fresh_tid :: $fresh_tids((n - 1))
      -- otherwise

;; ../../../../spec-concrete/2.0-domain.watsup:56.14-56.24
syntax pid = 
   | id `#` bool

;; ../../../../spec-concrete/2.0-domain.watsup:57.14-57.26
syntax rid = 
   | id `(` pid* `)`

;; ../../../../spec-concrete/2.0-domain.watsup:59.1-59.36
def $rid(name, parameterList) : rid =

   ;; ../../../../spec-concrete/2.0-domain.watsup:63.1-64.42
   clause 0(name, parameterList) = $name(name) `(` $pids(parameterList) `)`

;; ../../../../spec-concrete/2.0-domain.watsup:60.1-60.32
def $pids(parameterList) : pid* =

   ;; ../../../../spec-concrete/2.0-domain.watsup:66.1-66.24
   clause 0(parameterList) = []
      -- if parameterList matches ``EMPTY`

   ;; ../../../../spec-concrete/2.0-domain.watsup:67.1-67.39
   clause 1(parameterList) = [$pid(parameter)]
      -- if parameterList <: parameter
      -- let parameter = parameterList as parameter

   ;; ../../../../spec-concrete/2.0-domain.watsup:68.1-69.56
   clause 2(parameterList) = $pids(nonEmptyParameterList as parameterList) ++ [$pid(parameter)]
      -- if parameterList <: nonEmptyParameterList
      -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
      -- if nonEmptyParameterList' matches `%,%`
      -- let nonEmptyParameterList `,` parameter = nonEmptyParameterList'

;; ../../../../spec-concrete/2.0-domain.watsup:61.1-61.26
def $pid(parameter) : pid =

   ;; ../../../../spec-concrete/2.0-domain.watsup:71.1-71.51
   clause 0(_annotationList _direction _type name initializerOpt) = $name(name) `#` false
      -- if initializerOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/2.0-domain.watsup:72.1-72.55
   clause 1(_annotationList _direction _type name initializerOpt) = $name(name) `#` true
      -- if initializerOpt <: initializer
      -- let initializer = initializerOpt as initializer

;; ../../../../spec-concrete/2.0-domain.watsup:78.14-78.17
syntax cid = rid

;; ../../../../spec-concrete/2.0-domain.watsup:80.1-80.50
def $cid(name, constructorParameterListOpt) : cid =

   ;; ../../../../spec-concrete/2.0-domain.watsup:82.1-82.46
   clause 0(name, constructorParameterListOpt) = $name(name) `(` [] `)`
      -- if constructorParameterListOpt matches ``EMPTY`

   ;; ../../../../spec-concrete/2.0-domain.watsup:83.1-84.42
   clause 1(name, constructorParameterListOpt) = $name(name) `(` $pids(parameterList) `)`
      -- if constructorParameterListOpt matches `(%)`
      -- let `(` parameterList `)` = constructorParameterListOpt

;; ../../../../spec-concrete/2.1.1-value.watsup:14.1-17.15
syntax primitiveValue = 
   | `B` bool
   | `ERROR.` id
   | `MATCH_KIND.` id
   | `"` text `"`

;; ../../../../spec-concrete/2.1.1-value.watsup:24.1-27.21
syntax numberValue = 
   | `D` int
   | nat `S` int
   | nat `W` int
   | nat `V` int `#` nat

;; ../../../../spec-concrete/2.1.1-value.watsup:29.20-29.50
syntax baseValue = 
   | `B` bool
   | `ERROR.` id
   | `MATCH_KIND.` id
   | `"` text `"`
   | `D` int
   | nat `S` int
   | nat `W` int
   | nat `V` int `#` nat

;; ../../../../spec-concrete/2.1.1-value.watsup:37.20-37.31
syntax listValue = 
   | `[` value* `]`

;; ../../../../spec-concrete/2.1.1-value.watsup:38.21-38.32
syntax tupleValue = 
   | `(` value* `)`

;; ../../../../spec-concrete/2.1.1-value.watsup:39.27-39.55
syntax headerStackValue = 
   | `[` value* `#(` nat `;` nat `)]`

;; ../../../../spec-concrete/2.1.1-value.watsup:41.21-41.32
syntax fieldValue = 
   | value id `;`

;; ../../../../spec-concrete/2.1.1-value.watsup:43.22-43.49
syntax structValue = 
   | `STRUCT` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:44.22-44.49
syntax headerValue = 
   | `HEADER` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:45.27-45.60
syntax headerUnionValue = 
   | `HEADER_UNION` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:48.1-49.23
syntax enumValue = 
   | tid `.` id
   | tid `.` id `#` value

;; ../../../../spec-concrete/2.1.1-value.watsup:52.1-58.14
syntax dataValue = 
   | `[` value* `]`
   | `(` value* `)`
   | `[` value* `#(` nat `;` nat `)]`
   | `STRUCT` tid `{` fieldValue* `}`
   | `HEADER` tid `{` fieldValue* `}`
   | `HEADER_UNION` tid `{` fieldValue* `}`
   | tid `.` id
   | tid `.` id `#` value

;; ../../../../spec-concrete/2.1.1-value.watsup:64.23-64.30
syntax defaultValue = 
   | `DEFAULT`

;; ../../../../spec-concrete/2.1.1-value.watsup:66.29-66.33
syntax invalidHeaderValue = 
   | `{#}`

;; ../../../../spec-concrete/2.1.1-value.watsup:69.1-70.28
syntax sequenceValue = 
   | `SEQ(` value* `)`
   | `SEQ(` value* `,...)`

;; ../../../../spec-concrete/2.1.1-value.watsup:73.1-74.36
syntax recordValue = 
   | `RECORD{` fieldValue* `}`
   | `RECORD{` fieldValue* `,...}`

;; ../../../../spec-concrete/2.1.1-value.watsup:77.1-79.29
syntax setValue = 
   | `SET{` value `}`
   | `SET{` value `&&&` value `}`
   | `SET{` value `..` value `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:82.1-83.38
syntax tableValue = 
   | `TABLE_ENUM` tid `.` id
   | `TABLE_STRUCT` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:86.1-91.15
syntax synthesizedValue = 
   | `DEFAULT`
   | `{#}`
   | `SEQ(` value* `)`
   | `SEQ(` value* `,...)`
   | `RECORD{` fieldValue* `}`
   | `RECORD{` fieldValue* `,...}`
   | `SET{` value `}`
   | `SET{` value `&&&` value `}`
   | `SET{` value `..` value `}`
   | `TABLE_ENUM` tid `.` id
   | `TABLE_STRUCT` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.1-value.watsup:97.16-97.58
syntax value = 
   | `B` bool
   | `ERROR.` id
   | `MATCH_KIND.` id
   | `"` text `"`
   | `D` int
   | nat `S` int
   | nat `W` int
   | nat `V` int `#` nat
   | `[` value* `]`
   | `(` value* `)`
   | `[` value* `#(` nat `;` nat `)]`
   | `STRUCT` tid `{` fieldValue* `}`
   | `HEADER` tid `{` fieldValue* `}`
   | `HEADER_UNION` tid `{` fieldValue* `}`
   | tid `.` id
   | tid `.` id `#` value
   | `DEFAULT`
   | `{#}`
   | `SEQ(` value* `)`
   | `SEQ(` value* `,...)`
   | `RECORD{` fieldValue* `}`
   | `RECORD{` fieldValue* `,...}`
   | `SET{` value `}`
   | `SET{` value `&&&` value `}`
   | `SET{` value `..` value `}`
   | `TABLE_ENUM` tid `.` id
   | `TABLE_STRUCT` tid `{` fieldValue* `}`

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:5.1-5.28
def $to_int(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:12.1-12.31
def $to_bitstr(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:18.1-18.28
def $to_number(value) : int =

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:20.1-20.24
   clause 0(value) = i
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i = numberValue

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:21.1-21.38
   clause 1(value) = $to_int(w as int, i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i = numberValue

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:22.1-22.26
   clause 2(value) = i
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i = numberValue

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:23.1-23.31
   clause 3(value) = i
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%V%#%`
      -- let w `V` i `#` _nat = numberValue

;; ../../../../spec-concrete/2.2.1-type.watsup:14.1-18.11
syntax primitiveTypeIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`

;; ../../../../spec-concrete/2.2.1-type.watsup:25.1-28.20
syntax numberTypeIR = 
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:30.21-30.51
syntax baseTypeIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:40.1-41.31
syntax namedTypeIR = 
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:52.1-53.20
syntax aliasTypeIR = 
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:59.21-59.37
syntax listTypeIR = 
   | `LIST<` typeIR `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:60.22-60.40
syntax tupleTypeIR = 
   | `TUPLE<` typeIR* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:61.28-61.43
syntax headerStackTypeIR = 
   | typeIR `[` nat `]`

;; ../../../../spec-concrete/2.2.1-type.watsup:63.22-63.34
syntax fieldTypeIR = 
   | typeIR id `;`

;; ../../../../spec-concrete/2.2.1-type.watsup:65.23-65.51
syntax structTypeIR = 
   | `STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:66.23-66.51
syntax headerTypeIR = 
   | `HEADER` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:67.28-67.62
syntax headerUnionTypeIR = 
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:69.23-69.37
syntax valueFieldIR = 
   | id `=` value `;`

;; ../../../../spec-concrete/2.2.1-type.watsup:72.1-73.42
syntax enumTypeIR = 
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:76.1-82.15
syntax dataTypeIR = 
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:92.3-92.40
syntax externObjectTypeIR = 
   | `EXTERN` tid map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/2.2.1-type.watsup:93.29-93.57
syntax parserObjectTypeIR = 
   | `PARSER(` parameterTypeIR* `)`

;; ../../../../spec-concrete/2.2.1-type.watsup:94.30-94.59
syntax controlObjectTypeIR = 
   | `CONTROL(` parameterTypeIR* `)`

;; ../../../../spec-concrete/2.2.1-type.watsup:95.30-95.50
syntax packageObjectTypeIR = 
   | `PACKAGE<` typeIR* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:96.28-96.47
syntax tableObjectTypeIR = 
   | `TABLE` tid `#` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:99.1-103.22
syntax objectTypeIR = 
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:106.1-108.17
syntax definedTypeIR = 
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:114.24-114.31
syntax defaultTypeIR = 
   | `DEFAULT`

;; ../../../../spec-concrete/2.2.1-type.watsup:116.30-116.44
syntax invalidHeaderTypeIR = 
   | `HEADER_INVALID`

;; ../../../../spec-concrete/2.2.1-type.watsup:119.1-120.29
syntax sequenceTypeIR = 
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`

;; ../../../../spec-concrete/2.2.1-type.watsup:123.1-124.37
syntax recordTypeIR = 
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`

;; ../../../../spec-concrete/2.2.1-type.watsup:126.20-126.36
syntax setTypeIR = 
   | `SET<` typeIR* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:129.1-130.39
syntax tableTypeIR = 
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:133.1-138.16
syntax synthesizedTypeIR = 
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:145.1-148.22
syntax typeIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/2.2.1-type.watsup:154.24-154.30
syntax monoTypeDefIR = typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:156.24-156.48
syntax polyTypeDefIR = 
   | typeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:158.20-158.49
syntax typeDefIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`
   | typeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:164.26-164.52
syntax parameterTypeIR = 
   | direction typeIR id value?

;; ../../../../spec-concrete/2.2.1-type.watsup:171.1-174.53
syntax functionTypeIR = 
   | `BUILTIN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `FUNCTION(` parameterTypeIR* `)->` typeIR
   | `ACTION(` parameterTypeIR* `)`
   | `EXTERN_FUNCTION(` parameterTypeIR* `)->` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:177.1-182.27
syntax methodTypeIR = 
   | `BUILTIN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHODABSTRACT(` parameterTypeIR* `)->` typeIR
   | `PARSER_APPLY(` parameterTypeIR* `)`
   | `CONTROL_APPLY(` parameterTypeIR* `)`
   | `TABLE_APPLY->` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:185.1-186.17
syntax routineTypeIR = 
   | `BUILTIN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `FUNCTION(` parameterTypeIR* `)->` typeIR
   | `ACTION(` parameterTypeIR* `)`
   | `EXTERN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `BUILTIN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHODABSTRACT(` parameterTypeIR* `)->` typeIR
   | `PARSER_APPLY(` parameterTypeIR* `)`
   | `CONTROL_APPLY(` parameterTypeIR* `)`
   | `TABLE_APPLY->` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:192.31-192.44
syntax monoRoutineTypeDefIR = routineTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:194.31-194.62
syntax polyRoutineTypeDefIR = 
   | routineTypeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:197.1-198.25
syntax routineTypeDefIR = 
   | `BUILTIN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `FUNCTION(` parameterTypeIR* `)->` typeIR
   | `ACTION(` parameterTypeIR* `)`
   | `EXTERN_FUNCTION(` parameterTypeIR* `)->` typeIR
   | `BUILTIN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHOD(` parameterTypeIR* `)->` typeIR
   | `EXTERN_METHODABSTRACT(` parameterTypeIR* `)->` typeIR
   | `PARSER_APPLY(` parameterTypeIR* `)`
   | `CONTROL_APPLY(` parameterTypeIR* `)`
   | `TABLE_APPLY->` typeIR
   | routineTypeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.1-type.watsup:204.37-204.52
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:211.3-211.58
syntax constructorTypeIR = 
   | `CONSTRUCTOR(` constructorParameterTypeIR* `)->` typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:217.31-217.66
syntax constructorTypeDefIR = 
   | constructorTypeIR `<` tid* `,` tid* `>`

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:9.1-9.34
def $is_baseTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:10.1-10.38
   clause 0(typeIR) = true
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:11.1-12.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:16.1-16.39
def $is_primitiveTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:17.1-17.48
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:18.1-19.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:21.1-21.35
def $is_void_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:22.1-22.33
   clause 0(typeIR) = true
      -- if (typeIR = `VOID` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:23.1-24.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:26.1-26.35
def $is_bool_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:27.1-27.33
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:28.1-29.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:31.1-31.36
def $is_error_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:32.1-32.35
   clause 0(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:33.1-34.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:36.1-36.40
def $is_matchkind_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:37.1-37.44
   clause 0(typeIR) = true
      -- if (typeIR = `MATCH_KIND` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:38.1-39.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:41.1-41.37
def $is_string_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:42.1-42.37
   clause 0(typeIR) = true
      -- if (typeIR = `STRING` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:43.1-44.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:48.1-48.36
def $is_numberTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:49.1-49.42
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:50.1-51.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:53.1-53.44
def $is_arbitrary_int_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:54.1-54.41
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:55.1-56.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:58.1-58.40
def $is_fixed_int_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:59.1-59.44
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:60.1-61.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:63.1-63.40
def $is_fixed_bit_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:64.1-64.44
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:65.1-66.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:78.1-78.36
def $is_objectTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:79.1-79.42
   clause 0(typeIR) = true
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:80.1-81.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:83.1-83.44
def $is_extern_object_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:84.1-84.48
   clause 0(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:85.1-86.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:88.1-88.45
def $is_package_object_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:89.1-89.53
   clause 0(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:90.1-91.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:95.1-95.41
def $is_synthesizedTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:96.1-96.52
   clause 0(typeIR) = true
      -- if typeIR <: synthesizedTypeIR
      -- let synthesizedTypeIR = typeIR as synthesizedTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:97.1-98.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:100.1-100.34
def $is_set_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:101.1-101.38
   clause 0(typeIR) = true
      -- if typeIR <: setTypeIR
      -- let `SET<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as setTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:102.1-103.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:5.16-5.24
syntax bound = set<tid>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:6.16-6.32
syntax theta = map<tid, typeIR>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:8.1-8.31
def $free_type(typeIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:27.1-27.38
   clause 0(typeIR) = `{` [] `}`
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:31.1-31.35
   clause 1(typeIR) = `{` [tid] `}`
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:33.1-36.59
   clause 2(typeIR') = $union_set<tid>(bound_base, bound_args)
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR `<` typeIR*{typeIR <- typeIR*} `>` = namedTypeIR
      -- let bound_base = $free_typeDef(polyTypeDefIR as typeDefIR)
      -- let bound_args = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:40.1-40.54
   clause 3(typeIR') = $free_type(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:42.1-42.51
   clause 4(typeIR') = $free_type(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:46.1-46.54
   clause 5(typeIR') = $free_type(typeIR)
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR `>` = typeIR' as listTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:48.1-49.42
   clause 6(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:51.1-51.51
   clause 7(typeIR') = $free_type(typeIR)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:53.1-54.42
   clause 8(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:56.1-57.42
   clause 9(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerUnionTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:59.1-60.42
   clause 10(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:62.1-62.41
   clause 11(typeIR) = `{` [] `}`
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:64.1-64.61
   clause 12(typeIR') = $free_type(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:68.1-69.62
   clause 13(typeIR) = $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*{routineTypeDefIR <- routineTypeDefIR*})
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid `{` _rid `:` routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} `}` = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:71.1-74.64
   clause 14(typeIR) = bound_params
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as parserObjectTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:76.1-79.64
   clause 15(typeIR) = bound_params
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as controlObjectTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:81.1-82.42
   clause 16(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as packageObjectTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:84.1-84.55
   clause 17(typeIR') = $free_type(typeIR)
      -- if typeIR' <: tableObjectTypeIR
      -- let `TABLE` _tid `#` typeIR = typeIR' as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:88.1-88.35
   clause 18(typeIR) = `{` [] `}`
      -- if (typeIR = `DEFAULT` as typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:90.1-90.42
   clause 19(typeIR) = `{` [] `}`
      -- if (typeIR = `HEADER_INVALID` as typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:92.1-93.42
   clause 20(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:95.1-96.42
   clause 21(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `,...>` = sequenceTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:98.1-99.42
   clause 22(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = recordTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:101.1-102.42
   clause 23(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `,...}` = recordTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:104.1-105.42
   clause 24(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:107.1-107.47
   clause 25(typeIR) = `{` [] `}`
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` _tid `{` _id*{_id <- _id*} `}` = tableTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:109.1-109.49
   clause 26(typeIR) = `{` [] `}`
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:9.1-9.37
def $free_typeDef(typeDefIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:115.1-115.47
   clause 0(typeDefIR) = $free_type(typeIR)
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:117.1-120.49
   clause 1(typeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = typeDefIR as polyTypeDefIR
      -- let bound_base = $free_typeDef(typeIR_base as typeDefIR)
      -- let bound_tparams = `{` tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} `}`

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:10.1-10.49
def $free_parameterType(parameterTypeIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:126.1-126.59
   clause 0(_direction typeIR _id _value?{_value <- _value?}) = $free_type(typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:11.1-11.45
def $free_routineType(routineTypeIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:132.1-138.43
   clause 0(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:140.1-146.43
   clause 1(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:148.1-153.64
   clause 2(routineTypeIR) = bound_params
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:155.1-161.43
   clause 3(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:163.1-169.43
   clause 4(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:171.1-177.43
   clause 5(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:179.1-185.43
   clause 6(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:187.1-192.64
   clause 7(routineTypeIR) = bound_params
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:194.1-199.64
   clause 8(routineTypeIR) = bound_params
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:201.1-205.43
   clause 9(routineTypeIR) = bound_ret
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_ret = methodTypeIR
      -- let bound_ret = $free_type(typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:12.1-12.51
def $free_routineTypeDef(routineTypeDefIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:211.1-212.37
   clause 0(routineTypeDefIR) = $free_routineType(routineTypeIR)
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:214.1-219.49
   clause 1(routineTypeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let bound_base = $free_routineTypeDef(routineTypeIR as routineTypeDefIR)
      -- let bound_tparams = `{` tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} `}`

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:14.1-14.40
def $subst_type(theta, typeIR) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:227.1-228.52
   clause 0(theta, typeIR') = typeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $find_map<tid, typeIR>(theta, tid)
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:230.1-234.53
   clause 1(theta, typeIR') = polyTypeDefIR_subst `<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR `<` typeIR*{typeIR <- typeIR*} `>` = namedTypeIR
      -- let typeDefIR = $subst_typeDef(theta, polyTypeDefIR as typeDefIR)
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR_subst = typeDefIR as polyTypeDefIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:238.1-240.50
   clause 2(theta, typeIR') = `TYPEDEF` tid typeIR_subst as typeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` tid typeIR = aliasTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:242.1-244.50
   clause 3(theta, typeIR') = `TYPE` tid typeIR_subst as typeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` tid typeIR = aliasTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:248.1-250.50
   clause 4(theta, typeIR') = `LIST<` typeIR_subst `>` as typeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR `>` = typeIR' as listTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:252.1-254.53
   clause 5(theta, typeIR') = `TUPLE<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:256.1-258.50
   clause 6(theta, typeIR') = typeIR_subst `[` n `]` as typeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n `]` = typeIR' as headerStackTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:260.1-265.57
   clause 7(theta, typeIR) = `STRUCT` tid `{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `}` as typeIR
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as structTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:267.1-272.57
   clause 8(theta, typeIR) = `HEADER` tid `{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `}` as typeIR
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:274.1-279.57
   clause 9(theta, typeIR) = `HEADER_UNION` tid `{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `}` as typeIR
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerUnionTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:281.1-286.50
   clause 10(theta, typeIR') = `ENUM` tid `#` typeIR_subst `{` valueFieldIR*{valueFieldIR <- valueFieldIR*} `}` as typeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` typeIR `{` valueFieldIR*{valueFieldIR <- valueFieldIR*} `}` = enumTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:290.1-296.59
   clause 11(theta, typeIR) = `EXTERN` tid `{` rid `:` routineTypeDefIR_subst*{rid <- rid*, routineTypeDefIR_subst <- routineTypeDefIR_subst*} `}` as typeIR
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` tid `{` rid `:` routineTypeDefIR*{rid <- rid*, routineTypeDefIR <- routineTypeDefIR*} `}` = typeIR as externObjectTypeIR
      -- (let routineTypeDefIR_subst = $subst_routineTypeDef(theta, routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*, routineTypeDefIR_subst <- routineTypeDefIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:298.1-301.57
   clause 12(theta, typeIR) = `PARSER(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as typeIR
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as parserObjectTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:303.1-306.57
   clause 13(theta, typeIR) = `CONTROL(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as typeIR
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as controlObjectTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:308.1-310.53
   clause 14(theta, typeIR') = `PACKAGE<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as packageObjectTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:312.1-314.50
   clause 15(theta, typeIR') = `TABLE` tid `#` typeIR_subst as typeIR
      -- if typeIR' <: tableObjectTypeIR
      -- let `TABLE` tid `#` typeIR = typeIR' as tableObjectTypeIR
      -- let typeIR_subst = $subst_type(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:318.1-320.53
   clause 16(theta, typeIR') = `SEQ<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:322.1-324.53
   clause 17(theta, typeIR') = `SEQ<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `,...>` as typeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `,...>` = sequenceTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:326.1-331.57
   clause 18(theta, typeIR) = `RECORD{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `}` as typeIR
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = recordTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:333.1-338.57
   clause 19(theta, typeIR) = `RECORD{` typeIR_f_subst id_f `;`*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} `,...}` as typeIR
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `,...}` = recordTypeIR
      -- (let typeIR_f_subst = $subst_type(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:340.1-342.53
   clause 20(theta, typeIR') = `SET<` typeIR_subst*{typeIR_subst <- typeIR_subst*} `>` as typeIR
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR
      -- (let typeIR_subst = $subst_type(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:346.1-347.15
   clause 21(theta, typeIR) = typeIR
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:15.1-15.49
def $subst_typeDef(theta, typeDefIR) : typeDefIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:353.1-353.63
   clause 0(theta, typeDefIR) = $subst_type(theta, typeIR) as typeDefIR
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:355.1-374.62
   clause 1(theta, typeDefIR) = typeIR_base_subst `<` tid_fresh*{tid_fresh <- tid_fresh*} `,` tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} `>` as typeDefIR
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = typeDefIR as polyTypeDefIR
      -- let `{` tid_free*{tid_free <- tid_free*} `}` = $diff_set<tid>($free_type(typeIR_base), `{` tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} `}`)
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
      -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
      -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
      -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
      -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, `TID` tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
      -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, `TID` tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
      -- let typeIR_base_subst = $subst_type(theta'', typeIR_base)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:16.1-16.67
def $subst_parameterType(theta, parameterTypeIR) : parameterTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:380.1-382.50
   clause 0(theta, direction typeIR id value?{value <- value?}) = direction typeIR_subst id value?{value <- value?}
      -- let typeIR_subst = $subst_type(theta, typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:17.1-17.61
def $subst_routineType(theta, routineTypeIR) : routineTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:388.1-395.58
   clause 0(theta, routineTypeIR) = `BUILTIN_FUNCTION(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:397.1-404.58
   clause 1(theta, routineTypeIR) = `FUNCTION(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:406.1-412.57
   clause 2(theta, routineTypeIR) = `ACTION(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:414.1-421.58
   clause 3(theta, routineTypeIR) = `EXTERN_FUNCTION(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:423.1-430.58
   clause 4(theta, routineTypeIR) = `BUILTIN_METHOD(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:432.1-439.58
   clause 5(theta, routineTypeIR) = `EXTERN_METHOD(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:441.1-448.58
   clause 6(theta, routineTypeIR) = `EXTERN_METHODABSTRACT(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:450.1-456.57
   clause 7(theta, routineTypeIR) = `PARSER_APPLY(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:458.1-464.57
   clause 8(theta, routineTypeIR) = `CONTROL_APPLY(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)` as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:466.1-471.58
   clause 9(theta, routineTypeIR) = `TABLE_APPLY->` typeIR_ret_subst as routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_ret = methodTypeIR
      -- let typeIR_ret_subst = $subst_type(theta, typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:18.1-18.70
def $subst_routineTypeDef(theta, routineTypeDefIR) : routineTypeDefIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:477.1-478.45
   clause 0(theta, routineTypeDefIR) = $subst_routineType(theta, routineTypeIR) as routineTypeDefIR
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:480.1-499.73
   clause 1(theta, routineTypeDefIR) = routineTypeIR_subst `<` tid_fresh*{tid_fresh <- tid_fresh*} `,` tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} `>` as routineTypeDefIR
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let `{` tid_free*{tid_free <- tid_free*} `}` = $diff_set<tid>($free_routineType(routineTypeIR), `{` tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} `}`)
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
      -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
      -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
      -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
      -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, `TID` tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
      -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, `TID` tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
      -- let routineTypeIR_subst = $subst_routineType(theta'', routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:19.1-19.73
def $subst_constructorType(theta, constructorTypeIR) : constructorTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:505.1-512.58
   clause 0(theta, `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_obj) = `CONSTRUCTOR(` parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} `)->` typeIR_obj_subst
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_obj_subst = $subst_type(theta, typeIR_obj)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:522.1-522.53
def $specialize_typeDef(typeDefIR, typeIR*) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:524.1-524.46
   clause 0(typeDefIR, typeIR'*{typeIR' <- typeIR'*}) = typeIR
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches []

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:526.1-529.49
   clause 1(typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $subst_type(theta, typeIR_base)
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_base `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = typeDefIR as polyTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- let theta = `{` tid_tparam `:` typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} `}`

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:535.1-536.29
def $specialize_routineTypeDef(routineTypeDefIR, typeIR*) : (routineTypeDefIR, tid*) =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:538.1-539.25
   clause 0(routineTypeDefIR, typeIR*{typeIR <- typeIR*}) = (routineTypeIR as routineTypeDefIR, [])
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches []

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:541.1-548.49
   clause 1(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR) as routineTypeDefIR, [])
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
      -- let theta = `{` tid_tparam `:` typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} `}`

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:550.1-558.54
   clause 2(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
      -- let theta = `{` tid_tparam `:` `TID` tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} `}`

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:560.1-571.53
   clause 3(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ `TID` tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
      -- let theta = `{` tid_tparam `:` typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} `}`

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:577.1-578.30
def $specialize_constructorTypeDef(constructorTypeDefIR, typeIR*) : (constructorTypeIR, tid*) =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:580.1-587.49
   clause 0(constructorTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>`, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_constructorType(theta, constructorTypeIR), [])
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
      -- let theta = `{` tid_tparam `:` typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} `}`

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:589.1-597.54
   clause 1(constructorTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>`, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_constructorType(theta, constructorTypeIR), tid_fresh*{tid_fresh <- tid_fresh*})
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
      -- let theta = `{` tid_tparam `:` `TID` tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} `}`

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:599.1-610.53
   clause 2(constructorTypeIR `<` tid*{tid <- tid*} `,` tid_hidden*{tid_hidden <- tid_hidden*} `>`, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_constructorType(theta, constructorTypeIR), tid_fresh*{tid_fresh <- tid_fresh*})
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ `TID` tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
      -- let theta = `{` tid_tparam `:` typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} `}`

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:617.1-617.28
def $canon(typeIR) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:619.1-620.65
   clause 0(typeIR') = $canon(typeIR)
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR
      -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:622.1-622.46
   clause 1(typeIR') = $canon(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:624.1-625.15
   clause 2(typeIR) = typeIR
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:7.1-7.38
def $is_nominal_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:10.1-11.40
   clause 0(typeIR) = $is_nominal_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:8.1-8.39
def $is_nominal_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:12.1-12.41
   clause 0(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:13.1-13.48
   clause 1(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:14.1-14.48
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:15.1-15.54
   clause 3(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:16.1-16.46
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:17.1-17.51
   clause 5(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:18.1-18.43
   clause 6(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:19.1-19.45
   clause 7(typeIR) = true
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:20.1-21.15
   clause 8(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:25.1-25.42
def $is_defaultable_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:28.1-29.44
   clause 0(typeIR) = $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:26.1-26.43
def $is_defaultable_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:30.1-30.41
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:31.1-31.42
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:32.1-32.43
   clause 2(typeIR) = true
      -- if (typeIR = `STRING` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:33.1-33.49
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:34.1-35.35
   clause 4(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:36.1-37.40
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:38.1-39.35
   clause 6(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:40.1-41.40
   clause 7(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:42.1-43.40
   clause 8(typeIR') = true
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:44.1-45.40
   clause 9(typeIR') = true
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as headerUnionTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:46.1-46.50
   clause 10(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:47.1-48.35
   clause 11(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:49.1-50.15
   clause 12(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:54.1-54.40
def $is_equalable_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:57.1-58.42
   clause 0(typeIR) = $is_equalable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:55.1-55.41
def $is_equalable_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:59.1-59.40
   clause 0(typeIR) = false
      -- if (typeIR = `VOID` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:60.1-60.43
   clause 1(typeIR) = false
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:61.1-61.46
   clause 2(typeIR) = false
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:62.1-62.49
   clause 3(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:63.1-63.50
   clause 4(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:64.1-64.50
   clause 5(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:65.1-65.48
   clause 6(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:66.1-66.43
   clause 7(typeIR) = false
      -- if (typeIR = `DEFAULT` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:67.1-67.54
   clause 8(typeIR) = false
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` _typeIR*{_typeIR <- _typeIR*} `,...>` = sequenceTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:68.1-68.57
   clause 9(typeIR) = false
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `,...}` = recordTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:69.1-69.50
   clause 10(typeIR) = false
      -- if (typeIR = `HEADER_INVALID` as typeIR)

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:70.1-70.46
   clause 11(typeIR) = false
      -- if typeIR <: setTypeIR
      -- let `SET<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as setTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:71.1-71.55
   clause 12(typeIR) = false
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` _tid `{` _id*{_id <- _id*} `}` = tableTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:72.1-72.57
   clause 13(typeIR) = false
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:73.1-74.15
   clause 14(typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:5.1-7.20
relation Type_alpha: typeIR `~~` typeIR

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:27.1-28.27
   rule basetype: typeIR `~~` typeIR'
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR
      -- if typeIR' <: baseTypeIR
      -- let baseTypeIR' = typeIR' as baseTypeIR
      -- if (baseTypeIR = baseTypeIR')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:32.1-33.26
   rule nametype: typeIR `~~` typeIR'
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `TID%`
      -- let `TID` tid' = namedTypeIR'
      -- if (tid = tid')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:35.1-43.41
   rule spectype-nominal: typeIR `~~` typeIR'
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_a `<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_b `<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = namedTypeIR'
      -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
      -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
      -- if Type_alpha: typeIR_a_spec `~~` typeIR_b_spec holds
      -- if ($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:45.1-52.46
   rule spectype-structural: typeIR `~~` typeIR'
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_a `<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_b `<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = namedTypeIR'
      -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
      -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
      -- if Type_alpha: typeIR_a_spec `~~` typeIR_b_spec holds
      -- if (~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:56.1-58.38
   rule typedeftype-left: typeIR `~~` typeIR_b
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR_a = aliasTypeIR
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:60.1-62.38
   rule typedeftype-right: typeIR_a `~~` typeIR
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR_b = aliasTypeIR
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:64.1-66.38
   rule newtype: typeIR `~~` typeIR'
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` tid typeIR_a = aliasTypeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR' = typeIR' as aliasTypeIR
      -- if aliasTypeIR' matches `TYPE%%`
      -- let `TYPE` tid' typeIR_b = aliasTypeIR'
      -- if (tid = tid')
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:70.1-72.38
   rule listtype: typeIR `~~` typeIR'
      -- if typeIR <: listTypeIR
      -- let `LIST<` typeIR_a `>` = typeIR as listTypeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR_b `>` = typeIR' as listTypeIR
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:74.1-76.41
   rule tupletype: typeIR `~~` typeIR'
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = typeIR as tupleTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:78.1-80.38
   rule stacktype: typeIR `~~` typeIR'
      -- if typeIR <: headerStackTypeIR
      -- let typeIR_a `[` n_s `]` = typeIR as headerStackTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_s' `]` = typeIR' as headerStackTypeIR
      -- if (n_s = n_s')
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:82.1-85.45
   rule structtype: typeIR `~~` typeIR'
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_f_a id_f `;`*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} `}` = typeIR as structTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` tid' `{` typeIR_f_b id_f' `;`*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} `}` = typeIR' as structTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a `~~` typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:87.1-90.45
   rule headertype: typeIR `~~` typeIR'
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_f_a id_f `;`*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} `}` = typeIR as headerTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` tid' `{` typeIR_f_b id_f' `;`*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} `}` = typeIR' as headerTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a `~~` typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:92.1-95.45
   rule headeruniontype: typeIR `~~` typeIR'
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` tid `{` typeIR_f_a id_f `;`*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} `}` = typeIR as headerUnionTypeIR
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` tid' `{` typeIR_f_b id_f' `;`*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} `}` = typeIR' as headerUnionTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a `~~` typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:97.1-98.49
   rule enumtype: typeIR `~~` typeIR'
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` tid `{` id_f*{id_f <- id_f*} `}` = enumTypeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR' = typeIR' as enumTypeIR
      -- if enumTypeIR' matches `ENUM%{%}`
      -- let `ENUM` tid' `{` id_f'*{id_f' <- id_f'*} `}` = enumTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:100.1-103.38
   rule serenumtype: typeIR `~~` typeIR'
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` typeIR_a `{` id_f `=` value_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = enumTypeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR' = typeIR' as enumTypeIR
      -- if enumTypeIR' matches `ENUM%#%{%}`
      -- let `ENUM` tid' `#` typeIR_b `{` id_f' `=` value_f' `;`*{id_f' <- id_f'*, value_f' <- value_f'*} `}` = enumTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if (value_f = value_f'))*{value_f <- value_f*, value_f' <- value_f'*}
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:107.1-119.73
   rule externtype: typeIR `~~` typeIR'
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` tid `{` rid_a `:` routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} `}` = typeIR as externObjectTypeIR
      -- if typeIR' <: externObjectTypeIR
      -- let `EXTERN` tid' `{` rid_b `:` routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} `}` = typeIR' as externObjectTypeIR
      -- if (tid = tid')
      -- if $eq_set<rid>(`{` rid_a*{rid_a <- rid_a*} `}`, `{` rid_b*{rid_b <- rid_b*} `}`)
      -- (let routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} = $find_map<rid, routineTypeDefIR>(`{` rid_a `:` routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} `}`, rid_a))*{rid_a <- rid_a*, routineTypeDefIR? <- routineTypeDefIR?*}
      -- (if routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} matches (_))*{routineTypeDefIR? <- routineTypeDefIR?*}
      -- (let ?(routineTypeDefIR_a') = routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?})*{routineTypeDefIR? <- routineTypeDefIR?*, routineTypeDefIR_a' <- routineTypeDefIR_a'*}
      -- (let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_map<rid, routineTypeDefIR>(`{` rid_b `:` routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} `}`, rid_a))*{rid_a <- rid_a*, routineTypeDefIR'? <- routineTypeDefIR'?*}
      -- (if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_))*{routineTypeDefIR'? <- routineTypeDefIR'?*}
      -- (let ?(routineTypeDefIR_b') = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?})*{routineTypeDefIR'? <- routineTypeDefIR'?*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}
      -- (if RoutineTypeDef_alpha: routineTypeDefIR_a' `~~` routineTypeDefIR_b' holds)*{routineTypeDefIR_a' <- routineTypeDefIR_a'*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:121.1-123.68
   rule parsertype: typeIR `~~` typeIR'
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = typeIR as parserObjectTypeIR
      -- if typeIR' <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = typeIR' as parserObjectTypeIR
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:125.1-127.68
   rule controltype: typeIR `~~` typeIR'
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = typeIR as controlObjectTypeIR
      -- if typeIR' <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = typeIR' as controlObjectTypeIR
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:129.1-131.41
   rule packagetype: typeIR `~~` typeIR'
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = typeIR as packageObjectTypeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as packageObjectTypeIR
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:133.1-135.38
   rule tabletype: typeIR `~~` typeIR'
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` tid `#` typeIR_a = typeIR as tableObjectTypeIR
      -- if typeIR' <: tableObjectTypeIR
      -- let `TABLE` tid' `#` typeIR_b = typeIR' as tableObjectTypeIR
      -- if (tid = tid')
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:139.1-140.21
   rule defaulttype: typeIR `~~` typeIR'
      -- if (typeIR = `DEFAULT` as typeIR)
      -- if (typeIR' = `DEFAULT` as typeIR)

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:142.1-144.41
   rule sequencetype: typeIR `~~` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SEQ<%>`
      -- let `SEQ<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = sequenceTypeIR'
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:146.1-148.41
   rule sequencedefaulttype: typeIR `~~` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_b*{typeIR_b <- typeIR_b*} `,...>` = sequenceTypeIR'
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:150.1-152.41
   rule recordtype: typeIR `~~` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id `;`*{id <- id*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR' = typeIR' as recordTypeIR
      -- if recordTypeIR' matches `RECORD{%}`
      -- let `RECORD{` typeIR_b id' `;`*{id' <- id'*, typeIR_b <- typeIR_b*} `}` = recordTypeIR'
      -- (if (id = id'))*{id <- id*, id' <- id'*}
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:154.1-157.41
   rule recorddefaulttype: typeIR `~~` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id `;`*{id <- id*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR' = typeIR' as recordTypeIR
      -- if recordTypeIR' matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_b id' `;`*{id' <- id'*, typeIR_b <- typeIR_b*} `,...}` = recordTypeIR'
      -- (if (id = id'))*{id <- id*, id' <- id'*}
      -- (if Type_alpha: typeIR_a `~~` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:159.1-160.35
   rule invalidtype: typeIR `~~` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if (typeIR' = `HEADER_INVALID` as typeIR)

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:162.1-164.38
   rule settype: typeIR' `~~` typeIR'''
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_a] = typeIR*{typeIR <- typeIR*}
      -- if typeIR''' <: setTypeIR
      -- let `SET<` typeIR''*{typeIR'' <- typeIR''*} `>` = typeIR''' as setTypeIR
      -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
      -- let [typeIR_b] = typeIR''*{typeIR'' <- typeIR''*}
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:166.1-167.61
   rule tableenumtype: typeIR `~~` typeIR'
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` tid `{` id_f*{id_f <- id_f*} `}` = tableTypeIR
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR' = typeIR' as tableTypeIR
      -- if tableTypeIR' matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` tid' `{` id_f'*{id_f' <- id_f'*} `}` = tableTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:169.1-172.45
   rule tablestructtype: typeIR `~~` typeIR'
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` tid `{` typeIR_f_a id_f `;`*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} `}` = tableTypeIR
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR' = typeIR' as tableTypeIR
      -- if tableTypeIR' matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` tid' `{` typeIR_f_b id_f' `;`*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} `}` = tableTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: typeIR_f_a `~~` typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:9.1-11.20
relation ParameterType_alpha: parameterTypeIR `~~` parameterTypeIR

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:178.1-180.38
   rule : _direction typeIR_a _id _value?{_value <- _value?} `~~` _direction' typeIR_b _id' _value'?{_value' <- _value'?}
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:13.1-15.20
relation RoutineType_alpha: routineTypeIR `~~` routineTypeIR

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:186.1-190.46
   rule builtinfunction: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:192.1-196.46
   rule function: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:198.1-200.68
   rule action: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:202.1-206.46
   rule externfunction: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = functionTypeIR
      -- if routineTypeIR' <: functionTypeIR
      -- let functionTypeIR' = routineTypeIR' as functionTypeIR
      -- if functionTypeIR' matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = functionTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:208.1-212.46
   rule builtinmethod: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:214.1-218.46
   rule externmethod: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:220.1-224.46
   rule externmethod-abstract: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)->` typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)->` typeIR_ret_b = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:226.1-229.68
   rule parserapply: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:231.1-234.68
   rule controlapply: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} `)` = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} `)` = methodTypeIR'
      -- (if ParameterType_alpha: parameterTypeIR_a `~~` parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:236.1-239.46
   rule tableapply: routineTypeIR `~~` routineTypeIR'
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_ret_a = methodTypeIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_ret_b = methodTypeIR'
      -- if Type_alpha: typeIR_ret_a `~~` typeIR_ret_b holds

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:17.1-19.20
relation RoutineTypeDef_alpha: routineTypeDefIR `~~` routineTypeDefIR

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:245.1-247.59
   rule mono: routineTypeDefIR `~~` routineTypeDefIR'
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR_a = routineTypeDefIR as routineTypeIR
      -- if routineTypeDefIR' <: routineTypeIR
      -- let routineTypeIR_b = routineTypeDefIR' as routineTypeIR
      -- if RoutineType_alpha: routineTypeIR_a `~~` routineTypeIR_b holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:249.1-268.71
   rule poly: routineTypeDefIR `~~` routineTypeDefIR'
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR_a `<` tid_a*{tid_a <- tid_a*} `,` tid_hidden_a*{tid_hidden_a <- tid_hidden_a*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR_b `<` tid_b*{tid_b <- tid_b*} `,` tid_hidden_b*{tid_hidden_b <- tid_hidden_b*} `>` = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if (|tid_a*{tid_a <- tid_a*}| = |tid_b*{tid_b <- tid_b*}|)
      -- if (|tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}| = |tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}|)
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids((|tid_a*{tid_a <- tid_a*}| + |tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}|))
      -- let tid_a'*{tid_a' <- tid_a'*} = tid_a*{tid_a <- tid_a*} ++ tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}
      -- let theta_a = `{` tid_a' `:` `TID` tid_fresh as typeIR*{tid_a' <- tid_a'*, tid_fresh <- tid_fresh*} `}`
      -- let routineTypeIR_a_subst = $subst_routineType(theta_a, routineTypeIR_a)
      -- let tid_b'*{tid_b' <- tid_b'*} = tid_b*{tid_b <- tid_b*} ++ tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}
      -- let theta_b = `{` tid_b' `:` `TID` tid_fresh as typeIR*{tid_b' <- tid_b'*, tid_fresh <- tid_fresh*} `}`
      -- let routineTypeIR_b_subst = $subst_routineType(theta_b, routineTypeIR_b)
      -- if RoutineType_alpha: routineTypeIR_a_subst `~~` routineTypeIR_b_subst holds

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:5.14-5.30
syntax ctk = 
   | `LCTK`
   | `CTK`
   | `DYN`

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:7.1-7.30
def $join_ctk(ctk, ctk) : ctk =

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:9.1-9.33
   clause 0(ctk, ctk') = `LCTK`
      -- if ctk matches `LCTK`
      -- if ctk' matches `LCTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:10.1-10.31
   clause 1(ctk, ctk') = `CTK`
      -- if ctk matches `LCTK`
      -- if ctk' matches `CTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:11.1-11.31
   clause 2(ctk, ctk') = `CTK`
      -- if ctk matches `CTK`
      -- if ctk' matches `LCTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:12.1-12.30
   clause 3(ctk, ctk') = `CTK`
      -- if ctk matches `CTK`
      -- if ctk' matches `CTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:13.1-14.15
   clause 4(ctk_a, ctk_b) = `DYN`
      -- otherwise

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:16.1-16.27
def $joins_ctk(ctk*) : ctk =

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:18.1-18.26
   clause 0(ctk*{ctk <- ctk*}) = `DYN`
      -- if ctk*{ctk <- ctk*} matches []

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:19.1-19.26
   clause 1(ctk'*{ctk' <- ctk'*}) = ctk
      -- if ctk'*{ctk' <- ctk'*} matches [ _/1 ]
      -- let [ctk] = ctk'*{ctk' <- ctk'*}

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:20.1-20.57
   clause 2(ctk'*{ctk' <- ctk'*}) = $join_ctk(ctk_a, ctk_b)
      -- if ctk'*{ctk' <- ctk'*} matches _ :: _
      -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
      -- if ctk*{ctk <- ctk*} matches [ _/1 ]
      -- let [ctk_b] = ctk*{ctk <- ctk*}

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:21.1-22.40
   clause 3(ctk'*{ctk' <- ctk'*}) = $joins_ctk(ctk_d :: ctk_c*{ctk_c <- ctk_c*})
      -- if ctk'*{ctk' <- ctk'*} matches _ :: _
      -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
      -- if ctk*{ctk <- ctk*} matches _ :: _
      -- let ctk_b :: ctk_c*{ctk_c <- ctk_c*} = ctk*{ctk <- ctk*}
      -- let ctk_d = $join_ctk(ctk_a, ctk_b)

;; ../../../../spec-concrete/3-numerics.watsup:5.1-5.21
def $pow2(nat) : int =

;; ../../../../spec-concrete/3-numerics.watsup:7.1-7.25
def $shl(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:8.1-8.25
def $shr(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:9.1-9.36
def $shr_arith(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:11.1-11.21
def $bneg(int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:12.1-12.26
def $band(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:13.1-13.26
def $bxor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:14.1-14.25
def $bor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:16.1-16.33
def $bitacc(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:24.1-24.28
def $un_bnot(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:26.1-27.22
   clause 0(value) = w `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i = numberValue
      -- let i' = $bneg(i)

;; ../../../../spec-concrete/3-numerics.watsup:31.1-31.28
def $un_lnot(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:33.1-33.27
   clause 0(value) = `B` ~b as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b = primitiveValue

;; ../../../../spec-concrete/3-numerics.watsup:37.1-37.28
def $un_plus(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:39.1-39.24
   clause 0(value) = `D` i as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:40.1-40.28
   clause 1(value) = w `W` i as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:41.1-41.28
   clause 2(value) = w `S` i as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i = numberValue

;; ../../../../spec-concrete/3-numerics.watsup:45.1-45.29
def $un_minus(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:47.1-47.29
   clause 0(value) = `D` -i as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:48.1-49.29
   clause 1(value) = w `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i = numberValue
      -- let i' = ($pow2(w) - i)

   ;; ../../../../spec-concrete/3-numerics.watsup:50.1-51.46
   clause 2(value) = w `S` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i = numberValue
      -- let i' = $to_bitstr(w as int, $to_int(w as int, -i))

;; ../../../../spec-concrete/3-numerics.watsup:59.1-59.36
def $bin_plus(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:61.1-61.45
   clause 0(value, value') = `D` (i_l + i_r) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:62.1-65.43
   clause 1(value, value') = w `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:66.1-69.43
   clause 2(value, value') = w `S` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:82.1-85.43
   clause 3(value, value') = w `S` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:98.1-101.43
   clause 4(value, value') = w `S` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:75.1-75.37
def $bin_minus(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:77.1-77.46
   clause 0(value, value') = `D` (i_l - i_r) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:78.1-81.43
   clause 1(value, value') = w `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:94.1-97.43
   clause 2(value, value') = w `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:91.1-91.35
def $bin_mul(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:93.1-93.44
   clause 0(value, value') = `D` (i_l * i_r) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

;; ../../../../spec-concrete/3-numerics.watsup:105.1-105.35
def $bin_div(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:107.1-107.44
   clause 0(value, value') = `D` (i_l / i_r) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

;; ../../../../spec-concrete/3-numerics.watsup:111.1-111.35
def $bin_mod(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:113.1-113.44
   clause 0(value, value') = `D` (i_l \ i_r) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

;; ../../../../spec-concrete/3-numerics.watsup:117.1-117.35
def $bin_shl(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:119.1-119.46
   clause 0(value, value') = `D` $shl(i_l, i_r) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:120.1-120.50
   clause 1(value, value') = `D` $shl(i_l, i_r) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_r `W` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:121.1-122.33
   clause 2(value, value') = `D` $shl(i_l, i_r') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_r `S` i_r = numberValue'
      -- let i_r' = $to_int(w_r as int, i_r)

   ;; ../../../../spec-concrete/3-numerics.watsup:124.1-125.49
   clause 3(value, value') = $bin_shl(w_l `W` i_l as value, w_l `W` $to_int(w_l as int, i_r) as value)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w_l `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:126.1-127.45
   clause 4(value, value') = w_l `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w_l `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_r `W` i_r = numberValue'
      -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:128.1-130.46
   clause 5(value, value') = w_l `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w_l `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_r `S` i_r = numberValue'
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:132.1-133.49
   clause 6(value, value') = $bin_shl(w_l `S` i_l as value, w_l `S` $to_int(w_l as int, i_r) as value)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:134.1-136.46
   clause 7(value, value') = w_l `S` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_r `W` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:137.1-140.47
   clause 8(value, value') = w_l `S` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_r `S` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:144.1-144.35
def $bin_shr(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:146.1-146.46
   clause 0(value, value') = `D` $shr(i_l, i_r) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:147.1-147.50
   clause 1(value, value') = `D` $shr(i_l, i_r) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_r `W` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:148.1-149.33
   clause 2(value, value') = `D` $shr(i_l, i_r') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_r `S` i_r = numberValue'
      -- let i_r' = $to_int(w_r as int, i_r)

   ;; ../../../../spec-concrete/3-numerics.watsup:151.1-152.49
   clause 3(value, value') = $bin_shr(w_l `W` i_l as value, w_l `W` $to_int(w_l as int, i_r) as value)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w_l `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:153.1-154.45
   clause 4(value, value') = w_l `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w_l `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_r `W` i_r = numberValue'
      -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:155.1-157.46
   clause 5(value, value') = w_l `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w_l `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_r `S` i_r = numberValue'
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:159.1-163.34
   clause 6(value, value') = w_l `S` i'' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:164.1-168.34
   clause 7(value, value') = w_l `S` i'' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:169.1-173.34
   clause 8(value, value') = w_l `S` i'' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_r `W` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:174.1-178.34
   clause 9(value, value') = w_l `S` i'' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_r `W` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:179.1-184.34
   clause 10(value, value') = w_l `S` i'' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_r `S` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:185.1-190.34
   clause 11(value, value') = w_l `S` i'' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_r `S` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

;; ../../../../spec-concrete/3-numerics.watsup:194.1-194.33
def $bin_le(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:196.1-196.42
   clause 0(value, value') = (i_l <= i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:197.1-197.46
   clause 1(value, value') = (i_l <= i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:198.1-200.31
   clause 2(value, value') = (i_l' <= i_r')
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:204.1-204.33
def $bin_ge(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:206.1-206.42
   clause 0(value, value') = (i_l >= i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:207.1-207.46
   clause 1(value, value') = (i_l >= i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:208.1-210.31
   clause 2(value, value') = (i_l' >= i_r')
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:214.1-214.33
def $bin_lt(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:216.1-216.41
   clause 0(value, value') = (i_l < i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:217.1-217.45
   clause 1(value, value') = (i_l < i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:218.1-220.31
   clause 2(value, value') = (i_l' < i_r')
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:224.1-224.33
def $bin_gt(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:226.1-226.41
   clause 0(value, value') = (i_l > i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_r = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:227.1-227.45
   clause 1(value, value') = (i_l > i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:228.1-230.31
   clause 2(value, value') = (i_l' > i_r')
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:234.1-234.33
def $bin_eq(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:238.1-239.42
   clause 0(value, value') = (primitiveValue_a = primitiveValue_b)
      -- if value <: primitiveValue
      -- let primitiveValue_a = value as primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue_b = value' as primitiveValue

   ;; ../../../../spec-concrete/3-numerics.watsup:241.1-241.40
   clause 1(value, value') = (i_a = i_b)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i_a = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `D%`
      -- let `D` i_b = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:242.1-242.63
   clause 2(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w_a `W` i_a = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_b `W` i_b = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:243.1-243.63
   clause 3(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_a `S` i_a = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_b `S` i_b = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:244.1-244.73
   clause 4(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%V%#%`
      -- let w_a `V` i_a `#` _nat = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%V%#%`
      -- let w_b `V` i_b `#` _nat' = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:246.1-247.33
   clause 5(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
      -- if value <: listValue
      -- let `[` value_a*{value_a <- value_a*} `]` = value as listValue
      -- if value' <: listValue
      -- let `[` value_b*{value_b <- value_b*} `]` = value' as listValue

   ;; ../../../../spec-concrete/3-numerics.watsup:248.1-249.33
   clause 6(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
      -- if value <: tupleValue
      -- let `(` value_a*{value_a <- value_a*} `)` = value as tupleValue
      -- if value' <: tupleValue
      -- let `(` value_b*{value_b <- value_b*} `)` = value' as tupleValue

   ;; ../../../../spec-concrete/3-numerics.watsup:250.1-251.52
   clause 7(value, value') = ($bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*}) /\ (n_s_a = n_s_b))
      -- if value <: headerStackValue
      -- let `[` value_a*{value_a <- value_a*} `#(` _nat `;` n_s_a `)]` = value as headerStackValue
      -- if value' <: headerStackValue
      -- let `[` value_b*{value_b <- value_b*} `#(` _nat' `;` n_s_b `)]` = value' as headerStackValue

   ;; ../../../../spec-concrete/3-numerics.watsup:252.1-257.67
   clause 8(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: structValue
      -- let `STRUCT` tid_a `{` value_f_a id_f_a `;`*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} `}` = value as structValue
      -- if value' <: structValue
      -- let `STRUCT` tid_b `{` value_f_b id_f_b `;`*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} `}` = value' as structValue

   ;; ../../../../spec-concrete/3-numerics.watsup:258.1-263.67
   clause 9(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: headerValue
      -- let `HEADER` tid_a `{` value_f_a id_f_a `;`*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} `}` = value as headerValue
      -- if value' <: headerValue
      -- let `HEADER` tid_b `{` value_f_b id_f_b `;`*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} `}` = value' as headerValue

   ;; ../../../../spec-concrete/3-numerics.watsup:264.1-269.67
   clause 10(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: headerUnionValue
      -- let `HEADER_UNION` tid_a `{` value_f_a id_f_a `;`*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} `}` = value as headerUnionValue
      -- if value' <: headerUnionValue
      -- let `HEADER_UNION` tid_b `{` value_f_b id_f_b `;`*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} `}` = value' as headerUnionValue

   ;; ../../../../spec-concrete/3-numerics.watsup:270.1-271.41
   clause 11(value, value') = ((tid_a = tid_b) /\ (id_f_a = id_f_b))
      -- if value <: enumValue
      -- let enumValue = value as enumValue
      -- if enumValue matches `%.%`
      -- let tid_a `.` id_f_a = enumValue
      -- if value' <: enumValue
      -- let enumValue' = value' as enumValue
      -- if enumValue' matches `%.%`
      -- let tid_b `.` id_f_b = enumValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:272.1-273.74
   clause 12(value, value') = (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))
      -- if value <: enumValue
      -- let enumValue = value as enumValue
      -- if enumValue matches `%.%#%`
      -- let tid_a `.` id_f_a `#` value_f_a = enumValue
      -- if value' <: enumValue
      -- let enumValue' = value' as enumValue
      -- if enumValue' matches `%.%#%`
      -- let tid_b `.` id_f_b `#` value_f_b = enumValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:275.1-275.31
   clause 13(value, value') = true
      -- if (value = `{#}` as value)
      -- if (value' = `{#}` as value)

;; ../../../../spec-concrete/3-numerics.watsup:235.1-235.36
def $bin_eqs(value*, value*) : bool =

;; ../../../../spec-concrete/3-numerics.watsup:236.1-236.55
def $bin_eqs_fields((value, id)*, (value, id)*) : bool =

;; ../../../../spec-concrete/3-numerics.watsup:279.1-279.33
def $bin_ne(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:281.1-281.59
   clause 0(value_l, value_r) = ~$bin_eq(value_l, value_r)

;; ../../../../spec-concrete/3-numerics.watsup:285.1-285.36
def $bin_band(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:287.1-288.44
   clause 0(value, value') = w `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $band(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:290.1-293.46
   clause 1(value, value') = w `S` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $band(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:297.1-297.36
def $bin_bxor(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:299.1-300.44
   clause 0(value, value') = w `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $bxor(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:302.1-305.46
   clause 1(value, value') = w `S` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $bxor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:309.1-309.35
def $bin_bor(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:311.1-312.43
   clause 0(value, value') = w `W` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w' `W` i_r = numberValue'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $bor(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:314.1-317.45
   clause 1(value, value') = w `S` i' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w' `S` i_r = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $bor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:321.1-321.38
def $bin_concat(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:323.1-327.35
   clause 0(value, value') = w `W` i'' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w_l `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_r `W` i_r = numberValue'
      -- let i_l' = $shl(i_l, w_r as int)
      -- let i_l'' = (i_l' + i_r)
      -- let w = (w_l + w_r)
      -- let i'' = $to_bitstr(w as int, i_l'')

   ;; ../../../../spec-concrete/3-numerics.watsup:328.1-332.35
   clause 1(value, value') = w `W` i'' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w_l `W` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_r `S` i_r = numberValue'
      -- let i_l' = $shl(i_l, w_r as int)
      -- let i_l'' = (i_l' + i_r)
      -- let w = (w_l + w_r)
      -- let i'' = $to_bitstr(w as int, i_l'')

   ;; ../../../../spec-concrete/3-numerics.watsup:334.1-339.37
   clause 2(value, value') = w `S` i''' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%W%`
      -- let w_r `W` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_l'' = $shl(i_l', w_r as int)
      -- let i_l''' = (i_l'' + i_r)
      -- let w = (w_l + w_r)
      -- let i''' = $to_bitstr(w as int, i_l''')

   ;; ../../../../spec-concrete/3-numerics.watsup:340.1-345.37
   clause 3(value, value') = w `S` i''' as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w_l `S` i_l = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `%S%`
      -- let w_r `S` i_r = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_l'' = $shl(i_l', w_r as int)
      -- let i_l''' = (i_l'' + i_r)
      -- let w = (w_l + w_r)
      -- let i''' = $to_bitstr(w as int, i_l''')

;; ../../../../spec-concrete/3-numerics.watsup:349.1-349.36
def $bin_land(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:351.1-351.45
   clause 0(value, value') = `B` (b_l /\ b_r) as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b_l = primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue' = value' as primitiveValue
      -- if primitiveValue' matches `B%`
      -- let `B` b_r = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:355.1-355.35
def $bin_lor(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:357.1-357.44
   clause 0(value, value') = `B` (b_l \/ b_r) as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b_l = primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue' = value' as primitiveValue
      -- if primitiveValue' matches `B%`
      -- let `B` b_r = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:363.1-363.36
def $cast_op(typeIR, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:380.1-380.50
   clause 0(typeIR, value) = $cast_bool(typeIR, b)
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b = primitiveValue

   ;; ../../../../spec-concrete/3-numerics.watsup:396.1-396.52
   clause 1(typeIR, value) = $cast_arbint(typeIR, i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `D%`
      -- let `D` i = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:414.1-414.57
   clause 2(typeIR, value) = $cast_fixbit(typeIR, w, i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%W%`
      -- let w `W` i = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:431.1-431.57
   clause 3(typeIR, value) = $cast_fixint(typeIR, w, i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `%S%`
      -- let w `S` i = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:444.1-445.48
   clause 4(typeIR, value) = $cast_struct(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if value <: structValue
      -- let `STRUCT` tid `{` value_f id_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = value as structValue

   ;; ../../../../spec-concrete/3-numerics.watsup:458.1-459.48
   clause 5(typeIR, value) = $cast_header(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if value <: headerValue
      -- let `HEADER` tid `{` value_f id_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = value as headerValue

   ;; ../../../../spec-concrete/3-numerics.watsup:463.1-463.64
   clause 6(typeIR, value') = $cast_op(typeIR, value)
      -- if value' <: enumValue
      -- let enumValue = value' as enumValue
      -- if enumValue matches `%.%#%`
      -- let _tid `.` _id `#` value = enumValue

   ;; ../../../../spec-concrete/3-numerics.watsup:492.1-492.71
   clause 7(typeIR, value') = $cast_sequence(typeIR, value*{value <- value*})
      -- if value' <: sequenceValue
      -- let sequenceValue = value' as sequenceValue
      -- if sequenceValue matches `SEQ(%)`
      -- let `SEQ(` value*{value <- value*} `)` = sequenceValue

   ;; ../../../../spec-concrete/3-numerics.watsup:520.1-521.39
   clause 8(typeIR, value') = $cast_record(typeIR, (value, id)*{id <- id*, value <- value*})
      -- if value' <: recordValue
      -- let recordValue = value' as recordValue
      -- if recordValue matches `RECORD{%}`
      -- let `RECORD{` value id `;`*{id <- id*, value <- value*} `}` = recordValue

   ;; ../../../../spec-concrete/3-numerics.watsup:527.1-527.49
   clause 9(typeIR, value) = $default(typeIR)
      -- if (value = `DEFAULT` as value)

   ;; ../../../../spec-concrete/3-numerics.watsup:564.1-565.39
   clause 10(typeIR, value') = $cast_set_singleton(typeIR, value)
      -- if value' <: setValue
      -- let setValue = value' as setValue
      -- if setValue matches `SET{%}`
      -- let `SET{` value `}` = setValue

   ;; ../../../../spec-concrete/3-numerics.watsup:566.1-567.45
   clause 11(typeIR, value) = $cast_set_mask(typeIR, value_b, value_m)
      -- if value <: setValue
      -- let setValue = value as setValue
      -- if setValue matches `SET{%&&&%}`
      -- let `SET{` value_b `&&&` value_m `}` = setValue

   ;; ../../../../spec-concrete/3-numerics.watsup:568.1-569.46
   clause 12(typeIR, value) = $cast_set_range(typeIR, value_l, value_u)
      -- if value <: setValue
      -- let setValue = value as setValue
      -- if setValue matches `SET{%..%}`
      -- let `SET{` value_l `..` value_u `}` = setValue

;; ../../../../spec-concrete/3-numerics.watsup:365.1-365.29
def $default(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:576.1-576.49
   clause 0(typeIR) = $default'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:366.1-366.30
def $default'(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:578.1-578.30
   clause 0(typeIR) = `B` false as value
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:579.1-579.42
   clause 1(typeIR) = `ERROR.` "NoError" as value
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:580.1-581.24
   clause 2(typeIR) = `"` text_empty `"` as value
      -- if (typeIR = `STRING` as typeIR)
      -- let text_empty = ""

   ;; ../../../../spec-concrete/3-numerics.watsup:583.1-583.25
   clause 3(typeIR) = `D` 0 as int as value
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:584.1-584.34
   clause 4(typeIR) = w `W` 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:585.1-585.34
   clause 5(typeIR) = w `S` 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:586.1-586.42
   clause 6(typeIR) = w `V` 0 as int `#` 0 as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:588.1-588.59
   clause 7(typeIR') = `[` $default(typeIR)*{typeIR <- typeIR*} `]` as value
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:590.1-591.56
   clause 8(typeIR') = `[` value*{value <- value*} `#(` 0 `;` n_s `)]` as value
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_s `]` = typeIR' as headerStackTypeIR
      -- let value*{value <- value*} = $repeat_<value>($default(typeIR), n_s)

   ;; ../../../../spec-concrete/3-numerics.watsup:593.1-594.50
   clause 9(typeIR) = `STRUCT` tid `{` $default(typeIR_f) id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` as value
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:596.1-597.50
   clause 10(typeIR) = `HEADER` tid `{` $default(typeIR_f) id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` as value
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:599.1-600.56
   clause 11(typeIR) = `HEADER_UNION` tid `{` $default(typeIR_f) id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` as value
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:602.1-602.57
   clause 12(typeIR) = tid `.` id_f_h as value
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` tid `{` id*{id <- id*} `}` = enumTypeIR
      -- if id*{id <- id*} matches _ :: _
      -- let id_f_h :: _id*{_id <- _id*} = id*{id <- id*}

   ;; ../../../../spec-concrete/3-numerics.watsup:604.1-607.67
   clause 13(typeIR') = tid `.` id_zero `#` value_zero as value
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` typeIR `{` id_f `=` value_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = enumTypeIR
      -- let value_zero = $cast_arbint(typeIR, 0 as int)
      -- let id?{id <- id?} = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if id?{id <- id?} matches (_)
      -- let ?(id_zero) = id?{id <- id?}

   ;; ../../../../spec-concrete/3-numerics.watsup:609.1-613.34
   clause 14(typeIR') = tid `.` id_zero `#` value_zero as value
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` tid `#` typeIR `{` id_f `=` value_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` = enumTypeIR
      -- let value_zero = $cast_arbint(typeIR, 0 as int)
      -- if (?() = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}))
      -- let id_zero = "__UNSPECIFIED"

;; ../../../../spec-concrete/3-numerics.watsup:370.1-370.37
def $cast_bool(typeIR, bool) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:373.1-373.59
   clause 0(typeIR, b) = $cast_bool'($canon(typeIR), b)

;; ../../../../spec-concrete/3-numerics.watsup:371.1-371.38
def $cast_bool'(typeIR, bool) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:375.1-375.31
   clause 0(typeIR, b) = `B` b as value
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:376.1-376.42
   clause 1(typeIR, bool) = w `W` 1 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if (bool = true)

   ;; ../../../../spec-concrete/3-numerics.watsup:377.1-377.43
   clause 2(typeIR, bool) = w `W` 0 as int as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if (bool = false)

   ;; ../../../../spec-concrete/3-numerics.watsup:378.1-378.58
   clause 3(typeIR', b) = $cast_bool(typeIR, b)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:384.1-384.38
def $cast_arbint(typeIR, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:387.1-387.63
   clause 0(typeIR, i) = $cast_arbint'($canon(typeIR), i)

;; ../../../../spec-concrete/3-numerics.watsup:385.1-385.39
def $cast_arbint'(typeIR, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:389.1-389.39
   clause 0(typeIR, i) = `B` (i = 0 as int) as value
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:390.1-390.32
   clause 1(typeIR, i) = `D` i as value
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:391.1-391.58
   clause 2(typeIR, i) = w `W` $to_bitstr(w as int, i) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:392.1-392.58
   clause 3(typeIR, i) = w `S` $to_bitstr(w as int, i) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:393.1-393.62
   clause 4(typeIR', i) = $cast_arbint(typeIR, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:394.1-394.73
   clause 5(typeIR'', i) = `SET{` $cast_arbint(typeIR, i) `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:400.1-400.43
def $cast_fixbit(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:403.1-403.69
   clause 0(typeIR, w, i) = $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:401.1-401.44
def $cast_fixbit'(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:405.1-405.42
   clause 0(typeIR, w, i) = `B` (i = 1 as int) as value
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:406.1-406.35
   clause 1(typeIR, _nat, i) = `D` i as value
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:407.1-408.33
   clause 2(typeIR, _nat, i) = w_to `W` i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w_to `>` = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, i)

   ;; ../../../../spec-concrete/3-numerics.watsup:409.1-410.33
   clause 3(typeIR, _nat, i) = w_to `S` i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w_to `>` = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, i)

   ;; ../../../../spec-concrete/3-numerics.watsup:411.1-411.68
   clause 4(typeIR', w, i) = $cast_fixbit(typeIR, w, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:412.1-412.79
   clause 5(typeIR'', w, i) = `SET{` $cast_fixbit(typeIR, w, i) `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:418.1-418.43
def $cast_fixint(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:421.1-421.69
   clause 0(typeIR, w, i) = $cast_fixint'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:419.1-419.44
def $cast_fixint'(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:423.1-423.47
   clause 0(typeIR, w, i) = `D` $to_int(w as int, i) as value
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/3-numerics.watsup:424.1-425.50
   clause 1(typeIR, w_from, i) = w_to `W` i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w_to `>` = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

   ;; ../../../../spec-concrete/3-numerics.watsup:426.1-427.50
   clause 2(typeIR, w_from, i) = w_to `S` i' as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w_to `>` = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

   ;; ../../../../spec-concrete/3-numerics.watsup:428.1-428.68
   clause 3(typeIR', w, i) = $cast_fixint(typeIR, w, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:429.1-429.79
   clause 4(typeIR'', w, i) = `SET{` $cast_fixint(typeIR, w, i) `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:435.1-435.52
def $cast_struct(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:438.1-439.57
   clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_struct'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:436.1-436.53
def $cast_struct'(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:441.1-442.39
   clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `STRUCT` tid `{` value_f id_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` as value
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR
      -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:449.1-449.52
def $cast_header(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:452.1-453.57
   clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_header'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:450.1-450.53
def $cast_header'(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:455.1-456.39
   clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `HEADER` tid `{` value_f id_f `;`*{id_f <- id_f*, value_f <- value_f*} `}` as value
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR
      -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:467.1-467.43
def $cast_sequence(typeIR, value*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:470.1-471.44
   clause 0(typeIR, value*{value <- value*}) = $cast_sequence'($canon(typeIR), value*{value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:468.1-468.44
def $cast_sequence'(typeIR, value*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:473.1-474.34
   clause 0(typeIR', value*{value <- value*}) = `[` $cast_op(typeIR, value)*{value <- value*} `]` as value
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR `>` = typeIR' as listTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:476.1-477.34
   clause 1(typeIR', value*{value <- value*}) = `(` $cast_op(typeIR, value)*{typeIR <- typeIR*, value <- value*} `)` as value
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:479.1-482.25
   clause 2(typeIR', value*{value <- value*}) = `[` value_cast*{value_cast <- value_cast*} `#(` n_idx `;` n_s `)]` as value
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_s `]` = typeIR' as headerStackTypeIR
      -- (let value_cast = $cast_op(typeIR, value))*{value <- value*, value_cast <- value_cast*}
      -- let n_idx = |value*{value <- value*}|

   ;; ../../../../spec-concrete/3-numerics.watsup:484.1-486.50
   clause 3(typeIR, value*{value <- value*}) = `STRUCT` tid `{` value_cast id_f `;`*{id_f <- id_f*, value_cast <- value_cast*} `}` as value
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as structTypeIR
      -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

   ;; ../../../../spec-concrete/3-numerics.watsup:488.1-490.50
   clause 4(typeIR, value*{value <- value*}) = `HEADER` tid `{` value_cast id_f `;`*{id_f <- id_f*, value_cast <- value_cast*} `}` as value
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_f id_f `;`*{id_f <- id_f*, typeIR_f <- typeIR_f*} `}` = typeIR as headerTypeIR
      -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:498.1-498.47
def $cast_record(typeIR, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:501.1-502.48
   clause 0(typeIR, (value, id)*{id <- id*, value <- value*}) = $cast_record'($canon(typeIR), (value, id)*{id <- id*, value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:499.1-499.48
def $cast_record'(typeIR, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:504.1-510.57
   clause 0(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `STRUCT` tid `{` value_f_cast id_f `;`*{id_f <- id_f*, value_f_cast <- value_f_cast*} `}` as value
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_t_f id_t_f `;`*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} `}` = typeIR as structTypeIR
      -- (let value?{value <- value?} = $find_map<id, value>(`{` id_f `:` value_f*{id_f <- id_f*, value_f <- value_f*} `}`, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
      -- (if value?{value <- value?} matches (_))*{value? <- value?*}
      -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
      -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

   ;; ../../../../spec-concrete/3-numerics.watsup:512.1-518.57
   clause 1(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `HEADER` tid `{` value_f_cast id_f `;`*{id_f <- id_f*, value_f_cast <- value_f_cast*} `}` as value
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_t_f id_t_f `;`*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} `}` = typeIR as headerTypeIR
      -- (let value?{value <- value?} = $find_map<id, value>(`{` id_f `:` value_f*{id_f <- id_f*, value_f <- value_f*} `}`, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
      -- (if value?{value <- value?} matches (_))*{value? <- value?*}
      -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
      -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:533.1-533.47
def $cast_set_singleton(typeIR, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:536.1-537.48
   clause 0(typeIR, value) = $cast_set_singleton'($canon(typeIR), value)

;; ../../../../spec-concrete/3-numerics.watsup:534.1-534.48
def $cast_set_singleton'(typeIR, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:539.1-540.37
   clause 0(typeIR'', value) = `SET{` $cast_op(typeIR, value) `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:542.1-542.49
def $cast_set_mask(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:545.1-546.54
   clause 0(typeIR, value_b, value_m) = $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:543.1-543.50
def $cast_set_mask'(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:548.1-551.49
   clause 0(typeIR'', value_b, value_m) = `SET{` value_b_cast `&&&` value_m_cast `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- let value_b_cast = $cast_op(typeIR, value_b)
      -- let value_m_cast = $cast_op(typeIR, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:553.1-553.50
def $cast_set_range(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:556.1-557.55
   clause 0(typeIR, value_l, value_u) = $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:554.1-554.51
def $cast_set_range'(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:559.1-562.49
   clause 0(typeIR'', value_l, value_u) = `SET{` value_l_cast `..` value_u_cast `}` as value
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- let value_l_cast = $cast_op(typeIR, value_l)
      -- let value_u_cast = $cast_op(typeIR, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:619.1-619.44
def $bitacc_op(value, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:621.1-626.35
   clause 0(value_b, value_h, value_l) = w `W` i as value
      -- let i_b = $to_number(value_b)
      -- let i_h = $to_number(value_h)
      -- let i_l = $to_number(value_l)
      -- let int = ((i_h + 1 as int) - i_l)
      -- if int <: nat
      -- let w = int as nat
      -- let i = $bitacc(i_b, i_h, i_l)

;; ../../../../spec-concrete/4-ir-syntax.watsup:6.1-7.14
syntax prefixedNameIR = 
   | ``` nameIR
   | `.` nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:9.1-9.63
def $prefixedNonTypeName(prefixedNonTypeName) : prefixedNameIR =

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:10.1-10.62
   clause 0(prefixedNonTypeName) = ``` $name(nonTypeName as name)
      -- if prefixedNonTypeName <: nonTypeName
      -- let nonTypeName = prefixedNonTypeName as nonTypeName

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:11.1-11.69
   clause 1(prefixedNonTypeName) = `.` $name(nonTypeName as name)
      -- if prefixedNonTypeName matches ``ID.%`
      -- let ``ID.` nonTypeName = prefixedNonTypeName

;; ../../../../spec-concrete/4-ir-syntax.watsup:13.1-13.57
def $prefixedTypeName(prefixedTypeName) : prefixedNameIR =

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:14.1-14.53
   clause 0(prefixedTypeName) = ``` $name(typeName as name)
      -- if prefixedTypeName <: typeName
      -- let typeName = prefixedTypeName as typeName

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:15.1-15.61
   clause 1(prefixedTypeName) = `.` $name(typeName as name)
      -- if prefixedTypeName matches ``TID.%`
      -- let ``TID.` typeName = prefixedTypeName

;; ../../../../spec-concrete/4-ir-syntax.watsup:17.1-17.53
def $flatten_prefixedNameIR(prefixedNameIR) : nameIR =

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:18.1-18.48
   clause 0(prefixedNameIR) = nameIR
      -- if prefixedNameIR matches ``%`
      -- let ``` nameIR = prefixedNameIR

   ;; ../../../../spec-concrete/4-ir-syntax.watsup:19.1-19.55
   clause 1(prefixedNameIR) = "." ++ nameIR
      -- if prefixedNameIR matches `.%`
      -- let `.` nameIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:21.21-21.28
syntax nameListIR = nameIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:27.26-27.29
syntax typeParameterIR = tid

;; ../../../../spec-concrete/4-ir-syntax.watsup:29.30-29.46
syntax typeParameterListIR = typeParameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:38.3-38.66
syntax parameterIR = 
   | annotationList direction typeIR nameIR constantInitializerOptIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:40.26-40.38
syntax parameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:46.33-46.44
syntax constructorParameterIR = parameterIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:48.37-48.49
syntax constructorParameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:56.28-56.55
syntax namedExpressionIR = 
   | nameIR `=` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:58.32-58.50
syntax namedExpressionListIR = namedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:68.30-68.47
syntax literalExpressionIR = literalExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:74.32-74.46
syntax referenceExpressionIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:80.30-80.47
syntax defaultExpressionIR = defaultExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:86.28-86.50
syntax unaryExpressionIR = 
   | unop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:89.3-89.44
syntax binaryExpressionIR = 
   | typedExpressionIR binop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:92.3-92.62
syntax ternaryExpressionIR = 
   | typedExpressionIR `?` typedExpressionIR `:` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:98.27-98.56
syntax castExpressionIR = 
   | `(` typeIR `)` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:107.1-111.46
syntax dataExpressionIR = 
   | `{#}`
   | `SEQ{` typedExpressionListIR `}`
   | `SEQ{` typedExpressionListIR `,...}`
   | `RECORD{` namedExpressionListIR `}`
   | `RECORD{` namedExpressionListIR `,...}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:120.3-120.18
syntax errorAccessExpressionIR = 
   | `ERROR.` nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:123.3-123.31
syntax memberAccessExpressionIR = 
   | memberAccessBaseIR `.` nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:126.1-127.66
syntax indexAccessExpressionIR = 
   | typedExpressionIR `[` typedExpressionIR `]`
   | typedExpressionIR `[` typedExpressionIR `:` typedExpressionIR `]`

;; ../../../../spec-concrete/4-ir-syntax.watsup:130.1-132.28
syntax accessExpressionIR = 
   | `ERROR.` nameIR
   | memberAccessBaseIR `.` nameIR
   | typedExpressionIR `[` typedExpressionIR `]`
   | typedExpressionIR `[` typedExpressionIR `:` typedExpressionIR `]`

;; ../../../../spec-concrete/4-ir-syntax.watsup:141.27-141.41
syntax functionTargetIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:142.25-142.49
syntax methodTargetIR = memberAccessExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:145.1-147.25
syntax routineTargetIR = 
   | ``` nameIR
   | `.` nameIR
   | memberAccessBaseIR `.` nameIR
   | `(` routineTargetIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:150.30-150.60
syntax constructorTargetIR = 
   | typeIR `<` typeArgumentListIR `>`

;; ../../../../spec-concrete/4-ir-syntax.watsup:153.1-154.64
syntax callExpressionIR = 
   | constructorTargetIR `(` argumentListIR `)`
   | routineTargetIR `<` typeArgumentListIR `>(` argumentListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:160.36-160.58
syntax parenthesizedExpressionIR = 
   | `(` typedExpressionIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:167.1-177.30
syntax expressionIR = 
   | `TRUE`
   | `FALSE`
   | `D` int
   | nat `W` int
   | nat `S` int
   | `"` text `"`
   | ``` nameIR
   | `.` nameIR
   | `...`
   | unop typedExpressionIR
   | typedExpressionIR binop typedExpressionIR
   | typedExpressionIR `?` typedExpressionIR `:` typedExpressionIR
   | `(` typeIR `)` typedExpressionIR
   | `{#}`
   | `SEQ{` typedExpressionListIR `}`
   | `SEQ{` typedExpressionListIR `,...}`
   | `RECORD{` namedExpressionListIR `}`
   | `RECORD{` namedExpressionListIR `,...}`
   | `ERROR.` nameIR
   | memberAccessBaseIR `.` nameIR
   | typedExpressionIR `[` typedExpressionIR `]`
   | typedExpressionIR `[` typedExpressionIR `:` typedExpressionIR `]`
   | constructorTargetIR `(` argumentListIR `)`
   | routineTargetIR `<` typeArgumentListIR `>(` argumentListIR `)`
   | `(` typedExpressionIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:179.27-179.42
syntax expressionNoteIR = 
   | `(` typeIR ctk `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:182.3-182.35
syntax typedExpressionIR = 
   | expressionIR `#` expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:184.32-184.50
syntax typedExpressionListIR = typedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:187.1-188.22
syntax memberAccessBaseIR = 
   | `TYPE` prefixedNameIR
   | expressionIR `#` expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:195.1-199.7
syntax simpleKeysetExpressionIR = 
   | expressionIR `#` expressionNoteIR
   | typedExpressionIR `&&&` typedExpressionIR
   | typedExpressionIR `..` typedExpressionIR
   | `DEFAULT`
   | `_`

;; ../../../../spec-concrete/4-ir-syntax.watsup:201.39-201.64
syntax simpleKeysetExpressionListIR = simpleKeysetExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:203.34-203.67
syntax tupleKeysetExpressionIR = 
   | `(` simpleKeysetExpressionListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:206.1-207.28
syntax keysetExpressionIR = 
   | expressionIR `#` expressionNoteIR
   | typedExpressionIR `&&&` typedExpressionIR
   | typedExpressionIR `..` typedExpressionIR
   | `DEFAULT`
   | `_`
   | `(` simpleKeysetExpressionListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:210.3-210.40
syntax typedKeysetExpressionIR = 
   | keysetExpressionIR `#(` typeIR ctk `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:216.25-216.31
syntax typeArgumentIR = typeIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:218.29-218.44
syntax typeArgumentListIR = typeArgumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:225.1-228.7
syntax argumentIR = 
   | expressionIR `#` expressionNoteIR
   | nameIR `=` typedExpressionIR
   | nameIR `=_`
   | `_`

;; ../../../../spec-concrete/4-ir-syntax.watsup:230.25-230.36
syntax argumentListIR = argumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:239.1-243.23
syntax lvalueIR = 
   | ``` nameIR
   | `.` nameIR
   | typedLvalueIR `.` nameIR
   | typedLvalueIR `[` typedExpressionIR `]`
   | typedLvalueIR `[` typedExpressionIR `:` typedExpressionIR `]`
   | `(` typedLvalueIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:245.24-245.47
syntax typedLvalueIR = 
   | lvalueIR `#(` typeIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:248.1-250.25
syntax routineLvalueIR = 
   | ``` nameIR
   | `.` nameIR
   | typedLvalueIR `.` nameIR
   | `(` routineLvalueIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:260.27-260.41
syntax emptyStatementIR = emptyStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:267.3-267.46
syntax assignmentStatementIR = 
   | typedLvalueIR assignop typedExpressionIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:274.3-274.65
syntax callStatementIR = 
   | routineLvalueIR `<` typeArgumentListIR `>(` argumentListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:281.3-281.41
syntax directApplicationStatementIR = 
   | typeIR `.APPLY(` argumentListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:288.1-289.32
syntax returnStatementIR = 
   | `RETURN;`
   | `RETURN` typedExpressionIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:295.26-295.39
syntax exitStatementIR = exitStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:304.3-304.50
syntax blockStatementIR = 
   | annotationList `{` blockElementStatementListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:313.1-314.59
syntax conditionalStatementIR = 
   | `IF(` typedExpressionIR `)` statementIR
   | `IF(` typedExpressionIR `)` statementIR `ELSE` statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:323.1-326.35
syntax forInitStatementIR = 
   | annotationList typeIR nameIR initializerOptIR
   | lvalueIR `(` argumentListIR `)`
   | lvalueIR `<` typeArgumentListIR `>(` argumentListIR `)`
   | lvalueIR assignop expressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:328.33-328.52
syntax forInitStatementListIR = forInitStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:330.31-330.49
syntax forUpdateStatementIR = forInitStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:332.35-332.56
syntax forUpdateStatementListIR = forUpdateStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:335.1-336.44
syntax forCollectionExpressionIR = 
   | expressionIR `#` expressionNoteIR
   | typedExpressionIR `..` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:339.1-347.18
syntax forStatementIR = 
   | annotationList `FOR(` forInitStatementListIR `;` typedExpressionIR `;` forUpdateStatementListIR `)` statementIR
   | annotationList `FOR(` typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | annotationList `FOR(` annotationList typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:354.1-355.22
syntax switchLabelIR = 
   | `DEFAULT`
   | expressionIR `#` expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:358.1-359.21
syntax switchCaseIR = 
   | switchLabelIR `:` blockStatementIR
   | switchLabelIR `:`

;; ../../../../spec-concrete/4-ir-syntax.watsup:361.27-361.40
syntax switchCaseListIR = switchCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:364.3-364.54
syntax switchStatementIR = 
   | `SWITCH(` typedExpressionIR `){` switchCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:370.27-370.41
syntax breakStatementIR = breakStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:372.30-372.47
syntax continueStatementIR = continueStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:379.1-390.22
syntax statementIR = 
   | `;`
   | typedLvalueIR assignop typedExpressionIR `;`
   | routineLvalueIR `<` typeArgumentListIR `>(` argumentListIR `);`
   | typeIR `.APPLY(` argumentListIR `);`
   | `RETURN;`
   | `RETURN` typedExpressionIR `;`
   | `EXIT;`
   | annotationList `{` blockElementStatementListIR `}`
   | `IF(` typedExpressionIR `)` statementIR
   | `IF(` typedExpressionIR `)` statementIR `ELSE` statementIR
   | annotationList `FOR(` forInitStatementListIR `;` typedExpressionIR `;` forUpdateStatementListIR `)` statementIR
   | annotationList `FOR(` typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | annotationList `FOR(` annotationList typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | `BREAK;`
   | `CONTINUE;`
   | `SWITCH(` typedExpressionIR `){` switchCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:400.32-400.40
syntax constantInitializerIR = 
   | `=` value

;; ../../../../spec-concrete/4-ir-syntax.watsup:402.35-402.57
syntax constantInitializerOptIR = constantInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:405.3-405.62
syntax constantDeclarationIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:407.24-407.44
syntax initializerIR = 
   | `=` typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:409.27-409.41
syntax initializerOptIR = initializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:412.3-412.51
syntax variableDeclarationIR = 
   | annotationList typeIR nameIR initializerOptIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:415.1-417.16
syntax blockElementStatementIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList typeIR nameIR initializerOptIR `;`
   | `;`
   | typedLvalueIR assignop typedExpressionIR `;`
   | routineLvalueIR `<` typeArgumentListIR `>(` argumentListIR `);`
   | typeIR `.APPLY(` argumentListIR `);`
   | `RETURN;`
   | `RETURN` typedExpressionIR `;`
   | `EXIT;`
   | annotationList `{` blockElementStatementListIR `}`
   | `IF(` typedExpressionIR `)` statementIR
   | `IF(` typedExpressionIR `)` statementIR `ELSE` statementIR
   | annotationList `FOR(` forInitStatementListIR `;` typedExpressionIR `;` forUpdateStatementListIR `)` statementIR
   | annotationList `FOR(` typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | annotationList `FOR(` annotationList typeIR nameIR `IN` forCollectionExpressionIR `)` statementIR
   | `BREAK;`
   | `CONTINUE;`
   | `SWITCH(` typedExpressionIR `){` switchCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:419.38-419.62
syntax blockElementStatementListIR = blockElementStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:426.3-427.73
syntax functionPrototypeIR = 
   | typeIR nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:430.3-430.54
syntax functionDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:437.3-437.69
syntax actionDeclarationIR = 
   | annotationList `ACTION` nameIR `(` parameterListIR `)` blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:445.30-445.61
syntax objectInitializerIR = 
   | `={` objectDeclarationListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:447.33-447.53
syntax objectInitializerOptIR = objectInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:450.3-452.30
syntax instantiationIR = 
   | annotationList typeIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:455.1-456.20
syntax objectDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList typeIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:458.34-458.54
syntax objectDeclarationListIR = objectDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:464.29-464.50
syntax errorDeclarationIR = 
   | `ERROR{` nameListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:470.33-470.59
syntax matchKindDeclarationIR = 
   | `MATCH_KIND{` nameListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:481.1-482.65
syntax enumTypeDeclarationIR = 
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:488.22-488.53
syntax typeFieldIR = 
   | annotationList typeIR nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:490.26-490.38
syntax typeFieldListIR = typeFieldIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:493.3-494.73
syntax structTypeDeclarationIR = 
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:497.3-498.73
syntax headerTypeDeclarationIR = 
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:501.3-502.73
syntax headerUnionTypeDeclarationIR = 
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:505.1-508.33
syntax derivedTypeDeclarationIR = 
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:515.1-516.29
syntax typedefTypeIR = 
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:519.1-520.41
syntax typedefDeclarationIR = 
   | annotationList `TYPEDEF` typedefTypeIR nameIR `;`
   | annotationList `TYPE` typeIR nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:527.3-527.47
syntax externFunctionDeclarationIR = 
   | annotationList `EXTERN` functionPrototypeIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:530.1-532.51
syntax methodPrototypeIR = 
   | annotationList nameIR `<,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList functionPrototypeIR `;`
   | annotationList `ABSTRACT` functionPrototypeIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:534.32-534.50
syntax methodPrototypeListIR = methodPrototypeIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:537.3-539.31
syntax externObjectDeclarationIR = 
   | annotationList `EXTERN` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` methodPrototypeListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:542.1-543.30
syntax externDeclarationIR = 
   | annotationList `EXTERN` functionPrototypeIR `;`
   | annotationList `EXTERN` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` methodPrototypeListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:553.23-553.59
syntax selectCaseIR = 
   | typedKeysetExpressionIR `:` nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:555.27-555.40
syntax selectCaseListIR = selectCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:558.3-558.58
syntax selectExpressionIR = 
   | `SELECT(` typedExpressionListIR `){` selectCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:565.1-566.23
syntax stateExpressionIR = 
   | nameIR `;`
   | `SELECT(` typedExpressionListIR `){` selectCaseListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:568.32-568.60
syntax transitionStatementIR = 
   | `TRANSITION` stateExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:575.3-575.66
syntax valueSetDeclarationIR = 
   | annotationList `VALUESET<` typeIR `>(` expressionIR `)` nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:582.3-583.76
syntax parserTypeDeclarationIR = 
   | annotationList `PARSER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:592.3-592.44
syntax parserBlockStatementIR = 
   | annotationList `{` parserStatementListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:595.1-602.27
syntax parserStatementIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList typeIR nameIR initializerOptIR `;`
   | `;`
   | typedLvalueIR assignop typedExpressionIR `;`
   | routineLvalueIR `<` typeArgumentListIR `>(` argumentListIR `);`
   | typeIR `.APPLY(` argumentListIR `);`
   | annotationList `{` parserStatementListIR `}`
   | `IF(` typedExpressionIR `)` statementIR
   | `IF(` typedExpressionIR `)` statementIR `ELSE` statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:604.32-604.50
syntax parserStatementListIR = parserStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:607.3-608.53
syntax parserStateIR = 
   | annotationList `STATE` nameIR `{` parserStatementListIR transitionStatementIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:610.28-610.42
syntax parserStateListIR = parserStateIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:613.1-616.26
syntax parserLocalDeclarationIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList typeIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`
   | annotationList typeIR nameIR initializerOptIR `;`
   | annotationList `VALUESET<` typeIR `>(` expressionIR `)` nameIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:619.3-619.28
syntax parserLocalDeclarationListIR = parserLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:622.3-625.56
syntax parserDeclarationIR = 
   | annotationList `PARSER` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` parserLocalDeclarationListIR parserStateListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:635.18-635.23
syntax constIR = const

;; ../../../../spec-concrete/4-ir-syntax.watsup:637.21-637.29
syntax constOptIR = constIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:643.21-643.66
syntax tableKeyIR = 
   | typedExpressionIR `:` nameIR annotationList `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:645.25-645.36
syntax tableKeyListIR = tableKeyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:651.33-651.67
syntax tableActionReferenceIR = 
   | prefixedNameIR `(` argumentListIR `)`

;; ../../../../spec-concrete/4-ir-syntax.watsup:653.24-653.64
syntax tableActionIR = 
   | annotationList tableActionReferenceIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:655.28-655.42
syntax tableActionListIR = tableActionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:662.1-663.42
syntax tableEntryPriorityIR = 
   | `PRIORITY=` number `:`
   | `PRIORITY=(` typedExpressionIR `):`

;; ../../../../spec-concrete/4-ir-syntax.watsup:665.34-665.55
syntax tableEntryPriorityOptIR = tableEntryPriorityIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:668.3-669.72
syntax tableEntryIR = 
   | constOptIR tableEntryPriorityOptIR typedKeysetExpressionIR `:` tableActionReferenceIR annotationList `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:671.27-671.40
syntax tableEntryListIR = tableEntryIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:678.1-682.54
syntax tablePropertyIR = 
   | `KEY={` tableKeyListIR `}`
   | `ACTIONS={` tableActionListIR `}`
   | annotationList constOptIR `ENTRIES={` tableEntryListIR `}`
   | annotationList constOptIR `DEFAULT_ACTION=` tableActionReferenceIR `;`
   | annotationList constOptIR nameIR initializerIR `;`

;; ../../../../spec-concrete/4-ir-syntax.watsup:684.30-684.46
syntax tablePropertyListIR = tablePropertyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:687.3-687.55
syntax tableDeclarationIR = 
   | annotationList `TABLE` nameIR `{` tablePropertyListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:694.3-696.28
syntax controlTypeDeclarationIR = 
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:702.24-702.40
syntax controlBodyIR = blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:705.1-709.23
syntax controlLocalDeclarationIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList typeIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`
   | annotationList typeIR nameIR initializerOptIR `;`
   | annotationList `ACTION` nameIR `(` parameterListIR `)` blockStatementIR
   | annotationList `TABLE` nameIR `{` tablePropertyListIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:712.3-712.29
syntax controlLocalDeclarationListIR = controlLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:715.3-718.59
syntax controlDeclarationIR = 
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` controlLocalDeclarationListIR `APPLY` controlBodyIR `}`

;; ../../../../spec-concrete/4-ir-syntax.watsup:725.3-727.28
syntax packageTypeDeclarationIR = 
   | annotationList `PACKAGE` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:734.1-738.29
syntax typeDeclarationIR = 
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `TYPEDEF` typedefTypeIR nameIR `;`
   | annotationList `TYPE` typeIR nameIR `;`
   | annotationList `PARSER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList `PACKAGE` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:745.1-754.22
syntax declarationIR = 
   | annotationList `CONST` typeIR nameIR constantInitializerIR `;`
   | annotationList typeIR `<` typeArgumentListIR `>(` argumentListIR `)` nameIR objectInitializerOptIR `;`
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList `ACTION` nameIR `(` parameterListIR `)` blockStatementIR
   | `ERROR{` nameListIR `}`
   | `MATCH_KIND{` nameListIR `}`
   | annotationList `EXTERN` functionPrototypeIR `;`
   | annotationList `EXTERN` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` methodPrototypeListIR `}`
   | annotationList `PARSER` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` parserLocalDeclarationListIR parserStateListIR `}`
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` controlLocalDeclarationListIR `APPLY` controlBodyIR `}`
   | annotationList `ENUM` nameIR `{` nameListIR `}`
   | annotationList `ENUM` typeIR nameIR `{` namedExpressionListIR `}`
   | annotationList `STRUCT` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `HEADER_UNION` nameIR `<` typeParameterListIR `,` typeParameterListIR `>{` typeFieldListIR `}`
   | annotationList `TYPEDEF` typedefTypeIR nameIR `;`
   | annotationList `TYPE` typeIR nameIR `;`
   | annotationList `PARSER` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList `CONTROL` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`
   | annotationList `PACKAGE` nameIR `<` typeParameterListIR `,` typeParameterListIR `>(` parameterListIR `);`

;; ../../../../spec-concrete/4-ir-syntax.watsup:760.22-760.39
syntax p4programIR = 
   | declarationIR* `;`

;; ../../../../spec-concrete/5.0-flow.watsup:5.15-5.25
syntax flow = 
   | `CONT`
   | `RET`

;; ../../../../spec-concrete/5.0-flow.watsup:9.1-9.34
def $join_flow(flow, flow) : flow =

   ;; ../../../../spec-concrete/5.0-flow.watsup:10.1-10.31
   clause 0(flow, flow') = `RET`
      -- if flow matches `RET`
      -- if flow' matches `RET`

   ;; ../../../../spec-concrete/5.0-flow.watsup:11.1-12.15
   clause 1(f_a, f_b) = `CONT`
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:5.20-5.47
syntax varTypeIR = 
   | direction typeIR ctk value?

;; ../../../../spec-concrete/5.01-env.watsup:12.16-12.34
syntax frame = map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:14.1-14.27
def $empty_frame : frame =

   ;; ../../../../spec-concrete/5.01-env.watsup:15.1-15.47
   clause 0 = $empty_map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:18.16-18.35
syntax tdenv = map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:20.1-20.27
def $empty_tdenv : tdenv =

   ;; ../../../../spec-concrete/5.01-env.watsup:21.1-21.48
   clause 0 = $empty_map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:24.16-24.42
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:26.1-26.27
def $empty_rdenv : rdenv =

   ;; ../../../../spec-concrete/5.01-env.watsup:27.1-27.55
   clause 0 = $empty_map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:30.16-30.46
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:32.1-32.27
def $empty_cdenv : cdenv =

   ;; ../../../../spec-concrete/5.01-env.watsup:33.1-33.59
   clause 0 = $empty_map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:39.1-39.39
def $check_routine_name(id, id) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:40.1-40.50
   clause 0(id_l, id_r) = (id_l = id_r)

;; ../../../../spec-concrete/5.01-env.watsup:42.1-42.37
def $check_arity(id?*, id*) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:43.1-43.72
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| = |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:45.1-45.42
def $check_arity_more(id?*, id*) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:46.1-46.77
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:48.1-48.42
def $check_arity_less(id?*, id*) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:49.1-49.77
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| < |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:51.1-51.44
def $get_missing_parameters(id*, id*) : id* =

   ;; ../../../../spec-concrete/5.01-env.watsup:53.1-53.48
   clause 0(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = []
      -- if id*{id <- id*} matches []

   ;; ../../../../spec-concrete/5.01-env.watsup:54.1-59.47
   clause 1(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = id_param_h :: $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
      -- if id*{id <- id*} matches _ :: _
      -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
      -- if ~$in_set<id>(id_param_h, `{` id_arg*{id_arg <- id_arg*} `}`)

   ;; ../../../../spec-concrete/5.01-env.watsup:60.1-65.15
   clause 2(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
      -- if id*{id <- id*} matches _ :: _
      -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:68.1-68.61
def $find_match_named<V>(rid, V, id*, pid*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:70.1-72.50
   clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param `#` bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, []))
      -- if $eq_set<id>(`{` id_arg*{id_arg <- id_arg*} `}`, `{` id_param*{id_param <- id_param*} `}`)

   ;; ../../../../spec-concrete/5.01-env.watsup:73.1-74.15
   clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:77.1-77.69
def $find_match_named_default<V>(rid, V, id*, pid*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:79.1-86.18
   clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param `#` bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, id_default*{id_default <- id_default*}))
      -- let id_default*{id_default <- id_default*} = $get_missing_parameters(id_param*{id_param <- id_param*}, id_arg*{id_arg <- id_arg*})
      -- if ($find_match_named<V>(rid, V, id_arg*{id_arg <- id_arg*} ++ id_default*{id_default <- id_default*}, id_param `#` bool_param*{bool_param <- bool_param*, id_param <- id_param*}) =/= ?())

   ;; ../../../../spec-concrete/5.01-env.watsup:87.1-88.15
   clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:91.1-91.74
def $find_match_unnamed_default<V>(rid, V, id?*, pid*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:93.1-95.74
   clause 0(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?((rid, V, id_default*{id_default <- id_default*}))
      -- let (_pid*{_pid <- _pid*}, id_default `#` bool*{bool <- bool*, id_default <- id_default*}) = $partition_<pid>(pid*{pid <- pid*}, |id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}|)
      -- (if (bool = true))*{bool <- bool*}

   ;; ../../../../spec-concrete/5.01-env.watsup:96.1-97.15
   clause 1(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:100.1-100.64
def $find_matching<V>(id, id?*, id*, rid, V) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:103.1-105.42
   clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' `(` pid_r'*{pid_r' <- pid_r'*} `)`, V) = ?()
      -- if ~$check_routine_name(id_r, id_r')

   ;; ../../../../spec-concrete/5.01-env.watsup:107.1-113.50
   clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = ?()
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_more(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:115.1-125.45
   clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = $find_match_named<V>(id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V, id_arg'*{id_arg' <- id_arg'*}, id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:127.1-133.45
   clause 3(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = ?((id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V, []))
      -- if id*{id <- id*} matches []
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:135.1-145.50
   clause 4(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = $find_match_named_default<V>(id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V, id_arg'*{id_arg' <- id_arg'*}, id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:147.1-156.50
   clause 5(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V) = $find_match_unnamed_default<V>(id_r' `(` id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} `)`, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param' `#` bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if id*{id <- id*} matches []
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

;; ../../../../spec-concrete/5.01-env.watsup:159.1-159.67
def $find_matchings<V>(id, id?*, id*, rid*, V*) : (rid, V, id*)* =

   ;; ../../../../spec-concrete/5.01-env.watsup:161.1-165.8
   clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = []
      -- if rid*{rid <- rid*} matches []
      -- if V*{V <- V*} matches []

   ;; ../../../../spec-concrete/5.01-env.watsup:166.1-171.72
   clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
      -- if rid*{rid <- rid*} matches _ :: _
      -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid*{rid <- rid*}
      -- if V*{V <- V*} matches _ :: _
      -- let V_h :: V_t*{V_t <- V_t*} = V*{V <- V*}
      -- if ($find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h) = ?())

   ;; ../../../../spec-concrete/5.01-env.watsup:172.1-178.66
   clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid'*{rid' <- rid'*}, V'*{V' <- V'*}) = (rid, V, id_default*{id_default <- id_default*}) :: $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
      -- if rid'*{rid' <- rid'*} matches _ :: _
      -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid'*{rid' <- rid'*}
      -- if V'*{V' <- V'*} matches _ :: _
      -- let V_h :: V_t*{V_t <- V_t*} = V'*{V' <- V'*}
      -- let (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} = $find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h)
      -- if (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} matches (_)
      -- let ?((rid, V, id_default*{id_default <- id_default*})) = (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?}

;; ../../../../spec-concrete/5.01-env.watsup:181.1-181.66
def $find_overloaded<V>(map<rid, V>, id, id?*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:184.1-190.71
   clause 0(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
      -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
      -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
      -- (if id?{id <- id?} matches (_))*{id? <- id?*}
      -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
      -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = [])

   ;; ../../../../spec-concrete/5.01-env.watsup:191.1-198.65
   clause 1(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
      -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
      -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
      -- (if id?{id <- id?} matches (_))*{id? <- id?*}
      -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
      -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*})
      -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
      -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

   ;; ../../../../spec-concrete/5.01-env.watsup:200.1-205.66
   clause 2(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
      -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
      -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*}) = [])

   ;; ../../../../spec-concrete/5.01-env.watsup:206.1-212.60
   clause 3(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
      -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
      -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*})
      -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
      -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

;; ../../../../spec-concrete/5.01-env.watsup:218.1-218.50
def $find_non_overloaded<V>(map<rid, V>, id) : V? =

   ;; ../../../../spec-concrete/5.01-env.watsup:221.1-222.60
   clause 0(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id) = ?(V')
      -- let V''*{V'' <- V''*} = $find_non_overloaded'<V>(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id)
      -- if V''*{V'' <- V''*} matches [ _/1 ]
      -- let [V'] = V''*{V'' <- V''*}

   ;; ../../../../spec-concrete/5.01-env.watsup:223.1-224.15
   clause 1(`{` rid `:` V*{V <- V*, rid <- rid*} `}`, id) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:219.1-219.51
def $find_non_overloaded'<V>(map<rid, V>, id) : V* =

   ;; ../../../../spec-concrete/5.01-env.watsup:226.1-226.49
   clause 0(set<pair<rid, V>>, id) = []
      -- if (set<pair<rid, V>> = `{` [] `}`)

   ;; ../../../../spec-concrete/5.01-env.watsup:227.1-233.59
   clause 1(`{` pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} `}`, id) = V_h :: V_t_found*{V_t_found <- V_t_found*}
      -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
      -- let rid_h `:` V_h :: rid_t `:` V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
      -- let id' `(` _pid*{_pid <- _pid*} `)` = rid_h
      -- if (id' = id)
      -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>(`{` rid_t `:` V_t*{V_t <- V_t*, rid_t <- rid_t*} `}`, id)

   ;; ../../../../spec-concrete/5.01-env.watsup:234.1-241.59
   clause 2(`{` pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} `}`, id) = V_t_found*{V_t_found <- V_t_found*}
      -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
      -- let rid_h `:` V_h :: rid_t `:` V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
      -- let id_h `(` _pid*{_pid <- _pid*} `)` = rid_h
      -- if (id =/= id_h)
      -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>(`{` rid_t `:` V_t*{V_t <- V_t*, rid_t <- rid_t*} `}`, id)

;; ../../../../spec-concrete/5.02-context.watsup:5.17-5.39
syntax cursor = 
   | `GLOBAL`
   | `BLOCK`
   | `LOCAL`

;; ../../../../spec-concrete/5.02-context.watsup:16.3-19.18
syntax glayer = {`CDENV` cdenv, `TDENV` tdenv, `RDENV` rdenv, `FRAME` frame}

;; ../../../../spec-concrete/5.02-context.watsup:24.3-27.18
syntax blayer = {`ID` id, `TDENV` tdenv, `RDENV` rdenv, `FRAME` frame}

;; ../../../../spec-concrete/5.02-context.watsup:31.15-31.30
syntax lret = 
   | ``EMPTY`
   | `VOID`
   | `BOOL`
   | `ERROR`
   | `MATCH_KIND`
   | `STRING`
   | `INT`
   | `INT<` nat `>`
   | `BIT<` nat `>`
   | `VARBIT<` nat `>`
   | `TID` tid
   | polyTypeDefIR `<` typeIR* `>`
   | `TYPEDEF` tid typeIR
   | `TYPE` tid typeIR
   | `LIST<` typeIR `>`
   | `TUPLE<` typeIR* `>`
   | typeIR `[` nat `]`
   | `STRUCT` tid `{` fieldTypeIR* `}`
   | `HEADER` tid `{` fieldTypeIR* `}`
   | `HEADER_UNION` tid `{` fieldTypeIR* `}`
   | `ENUM` tid `{` id* `}`
   | `ENUM` tid `#` typeIR `{` valueFieldIR* `}`
   | `EXTERN` tid map<rid, routineTypeDefIR>
   | `PARSER(` parameterTypeIR* `)`
   | `CONTROL(` parameterTypeIR* `)`
   | `PACKAGE<` typeIR* `>`
   | `TABLE` tid `#` typeIR
   | `DEFAULT`
   | `HEADER_INVALID`
   | `SEQ<` typeIR* `>`
   | `SEQ<` typeIR* `,...>`
   | `RECORD{` fieldTypeIR* `}`
   | `RECORD{` fieldTypeIR* `,...}`
   | `SET<` typeIR* `>`
   | `TABLE_ENUM` tid `{` id* `}`
   | `TABLE_STRUCT` tid `{` fieldTypeIR* `}`

;; ../../../../spec-concrete/5.02-context.watsup:34.3-37.20
syntax llayer = {`ID` id, `RET` lret, `TDENV` tdenv, `FRAMES` frame*}

;; ../../../../spec-concrete/5.02-context.watsup:44.3-46.19
syntax context = {`GLOBAL` glayer, `BLOCK` blayer, `LOCAL` llayer}

;; ../../../../spec-concrete/5.02-context.watsup:54.1-54.29
def $empty_context : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:56.1-72.58
   clause 0 = C
      -- let glayer = {CDENV $empty_cdenv, TDENV $empty_tdenv, RDENV $empty_rdenv, FRAME $empty_frame}
      -- let blayer = {ID "", TDENV $empty_tdenv, RDENV $empty_rdenv, FRAME $empty_frame}
      -- let llayer = {ID "", RET ``EMPTY`, TDENV $empty_tdenv, FRAMES [$empty_frame]}
      -- let C = {GLOBAL glayer, BLOCK blayer, LOCAL llayer}

;; ../../../../spec-concrete/5.02-context.watsup:78.1-78.36
def $bound(cursor, context) : bound =

   ;; ../../../../spec-concrete/5.02-context.watsup:80.1-80.33
   clause 0(cursor, C) = `{` [] `}`
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.02-context.watsup:81.1-81.63
   clause 1(cursor, C) = $dom_map<tid, typeDefIR>(C.BLOCK.TDENV)
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.02-context.watsup:82.1-84.62
   clause 2(cursor, C) = $union_set<tid>(bound_block, bound_local)
      -- if cursor matches `LOCAL`
      -- let bound_block = $bound(`BLOCK`, C)
      -- let bound_local = $dom_map<tid, typeDefIR>(C.LOCAL.TDENV)

;; ../../../../spec-concrete/5.02-context.watsup:90.1-90.30
def $enter(context) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:92.1-92.68
   clause 0(C) = C[LOCAL.FRAMES = $empty_frame :: C.LOCAL.FRAMES]

;; ../../../../spec-concrete/5.02-context.watsup:94.1-94.29
def $exit(context) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:96.1-97.45
   clause 0(C) = C[LOCAL.FRAMES = frame_t*{frame_t <- frame_t*}]
      -- let frame*{frame <- frame*} = C.LOCAL.FRAMES
      -- if frame*{frame <- frame*} matches _ :: _
      -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame*{frame <- frame*}

;; ../../../../spec-concrete/5.02-context.watsup:103.1-103.48
def $set_return_type(context, typeIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:105.1-106.33
   clause 0(C, typeIR_ret) = C[LOCAL.RET = typeIR_ret as lret]

;; ../../../../spec-concrete/5.02-context.watsup:108.1-108.40
def $get_return_type(context) : typeIR? =

   ;; ../../../../spec-concrete/5.02-context.watsup:110.1-111.33
   clause 0(C) = ?(typeIR_ret)
      -- let lret = C.LOCAL.RET
      -- if lret <: typeIR
      -- let typeIR_ret = lret as typeIR

   ;; ../../../../spec-concrete/5.02-context.watsup:112.1-113.15
   clause 1(C) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:121.1-121.55
def $add_var(cursor, context, id, varTypeIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:124.1-125.71
   clause 0(cursor, C, id, varTypeIR) = C[GLOBAL.FRAME = frame]
      -- if cursor matches `GLOBAL`
      -- let frame = $add_map<id, varTypeIR>(C.GLOBAL.FRAME, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02-context.watsup:126.1-127.70
   clause 1(cursor, C, id, varTypeIR) = C[BLOCK.FRAME = frame]
      -- if cursor matches `BLOCK`
      -- let frame = $add_map<id, varTypeIR>(C.BLOCK.FRAME, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02-context.watsup:128.1-131.44
   clause 2(cursor, C, id, varTypeIR) = C[LOCAL.FRAMES = frame*{frame <- frame*}]
      -- if cursor matches `LOCAL`
      -- let frame'*{frame' <- frame'*} = C.LOCAL.FRAMES
      -- if frame'*{frame' <- frame'*} matches _ :: _
      -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame'*{frame' <- frame'*}
      -- let frame_h_update = $add_map<id, varTypeIR>(frame_h, id, varTypeIR)
      -- let frame*{frame <- frame*} = frame_h_update :: frame_t*{frame_t <- frame_t*}

;; ../../../../spec-concrete/5.02-context.watsup:122.1-122.58
def $add_vars(cursor, context, id*, varTypeIR*) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:133.1-133.34
   clause 0(p, C, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = C
      -- if id*{id <- id*} matches []
      -- if varTypeIR*{varTypeIR <- varTypeIR*} matches []

   ;; ../../../../spec-concrete/5.02-context.watsup:134.1-136.52
   clause 1(p, C, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = C''
      -- if id*{id <- id*} matches _ :: _
      -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
      -- if varTypeIR*{varTypeIR <- varTypeIR*} matches _ :: _
      -- let varTypeIR_h :: varTypeIR_t*{varTypeIR_t <- varTypeIR_t*} = varTypeIR*{varTypeIR <- varTypeIR*}
      -- let C' = $add_var(p, C, id_h, varTypeIR_h)
      -- let C'' = $add_vars(p, C', id_t*{id_t <- id_t*}, varTypeIR_t*{varTypeIR_t <- varTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:140.1-140.63
def $add_parameter(cursor, context, parameterTypeIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:143.1-145.48
   clause 0(cursor, C, direction typeIR id value?{value <- value?}) = C'
      -- if direction matches ``EMPTY`
      -- let varTypeIR = ``EMPTY` typeIR `CTK` value?{value <- value?}
      -- let C' = $add_var(cursor, C, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02-context.watsup:146.1-149.48
   clause 1(cursor, C, direction typeIR id value?{value <- value?}) = C'
      -- if (((direction = `IN`) \/ (direction = `OUT`)) \/ (direction = `INOUT`))
      -- let varTypeIR = direction typeIR `DYN` value?{value <- value?}
      -- let C' = $add_var(cursor, C, id, varTypeIR)

;; ../../../../spec-concrete/5.02-context.watsup:141.1-141.65
def $add_parameters(cursor, context, parameterTypeIR*) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:151.1-151.40
   clause 0(cursor, C, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = C
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.02-context.watsup:152.1-154.62
   clause 1(cursor, C, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = C''
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let C' = $add_parameter(cursor, C, parameterTypeIR_h)
      -- let C'' = $add_parameters(cursor, C', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:158.1-158.66
def $add_constructorParameter(context, parameterTypeIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:161.1-163.47
   clause 0(C, direction typeIR id value?{value <- value?}) = C'
      -- if value?{value <- value?} matches ()
      -- let varTypeIR = direction typeIR `CTK` ?()
      -- let C' = $add_var(`BLOCK`, C, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02-context.watsup:164.1-166.47
   clause 1(C, direction typeIR id value'?{value' <- value'?}) = C'
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- let varTypeIR = direction typeIR `CTK` ?(value)
      -- let C' = $add_var(`BLOCK`, C, id, varTypeIR)

;; ../../../../spec-concrete/5.02-context.watsup:159.1-159.68
def $add_constructorParameters(context, parameterTypeIR*) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:168.1-168.43
   clause 0(C, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = C
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.02-context.watsup:169.1-171.65
   clause 1(C, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = C''
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let C' = $add_constructorParameter(C, parameterTypeIR_h)
      -- let C'' = $add_constructorParameters(C', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:175.1-175.57
def $add_type(cursor, context, tid, typeDefIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:176.1-180.48
   clause 0(cursor, C, tid, typeDefIR) = C'
      -- if cursor matches `GLOBAL`
      -- let tdenv = C.GLOBAL.TDENV
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let C' = C[GLOBAL.TDENV = tdenv_update]

   ;; ../../../../spec-concrete/5.02-context.watsup:181.1-185.47
   clause 1(cursor, C, tid, typeDefIR) = C'
      -- if cursor matches `BLOCK`
      -- let tdenv = C.BLOCK.TDENV
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let C' = C[BLOCK.TDENV = tdenv_update]

   ;; ../../../../spec-concrete/5.02-context.watsup:186.1-190.47
   clause 2(cursor, C, tid, typeDefIR) = C'
      -- if cursor matches `LOCAL`
      -- let tdenv = C.LOCAL.TDENV
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let C' = C[LOCAL.TDENV = tdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:192.1-192.60
def $add_types(cursor, context, tid*, typeDefIR*) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:193.1-193.35
   clause 0(p, C, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = C
      -- if tid*{tid <- tid*} matches []
      -- if typeDefIR*{typeDefIR <- typeDefIR*} matches []

   ;; ../../../../spec-concrete/5.02-context.watsup:194.1-196.54
   clause 1(p, C, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = C''
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if typeDefIR*{typeDefIR <- typeDefIR*} matches _ :: _
      -- let typeDefIR_h :: typeDefIR_t*{typeDefIR_t <- typeDefIR_t*} = typeDefIR*{typeDefIR <- typeDefIR*}
      -- let C' = $add_type(p, C, tid_h, typeDefIR_h)
      -- let C'' = $add_types(p, C', tid_t*{tid_t <- tid_t*}, typeDefIR_t*{typeDefIR_t <- typeDefIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:200.1-200.76
def $add_routine_overload(cursor, context, rid, routineTypeDefIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:202.1-206.48
   clause 0(cursor, C, rid, routineTypeDefIR) = C'
      -- if cursor matches `GLOBAL`
      -- let rdenv = C.GLOBAL.RDENV
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let C' = C[GLOBAL.RDENV = rdenv_update]

   ;; ../../../../spec-concrete/5.02-context.watsup:207.1-211.47
   clause 1(cursor, C, rid, routineTypeDefIR) = C'
      -- if cursor matches `BLOCK`
      -- let rdenv = C.BLOCK.RDENV
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let C' = C[BLOCK.RDENV = rdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:213.1-213.80
def $add_routine_non_overload(cursor, context, rid, routineTypeDefIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:215.1-219.48
   clause 0(cursor, C, rid, routineTypeDefIR) = C'
      -- if cursor matches `GLOBAL`
      -- let rdenv = C.GLOBAL.RDENV
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let C' = C[GLOBAL.RDENV = rdenv_update]

   ;; ../../../../spec-concrete/5.02-context.watsup:220.1-224.47
   clause 1(cursor, C, rid, routineTypeDefIR) = C'
      -- if cursor matches `BLOCK`
      -- let rdenv = C.BLOCK.RDENV
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let C' = C[BLOCK.RDENV = rdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:228.1-228.67
def $add_constructor(context, cid, constructorTypeDefIR) : context =

   ;; ../../../../spec-concrete/5.02-context.watsup:230.1-234.48
   clause 0(C, cid, constructorTypeDefIR) = C'
      -- let cdenv = C.GLOBAL.CDENV
      -- let cdenv_update = $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR)
      -- let C' = C[GLOBAL.CDENV = cdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:242.1-242.60
def $find_var(cursor, context, prefixedNameIR) : varTypeIR? =

   ;; ../../../../spec-concrete/5.02-context.watsup:244.1-245.31
   clause 0(p, C, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR
      -- let frame = C.GLOBAL.FRAME

   ;; ../../../../spec-concrete/5.02-context.watsup:246.1-247.31
   clause 1(cursor, C, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.GLOBAL.FRAME

   ;; ../../../../spec-concrete/5.02-context.watsup:248.1-250.56
   clause 2(cursor, C, prefixedNameIR) = ?(varTypeIR)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.BLOCK.FRAME
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:251.1-253.50
   clause 3(cursor, C, prefixedNameIR) = $find_var(`GLOBAL`, C, ``` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.BLOCK.FRAME
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../spec-concrete/5.02-context.watsup:254.1-256.58
   clause 4(cursor, C, prefixedNameIR) = ?(varTypeIR)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame*{frame <- frame*} = C.LOCAL.FRAMES
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:257.1-259.52
   clause 5(cursor, C, prefixedNameIR) = $find_var(`BLOCK`, C, ``` id)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame*{frame <- frame*} = C.LOCAL.FRAMES
      -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../spec-concrete/5.02-context.watsup:263.1-263.57
def $find_value(cursor, context, prefixedNameIR) : value =

   ;; ../../../../spec-concrete/5.02-context.watsup:265.1-267.58
   clause 0(p, C, prefixedNameIR) = value
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR
      -- let frame = C.GLOBAL.FRAME
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:268.1-270.58
   clause 1(cursor, C, prefixedNameIR) = value
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.GLOBAL.FRAME
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:271.1-273.58
   clause 2(cursor, C, prefixedNameIR) = value
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.BLOCK.FRAME
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:274.1-276.50
   clause 3(cursor, C, prefixedNameIR) = $find_value(`GLOBAL`, C, ``` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame = C.BLOCK.FRAME
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../spec-concrete/5.02-context.watsup:277.1-279.60
   clause 4(cursor, C, prefixedNameIR) = value
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let frame*{frame <- frame*} = C.LOCAL.FRAMES
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

;; ../../../../spec-concrete/5.02-context.watsup:283.1-283.61
def $find_type(cursor, context, prefixedNameIR) : typeDefIR? =

   ;; ../../../../spec-concrete/5.02-context.watsup:285.1-287.31
   clause 0(p, C, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if prefixedNameIR matches `.%`
      -- let `.` tid = prefixedNameIR
      -- let tdenv = C.GLOBAL.TDENV

   ;; ../../../../spec-concrete/5.02-context.watsup:288.1-290.31
   clause 1(cursor, C, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv = C.GLOBAL.TDENV

   ;; ../../../../spec-concrete/5.02-context.watsup:291.1-293.58
   clause 2(cursor, C, prefixedNameIR) = ?(typeDefIR)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv = C.BLOCK.TDENV
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:294.1-296.52
   clause 3(cursor, C, prefixedNameIR) = $find_type(`GLOBAL`, C, ``` tid)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv = C.BLOCK.TDENV
      -- if (?() = $find_map<tid, typeDefIR>(tdenv, tid))

   ;; ../../../../spec-concrete/5.02-context.watsup:297.1-299.60
   clause 4(cursor, C, prefixedNameIR) = ?(typeDefIR)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv*{tdenv <- tdenv*} = [C.LOCAL.TDENV]
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:300.1-302.54
   clause 5(cursor, C, prefixedNameIR) = $find_type(`BLOCK`, C, ``` tid)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` tid = prefixedNameIR
      -- let tdenv*{tdenv <- tdenv*} = [C.LOCAL.TDENV]
      -- if (?() = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid))

;; ../../../../spec-concrete/5.02-context.watsup:306.1-306.39
def $ids_arguments(argument*) : id?* =

   ;; ../../../../spec-concrete/5.02-context.watsup:309.1-309.58
   clause 0(argument*{argument <- argument*}) = $id_argument(argument)*{argument <- argument*}

;; ../../../../spec-concrete/5.02-context.watsup:307.1-307.33
def $id_argument(argument) : id? =

   ;; ../../../../spec-concrete/5.02-context.watsup:310.1-310.35
   clause 0(argument) = ?()
      -- if argument <: expression
      -- let expression = argument as expression

   ;; ../../../../spec-concrete/5.02-context.watsup:311.1-311.42
   clause 1(argument) = ?($name(name))
      -- if argument matches `%=%`
      -- let name `=` _expression = argument

   ;; ../../../../spec-concrete/5.02-context.watsup:312.1-312.43
   clause 2(argument) = ?($name(name))
      -- if argument matches `%=_`
      -- let name `=_` = argument

   ;; ../../../../spec-concrete/5.02-context.watsup:313.1-313.27
   clause 3(argument) = ?()
      -- if argument matches `_`

;; ../../../../spec-concrete/5.02-context.watsup:315.1-316.34
def $find_routine_overloaded(cursor, context, prefixedNameIR, argument*) : (rid, routineTypeDefIR, id*)? =

   ;; ../../../../spec-concrete/5.02-context.watsup:318.1-321.47
   clause 0(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR
      -- let rdenv = C.GLOBAL.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})

   ;; ../../../../spec-concrete/5.02-context.watsup:322.1-325.47
   clause 1(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let rdenv = C.GLOBAL.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})

   ;; ../../../../spec-concrete/5.02-context.watsup:326.1-331.66
   clause 2(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*}))
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let rdenv = C.BLOCK.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}

   ;; ../../../../spec-concrete/5.02-context.watsup:332.1-337.66
   clause 3(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = $find_routine_overloaded(`GLOBAL`, C, ``` id, argument*{argument <- argument*})
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let rdenv = C.BLOCK.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- if (?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

   ;; ../../../../spec-concrete/5.02-context.watsup:338.1-339.57
   clause 4(cursor, C, prefixedNameIR, argument*{argument <- argument*}) = $find_routine_overloaded(`BLOCK`, C, ``` id, argument*{argument <- argument*})
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR

;; ../../../../spec-concrete/5.02-context.watsup:341.1-342.22
def $find_routine_non_overloaded(cursor, context, prefixedNameIR) : routineTypeDefIR? =

   ;; ../../../../spec-concrete/5.02-context.watsup:344.1-345.63
   clause 0(p, C, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(C.GLOBAL.RDENV, id)
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR

   ;; ../../../../spec-concrete/5.02-context.watsup:346.1-347.63
   clause 1(cursor, C, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(C.GLOBAL.RDENV, id)
      -- if cursor matches `GLOBAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR

   ;; ../../../../spec-concrete/5.02-context.watsup:348.1-350.66
   clause 2(cursor, C, prefixedNameIR) = ?(routineTypeDefIR)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_non_overloaded<routineTypeDefIR>(C.BLOCK.RDENV, id)
      -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
      -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}

   ;; ../../../../spec-concrete/5.02-context.watsup:351.1-354.66
   clause 3(cursor, C, prefixedNameIR) = $find_routine_non_overloaded(`GLOBAL`, C, ``` id)
      -- if cursor matches `BLOCK`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- if (?() = $find_non_overloaded<routineTypeDefIR>(C.BLOCK.RDENV, id))

   ;; ../../../../spec-concrete/5.02-context.watsup:355.1-356.50
   clause 4(cursor, C, prefixedNameIR) = $find_routine_non_overloaded(`BLOCK`, C, ``` id)
      -- if cursor matches `LOCAL`
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR

;; ../../../../spec-concrete/5.02-context.watsup:360.1-361.38
def $find_constructor_overloaded(context, prefixedNameIR, argument*) : (rid, constructorTypeDefIR, id*)? =

   ;; ../../../../spec-concrete/5.02-context.watsup:363.1-366.47
   clause 0(C, prefixedNameIR, argument*{argument <- argument*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches `.%`
      -- let `.` id = prefixedNameIR
      -- let cdenv = C.GLOBAL.CDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})

   ;; ../../../../spec-concrete/5.02-context.watsup:367.1-370.47
   clause 1(C, prefixedNameIR, argument*{argument <- argument*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedNameIR matches ``%`
      -- let ``` id = prefixedNameIR
      -- let cdenv = C.GLOBAL.CDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})

;; ../../../../spec-concrete/5.03-table-context.watsup:5.19-5.31
syntax matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:7.22-7.72
syntax matchAction = (prefixedNameIR, parameterTypeIR*, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:10.3-13.24
syntax matchPriority = {`VALUES` int*, `INIT` bool, `DELTA` int, `LARGEST_WINS` bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:18.3-19.17
syntax matchEntry = {`SIZE` int, `CONST` bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:24.1-27.11
syntax matchMode = 
   | `NOPRI`
   | `NOPRILPM` nat
   | `PRI`
   | `PRILPM`

;; ../../../../spec-concrete/5.03-table-context.watsup:30.3-34.21
syntax tblctx = {`KEYS` matchKey*, `ACTIONS` matchAction*, `PRIORITIES` matchPriority, `ENTRIES` matchEntry, `MODE` matchMode}

;; ../../../../spec-concrete/5.03-table-context.watsup:43.1-44.10
syntax tblstate = 
   | `LPM` nat
   | `NOLPM`

;; ../../../../spec-concrete/5.03-table-context.watsup:50.1-50.26
def $empty_tblctx : tblctx =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:51.1-64.25
   clause 0 = {KEYS [], ACTIONS [], PRIORITIES matchPriority, ENTRIES matchEntry, MODE `NOPRI`}
      -- let matchPriority = {VALUES [], INIT false, DELTA 1 as int, LARGEST_WINS true}
      -- let matchEntry = {SIZE 0 as int, CONST true}

;; ../../../../spec-concrete/5.03-table-context.watsup:72.1-72.42
def $add_key(tblctx, id, typeIR) : tblctx =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:74.1-76.32
   clause 0(TC, id, typeIR) = TC[KEYS = TC.KEYS ++ [matchKey]]
      -- let matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:80.1-80.83
def $add_action(tblctx, prefixedNameIR, parameterTypeIR*, argumentListIR) : tblctx =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:82.1-84.73
   clause 0(TC, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = TC[ACTIONS = TC.ACTIONS ++ [matchAction]]
      -- let matchAction = (prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:92.1-92.46
def $update_mode(tblctx, id, typeIR) : tblctx =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:94.1-95.24
   clause 0(TC, text, typeIR) = TC[MODE = `NOPRILPM` n]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` n `>` = numberTypeIR
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:96.1-97.24
   clause 1(TC, text, typeIR) = TC[MODE = `NOPRILPM` n]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` n `>` = numberTypeIR
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:98.1-99.24
   clause 2(TC, text, typeIR) = TC[MODE = `NOPRILPM` n]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` n `>` = numberTypeIR
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:100.1-101.36
   clause 3(TC, text, typeIR') = $update_mode(TC, "lpm", typeIR)
      -- if (text = "lpm")
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-table-context.watsup:102.1-103.22
   clause 4(TC, text, _typeIR) = TC[MODE = `PRILPM`]
      -- if (text = "lpm")
      -- if (TC.MODE = `PRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:104.1-105.24
   clause 5(TC, text, _typeIR) = TC[MODE = `PRI`]
      -- if (text = "range")
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:106.1-107.24
   clause 6(TC, text, _typeIR) = TC[MODE = `PRI`]
      -- if (text = "ternary")
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:108.1-109.24
   clause 7(TC, text, _typeIR) = TC[MODE = `PRI`]
      -- if (text = "optional")
      -- if (TC.MODE = `NOPRI`)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:110.1-111.29
   clause 8(TC, text, _typeIR) = TC[MODE = `PRILPM`]
      -- if (text = "range")
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` _nat = matchMode

   ;; ../../../../spec-concrete/5.03-table-context.watsup:112.1-113.29
   clause 9(TC, text, _typeIR) = TC[MODE = `PRILPM`]
      -- if (text = "ternary")
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` _nat = matchMode

   ;; ../../../../spec-concrete/5.03-table-context.watsup:114.1-115.29
   clause 10(TC, text, _typeIR) = TC[MODE = `PRILPM`]
      -- if (text = "optional")
      -- let matchMode = TC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM` _nat = matchMode

   ;; ../../../../spec-concrete/5.03-table-context.watsup:116.1-117.15
   clause 11(TC, _id, _typeIR) = TC
      -- otherwise

;; ../../../../spec-concrete/5.03-table-context.watsup:125.1-125.79
def $find_action(tblctx, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:128.1-128.81
   clause 0(TC, prefixedNameIR) = $find_action'(TC.ACTIONS, prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:126.1-126.86
def $find_action'(matchAction*, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

   ;; ../../../../spec-concrete/5.03-table-context.watsup:130.1-130.45
   clause 0(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?()
      -- if matchAction*{matchAction <- matchAction*} matches []

   ;; ../../../../spec-concrete/5.03-table-context.watsup:132.1-134.75
   clause 1(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?((parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR))
      -- if matchAction*{matchAction <- matchAction*} matches _ :: _
      -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
      -- let (prefixedNameIR', parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = matchAction_h
      -- if (prefixedNameIR' = prefixedNameIR)

   ;; ../../../../spec-concrete/5.03-table-context.watsup:136.1-139.44
   clause 2(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = $find_action'(matchAction_t*{matchAction_t <- matchAction_t*}, prefixedNameIR)
      -- if matchAction*{matchAction <- matchAction*} matches _ :: _
      -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
      -- let (prefixedNameIR_h, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR) = matchAction_h
      -- if (prefixedNameIR_h =/= prefixedNameIR)

;; ../../../../spec-concrete/5.03-wellformed.watsup:5.1-7.20
relation Type_wf: bound `|-` typeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:82.1-83.22
   rule basetype: bound `|-` typeIR
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:87.1-89.33
   rule tid: bound `|-` typeIR
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid = namedTypeIR
      -- if $in_set<tid>(tid, bound)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:91.1-94.30
   rule spectype: bound `|-` typeIR'
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR
      -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:111.1-114.30
   rule typedeftype: bound `|-` typeIR'
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR = aliasTypeIR
      -- if $nestable_typedef(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:128.1-131.30
   rule newtype: bound `|-` typeIR'
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR
      -- if $nestable_new(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:149.1-152.30
   rule listttype: bound `|-` typeIR'
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR `>` = typeIR' as listTypeIR
      -- if $nestable_list(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:174.1-177.33
   rule tupletype: bound `|-` typeIR'
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $nestable_tuple(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:189.1-192.30
   rule stacktype: bound `|-` typeIR'
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR
      -- if $nestable_stack(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:214.1-218.33
   rule structtype: bound `|-` typeIR'
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_struct(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:251.1-255.33
   rule headertype: bound `|-` typeIR'
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `}` = typeIR' as headerTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_header(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:268.1-272.33
   rule headeruniontype: bound `|-` typeIR'
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `}` = typeIR' as headerUnionTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_headerunion(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:274.1-276.28
   rule enumtype: bound `|-` typeIR
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` id*{id <- id*} `}` = enumTypeIR
      -- if $distinct_<id>(id*{id <- id*})

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:302.1-306.30
   rule serenumtype: bound `|-` typeIR'
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` id `=` _value `;`*{_value <- _value*, id <- id*} `}` = enumTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- if $nestable_serenum(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:310.1-312.53
   rule externtype: bound `|-` typeIR
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid `{` _rid `:` routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} `}` = typeIR as externObjectTypeIR
      -- (if RoutineTypeDef_wf: bound `|-` routineTypeDefIR holds)*{routineTypeDefIR <- routineTypeDefIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:314.1-316.50
   rule parsertype: bound `|-` typeIR
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as parserObjectTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:318.1-320.50
   rule controltype: bound `|-` typeIR
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as controlObjectTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:322.1-324.33
   rule packagetype: bound `|-` typeIR'
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as packageObjectTypeIR
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:326.1-329.30
   rule tabletype: bound `|-` typeIR'
      -- if typeIR' <: tableObjectTypeIR
      -- let `TABLE` _tid `#` typeIR = typeIR' as tableObjectTypeIR
      -- let typeIR'' = $canon(typeIR)
      -- if typeIR'' <: tableTypeIR
      -- let tableTypeIR = typeIR'' as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid' `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:333.1-334.19
   rule defaulttype: bound `|-` typeIR
      -- if (typeIR = `DEFAULT` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:336.1-338.33
   rule sequencetype: bound `|-` typeIR'
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:340.1-342.33
   rule sequencedefaulttype: bound `|-` typeIR'
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `,...>` = sequenceTypeIR
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:344.1-347.33
   rule recordtype: bound `|-` typeIR'
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `}` = recordTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:349.1-352.33
   rule recorddefaulttype: bound `|-` typeIR'
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR id `;`*{id <- id*, typeIR <- typeIR*} `,...}` = recordTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if Type_wf: bound `|-` typeIR holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:354.1-355.26
   rule invalidtype: bound `|-` typeIR
      -- if (typeIR = `HEADER_INVALID` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:410.1-413.30
   rule settype: bound `|-` typeIR''
      -- if typeIR'' <: setTypeIR
      -- let `SET<` typeIR'*{typeIR' <- typeIR'*} `>` = typeIR'' as setTypeIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
      -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
      -- if $nestable_set(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:415.1-417.28
   rule tableenumtype: bound `|-` typeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_ENUM%{%}`
      -- let `TABLE_ENUM` _tid `{` id*{id <- id*} `}` = tableTypeIR
      -- if $distinct_<id>(id*{id <- id*})

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:419.1-420.33
   rule tablestructtype: bound `|-` typeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:9.1-11.20
relation TypeDef_wf: bound `|-` typeDefIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:436.1-439.30
   rule mono: bound `|-` typeDefIR
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- if $definable_type_mono(typeIR)
      -- if Type_wf: bound `|-` typeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:455.1-461.36
   rule poly: bound `|-` typeDefIR
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` = typeDefIR as polyTypeDefIR
      -- if $definable_type_poly(typeIR)
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, `{` tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} `}`)
      -- if Type_wf: bound_inner `|-` typeIR holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:13.1-15.20
relation ParameterType_wf: bound `|-` parameterTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:49.1-52.41
   rule default-empty-extern: bound `|-` direction typeIR _id value?{value <- value?}
      -- if direction matches ``EMPTY`
      -- if value?{value <- value?} matches ()
      -- if Type_wf: bound `|-` typeIR holds
      -- if $is_extern_object_typeIR(typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:54.1-57.42
   rule default-none-not-extern: bound `|-` direction typeIR _id value?{value <- value?}
      -- if value?{value <- value?} matches ()
      -- if Type_wf: bound `|-` typeIR holds
      -- if ~$is_extern_object_typeIR(typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:59.1-62.41
   rule default-some-extern: bound `|-` direction typeIR _id value'?{value' <- value'?}
      -- if direction matches ``EMPTY`
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- if Type_wf: bound `|-` typeIR holds
      -- if $is_extern_object_typeIR(typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:64.1-68.45
   rule default-some-not-extern: bound `|-` direction typeIR _id value'?{value' <- value'?}
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- if Type_wf: bound `|-` typeIR holds
      -- if ~$is_extern_object_typeIR(typeIR)
      -- if ((direction = `IN`) \/ (direction = ``EMPTY`))

;; ../../../../spec-concrete/5.03-wellformed.watsup:17.1-19.20
relation ParameterTypes_wf: bound `|-` parameterTypeIR*

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:70.1-74.51
   rule : bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- if $distinct_<id>(id*{id <- id*})
      -- (if ParameterType_wf: bound `|-` parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}

;; ../../../../spec-concrete/5.03-wellformed.watsup:21.1-23.20
relation RoutineType_wf: bound `|-` routineTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:469.1-472.34
   rule builtinfunction: bound `|-` routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:487.1-492.34
   rule functiontype: bound `|-` routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_function(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:520.1-525.45
   rule actiontype: bound `|-` routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- if $directionless_trailing(direction*{direction <- direction*})
      -- (if $nestable_action(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:543.1-548.34
   rule externfunctiontype: bound `|-` routineTypeIR
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externfunction(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:552.1-555.34
   rule builtinmethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:573.1-578.34
   rule externmethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:596.1-601.34
   rule externabstractmethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externabstractmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: bound `|-` typeIR_ret holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:618.1-622.56
   rule parserapplymethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_parserapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:639.1-643.57
   rule controlapplymethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- if ParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_controlapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:645.1-646.51
   rule tableapplymethod: bound `|-` routineTypeIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR = methodTypeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = tableTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:25.1-27.20
relation RoutineTypeDef_wf: bound `|-` routineTypeDefIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:663.1-666.44
   rule mono: bound `|-` routineTypeDefIR
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR
      -- if $definable_routine_mono(routineTypeIR)
      -- if RoutineType_wf: bound `|-` routineTypeIR holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:677.1-683.50
   rule poly: bound `|-` routineTypeDefIR
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- if $definable_routine_poly(routineTypeIR)
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, `{` tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} `}`)
      -- if RoutineType_wf: bound_inner `|-` routineTypeIR holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:29.1-31.20
relation ConstructorParameterType_wf: bound `|-` parameterTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:689.1-691.30
   rule : bound `|-` direction typeIR _id _value?{_value <- _value?}
      -- if direction matches ``EMPTY`
      -- if Type_wf: bound `|-` typeIR holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:33.1-35.20
relation ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:693.1-697.62
   rule : bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- if $distinct_<id>(id*{id <- id*})
      -- (if ConstructorParameterType_wf: bound `|-` parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}

;; ../../../../spec-concrete/5.03-wellformed.watsup:37.1-39.20
relation ConstructorType_wf: bound `|-` constructorTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:715.1-721.46
   rule externtype: bound `|-` `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object
      -- if ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR' as externObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_extern(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:734.1-740.46
   rule parsertype: bound `|-` `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object
      -- if ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR' as parserObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_parser(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:753.1-759.47
   rule controltype: bound `|-` `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object
      -- if ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR' as controlObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_control(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:770.1-776.47
   rule packagetype: bound `|-` `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object
      -- if ConstructorParameterTypes_wf: bound `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
      -- if Type_wf: bound `|-` typeIR_object holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR' as packageObjectTypeIR
      -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_package(typeIR))*{typeIR <- typeIR*}

;; ../../../../spec-concrete/5.03-wellformed.watsup:41.1-43.20
relation ConstructorTypeDef_wf: bound `|-` constructorTypeDefIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:794.1-801.58
   rule : bound `|-` constructorTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>`
      -- let `CONSTRUCTOR(` _constructorParameterTypeIR*{_constructorParameterTypeIR <- _constructorParameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- if $definable_constructor(typeIR_object)
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, `{` tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} `}`)
      -- if ConstructorType_wf: bound_inner `|-` constructorTypeIR holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:98.1-98.37
def $nestable_typedef(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:101.1-101.67
   clause 0(typeIR) = $nestable'_typedef($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:99.1-99.38
def $nestable'_typedef(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:102.1-102.36
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:103.1-103.37
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:104.1-104.38
   clause 2(typeIR) = true
      -- if (typeIR = `STRING` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:105.1-105.44
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:106.1-106.37
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:107.1-107.42
   clause 5(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:108.1-109.15
   clause 6(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:116.1-116.33
def $nestable_new(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:119.1-119.59
   clause 0(typeIR) = $nestable'_new($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:117.1-117.34
def $nestable'_new(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:120.1-120.32
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:121.1-121.38
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:122.1-122.38
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:123.1-123.33
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:124.1-124.36
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:125.1-126.15
   clause 5(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:135.1-135.34
def $nestable_list(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:138.1-138.61
   clause 0(typeIR) = $nestable'_list($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:136.1-136.35
def $nestable'_list(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:139.1-139.33
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:140.1-140.34
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:141.1-141.39
   clause 2(typeIR) = true
      -- if (typeIR = `MATCH_KIND` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:142.1-142.35
   clause 3(typeIR) = true
      -- if (typeIR = `STRING` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:143.1-143.41
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:144.1-144.34
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:145.1-145.39
   clause 6(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:146.1-147.15
   clause 7(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:154.1-154.35
def $nestable_tuple(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:157.1-157.63
   clause 0(typeIR) = $nestable'_tuple($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:155.1-155.36
def $nestable'_tuple(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:158.1-158.34
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:159.1-159.35
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:160.1-160.40
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:161.1-161.40
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:162.1-162.43
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:163.1-163.35
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:164.1-164.42
   clause 6(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as tupleTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:165.1-165.43
   clause 7(typeIR') = true
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:166.1-166.45
   clause 8(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:167.1-167.51
   clause 9(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:168.1-168.45
   clause 10(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:169.1-169.43
   clause 11(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:170.1-170.48
   clause 12(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:171.1-172.15
   clause 13(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:179.1-179.35
def $nestable_stack(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:182.1-182.63
   clause 0(typeIR) = $nestable'_stack($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:180.1-180.36
def $nestable'_stack(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:183.1-183.35
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:184.1-184.45
   clause 1(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:185.1-185.51
   clause 2(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:186.1-187.15
   clause 3(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:194.1-194.36
def $nestable_struct(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:197.1-197.65
   clause 0(typeIR) = $nestable'_struct($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:195.1-195.37
def $nestable'_struct(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:198.1-198.35
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:199.1-199.36
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:200.1-200.41
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:201.1-201.41
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:202.1-202.44
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:203.1-203.36
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:204.1-204.43
   clause 6(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as tupleTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:205.1-205.44
   clause 7(typeIR') = true
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` _nat `]` = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:206.1-206.46
   clause 8(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:207.1-207.46
   clause 9(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:208.1-208.52
   clause 10(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:209.1-209.44
   clause 11(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:210.1-210.49
   clause 12(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:211.1-212.15
   clause 13(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:220.1-220.36
def $nestable_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:225.1-225.65
   clause 0(typeIR) = $nestable'_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:221.1-221.37
def $nestable'_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:226.1-226.35
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:227.1-227.41
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:228.1-228.41
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:229.1-229.44
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VARBIT<%>`
      -- let `VARBIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:230.1-230.36
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:231.1-231.39
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:232.1-232.49
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:233.1-234.44
   clause 7(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR
      -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:235.1-236.15
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:222.1-222.46
def $nestable_struct_in_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:238.1-239.48
   clause 0(typeIR) = $nestable'_struct_in_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:223.1-223.47
def $nestable'_struct_in_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:240.1-240.45
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:241.1-241.51
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:242.1-242.51
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:243.1-243.46
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:244.1-244.49
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:245.1-245.59
   clause 5(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:246.1-247.44
   clause 6(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR _id `;`*{_id <- _id*, typeIR <- typeIR*} `}` = typeIR' as structTypeIR
      -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:248.1-249.15
   clause 7(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:257.1-257.41
def $nestable_headerunion(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:260.1-261.43
   clause 0(typeIR) = $nestable'_headerunion($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:258.1-258.42
def $nestable'_headerunion(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:262.1-262.41
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:263.1-263.44
   clause 1(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:264.1-264.51
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:265.1-266.15
   clause 3(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:278.1-278.37
def $nestable_serenum(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:283.1-284.39
   clause 0(typeIR) = $nestable'_serenum($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:279.1-279.38
def $nestable'_serenum(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:285.1-285.42
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:286.1-286.42
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:287.1-287.37
   clause 2(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:288.1-289.37
   clause 3(typeIR') = $nestable_new_in_serenum(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:290.1-291.15
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:280.1-280.44
def $nestable_new_in_serenum(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:293.1-294.46
   clause 0(typeIR) = $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:281.1-281.45
def $nestable_new_in_serenum'(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:295.1-295.49
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:296.1-296.49
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:297.1-297.44
   clause 2(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:298.1-298.47
   clause 3(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:299.1-300.15
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:357.1-357.33
def $nestable_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:364.1-364.59
   clause 0(typeIR) = $nestable'_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:358.1-358.34
def $nestable'_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:365.1-365.32
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:366.1-366.33
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:367.1-367.38
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:368.1-368.38
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:369.1-369.33
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:370.1-370.36
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:371.1-372.40
   clause 6(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:373.1-373.41
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:374.1-374.46
   clause 8(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:375.1-376.43
   clause 9(typeIR') = true
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:377.1-378.15
   clause 10(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:359.1-359.42
def $nestable_tuple_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:380.1-381.44
   clause 0(typeIR) = $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:360.1-360.43
def $nestable'_tuple_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:382.1-382.41
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:383.1-383.47
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:384.1-384.47
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:385.1-385.42
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:386.1-386.45
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:387.1-388.40
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:389.1-389.50
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:390.1-390.55
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:391.1-392.15
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:361.1-361.45
def $nestable_sequence_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:394.1-395.47
   clause 0(typeIR) = $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:362.1-362.46
def $nestable'_sequence_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:396.1-396.44
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:397.1-397.50
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:398.1-398.50
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:399.1-399.45
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:400.1-400.48
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid _typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:401.1-402.43
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as tupleTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:403.1-403.53
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:404.1-404.58
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:405.1-406.43
   clause 8(typeIR') = true
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR*{typeIR <- typeIR*} `>` = sequenceTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:407.1-408.15
   clause 9(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:426.1-426.40
def $definable_type_mono(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:428.1-428.39
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` _tid = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:429.1-429.45
   clause 1(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:430.1-430.47
   clause 2(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:431.1-431.52
   clause 3(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:432.1-432.46
   clause 4(typeIR) = true
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:433.1-434.15
   clause 5(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:441.1-441.40
def $definable_type_poly(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:443.1-443.46
   clause 0(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as tupleTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:444.1-444.42
   clause 1(typeIR) = true
      -- if typeIR <: headerStackTypeIR
      -- let _typeIR `[` _nat `]` = typeIR as headerStackTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:445.1-445.49
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:446.1-446.55
   clause 3(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:447.1-447.49
   clause 4(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `STRUCT` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR as structTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:448.1-448.44
   clause 5(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:449.1-449.47
   clause 6(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:450.1-450.48
   clause 7(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:451.1-451.48
   clause 8(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:452.1-453.15
   clause 9(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:474.1-474.49
def $nestable_function(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:477.1-478.51
   clause 0(direction, typeIR) = $nestable_function'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:475.1-475.50
def $nestable_function'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:479.1-480.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:481.1-482.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:483.1-483.57
   clause 2(direction, typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:484.1-485.15
   clause 3(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:494.1-494.47
def $directionless_trailing(direction*) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:497.1-498.65
   clause 0(direction*{direction <- direction*}) = $directionless_trailing'(true, $rev_<direction>(direction*{direction <- direction*}))

;; ../../../../spec-concrete/5.03-wellformed.watsup:495.1-495.54
def $directionless_trailing'(bool, direction*) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:500.1-500.44
   clause 0(_bool, direction*{direction <- direction*}) = true
      -- if direction*{direction <- direction*} matches []

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:501.1-502.49
   clause 1(bool, direction'*{direction' <- direction'*}) = $directionless_trailing'(true, direction_t*{direction_t <- direction_t*})
      -- if (bool = true)
      -- if direction'*{direction' <- direction'*} matches _ :: _
      -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
      -- if direction matches ``EMPTY`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:503.1-503.68
   clause 2(bool, direction'*{direction' <- direction'*}) = false
      -- if (bool = false)
      -- if direction'*{direction' <- direction'*} matches _ :: _
      -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
      -- if direction matches ``EMPTY`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:504.1-506.31
   clause 3(_bool, direction*{direction <- direction*}) = $directionless_trailing'(false, direction_t*{direction_t <- direction_t*})
      -- if direction*{direction <- direction*} matches _ :: _
      -- let direction_h :: direction_t*{direction_t <- direction_t*} = direction*{direction <- direction*}
      -- if (direction_h =/= ``EMPTY`)

;; ../../../../spec-concrete/5.03-wellformed.watsup:508.1-508.47
def $nestable_action(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:511.1-512.49
   clause 0(direction, typeIR) = $nestable_action'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:509.1-509.48
def $nestable_action'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:513.1-514.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:515.1-515.38
   clause 1(_direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:516.1-516.47
   clause 2(_direction, typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:517.1-518.15
   clause 3(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:527.1-527.55
def $nestable_externfunction(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:530.1-531.57
   clause 0(direction, typeIR) = $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:528.1-528.56
def $nestable_externfunction'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:532.1-533.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:534.1-535.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:536.1-536.64
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:537.1-537.65
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:538.1-538.65
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:539.1-539.63
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:540.1-541.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:557.1-557.53
def $nestable_externmethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:560.1-561.55
   clause 0(direction, typeIR) = $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:558.1-558.54
def $nestable_externmethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:562.1-563.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:564.1-565.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:566.1-566.62
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:567.1-567.63
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:568.1-568.63
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:569.1-569.61
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:570.1-571.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:580.1-580.61
def $nestable_externabstractmethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:583.1-584.63
   clause 0(direction, typeIR) = $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:581.1-581.62
def $nestable_externabstractmethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:585.1-586.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:587.1-588.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:589.1-589.70
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:590.1-590.71
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:591.1-591.71
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:592.1-592.69
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:593.1-594.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:603.1-603.58
def $nestable_parserapplymethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:606.1-607.60
   clause 0(direction, typeIR) = $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:604.1-604.59
def $nestable_parserapplymethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:608.1-609.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:610.1-611.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:612.1-612.68
   clause 2(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:613.1-613.68
   clause 3(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:614.1-614.66
   clause 4(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:615.1-616.15
   clause 5(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:624.1-624.59
def $nestable_controlapplymethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:627.1-628.61
   clause 0(direction, typeIR) = $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:625.1-625.60
def $nestable_controlapplymethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:629.1-630.29
   clause 0(direction, typeIR) = false
      -- if (typeIR = `STRING` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:631.1-632.29
   clause 1(direction, typeIR) = false
      -- if (typeIR = `INT` as typeIR)
      -- if (direction =/= ``EMPTY`)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:633.1-633.68
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:634.1-634.69
   clause 3(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:635.1-635.67
   clause 4(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:636.1-637.15
   clause 5(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:652.1-652.50
def $definable_routine_mono(routineTypeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:654.1-654.66
   clause 0(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
      -- let `BUILTIN_FUNCTION(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = functionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:655.1-655.50
   clause 1(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = functionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:656.1-656.64
   clause 2(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
      -- let `BUILTIN_METHOD(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:657.1-657.56
   clause 3(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:658.1-658.57
   clause 4(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:659.1-659.54
   clause 5(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:660.1-661.15
   clause 6(_routineTypeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:668.1-668.50
def $definable_routine_poly(routineTypeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:670.1-670.58
   clause 0(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `FUNCTION(%)->%`
      -- let `FUNCTION(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = functionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:671.1-671.65
   clause 1(routineTypeIR) = true
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = functionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:672.1-672.63
   clause 2(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:673.1-673.72
   clause 3(routineTypeIR) = true
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:674.1-675.15
   clause 4(_routineTypeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:703.1-703.48
def $nestable_constructor_extern(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:706.1-707.50
   clause 0(typeIR) = $nestable'_constructor_extern($canon(typeIR))

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:708.1-708.56
   clause 1(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:704.1-704.49
def $nestable'_constructor_extern(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:709.1-709.58
   clause 0(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:710.1-710.58
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:711.1-711.56
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:712.1-713.15
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:723.1-723.48
def $nestable_constructor_parser(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:726.1-727.50
   clause 0(typeIR) = $nestable'_constructor_parser($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:724.1-724.49
def $nestable'_constructor_parser(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:728.1-728.58
   clause 0(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:729.1-729.58
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:730.1-730.56
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:731.1-732.15
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:742.1-742.49
def $nestable_constructor_control(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:745.1-746.51
   clause 0(typeIR) = $nestable'_constructor_control($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:743.1-743.50
def $nestable'_constructor_control(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:747.1-747.58
   clause 0(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:748.1-748.59
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:749.1-749.57
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:750.1-751.15
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:761.1-761.49
def $nestable_constructor_package(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:764.1-765.51
   clause 0(typeIR) = $nestable'_constructor_package($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:762.1-762.50
def $nestable'_constructor_package(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:766.1-766.57
   clause 0(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` _typeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:767.1-768.15
   clause 1(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:782.1-782.42
def $definable_constructor(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:785.1-786.44
   clause 0(typeIR) = $definable'_constructor($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:783.1-783.43
def $definable'_constructor(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:787.1-787.47
   clause 0(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:788.1-788.50
   clause 1(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:789.1-789.51
   clause 2(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:790.1-790.51
   clause 3(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:791.1-792.15
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.04-typing-relation.watsup:6.1-8.23
relation Eval_static: cursor context `|-` typedExpressionIR `~>` value

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:16.1-17.36
   rule true: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` true as value
      -- if (expressionIR = `TRUE` as expressionIR)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:19.1-20.38
   rule false: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `B` false as value
      -- if (expressionIR = `FALSE` as expressionIR)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:24.1-25.34
   rule number-arbint: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `D` i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `D%`
      -- let `D` i = number

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:27.1-28.38
   rule number-fixbit: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` n `W` i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%W%`
      -- let n `W` i = number

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:30.1-31.38
   rule number-fixint: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` n `S` i as value
      -- if expressionIR <: number
      -- let number = expressionIR as number
      -- if number matches `%S%`
      -- let n `S` i = number

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:35.1-36.48
   rule stringliteral: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` `"` text `"` as value
      -- if expressionIR <: stringLiteral
      -- let `"` text `"` = expressionIR as stringLiteral

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:51.1-54.45
   rule castExpression: p C `|-` expressionIR `#` `(` _typeIR _ctk `)` `~>` value_cast
      -- if expressionIR <: castExpressionIR
      -- let `(` typeIR `)` typedExpressionIR = expressionIR as castExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR `~>` value
      -- let value_cast = $cast_op(typeIR, value)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:14.1-16.23
relation Type_ok: cursor context `|-` typeOrVoid `:` typeIR `#` tid*

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:11.1-12.28
   rule boolean: p C `|-` typeOrVoid `:` `BOOL` as typeIR `#` []
      -- if (typeOrVoid = `BOOL` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:16.1-17.30
   rule error: p C `|-` typeOrVoid `:` `ERROR` as typeIR `#` []
      -- if (typeOrVoid = `ERROR` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:21.1-22.40
   rule matchkind: p C `|-` typeOrVoid `:` `MATCH_KIND` as typeIR `#` []
      -- if (typeOrVoid = `MATCH_KIND` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:26.1-27.32
   rule string: p C `|-` typeOrVoid `:` `STRING` as typeIR `#` []
      -- if (typeOrVoid = `STRING` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:31.1-32.26
   rule arbint: p C `|-` typeOrVoid `:` `INT` as typeIR `#` []
      -- if (typeOrVoid = `INT` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:37.1-38.42
   rule fixint: p C `|-` typeOrVoid `:` `INT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `INT<%>`
      -- let `INT<` int `>` = baseType
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:40.1-44.30
   rule fixint-expr: p C `|-` typeOrVoid `:` `INT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `INT<(%)>`
      -- let `INT<(` expression `)>` = baseType
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:50.1-51.35
   rule bit: p C `|-` typeOrVoid `:` `BIT<` 1 `>` as typeIR `#` []
      -- if (typeOrVoid = `BIT` as typeOrVoid)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:53.1-54.42
   rule fixbit: p C `|-` typeOrVoid `:` `BIT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `BIT<%>`
      -- let `BIT<` int `>` = baseType
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:56.1-60.30
   rule fixbit-expr: p C `|-` typeOrVoid `:` `BIT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `BIT<(%)>`
      -- let `BIT<(` expression `)>` = baseType
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:65.1-66.48
   rule varbit: p C `|-` typeOrVoid `:` `VARBIT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `VARBIT<%>`
      -- let `VARBIT<` int `>` = baseType
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:68.1-72.30
   rule varbit-expr: p C `|-` typeOrVoid `:` `VARBIT<` n `>` as typeIR `#` []
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `VARBIT<(%)>`
      -- let `VARBIT<(` expression `)>` = baseType
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- Eval_static: p C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:79.1-82.50
   rule prefixedTypeName-mono: p C `|-` typeOrVoid `:` typeIR `#` []
      -- if typeOrVoid <: prefixedTypeName
      -- let prefixedTypeName = typeOrVoid as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:84.1-87.57
   rule prefixedTypeName-poly: p C `|-` typeOrVoid `:` polyTypeDefIR `<` [] `>` as typeIR `#` []
      -- if typeOrVoid <: prefixedTypeName
      -- let prefixedTypeName = typeOrVoid as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR as polyTypeDefIR

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:92.1-95.50
   rule specializedType-mono: p C `|-` typeOrVoid `:` typeIR `#` []
      -- if typeOrVoid <: specializedType
      -- let prefixedTypeName `<` typeArgumentList `>` = typeOrVoid as specializedType
      -- if typeArgumentList matches ``EMPTY`
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:97.1-104.72
   rule specializedType-poly: p C `|-` typeOrVoid `:` polyTypeDefIR `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` as typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: specializedType
      -- let prefixedTypeName `<` typeArgumentList `>` = typeOrVoid as specializedType
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR as polyTypeDefIR
      -- let typeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` = polyTypeDefIR
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeIR_arg*{typeIR_arg <- typeIR_arg*} `#` tid_fresh*{tid_fresh <- tid_fresh*}

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:109.1-120.59
   rule headerStackType-typeName-expression: p C `|-` typeOrVoid `:` polyTypeDefIR_stack `<` [typeIR_base] `>` as typeIR `#` []
      -- if typeOrVoid <: headerStackType
      -- let namedType `[` expression_size `]` = typeOrVoid as headerStackType
      -- if namedType <: typeName
      -- let typeName = namedType as typeName
      -- Type_ok: p C `|-` typeName as typeOrVoid `:` typeIR_base `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- Expr_ok: p C `|-` expression_size `:` typedExpressionIR_size
      -- Eval_static: p C `|-` typedExpressionIR_size `~>` value_size
      -- let int = $to_number(value_size)
      -- if int <: nat
      -- let n_size = int as nat
      -- let typeIR_stack = `TID` "T" as typeIR `[` n_size `]` as typeIR
      -- let polyTypeDefIR_stack = typeIR_stack `<` ["T"] `,` [] `>`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:122.1-133.59
   rule headerStackType-specializedType-expression: p C `|-` typeOrVoid `:` polyTypeDefIR_stack `<` [typeIR_base] `>` as typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: headerStackType
      -- let namedType `[` expression_size `]` = typeOrVoid as headerStackType
      -- if namedType <: specializedType
      -- let specializedType = namedType as specializedType
      -- Type_ok: p C `|-` specializedType as typeOrVoid `:` typeIR_base `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- Expr_ok: p C `|-` expression_size `:` typedExpressionIR_size
      -- Eval_static: p C `|-` typedExpressionIR_size `~>` value_size
      -- let int = $to_number(value_size)
      -- if int <: nat
      -- let n_size = int as nat
      -- let typeIR_stack = `TID` "T" as typeIR `[` n_size `]` as typeIR
      -- let polyTypeDefIR_stack = typeIR_stack `<` ["T"] `,` [] `>`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:138.1-145.57
   rule listType: p C `|-` typeOrVoid `:` polyTypeDefIR_list `<` [typeIR_arg] `>` as typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: listType
      -- let `LIST<` typeArgument `>` = typeOrVoid as listType
      -- TypeArgument_ok: p C `|-` typeArgument `:` typeIR_arg `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- let typeIR_list = `LIST<` `TID` "T" as typeIR `>` as typeIR
      -- let polyTypeDefIR_list = typeIR_list `<` ["T"] `,` [] `>`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:150.1-160.67
   rule tupleType: p C `|-` typeOrVoid `:` polyTypeDefIR_tuple `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` as typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if typeOrVoid <: tupleType
      -- let `TUPLE<` typeArgumentList `>` = typeOrVoid as tupleType
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeIR_arg*{typeIR_arg <- typeIR_arg*} `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- let i_idx*{i_idx <- i_idx*} = $init_(|typeIR_arg*{typeIR_arg <- typeIR_arg*}|) as int*
      -- (let tid_tparam = "T" ++ $int_to_text(i_idx))*{i_idx <- i_idx*, tid_tparam <- tid_tparam*}
      -- let typeIR_tuple = `TUPLE<` `TID` tid_tparam as typeIR*{tid_tparam <- tid_tparam*} `>` as typeIR
      -- let polyTypeDefIR_tuple = typeIR_tuple `<` tid_tparam*{tid_tparam <- tid_tparam*} `,` [] `>`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:164.1-165.28
   rule void: p C `|-` typeOrVoid `:` `VOID` as typeIR `#` []
      -- if typeOrVoid matches `VOID`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:18.1-20.23
relation TypeArgument_ok: cursor context `|-` typeArgument `:` typeArgumentIR `#` tid*

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:12.1-14.48
   rule : p C `|-` typeArgument `:` typeIR `#` tid_impl*{tid_impl <- tid_impl*}
      -- if typeArgument <: type
      -- let type = typeArgument as type
      -- Type_ok: p C `|-` type as typeOrVoid `:` typeIR `#` tid_impl*{tid_impl <- tid_impl*}

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:18.1-19.28
   rule : p C `|-` typeArgument `:` `VOID` as typeArgumentIR `#` []
      -- if (typeArgument = `VOID` as typeArgument)

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:23.1-25.32
   rule : p C `|-` typeArgument `:` `TID` tid_impl as typeArgumentIR `#` [tid_impl]
      -- if (typeArgument = `_` as typeArgument)
      -- let tid_impl = $fresh_tid

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:29.1-31.33
   rule : p C `|-` typeArgument `:` `TID` tid as typeArgumentIR `#` []
      -- if typeArgument <: nonTypeName
      -- let nonTypeName = typeArgument as nonTypeName
      -- let tid = $name(nonTypeName as name)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:22.1-24.23
relation TypeArguments_ok: cursor context `|-` typeArgument* `:` typeArgumentListIR `#` tid*

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:39.1-40.26
   rule : p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` [] `#` []
      -- if typeArgument*{typeArgument <- typeArgument*} matches []

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:42.1-49.47
   rule : p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeArgumentIR_h :: typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- if typeArgument*{typeArgument <- typeArgument*} matches _ :: _
      -- let typeArgument_h :: typeArgument_t*{typeArgument_t <- typeArgument_t*} = typeArgument*{typeArgument <- typeArgument*}
      -- TypeArgument_ok: p C `|-` typeArgument_h `:` typeArgumentIR_h `#` tid_impl_h*{tid_impl_h <- tid_impl_h*}
      -- TypeArguments_ok: p C `|-` typeArgument_t*{typeArgument_t <- typeArgument_t*} `:` typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} `#` tid_impl_t*{tid_impl_t <- tid_impl_t*}
      -- let tid_impl*{tid_impl <- tid_impl*} = tid_impl_h*{tid_impl_h <- tid_impl_h*} ++ tid_impl_t*{tid_impl_t <- tid_impl_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:30.1-30.54
relation Sub_expl: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:5.1-9.54
   rule : typeIR_a `<:` typeIR_b
      -- let typeIR_a_canon = $canon(typeIR_a)
      -- let typeIR_b_canon = $canon(typeIR_b)
      -- if Sub_expl_canon: typeIR_a_canon `<:` typeIR_b_canon holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:31.1-31.60
relation Sub_expl_canon: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:11.1-13.38
   rule equals: typeIR_a `<:` typeIR_b
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:15.1-18.46
   rule not-equals: typeIR_a `<:` typeIR_b
      -- if ~Type_alpha: typeIR_a `~~` typeIR_b holds
      -- if Sub_expl_canon_neq: typeIR_a `<:` typeIR_b holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:32.1-32.64
relation Sub_expl_canon_neq: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:20.1-21.21
   rule fixbit-boolean: typeIR `<:` typeIR'
      -- if (typeIR = `BIT<` 1 `>` as typeIR)
      -- if (typeIR' = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:23.1-24.21
   rule boolean-fixbit: typeIR `<:` typeIR'
      -- if (typeIR = `BOOL` as typeIR)
      -- if (typeIR' = `BIT<` 1 `>` as typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:26.1-27.20
   rule arbint-fixint: typeIR `<:` typeIR'
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:29.1-30.20
   rule arbint-fixbit: typeIR `<:` typeIR'
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:32.1-33.31
   rule fixint-fixint: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w_a `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w_b `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:35.1-36.27
   rule fixint-fixbit: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:38.1-39.27
   rule fixbit-fixint: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:41.1-42.31
   rule fixbit-fixbit: typeIR `<:` typeIR'
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w_a `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w_b `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:44.1-46.36
   rule newtype-left: typeIR `<:` typeIR_b
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR_a = aliasTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:48.1-50.36
   rule newtype-right: typeIR_a `<:` typeIR
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR_b = aliasTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:52.1-54.36
   rule serenum-left: typeIR `<:` typeIR_b
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_a `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:56.1-58.36
   rule serenum-right: typeIR_a `<:` typeIR
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_b `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:60.1-62.41
   rule default: typeIR `<:` typeIR_b
      -- if (typeIR = `DEFAULT` as typeIR)
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:64.1-65.36
   rule invalidheader-header: typeIR `<:` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:67.1-68.42
   rule invalidheader-headerunion: typeIR `<:` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR' as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:70.1-72.39
   rule seq-list: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR_b `>` = typeIR' as listTypeIR
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:74.1-76.39
   rule seq-tuple: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:78.1-81.39
   rule seq-stack: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:83.1-85.39
   rule seq-struct: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:87.1-89.39
   rule seq-header: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:91.1-97.50
   rule seqdefault-tuple: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:99.1-103.41
   rule seqdefault-stack: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:105.1-111.50
   rule seqdefault-struct: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:113.1-119.50
   rule seqdefault-header: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:121.1-128.55
   rule record-struct: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if $eq_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_expl: typeIR_a_aligned `<:` typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:130.1-137.55
   rule record-header: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if $eq_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_expl: typeIR_a_aligned `<:` typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:139.1-152.50
   rule recorddefault-struct: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if $sub_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_expl: typeIR_a_aligned `<:` typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{` id_default*{id_default <- id_default*} `}` = $diff_set<id>(`{` id_b*{id_b <- id_b*} `}`, `{` id_a*{id_a <- id_a*} `}`)
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:154.1-167.50
   rule recorddefault-header: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if $sub_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_expl: typeIR_a_aligned `<:` typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{` id_default*{id_default <- id_default*} `}` = $diff_set<id>(`{` id_b*{id_b <- id_b*} `}`, `{` id_a*{id_a <- id_a*} `}`)
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:169.1-171.36
   rule set-set: typeIR' `<:` typeIR'''
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_a] = typeIR*{typeIR <- typeIR*}
      -- if typeIR''' <: setTypeIR
      -- let `SET<` typeIR''*{typeIR'' <- typeIR''*} `>` = typeIR''' as setTypeIR
      -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
      -- let [typeIR_b] = typeIR''*{typeIR'' <- typeIR''*}
      -- if Sub_expl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:173.1-176.36
   rule non-set-set: typeIR_a `<:` typeIR'
      -- if typeIR' <: setTypeIR
      -- let `SET<` typeIR*{typeIR <- typeIR*} `>` = typeIR' as setTypeIR
      -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
      -- let [typeIR_b] = typeIR*{typeIR <- typeIR*}
      -- if ~$is_set_typeIR(typeIR_a)
      -- if Sub_expl: typeIR_a `<:` typeIR_b holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:34.1-34.54
relation Sub_impl: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:182.1-186.54
   rule : typeIR_a `<:` typeIR_b
      -- let typeIR_a_canon = $canon(typeIR_a)
      -- let typeIR_b_canon = $canon(typeIR_b)
      -- if Sub_impl_canon: typeIR_a_canon `<:` typeIR_b_canon holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:35.1-35.60
relation Sub_impl_canon: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:188.1-190.38
   rule equals: typeIR_a `<:` typeIR_b
      -- if Type_alpha: typeIR_a `~~` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:192.1-195.46
   rule not-equals: typeIR_a `<:` typeIR_b
      -- if ~Type_alpha: typeIR_a `~~` typeIR_b holds
      -- if Sub_impl_canon_neq: typeIR_a `<:` typeIR_b holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:36.1-36.64
relation Sub_impl_canon_neq: typeIR `<:` typeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:197.1-198.20
   rule arbint-fixint: typeIR `<:` typeIR'
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:200.1-201.20
   rule arbint-fixbit: typeIR `<:` typeIR'
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:203.1-205.36
   rule serenum-left: typeIR `<:` typeIR_b
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_a `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:207.1-209.36
   rule serenum-right: typeIR_a `<:` typeIR
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_b `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- if Sub_impl: typeIR_a `<:` typeIR_b holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:211.1-213.41
   rule default: typeIR `<:` typeIR_b
      -- if (typeIR = `DEFAULT` as typeIR)
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:215.1-216.36
   rule invalidheader-header: typeIR `<:` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:218.1-219.42
   rule invalidheader-headerunion: typeIR `<:` typeIR'
      -- if (typeIR = `HEADER_INVALID` as typeIR)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} `}` = typeIR' as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:221.1-223.39
   rule seq-list: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR_b `>` = typeIR' as listTypeIR
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:225.1-227.39
   rule seq-tuple: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:229.1-232.39
   rule seq-stack: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:234.1-236.39
   rule seq-struct: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:238.1-240.39
   rule seq-header: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:242.1-244.39
   rule seq-seq: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `>` = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SEQ<%>`
      -- let `SEQ<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = sequenceTypeIR'
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:246.1-252.50
   rule seqdefault-tuple: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_b*{typeIR_b <- typeIR_b*} `>` = typeIR' as tupleTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:254.1-258.41
   rule seqdefault-stack: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_b `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b holds)*{typeIR_a <- typeIR_a*}
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:260.1-266.50
   rule seqdefault-struct: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:268.1-274.50
   rule seqdefault-header: typeIR `<:` typeIR'
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SEQ<%,...>`
      -- let `SEQ<` typeIR_a*{typeIR_a <- typeIR_a*} `,...>` = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b _id `;`*{_id <- _id*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: typeIR_a `<:` typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:276.1-283.55
   rule record-struct: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if $eq_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_impl: typeIR_a_aligned `<:` typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:285.1-292.55
   rule record-header: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}` = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if $eq_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_impl: typeIR_a_aligned `<:` typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:294.1-307.50
   rule recorddefault-struct: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as structTypeIR
      -- if $sub_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_impl: typeIR_a_aligned `<:` typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{` id_default*{id_default <- id_default*} `}` = $diff_set<id>(`{` id_b*{id_b <- id_b*} `}`, `{` id_a*{id_a <- id_a*} `}`)
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:309.1-322.50
   rule recorddefault-header: typeIR `<:` typeIR'
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RECORD{%,...}`
      -- let `RECORD{` typeIR_a id_a `;`*{id_a <- id_a*, typeIR_a <- typeIR_a*} `,...}` = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_b id_b `;`*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}` = typeIR' as headerTypeIR
      -- if $sub_set<id>(`{` id_a*{id_a <- id_a*} `}`, `{` id_b*{id_b <- id_b*} `}`)
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{` id_a `:` typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} `}`, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_impl: typeIR_a_aligned `<:` typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{` id_default*{id_default <- id_default*} `}` = $diff_set<id>(`{` id_b*{id_b <- id_b*} `}`, `{` id_a*{id_a <- id_a*} `}`)
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{` id_b `:` typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} `}`, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:42.1-44.23
relation Expr_ok: cursor context `|-` expression `:` typedExpressionIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:12.1-14.42
   rule literalExpression-true: p C `|-` expression `:` `TRUE` as expressionIR `#` expressionNoteIR
      -- if (expression = `TRUE` as expression)
      -- let expressionNoteIR = `(` `BOOL` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:16.1-18.42
   rule literalExpression-false: p C `|-` expression `:` `FALSE` as expressionIR `#` expressionNoteIR
      -- if (expression = `FALSE` as expression)
      -- let expressionNoteIR = `(` `BOOL` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:22.1-24.41
   rule literalExpression-number-arbint: p C `|-` expression `:` `D` i as expressionIR `#` expressionNoteIR
      -- if expression <: number
      -- let number = expression as number
      -- if number matches `D%`
      -- let `D` i = number
      -- let expressionNoteIR = `(` `INT` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:26.1-28.50
   rule literalExpression-number-fixint: p C `|-` expression `:` n `S` i as expressionIR `#` expressionNoteIR
      -- if expression <: number
      -- let number = expression as number
      -- if number matches `%S%`
      -- let n `S` i = number
      -- let expressionNoteIR = `(` `INT<` n `>` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:30.1-32.50
   rule literalExpression-number-fixbit: p C `|-` expression `:` n `W` i as expressionIR `#` expressionNoteIR
      -- if expression <: number
      -- let number = expression as number
      -- if number matches `%W%`
      -- let n `W` i = number
      -- let expressionNoteIR = `(` `BIT<` n `>` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:36.1-38.44
   rule literalExpression-stringliteral: p C `|-` expression `:` `"` text `"` as expressionIR `#` expressionNoteIR
      -- if expression <: stringLiteral
      -- let `"` text `"` = expression as stringLiteral
      -- let expressionNoteIR = `(` `STRING` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:45.1-49.43
   rule referenceExpression-prefixedNonTypeName: p C `|-` expression `:` prefixedNameIR as expressionIR `#` expressionNoteIR
      -- if expression <: prefixedNonTypeName
      -- let prefixedNonTypeName = expression as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, C, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:53.1-57.43
   rule referenceExpression-this: p C `|-` expression `:` prefixedNameIR as expressionIR `#` expressionNoteIR
      -- if (expression = `THIS` as expression)
      -- let prefixedNameIR = ``` "this"
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, C, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:61.1-63.45
   rule defaultExpression: p C `|-` expression `:` `...` as expressionIR `#` expressionNoteIR
      -- if (expression = `...` as expression)
      -- let expressionNoteIR = `(` `DEFAULT` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:77.1-86.58
   rule unaryExpression-lnot: p C `|-` expression' `:` `!` typedExpressionIR_reduced as expressionIR `#` expressionNoteIR
      -- if expression' <: unaryExpression
      -- let unop expression = expression' as unaryExpression
      -- if unop matches `!`
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_lnot)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR `#` expressionNoteIR = typedExpressionIR_reduced

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:99.1-108.58
   rule unaryExpression-bnot: p C `|-` expression' `:` `~` typedExpressionIR_reduced as expressionIR `#` expressionNoteIR
      -- if expression' <: unaryExpression
      -- let unop expression = expression' as unaryExpression
      -- if unop matches `~`
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_bnot)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR `#` expressionNoteIR = typedExpressionIR_reduced

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:122.1-132.58
   rule unaryExpression-uplusminus: p C `|-` expression' `:` unop typedExpressionIR_reduced as expressionIR `#` expressionNoteIR
      -- if expression' <: unaryExpression
      -- let unop expression = expression' as unaryExpression
      -- if ((unop = `+`) \/ (unop = `-`))
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let _expressionIR `#` expressionNoteIR = typedExpressionIR_reduced

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:149.1-171.59
   rule binaryExpression-plusminusmult: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`+`, `-`, `*`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmult)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:185.1-207.59
   rule binaryExpression-satplusminus: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`|+|`, `|-|`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:220.1-247.59
   rule binaryExpression-divmod-lctk: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`/`, `%`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- if (ctk_r_reduced = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_r_reduced `~>` value_r
      -- let int = $to_number(value_r)
      -- if int <: nat
      -- let n_r = int as nat
      -- if (n_r > 0)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:249.1-274.59
   rule binaryExpression-divmod-non-lctk: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`/`, `%`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- if (ctk_r_reduced =/= `LCTK`)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:295.1-319.61
   rule binaryExpression-shift-fixbit: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`<<`, `>>`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_shift)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_l_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR_r_reduced ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if $is_fixed_bit_typeIR(typeIR_r_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_l_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:321.1-347.61
   rule binaryExpression-shift-integer: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`<<`, `>>`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_shift)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_l_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR_r_reduced ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced = `LCTK`)
      -- if ($is_arbitrary_int_typeIR(typeIR_r_reduced) \/ $is_fixed_int_typeIR(typeIR_r_reduced))
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_l_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:351.1-369.46
   rule binaryExpression-eq: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`==`, `!=`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR `#` `(` typeIR_cast ctk_l_cast `)` = typedExpressionIR_l_cast
      -- let _expressionIR' `#` `(` typeIR ctk_r_cast `)` = typedExpressionIR_r_cast
      -- if (typeIR = typeIR_cast)
      -- if $is_equalable_typeIR(typeIR_cast)
      -- let ctk_cast = $join_ctk(ctk_l_cast, ctk_r_cast)
      -- let expressionNoteIR = `(` `BOOL` as typeIR ctk_cast `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:384.1-406.59
   rule binaryExpression-compare: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`<=`, `>=`, `<`, `>`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:420.1-442.59
   rule binaryExpression-bitwise: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`&`, `^`, `|`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:458.1-479.59
   rule binaryExpression-concat: p C `|-` expression `:` typedExpressionIR_l `++` typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop matches `++`
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_concat)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:492.1-514.59
   rule binaryExpression-logical: p C `|-` expression `:` typedExpressionIR_l binop typedExpressionIR_r as expressionIR `#` expressionNoteIR
      -- if expression <: binaryExpression
      -- let expression_l binop expression_r = expression as binaryExpression
      -- if binop <- [`&&`, `||`]
      -- Expr_ok: p C `|-` expression_l `:` typedExpressionIR_l
      -- Expr_ok: p C `|-` expression_r `:` typedExpressionIR_r
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let _expressionIR `#` `(` typeIR_reduced ctk_l_reduced `)` = typedExpressionIR_l_reduced
      -- let _expressionIR' `#` `(` typeIR ctk_r_reduced `)` = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(` typeIR_reduced ctk_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:520.1-541.48
   rule ternaryExpression: p C `|-` expression `:` typedExpressionIR_cond `?` typedExpressionIR_true_cast `:` typedExpressionIR_false_cast as expressionIR `#` expressionNoteIR
      -- if expression <: ternaryExpression
      -- let expression_cond `?` expression_true `:` expression_false = expression as ternaryExpression
      -- Expr_ok: p C `|-` expression_cond `:` typedExpressionIR_cond
      -- let _expressionIR `#` `(` typeIR ctk_cond `)` = typedExpressionIR_cond
      -- if (typeIR = `BOOL` as typeIR)
      -- Expr_ok: p C `|-` expression_true `:` typedExpressionIR_true
      -- Expr_ok: p C `|-` expression_false `:` typedExpressionIR_false
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_true, typedExpressionIR_false)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let _expressionIR' `#` `(` typeIR_cast ctk_true_cast `)` = typedExpressionIR_true_cast
      -- let _expressionIR'' `#` `(` typeIR' ctk_false_cast `)` = typedExpressionIR_false_cast
      -- if (typeIR' = typeIR_cast)
      -- if ($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= `DYN`))
      -- let ctk = $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast])
      -- let expressionNoteIR = `(` typeIR_cast ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:546.1-559.45
   rule castExpression: p C `|-` expression' `:` `(` typeIR_t `)` typedExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression' <: castExpression
      -- let `(` type_t `)` expression = expression' as castExpression
      -- Type_ok: p C `|-` type_t as typeOrVoid `:` typeIR_t `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(p, C) `|-` typeIR_t holds
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR ctk `)` = typedExpressionIR
      -- if Sub_expl: typeIR `<:` typeIR_t holds
      -- let expressionNoteIR = `(` typeIR_t ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:566.1-568.52
   rule dataExpression-invalid: p C `|-` expression `:` `{#}` as expressionIR `#` expressionNoteIR
      -- if (expression = `{#}` as expression)
      -- let expressionNoteIR = `(` `HEADER_INVALID` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:576.1-587.43
   rule dataExpression-sequenceElementExpression: p C `|-` expression `:` `SEQ{` typedExpressionIR_e*{typedExpressionIR_e <- typedExpressionIR_e*} `}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: expressionList
      -- let expressionList = dataElementExpression as expressionList
      -- let expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList)
      -- (Expr_ok: p C `|-` expression_e `:` typedExpressionIR_e)*{expression_e <- expression_e*, typedExpressionIR_e <- typedExpressionIR_e*}
      -- (let _expressionIR `#` `(` typeIR_e ctk_e `)` = typedExpressionIR_e)*{_expressionIR <- _expressionIR*, ctk_e <- ctk_e*, typeIR_e <- typeIR_e*, typedExpressionIR_e <- typedExpressionIR_e*}
      -- let typeIR = `SEQ<` typeIR_e*{typeIR_e <- typeIR_e*} `>` as typeIR
      -- let ctk = $joins_ctk(ctk_e*{ctk_e <- ctk_e*})
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:594.1-605.45
   rule dataExpression-recordElementExpression-single: p C `|-` expression `:` `RECORD{` [nameIR_f `=` typedExpressionIR_f] `}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%`
      -- let name_f `=` expression_f = recordElementExpression
      -- let nameIR_f = $name(name_f)
      -- Expr_ok: p C `|-` expression_f `:` typedExpressionIR_f
      -- let _expressionIR `#` `(` typeIR_f ctk_f `)` = typedExpressionIR_f
      -- let typeIR = `RECORD{` [typeIR_f nameIR_f `;`] `}` as typeIR
      -- let expressionNoteIR = `(` typeIR ctk_f `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:609.1-620.45
   rule dataExpression-recordElementExpression-single_default: p C `|-` expression `:` `RECORD{` [nameIR_f `=` typedExpressionIR_f] `,...}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%,...`
      -- let name_f `=` expression_f `,...` = recordElementExpression
      -- let nameIR_f = $name(name_f)
      -- Expr_ok: p C `|-` expression_f `:` typedExpressionIR_f
      -- let _expressionIR `#` `(` typeIR_f ctk_f `)` = typedExpressionIR_f
      -- let typeIR = `RECORD{` [typeIR_f nameIR_f `;`] `,...}` as typeIR
      -- let expressionNoteIR = `(` typeIR ctk_f `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:624.1-640.43
   rule dataExpression-recordElementExpression-multiple: p C `|-` expression `:` `RECORD{` nameIR_f `=` typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} `}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%,%`
      -- let name_f_h `=` expression_f_h `,` namedExpressionList_t = recordElementExpression
      -- let name_f_t `=` expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
      -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
      -- (Expr_ok: p C `|-` expression_f `:` typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- (let _expressionIR `#` `(` typeIR_f ctk_f `)` = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- let typeIR = `RECORD{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` as typeIR
      -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:644.1-660.43
   rule dataExpression-recordElementExpression-multiple-default: p C `|-` expression `:` `RECORD{` nameIR_f `=` typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} `,...}` as expressionIR `#` expressionNoteIR
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `{%%}`
      -- let `{` dataElementExpression _trailingCommaOpt `}` = dataExpression
      -- if dataElementExpression <: recordElementExpression
      -- let recordElementExpression = dataElementExpression as recordElementExpression
      -- if recordElementExpression matches `%=%,%,...`
      -- let name_f_h `=` expression_f_h `,` namedExpressionList_t `,...` = recordElementExpression
      -- let name_f_t `=` expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
      -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
      -- (Expr_ok: p C `|-` expression_f `:` typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- (let _expressionIR `#` `(` typeIR_f ctk_f `)` = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- let typeIR = `RECORD{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `,...}` as typeIR
      -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
      -- let expressionNoteIR = `(` typeIR ctk `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:668.1-675.43
   rule accessExpression-errorAccessExpression: p C `|-` expression `:` `ERROR.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: errorAccessExpression
      -- let `ERROR.` member = expression as errorAccessExpression
      -- let nameIR = $name(member)
      -- let nameIR_error = "error." ++ nameIR
      -- if (`ERROR.` nameIR as value = $find_value(p, C, ``` nameIR_error))
      -- let expressionNoteIR = `(` `ERROR` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:683.1-695.49
   rule accessExpression-memberAccessExpression-prefixedType-enum: p C `|-` expression `:` `TYPE` prefixedNameIR_base `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: prefixedTypeName
      -- let prefixedTypeName_base = memberAccessBase as prefixedTypeName
      -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR_base)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR_base = typeDefIR as typeIR
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` nameIR_f*{nameIR_f <- nameIR_f*} `}` = enumTypeIR
      -- let nameIR = $name(member)
      -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
      -- let expressionNoteIR = `(` typeIR_base `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:697.1-709.49
   rule accessExpression-memberAccessExpression-prefixedType-serenum: p C `|-` expression `:` `TYPE` prefixedNameIR_base `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: prefixedTypeName
      -- let prefixedTypeName_base = memberAccessBase as prefixedTypeName
      -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR_base)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR_base = typeDefIR as typeIR
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` _typeIR `{` nameIR_f `=` _value `;`*{_value <- _value*, nameIR_f <- nameIR_f*} `}` = enumTypeIR
      -- let nameIR = $name(member)
      -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
      -- let expressionNoteIR = `(` typeIR_base `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:713.1-725.51
   rule accessExpression-memberAccessExpression-expression-stack-size: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` "size" as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("size" = $name(member))
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(` `BIT<` 32 `>` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:727.1-739.50
   rule accessExpression-memberAccessExpression-expression-stack-lastIndex: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` "lastIndex" as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("lastIndex" = $name(member))
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(` `BIT<` 32 `>` as typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:741.1-753.43
   rule accessExpression-memberAccessExpression-expression-stack-last: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` "last" as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("last" = $name(member))
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:755.1-767.43
   rule accessExpression-memberAccessExpression-expression-stack-next: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` "next" as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- if ("next" = $name(member))
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:769.1-782.43
   rule accessExpression-memberAccessExpression-expression-struct: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as structTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:784.1-797.43
   rule accessExpression-memberAccessExpression-expression-header: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as headerTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:799.1-812.43
   rule accessExpression-memberAccessExpression-expression-headerunion: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as headerUnionTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:814.1-827.43
   rule accessExpression-memberAccessExpression-expression-tablestruct: p C `|-` expression `:` typedExpressionIR_base as memberAccessBaseIR `.` nameIR as expressionIR `#` expressionNoteIR
      -- if expression <: memberAccessExpression
      -- let memberAccessBase `.` member = expression as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression_base = memberAccessBase as expression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- let _expressionIR `#` `(` typeIR_base _ctk `)` = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR = typeIR' as tableTypeIR
      -- if tableTypeIR matches `TABLE_STRUCT%{%}`
      -- let `TABLE_STRUCT` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = tableTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:845.1-870.55
   rule indexAccessExpression-tuple: p C `|-` expression `:` typedExpressionIR_base `[` typedExpressionIR_index_reduced `]` as expressionIR `#` expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%]`
      -- let expression_base `[` expression_index `]` = indexAccessExpression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- Expr_ok: p C `|-` expression_index `:` typedExpressionIR_index
      -- let _expressionIR `#` `(` typeIR_base ctk_base `)` = typedExpressionIR_base
      -- let _expressionIR' `#` `(` typeIR_index ctk_index `)` = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` typeIR_e*{typeIR_e <- typeIR_e*} `>` = typeIR as tupleTypeIR
      -- if (ctk_index = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_index_reduced `~>` value_index
      -- let int = $to_number(value_index)
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < |typeIR_e*{typeIR_e <- typeIR_e*}|)
      -- let expressionNoteIR = `(` typeIR_e*{typeIR_e <- typeIR_e*}[n_index] `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:872.1-897.43
   rule indexAccessExpression-stack-lctk: p C `|-` expression `:` typedExpressionIR_base `[` typedExpressionIR_index_reduced `]` as expressionIR `#` expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%]`
      -- let expression_base `[` expression_index `]` = indexAccessExpression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- Expr_ok: p C `|-` expression_index `:` typedExpressionIR_index
      -- let _expressionIR `#` `(` typeIR_base ctk_base `)` = typedExpressionIR_base
      -- let _expressionIR' `#` `(` typeIR_index ctk_index `)` = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (ctk_index = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_index_reduced `~>` value_index
      -- let int = $to_number(value_index)
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < n_size)
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:899.1-921.43
   rule indexAccessExpression-stack-non-lctk: p C `|-` expression `:` typedExpressionIR_base `[` typedExpressionIR_index_reduced `]` as expressionIR `#` expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%]`
      -- let expression_base `[` expression_index `]` = indexAccessExpression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- Expr_ok: p C `|-` expression_index `:` typedExpressionIR_index
      -- let _expressionIR `#` `(` typeIR_base ctk_base `)` = typedExpressionIR_base
      -- let _expressionIR' `#` `(` typeIR_index ctk_index `)` = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR `[` n_size `]` = typeIR' as headerStackTypeIR
      -- if (ctk_index =/= `LCTK`)
      -- let expressionNoteIR = `(` typeIR `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:962.1-1009.56
   rule indexAccessExpression-bitslice: p C `|-` expression `:` typedExpressionIR_base `[` typedExpressionIR_hi_reduced `:` typedExpressionIR_lo_reduced `]` as expressionIR `#` expressionNoteIR
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `%[%:%]`
      -- let expression_base `[` expression_hi `:` expression_lo `]` = indexAccessExpression
      -- Expr_ok: p C `|-` expression_base `:` typedExpressionIR_base
      -- Expr_ok: p C `|-` expression_hi `:` typedExpressionIR_hi
      -- Expr_ok: p C `|-` expression_lo `:` typedExpressionIR_lo
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_base_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let _expressionIR `#` `(` typeIR_base_reduced ctk_base_reduced `)` = typedExpressionIR_base_reduced
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
      -- if typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} matches (_)
      -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?}
      -- let _expressionIR' `#` `(` typeIR_hi_reduced ctk_hi_reduced `)` = typedExpressionIR_hi_reduced
      -- let _expressionIR'' `#` `(` typeIR_lo_reduced ctk_lo_reduced `)` = typedExpressionIR_lo_reduced
      -- if (ctk_hi_reduced = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_hi_reduced `~>` value_hi
      -- let int = $to_number(value_hi)
      -- if int <: nat
      -- let n_hi = int as nat
      -- if (ctk_lo_reduced = `LCTK`)
      -- Eval_static: p C `|-` typedExpressionIR_lo_reduced `~>` value_lo
      -- let int' = $to_number(value_lo)
      -- if int' <: nat
      -- let n_lo = int' as nat
      -- if $is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)
      -- let typeIR = `BIT<` ((n_hi - n_lo) + 1) `>` as typeIR
      -- let expressionNoteIR = `(` typeIR ctk_base_reduced `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1021.1-1039.47
   rule callExpression-non-generic-functionTarget: p C `|-` expression `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget `(` argumentList `)` = callExpression
      -- if callTarget <: functionTarget
      -- let functionTarget = callTarget as functionTarget
      -- let prefixedNameIR = $prefixedNonTypeName(functionTarget)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- FunctionType_ok: p C `|-` prefixedNameIR `<` [] `>(` argument*{argument <- argument*} `):` functionTypeIR `<#` tid_fresh*{tid_fresh <- tid_fresh*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_ok: p C `|-` functionTypeIR as routineTypeIR `<` [] `#` tid_fresh*{tid_fresh <- tid_fresh*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if (typeIR_ret =/= `VOID` as typeIR)
      -- let callExpressionIR = prefixedNameIR as routineTargetIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let expressionNoteIR = `(` typeIR_ret `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1041.1-1064.47
   rule callExpression-generic-functionTarget: p C `|-` expression `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%<%>(%)`
      -- let routineTarget `<` realTypeArgumentList `>(` argumentList `)` = callExpression
      -- if routineTarget <: functionTarget
      -- let functionTarget = routineTarget as functionTarget
      -- let realTypeArgument*{realTypeArgument <- realTypeArgument*} = $flatten_realTypeArgumentList(realTypeArgumentList)
      -- TypeArguments_ok: p C `|-` realTypeArgument*{realTypeArgument <- realTypeArgument*} as typeArgument* `:` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_fresh_arg*{tid_fresh_arg <- tid_fresh_arg*}
      -- let prefixedNameIR = $prefixedNonTypeName(functionTarget)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- FunctionType_ok: p C `|-` prefixedNameIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` functionTypeIR `<#` tid_fresh_func*{tid_fresh_func <- tid_fresh_func*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = tid_fresh_arg*{tid_fresh_arg <- tid_fresh_arg*} ++ tid_fresh_func*{tid_fresh_func <- tid_fresh_func*}
      -- Call_ok: p C `|-` functionTypeIR as routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_fresh*{tid_fresh <- tid_fresh*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if (typeIR_ret =/= `VOID` as typeIR)
      -- let callExpressionIR = prefixedNameIR as routineTargetIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let expressionNoteIR = `(` typeIR_ret `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1073.1-1084.41
   rule callExpression-non-generic-methodTarget-prefixedTypeName-builtin: p C `|-` expression `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget `(` argumentList `)` = callExpression
      -- if callTarget <: memberAccessExpression
      -- let memberAccessBase `.` member = callTarget as memberAccessExpression
      -- if memberAccessBase <: prefixedTypeName
      -- let prefixedTypeName = memberAccessBase as prefixedTypeName
      -- if argumentList matches ``EMPTY`
      -- let nameIR = $name(member)
      -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, C, prefixedNameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: typeIR
      -- let typeIR = typeDefIR as typeIR
      -- let callExpressionIR = `TYPE` prefixedNameIR `.` nameIR as routineTargetIR `<` [] `>(` [] `)`
      -- let expressionNoteIR = `(` `INT` as typeIR `LCTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1088.1-1109.47
   rule callExpression-non-generic-methodTarget-expression: p C `|-` expression' `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression' <: callExpression
      -- let callExpression = expression' as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget `(` argumentList `)` = callExpression
      -- if callTarget <: memberAccessExpression
      -- let memberAccessBase `.` member = callTarget as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression = memberAccessBase as expression
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let nameIR = $name(member)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- MethodType_ok: p C `|-` typedExpressionIR `.` nameIR `<` [] `>(` argument*{argument <- argument*} `):` methodTypeIR `<#` tid_fresh*{tid_fresh <- tid_fresh*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_ok: p C `|-` methodTypeIR as routineTypeIR `<` [] `#` tid_fresh*{tid_fresh <- tid_fresh*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if (typeIR_ret =/= `VOID` as typeIR)
      -- let callExpressionIR = typedExpressionIR as memberAccessBaseIR `.` nameIR as routineTargetIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let expressionNoteIR = `(` typeIR_ret `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1111.1-1136.47
   rule callExpression-generic-methodTarget-expression: p C `|-` expression' `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression' <: callExpression
      -- let callExpression = expression' as callExpression
      -- if callExpression matches `%<%>(%)`
      -- let routineTarget `<` realTypeArgumentList `>(` argumentList `)` = callExpression
      -- if routineTarget <: memberAccessExpression
      -- let memberAccessBase `.` member = routineTarget as memberAccessExpression
      -- if memberAccessBase <: expression
      -- let expression = memberAccessBase as expression
      -- let realTypeArgument*{realTypeArgument <- realTypeArgument*} = $flatten_realTypeArgumentList(realTypeArgumentList)
      -- TypeArguments_ok: p C `|-` realTypeArgument*{realTypeArgument <- realTypeArgument*} as typeArgument* `:` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_fresh_arg*{tid_fresh_arg <- tid_fresh_arg*}
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let nameIR = $name(member)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- MethodType_ok: p C `|-` typedExpressionIR `.` nameIR `<` [] `>(` argument*{argument <- argument*} `):` methodTypeIR `<#` tid_fresh_method*{tid_fresh_method <- tid_fresh_method*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = tid_fresh_arg*{tid_fresh_arg <- tid_fresh_arg*} ++ tid_fresh_method*{tid_fresh_method <- tid_fresh_method*}
      -- Call_ok: p C `|-` methodTypeIR as routineTypeIR `<` [] `#` tid_fresh*{tid_fresh <- tid_fresh*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if (typeIR_ret =/= `VOID` as typeIR)
      -- let callExpressionIR = typedExpressionIR as memberAccessBaseIR `.` nameIR as routineTargetIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let expressionNoteIR = `(` typeIR_ret `DYN` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1170.1-1188.50
   rule callExpression-constructorTarget-prefixedTypeName: p C `|-` expression `:` callExpressionIR as expressionIR `#` expressionNoteIR
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget `(` argumentList `)` = callExpression
      -- if callTarget <: prefixedTypeName
      -- let prefixedTypeName = callTarget as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- ConstructorType_ok: p C `|-` prefixedNameIR `<` [] `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Inst_ok: p C `|-` constructorTypeIR `<` [] `#` tid_impl*{tid_impl <- tid_impl*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if $is_concrete_extern_object(typeIR_object)
      -- let callExpressionIR = typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>` `(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let expressionNoteIR = `(` typeIR_object `CTK` `)`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1195.1-1198.50
   rule parenthesizedExpression: p C `|-` expression' `:` `(` typedExpressionIR `)` as expressionIR `#` expressionNoteIR
      -- if expression' <: parenthesizedExpression
      -- let `(` expression `)` = expression' as parenthesizedExpression
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` expressionNoteIR = typedExpressionIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:50.1-52.23
relation Argument_ok: cursor context `|-` argument `:` argumentIR

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:9.1-11.52
   rule expression: p C `|-` argument `:` typedExpressionIR as argumentIR
      -- if argument <: expression
      -- let expression = argument as expression
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:15.1-18.52
   rule name-expression: p C `|-` argument `:` nameIR `=` typedExpressionIR
      -- if argument matches `%=%`
      -- let name `=` expression = argument
      -- let nameIR = $name(name)
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:22.1-24.29
   rule name-dontcare: p C `|-` argument `:` nameIR `=_`
      -- if argument matches `%=_`
      -- let name `=_` = argument
      -- let nameIR = $name(name)

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:28.1-29.17
   rule dontcare: p C `|-` argument `:` `_`
      -- if argument matches `_`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:58.20-58.36
syntax lvaluectx = 
   | `ASSIGN`
   | `ROUTINE`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:60.1-62.26
relation Lvalue_ok: cursor context lvaluectx `|-` lvalue `:` typedLvalueIR

   ;; ../../../../spec-concrete/5.08.1-typing-lvalue.watsup:12.1-16.45
   rule referenceExpression-prefixedNonTypeName-assign: p C lvaluectx `|-` lvalue `:` prefixedNameIR as lvalueIR `#(` typeIR `)`
      -- if lvaluectx matches `ASSIGN`
      -- if lvalue <: prefixedNonTypeName
      -- let prefixedNonTypeName = lvalue as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, C, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(direction typeIR ctk value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if ctk matches `DYN`
      -- if value?{value <- value?} matches ()
      -- if ((direction = `OUT`) \/ (direction = `INOUT`))

   ;; ../../../../spec-concrete/5.08.1-typing-lvalue.watsup:18.1-21.65
   rule referenceExpression-prefixedNonTypeName-method: p C lvaluectx `|-` lvalue `:` prefixedNameIR as lvalueIR `#(` typeIR `)`
      -- if lvaluectx matches `ROUTINE`
      -- if lvalue <: prefixedNonTypeName
      -- let prefixedNonTypeName = lvalue as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, C, prefixedNameIR)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(direction typeIR _ctk value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value?{value <- value?} matches ()

   ;; ../../../../spec-concrete/5.08.1-typing-lvalue.watsup:28.1-41.54
   rule lvalue-member-struct: p C lvaluectx `|-` lvalue `:` typedLvalueIR
      -- if lvaluectx matches `ASSIGN`
      -- if lvalue matches `%.%`
      -- let lvalue_base `.` member = lvalue
      -- Lvalue_ok: p C `ASSIGN` `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as structTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = typedLvalueIR_base `.` nameIR `#(` typeIR `)`

   ;; ../../../../spec-concrete/5.08.1-typing-lvalue.watsup:43.1-56.54
   rule lvalue-member-header: p C lvaluectx `|-` lvalue `:` typedLvalueIR
      -- if lvaluectx matches `ASSIGN`
      -- if lvalue matches `%.%`
      -- let lvalue_base `.` member = lvalue
      -- Lvalue_ok: p C `ASSIGN` `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as headerTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = typedLvalueIR_base `.` nameIR `#(` typeIR `)`

   ;; ../../../../spec-concrete/5.08.1-typing-lvalue.watsup:58.1-71.54
   rule lvalue-member-union: p C lvaluectx `|-` lvalue `:` typedLvalueIR
      -- if lvaluectx matches `ASSIGN`
      -- if lvalue matches `%.%`
      -- let lvalue_base `.` member = lvalue
      -- Lvalue_ok: p C `ASSIGN` `|-` lvalue_base `:` typedLvalueIR_base
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` _tid `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` = typeIR' as headerUnionTypeIR
      -- let nameIR = $name(member)
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = typedLvalueIR_base `.` nameIR `#(` typeIR `)`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:64.1-66.23
relation Lvalue_routine_ok: cursor context `|-` lvalue `:` routineLvalueIR

   ;; ../../../../spec-concrete/5.08.2-typing-lvalue-routine.watsup:12.1-14.67
   rule prefixedNonTypeName: p C `|-` lvalue `:` prefixedNameIR as routineLvalueIR
      -- if lvalue <: prefixedNonTypeName
      -- let prefixedNonTypeName = lvalue as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)

   ;; ../../../../spec-concrete/5.08.2-typing-lvalue-routine.watsup:20.1-23.31
   rule lvalue-member: p C `|-` lvalue `:` typedLvalueIR_base `.` nameIR
      -- if lvalue matches `%.%`
      -- let lvalue_base `.` member = lvalue
      -- Lvalue_ok: p C `ROUTINE` `|-` lvalue_base `:` typedLvalueIR_base
      -- let nameIR = $name(member)

   ;; ../../../../spec-concrete/5.08.2-typing-lvalue-routine.watsup:27.1-29.56
   rule parenthesized: p C `|-` lvalue' `:` `(` routineLvalueIR `)`
      -- if lvalue' matches `(%)`
      -- let `(` lvalue `)` = lvalue'
      -- Lvalue_routine_ok: p C `|-` lvalue `:` routineLvalueIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:72.1-74.26
relation Stmt_ok: cursor context flow `|-` statement `:` context flow statementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:10.1-11.23
   rule emptyStatement: p C f `|-` statement `:` C f `;` as statementIR
      -- if (statement = `;` as statement)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:19.1-31.76
   rule assignmentStatement-eq: p C f `|-` statement `:` C f typedLvalueIR `=` typedExpressionIR `;` as statementIR
      -- if statement <: assignmentStatement
      -- let lvalue assignop expression `;` = statement as assignmentStatement
      -- if assignop matches `=`
      -- Lvalue_ok: p C `ASSIGN` `|-` lvalue `:` typedLvalueIR
      -- Expr_ok: p C `|-` expression `:` typedExpressionIR
      -- let _lvalueIR `#(` typeIR_l `)` = typedLvalueIR
      -- let _expressionIR `#` `(` typeIR_r _ctk `)` = typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_l)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:41.1-58.79
   rule callStatement-no-typeArgumentList: p C f `|-` statement `:` C f callStatementIR as statementIR
      -- if statement <: callStatement
      -- let callStatement = statement as callStatement
      -- if callStatement matches `%(%);`
      -- let lvalue_routine `(` argumentList `);` = callStatement
      -- Lvalue_routine_ok: p C `|-` lvalue_routine `:` routineLvalueIR
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- RoutineType_Lvalue_ok: p C `|-` routineLvalueIR `<` [] `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_ok: p C `|-` routineTypeIR `<` [] `#` tid_impl*{tid_impl <- tid_impl*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let callStatementIR = routineLvalueIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `);`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:62.1-83.79
   rule callStatement-typeArgumentList: p C f `|-` statement `:` C f callStatementIR as statementIR
      -- if statement <: callStatement
      -- let callStatement = statement as callStatement
      -- if callStatement matches `%<%>(%);`
      -- let lvalue_routine `<` typeArgumentList `>(` argumentList `);` = callStatement
      -- Lvalue_routine_ok: p C `|-` lvalue_routine `:` routineLvalueIR
      -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
      -- TypeArguments_ok: p C `|-` typeArgument*{typeArgument <- typeArgument*} `:` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- RoutineType_Lvalue_ok: p C `|-` routineLvalueIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_inserted*{tid_inserted <- tid_inserted*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Call_ok: p C `|-` routineTypeIR `<` [] `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let callStatementIR = routineLvalueIR `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `);`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:98.1-118.56
   rule directApplicationStatement-prefixedTypeName: p C_0 f `|-` statement `:` C_0 f directApplicationStatementIR as statementIR
      -- if statement <: directApplicationStatement
      -- let namedType `.APPLY(` argumentList `);` = statement as directApplicationStatement
      -- Expr_ok: p C_0 `|-` namedType as callTarget `(` ``EMPTY` `)` as expression `:` expressionIR `#` `(` _typeIR _ctk `)`
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `%(%)`
      -- let typeIR_object `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>` `(` argumentIR*{argumentIR <- argumentIR*} `)` = callExpressionIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if $compat_direct_application(typeIR_object)
      -- let nameIR_object = "__direct_application"
      -- let C_1 = $add_var(p, C_0, nameIR_object, ``EMPTY` typeIR_object `CTK` ?())
      -- let lvalue = ``ID` nameIR_object as lvalue `.` ``ID` "apply" as member
      -- Stmt_ok: p C_1 f `|-` lvalue `(` argumentList `);` as statement `:` _context _flow statementIR
      -- if statementIR <: callStatementIR
      -- let callStatementIR = statementIR as callStatementIR
      -- let routineLvalueIR `<` typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `);` = callStatementIR
      -- if (routineLvalueIR = ``` nameIR_object as lvalueIR `#(` typeIR_object `)` `.` "apply")
      -- if typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} matches []
      -- let directApplicationStatementIR = typeIR_object `.APPLY(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `);`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:125.1-129.35
   rule returnStatement-empty: cursor C f `|-` statement `:` C `RET` `RETURN;` as statementIR
      -- if cursor matches `LOCAL`
      -- if (statement = `RETURN;` as statement)
      -- if (?(`VOID` as typeIR) = $get_return_type(C))

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:133.1-144.78
   rule returnStatement-expression: cursor C f `|-` statement `:` C `RET` `RETURN` typedExpressionIR_cast `;` as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: returnStatement
      -- let returnStatement = statement as returnStatement
      -- if returnStatement matches `RETURN%;`
      -- let `RETURN` expression `;` = returnStatement
      -- Expr_ok: `LOCAL` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- let typeIR'?{typeIR' <- typeIR'?} = $get_return_type(C)
      -- if typeIR'?{typeIR' <- typeIR'?} matches (_)
      -- let ?(typeIR_ret) = typeIR'?{typeIR' <- typeIR'?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_ret)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:149.1-150.35
   rule exitStatement: p C f `|-` statement `:` C f `EXIT;` as statementIR
      -- if (statement = `EXIT;` as statement)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:154.1-157.51
   rule blockStatement: cursor C_0 f_0 `|-` statement `:` C_1 f_1 blockStatementIR as statementIR
      -- if cursor matches `LOCAL`
      -- if statement <: blockStatement
      -- let blockStatement = statement as blockStatement
      -- Block_ok: C_0 f_0 `|-` blockStatement `:` C_1 f_1 blockStatementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:164.1-173.71
   rule conditionalStatement-non-else: p C f `|-` statement `:` C f `IF(` typedExpressionIR_cond `)` statementIR_then as statementIR
      -- if statement <: conditionalStatement
      -- let conditionalStatement = statement as conditionalStatement
      -- if conditionalStatement matches `IF(%)%`
      -- let `IF(` expression_cond `)` statement_then = conditionalStatement
      -- Expr_ok: p C `|-` expression_cond `:` typedExpressionIR_cond
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR_cond
      -- if (typeIR = `BOOL` as typeIR)
      -- Stmt_ok: p C f `|-` statement_then `:` C_then f_then statementIR_then

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:177.1-189.44
   rule conditionalStatement-else: p C f `|-` statement `:` C f_post `IF(` typedExpressionIR_cond `)` statementIR_then `ELSE` statementIR_else as statementIR
      -- if statement <: conditionalStatement
      -- let conditionalStatement = statement as conditionalStatement
      -- if conditionalStatement matches `IF(%)%ELSE%`
      -- let `IF(` expression_cond `)` statement_then `ELSE` statement_else = conditionalStatement
      -- Expr_ok: p C `|-` expression_cond `:` typedExpressionIR_cond
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR_cond
      -- if (typeIR = `BOOL` as typeIR)
      -- Stmt_ok: p C f `|-` statement_then `:` C_then f_then statementIR_then
      -- Stmt_ok: p C f `|-` statement_else `:` C_else f_else statementIR_else
      -- let f_post = $join_flow(f_then, f_else)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:76.1-78.26
relation Stmts_ok: cursor context flow `|-` statement* `:` context flow statementIR*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:80.1-83.23
relation BlockElementStmt_ok: context flow `|-` blockElementStatement `:` context flow blockElementStatementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:205.1-207.75
   rule constantDeclaration: C_0 f `|-` blockElementStatement `:` C_1 f constantDeclarationIR as blockElementStatementIR
      -- if blockElementStatement <: constantDeclaration
      -- let constantDeclaration = blockElementStatement as constantDeclaration
      -- Decl_ok: `LOCAL` C_0 `|-` constantDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:213.1-224.44
   rule variableDeclaration-empty: C_0 f `|-` blockElementStatement `:` C_1 f variableDeclarationIR as blockElementStatementIR
      -- if blockElementStatement <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = blockElementStatement as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: `LOCAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`LOCAL`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`LOCAL`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() `;`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:226.1-243.73
   rule variableDeclaration-initializer: C_0 f `|-` blockElementStatement `:` C_1 f variableDeclarationIR as blockElementStatementIR
      -- if blockElementStatement <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = blockElementStatement as variableDeclaration
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: `LOCAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`LOCAL`, C_0) `|-` typeIR holds
      -- Expr_ok: `LOCAL` C_0 `|-` expression_init `:` typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`LOCAL`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(`=` typedExpressionIR_init_cast) `;`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:247.1-249.64
   rule statement: C_0 f `|-` blockElementStatement `:` C_1 f_post statementIR as blockElementStatementIR
      -- if blockElementStatement <: statement
      -- let statement = blockElementStatement as statement
      -- Stmt_ok: `LOCAL` C_0 f `|-` statement `:` C_1 f_post statementIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:85.1-88.23
relation BlockElementStmts_ok: context flow `|-` blockElementStatement* `:` context flow blockElementStatementIR*

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:255.1-256.23
   rule nil: C f `|-` blockElementStatement*{blockElementStatement <- blockElementStatement*} `:` C f []
      -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches []

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:258.1-264.73
   rule cons: C_0 f_0 `|-` blockElementStatement*{blockElementStatement <- blockElementStatement*} `:` C_2 f_2 blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}
      -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches _ :: _
      -- let blockElementStatement_h :: blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} = blockElementStatement*{blockElementStatement <- blockElementStatement*}
      -- BlockElementStmt_ok: C_0 f_0 `|-` blockElementStatement_h `:` C_1 f_1 blockElementStatementIR_h
      -- BlockElementStmts_ok: C_1 f_1 `|-` blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} `:` C_2 f_2 blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:90.1-93.23
relation Block_ok: context flow `|-` blockStatement `:` context flow blockStatementIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:272.1-283.72
   rule : C_0 f `|-` annotationList `{` blockElementStatementList `}` `:` C_3 f_post blockStatementIR
      -- let blockElementStatement*{blockElementStatement <- blockElementStatement*} = $flatten_blockElementStatementList(blockElementStatementList)
      -- let C_1 = $enter(C_0)
      -- BlockElementStmts_ok: C_1 f `|-` blockElementStatement*{blockElementStatement <- blockElementStatement*} `:` C_2 f_post blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
      -- let C_3 = $exit(C_2)
      -- let blockStatementIR = annotationList `{` blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} `}`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:100.1-102.23
relation Parameter_ok: cursor context `|-` parameter `:` parameterIR `#` tid*

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:12.1-19.29
   rule empty: p C `|-` annotationList direction type name initializerOpt `:` annotationList direction typeIR nameIR ?() `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: p C `|-` type as typeOrVoid `:` typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- let bound = $union_set<tid>($bound(p, C), `{` tid_fresh*{tid_fresh <- tid_fresh*} `}`)
      -- if Type_wf: bound `|-` typeIR holds
      -- let nameIR = $name(name)

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:23.1-41.67
   rule empty: p C `|-` annotationList direction type name initializerOpt `:` annotationList direction typeIR nameIR ?(`=` value_init) `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: p C `|-` type as typeOrVoid `:` typeIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- let bound = $union_set<tid>($bound(p, C), `{` tid_fresh*{tid_fresh <- tid_fresh*} `}`)
      -- if Type_wf: bound `|-` typeIR holds
      -- Expr_ok: p C `|-` expression_init `:` typedExpressionIR_init
      -- let _expressionIR `#` `(` typeIR_init ctk `)` = typedExpressionIR_init
      -- if ctk matches `LCTK`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- Eval_static: p C `|-` typedExpressionIR_init_cast `~>` value_init

;; ../../../../spec-concrete/5.04-typing-relation.watsup:104.1-106.23
relation Parameters_ok: cursor context `|-` parameter* `:` parameterListIR `#` tid*

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:49.1-50.26
   rule nil: p C `|-` parameter*{parameter <- parameter*} `:` [] `#` []
      -- if parameter*{parameter <- parameter*} matches []

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:52.1-56.73
   rule cons: p C `|-` parameter*{parameter <- parameter*} `:` parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} `#` tid_fresh_h*{tid_fresh_h <- tid_fresh_h*} ++ tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}
      -- if parameter*{parameter <- parameter*} matches _ :: _
      -- let parameter_h :: parameter_t*{parameter_t <- parameter_t*} = parameter*{parameter <- parameter*}
      -- Parameter_ok: p C `|-` parameter_h `:` parameterIR_h `#` tid_fresh_h*{tid_fresh_h <- tid_fresh_h*}
      -- Parameters_ok: p C `|-` parameter_t*{parameter_t <- parameter_t*} `:` parameterIR_t*{parameterIR_t <- parameterIR_t*} `#` tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:108.1-108.48
def $parameterIR(parameterIR) : parameterTypeIR =

   ;; ../../../../spec-concrete/5.04-typing-relation.watsup:109.1-110.32
   clause 0(_annotationList direction typeIR nameIR constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}) = direction typeIR nameIR ?()
      -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

   ;; ../../../../spec-concrete/5.04-typing-relation.watsup:111.1-112.34
   clause 1(_annotationList direction typeIR nameIR constantInitializerOptIR) = direction typeIR nameIR ?(value)
      -- if constantInitializerOptIR matches (_)
      -- let ?(`=` value) = constantInitializerOptIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:114.1-117.23
relation ConstructorParameter_ok: cursor context `|-` constructorParameter `:` constructorParameterIR `#` tid*

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:64.1-67.63
   rule : p C `|-` constructorParameter `:` constructorParameterIR `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- Parameter_ok: p C `|-` constructorParameter `:` constructorParameterIR `#` tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:119.1-122.23
relation ConstructorParameters_ok: cursor context `|-` constructorParameter* `:` constructorParameterListIR `#` tid*

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:75.1-78.65
   rule : p C `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid_fresh*{tid_fresh <- tid_fresh*}
      -- Parameters_ok: p C `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:124.1-124.81
def $constructorParameterIR(constructorParameterIR) : constructorParameterTypeIR =

   ;; ../../../../spec-concrete/5.04-typing-relation.watsup:125.1-126.41
   clause 0(constructorParameterIR) = $parameterIR(constructorParameterIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:132.1-134.23
relation ExternMethod_ok: context tid `|-` methodPrototype `:` context methodPrototypeIR

   ;; ../../../../spec-concrete/5.12.1-typing-extern-method.watsup:9.1-37.79
   rule non-abstract: C_0 tid_extern `|-` methodPrototype `:` C_3 methodPrototypeIR
      -- if methodPrototype matches `%%;`
      -- let annotationList typeOrVoid name typeParameterListOpt `(` parameterList `)` `;` = methodPrototype
      -- let nameIR = $name(name)
      -- if (nameIR =/= tid_extern)
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`LOCAL`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `LOCAL` C_1 `|-` typeOrVoid `:` typeIR_ret `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `LOCAL` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`LOCAL`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameterList)
      -- let methodTypeIR = `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(`BLOCK`, C_0) `|-` routineTypeDefIR holds
      -- let C_3 = $add_routine_overload(`BLOCK`, C_0, rid, routineTypeDefIR)
      -- let methodPrototypeIR = annotationList typeIR_ret nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `)` `;`

   ;; ../../../../spec-concrete/5.12.1-typing-extern-method.watsup:41.1-69.79
   rule abstract: C_0 tid_extern `|-` methodPrototype `:` C_3 methodPrototypeIR
      -- if methodPrototype matches `%ABSTRACT%;`
      -- let annotationList `ABSTRACT` typeOrVoid name typeParameterListOpt `(` parameterList `)` `;` = methodPrototype
      -- let nameIR = $name(name)
      -- if (nameIR =/= tid_extern)
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`LOCAL`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `LOCAL` C_1 `|-` typeOrVoid `:` typeIR_ret `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `LOCAL` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`LOCAL`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameterList)
      -- let methodTypeIR = `EXTERN_METHODABSTRACT(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret
      -- let routineTypeDefIR = methodTypeIR as routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(`BLOCK`, C_0) `|-` routineTypeDefIR holds
      -- let C_3 = $add_routine_overload(`BLOCK`, C_0, rid, routineTypeDefIR)
      -- let methodPrototypeIR = annotationList `ABSTRACT` typeIR_ret nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `)` `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:136.1-138.23
relation ExternMethods_ok: context tid `|-` methodPrototype* `:` context methodPrototypeIR*

   ;; ../../../../spec-concrete/5.12.1-typing-extern-method.watsup:77.1-78.30
   rule nil: C tid_extern `|-` methodPrototype*{methodPrototype <- methodPrototype*} `:` C []
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../spec-concrete/5.12.1-typing-extern-method.watsup:80.1-86.66
   rule cons: C_0 tid_extern `|-` methodPrototype*{methodPrototype <- methodPrototype*} `:` C_2 methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- ExternMethod_ok: C_0 tid_extern `|-` methodPrototype_h `:` C_1 methodPrototypeIR_h
      -- ExternMethods_ok: C_1 tid_extern `|-` methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} `:` C_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:140.1-142.23
relation ExternConstructor_ok: context tid `|-` methodPrototype `:` context methodPrototypeIR

   ;; ../../../../spec-concrete/5.12.1-typing-extern-method.watsup:96.1-122.80
   rule : C_0 tid_extern `|-` methodPrototype `:` C_1 methodPrototypeIR
      -- if methodPrototype matches `%%(%);`
      -- let annotationList typeIdentifier `(` parameterList `);` = methodPrototype
      -- let nameIR = $name(typeIdentifier as name)
      -- if (nameIR = tid_extern)
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
      -- ConstructorParameters_ok: `BLOCK` C_0 `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(`GLOBAL`, C_0, ``` nameIR)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let typeIR_extern `<` tid_expl*{tid_expl <- tid_expl*} `,` tid*{tid <- tid*} `>` = typeDefIR as polyTypeDefIR
      -- if tid*{tid <- tid*} matches []
      -- let cid = $cid(typeIdentifier as name, `(` parameterList `)`)
      -- let typeIR_extern_constructed = typeIR_extern `<` tid_expl*{tid_expl <- tid_expl*} `,` [] `>` `<` `TID` tid_expl as typeIR*{tid_expl <- tid_expl*} `>` as typeIR
      -- let constructorTypeIR = `CONSTRUCTOR(` constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} `)->` typeIR_extern_constructed
      -- let constructorTypeDefIR = constructorTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>`
      -- if ConstructorTypeDef_wf: $bound(`BLOCK`, C_0) `|-` constructorTypeDefIR holds
      -- let C_1 = $add_constructor(C_0, cid, constructorTypeDefIR)
      -- let methodPrototypeIR = annotationList nameIR `<,` tid_impl*{tid_impl <- tid_impl*} `>(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `);`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:144.1-146.23
relation ExternConstructors_ok: context tid `|-` methodPrototype* `:` context methodPrototypeIR*

   ;; ../../../../spec-concrete/5.12.1-typing-extern-method.watsup:130.1-131.30
   rule nil: C tid_extern `|-` methodPrototype*{methodPrototype <- methodPrototype*} `:` C []
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../spec-concrete/5.12.1-typing-extern-method.watsup:133.1-139.71
   rule cons: C_0 tid_extern `|-` methodPrototype*{methodPrototype <- methodPrototype*} `:` C_2 methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- ExternConstructor_ok: C_0 tid_extern `|-` methodPrototype_h `:` C_1 methodPrototypeIR_h
      -- ExternConstructors_ok: C_1 tid_extern `|-` methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} `:` C_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:152.1-154.23
relation ParserTransition_ok: context nameIR* `|-` transitionStatement `:` transitionStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:11.1-18.55
   rule name: C_0 nameIR_state*{nameIR_state <- nameIR_state*} `|-` `TRANSITION` stateExpression `:` transitionStatementIR
      -- if stateExpression matches `%;`
      -- let name `;` = stateExpression
      -- let nameIR = $name(name)
      -- if nameIR <- nameIR_state*{nameIR_state <- nameIR_state*}
      -- let transitionStatementIR = `TRANSITION` nameIR `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:156.1-158.20
relation ParserStmt_ok: context `|-` parserStatement `:` context parserStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:30.1-34.53
   rule constantDeclaration: C_0 `|-` parserStatement `:` C_1 constantDeclarationIR as parserStatementIR
      -- if parserStatement <: constantDeclaration
      -- let constantDeclaration = parserStatement as constantDeclaration
      -- Decl_ok: `LOCAL` C_0 `|-` constantDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:40.1-51.44
   rule variableDeclaration-empty: C_0 `|-` parserStatement `:` C_1 variableDeclarationIR as parserStatementIR
      -- if parserStatement <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = parserStatement as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: `LOCAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`LOCAL`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`LOCAL`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() `;`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:53.1-70.73
   rule variableDeclaration-initializer: C_0 `|-` parserStatement `:` C_1 variableDeclarationIR as parserStatementIR
      -- if parserStatement <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = parserStatement as variableDeclaration
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: `LOCAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`LOCAL`, C_0) `|-` typeIR holds
      -- Expr_ok: `LOCAL` C_0 `|-` expression_init `:` typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`LOCAL`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(`=` typedExpressionIR_init_cast) `;`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:74.1-78.54
   rule emptyStatement: C `|-` parserStatement `:` C emptyStatementIR as parserStatementIR
      -- if parserStatement <: emptyStatement
      -- let emptyStatement = parserStatement as emptyStatement
      -- Stmt_ok: `LOCAL` C `CONT` `|-` emptyStatement as statement `:` context flow statementIR
      -- if (context = C)
      -- if flow matches `CONT`
      -- if statementIR <: emptyStatementIR
      -- let emptyStatementIR = statementIR as emptyStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:82.1-86.63
   rule assignmentStatement: C_0 `|-` parserStatement `:` C_1 assignmentStatementIR as parserStatementIR
      -- if parserStatement <: assignmentStatement
      -- let assignmentStatement = parserStatement as assignmentStatement
      -- Stmt_ok: `LOCAL` C_0 `CONT` `|-` assignmentStatement as statement `:` C_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: assignmentStatementIR
      -- let assignmentStatementIR = statementIR as assignmentStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:90.1-94.57
   rule callStatement: C_0 `|-` parserStatement `:` C_1 callStatementIR as parserStatementIR
      -- if parserStatement <: callStatement
      -- let callStatement = parserStatement as callStatement
      -- Stmt_ok: `LOCAL` C_0 `CONT` `|-` callStatement as statement `:` C_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: callStatementIR
      -- let callStatementIR = statementIR as callStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:98.1-102.70
   rule directApplicationStatement: C_0 `|-` parserStatement `:` C_1 directApplicationStatementIR as parserStatementIR
      -- if parserStatement <: directApplicationStatement
      -- let directApplicationStatement = parserStatement as directApplicationStatement
      -- Stmt_ok: `LOCAL` C_0 `CONT` `|-` directApplicationStatement as statement `:` C_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: directApplicationStatementIR
      -- let directApplicationStatementIR = statementIR as directApplicationStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:107.1-117.72
   rule parserBlockStatement: C_0 `|-` parserStatement' `:` C_1 parserBlockStatementIR as parserStatementIR
      -- if parserStatement' <: parserBlockStatement
      -- let annotationList `{` parserStatementList `}` = parserStatement' as parserBlockStatement
      -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
      -- let C_1 = $enter(C_0)
      -- ParserStmts_ok: C_1 `|-` parserStatement*{parserStatement <- parserStatement*} `:` C_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
      -- let C_3 = $exit(C_2)
      -- let parserBlockStatementIR = annotationList `{` parserStatementIR*{parserStatementIR <- parserStatementIR*} `}`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:121.1-125.64
   rule conditionalStatement: C_0 `|-` parserStatement `:` C_1 conditionalStatementIR as parserStatementIR
      -- if parserStatement <: conditionalStatement
      -- let conditionalStatement = parserStatement as conditionalStatement
      -- Stmt_ok: `LOCAL` C_0 `CONT` `|-` conditionalStatement as statement `:` C_1 flow statementIR
      -- if flow matches `CONT`
      -- if statementIR <: conditionalStatementIR
      -- let conditionalStatementIR = statementIR as conditionalStatementIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:160.1-162.20
relation ParserStmts_ok: context `|-` parserStatement* `:` context parserStatementIR*

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:133.1-134.19
   rule nil: C `|-` parserStatement*{parserStatement <- parserStatement*} `:` C []
      -- if parserStatement*{parserStatement <- parserStatement*} matches []

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:136.1-142.53
   rule cons: C_0 `|-` parserStatement*{parserStatement <- parserStatement*} `:` C_2 parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}
      -- if parserStatement*{parserStatement <- parserStatement*} matches _ :: _
      -- let parserStatement_h :: parserStatement_t*{parserStatement_t <- parserStatement_t*} = parserStatement*{parserStatement <- parserStatement*}
      -- ParserStmt_ok: C_0 `|-` parserStatement_h `:` C_1 parserStatementIR_h
      -- ParserStmts_ok: C_1 `|-` parserStatement_t*{parserStatement_t <- parserStatement_t*} `:` C_2 parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:164.1-166.23
relation ParserState_ok: context nameIR* `|-` parserState `:` parserStateIR

   ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:8.1-26.82
   rule : C_0 nameIR_state*{nameIR_state <- nameIR_state*} `|-` annotationList `STATE` name `{` parserStatementList transitionStatement `}` `:` parserStateIR
      -- let nameIR = $name(name)
      -- let C_1 = $enter(C_0)
      -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
      -- ParserStmts_ok: C_1 `|-` parserStatement*{parserStatement <- parserStatement*} `:` C_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
      -- ParserTransition_ok: C_2 nameIR_state*{nameIR_state <- nameIR_state*} `|-` transitionStatement `:` transitionStatementIR
      -- let C_3 = $exit(C_2)
      -- let parserStateIR = annotationList `STATE` nameIR `{` parserStatementIR*{parserStatementIR <- parserStatementIR*} transitionStatementIR `}`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:168.1-170.20
relation ParserStates_ok: context `|-` parserState* `:` parserStateIR*

   ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:34.1-46.76
   rule : C `|-` parserState*{parserState <- parserState*} `:` parserStateIR*{parserStateIR <- parserStateIR*}
      -- (let _annotationList `STATE` name_state `{` _parserStatementList _transitionStatement `}` = parserState)*{_annotationList <- _annotationList*, _parserStatementList <- _parserStatementList*, _transitionStatement <- _transitionStatement*, name_state <- name_state*, parserState <- parserState*}
      -- (let nameIR_state = $name(name_state))*{nameIR_state <- nameIR_state*, name_state <- name_state*}
      -- if $distinct_<nameIR>(nameIR_state*{nameIR_state <- nameIR_state*})
      -- if "start" <- nameIR_state*{nameIR_state <- nameIR_state*}
      -- if (~"accept" <- nameIR_state*{nameIR_state <- nameIR_state*} /\ ~"reject" <- nameIR_state*{nameIR_state <- nameIR_state*})
      -- let nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} = "accept" :: "reject" :: nameIR_state*{nameIR_state <- nameIR_state*}
      -- (ParserState_ok: C nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} `|-` parserState `:` parserStateIR)*{parserState <- parserState*, parserStateIR <- parserStateIR*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:172.1-175.20
relation ParserLocalDecl_ok: context `|-` parserLocalDeclaration `:` context parserLocalDeclarationIR

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:9.1-13.53
   rule constantDeclaration: C_0 `|-` parserLocalDeclaration `:` C_1 constantDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: constantDeclaration
      -- let constantDeclaration = parserLocalDeclaration as constantDeclaration
      -- Decl_ok: `BLOCK` C_0 `|-` constantDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:17.1-21.47
   rule instantiation: C_0 `|-` parserLocalDeclaration `:` C_1 instantiationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: instantiation
      -- let instantiation = parserLocalDeclaration as instantiation
      -- Decl_ok: `BLOCK` C_0 `|-` instantiation as declaration `:` C_1 declarationIR
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:27.1-38.44
   rule variableDeclaration-empty: C_0 `|-` parserLocalDeclaration `:` C_1 variableDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = parserLocalDeclaration as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: `BLOCK` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`BLOCK`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() `;`

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:40.1-57.73
   rule variableDeclaration-initializer: C_0 `|-` parserLocalDeclaration `:` C_1 variableDeclarationIR as parserLocalDeclarationIR
      -- if parserLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = parserLocalDeclaration as variableDeclaration
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: `BLOCK` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`BLOCK`, C_0) `|-` typeIR holds
      -- Expr_ok: `BLOCK` C_0 `|-` expression_init `:` typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(`=` typedExpressionIR_init_cast) `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:177.1-180.20
relation ParserLocalDecls_ok: context `|-` parserLocalDeclaration* `:` context parserLocalDeclarationIR*

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:67.1-68.19
   rule nil: C `|-` parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} `:` C []
      -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches []

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:70.1-76.65
   rule cons: C_0 `|-` parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} `:` C_2 parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}
      -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches _ :: _
      -- let parserLocalDeclaration_h :: parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} = parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}
      -- ParserLocalDecl_ok: C_0 `|-` parserLocalDeclaration_h `:` C_1 parserLocalDeclarationIR_h
      -- ParserLocalDecls_ok: C_1 `|-` parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} `:` C_2 parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:186.1-188.23
relation TableKey_ok: context tblctx `|-` tableKey `:` tblctx tableKeyIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:47.1-64.67
   rule : C TC_0 `|-` expression `:` name annotationList `;` `:` TC_2 tableKeyIR
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if Type_wf: $bound(`BLOCK`, C) `|-` `SET<` [typeIR] `>` as typeIR holds
      -- let nameIR = $name(name)
      -- if (`MATCH_KIND.` nameIR as value = $find_value(`BLOCK`, C, ``` nameIR))
      -- if $compat_table_key(nameIR, typeIR)
      -- let TC_1 = $update_mode(TC_0, nameIR, typeIR)
      -- let TC_2 = $add_key(TC_1, nameIR, typeIR)
      -- let tableKeyIR = typedExpressionIR `:` nameIR annotationList `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:190.1-192.23
relation TableKeys_ok: context tblctx `|-` tableKey* `:` tblctx tableKeyListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:72.1-73.23
   rule nil: C TC `|-` tableKey*{tableKey <- tableKey*} `:` TC []
      -- if tableKey*{tableKey <- tableKey*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:75.1-79.62
   rule cons: C TC_0 `|-` tableKey*{tableKey <- tableKey*} `:` TC_2 tableKeyIR_h :: tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}
      -- if tableKey*{tableKey <- tableKey*} matches _ :: _
      -- let tableKey_h :: tableKey_t*{tableKey_t <- tableKey_t*} = tableKey*{tableKey <- tableKey*}
      -- TableKey_ok: C TC_0 `|-` tableKey_h `:` TC_1 tableKeyIR_h
      -- TableKeys_ok: C TC_1 `|-` tableKey_t*{tableKey_t <- tableKey_t*} `:` TC_2 tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:194.1-197.23
relation Call_action_partial_ok: context `|-` parameterTypeIR* `@` argumentListIR `:` parameterTypeIR* `,` parameterTypeIR* `@` argumentListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:103.1-115.41
   rule : C `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `,` parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} `@` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- if (|parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- Call_convention_ok: `BLOCK` C `ACTION` `|-` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:199.1-201.23
relation TableAction_ok: context tblctx `|-` tableAction `:` tblctx tableActionIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:122.1-136.68
   rule prefixedNonTypeName: C TC_0 `|-` annotationList tableActionReference `;` `:` TC_1 tableActionIR
      -- if tableActionReference <: prefixedNonTypeName
      -- let prefixedNonTypeName = tableActionReference as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(`BLOCK`, C, prefixedNameIR)
      -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
      -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
      -- if routineTypeDefIR <: functionTypeIR
      -- let functionTypeIR = routineTypeDefIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- Call_action_partial_ok: C `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` [] `:` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `,` parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} `@` argumentIR*{argumentIR <- argumentIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let TC_1 = $add_action(TC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, [])
      -- let tableActionIR = annotationList prefixedNameIR `(` [] `)` `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:140.1-157.81
   rule prefixedNonTypeName-argumentList: C TC_0 `|-` annotationList tableActionReference `;` `:` TC_1 tableActionIR
      -- if tableActionReference matches `%(%)`
      -- let prefixedNonTypeName `(` argumentList `)` = tableActionReference
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(`BLOCK`, C, prefixedNameIR)
      -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
      -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
      -- if routineTypeDefIR <: functionTypeIR
      -- let functionTypeIR = routineTypeDefIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: `BLOCK` C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_partial_ok: C `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `,` parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} `@` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let TC_1 = $add_action(TC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let tableActionIR = annotationList prefixedNameIR `(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)` `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:203.1-205.23
relation TableActions_ok: context tblctx `|-` tableAction* `:` tblctx tableActionListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:165.1-166.23
   rule nil: C TC `|-` tableAction*{tableAction <- tableAction*} `:` TC []
      -- if tableAction*{tableAction <- tableAction*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:168.1-172.71
   rule cons: C TC_0 `|-` tableAction*{tableAction <- tableAction*} `:` TC_2 tableActionIR_h :: tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}
      -- if tableAction*{tableAction <- tableAction*} matches _ :: _
      -- let tableAction_h :: tableAction_t*{tableAction_t <- tableAction_t*} = tableAction*{tableAction <- tableAction*}
      -- TableAction_ok: C TC_0 `|-` tableAction_h `:` TC_1 tableActionIR_h
      -- TableActions_ok: C TC_1 `|-` tableAction_t*{tableAction_t <- tableAction_t*} `:` TC_2 tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:207.1-210.23
relation Call_action_default_ok: context `|-` parameterTypeIR* `@` argumentListIR `:` parameterTypeIR* `,` parameterTypeIR* `@` argumentListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:180.1-190.41
   rule : C `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} `,` parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} `@` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- Call_convention_ok: `BLOCK` C `ACTION` `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:212.1-214.23
relation TableDefaultAction_ok: context tblctx `|-` initializer `:` tableActionReferenceIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:194.1-199.54
   rule prefixedNonTypeName: C TC `|-` `=` expression `:` prefixedNameIR `(` [] `)`
      -- if expression <: prefixedNonTypeName
      -- let prefixedNonTypeName = expression as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- if (?(([], [])) = $find_action(TC, prefixedNameIR))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:203.1-224.57
   rule prefixedNonTypeName-argumentList: C TC `|-` `=` expression `:` prefixedNameIR `(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `%(%)`
      -- let callTarget `(` argumentList `)` = callExpression
      -- if callTarget <: prefixedNonTypeName
      -- let prefixedNonTypeName = callTarget as prefixedNonTypeName
      -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
      -- let (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} = $find_action(TC, prefixedNameIR)
      -- if (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} matches (_)
      -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?}
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- (Argument_ok: `BLOCK` C `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_default_ok: C `|-` parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} `@` argumentIR*{argumentIR <- argumentIR*} `:` parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} `,` parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} `@` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
      -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:216.1-218.23
relation TableProperty_ok: context tblctx `|-` tableProperty `:` tblctx tablePropertyIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:234.1-238.58
   rule key: C TC_0 `|-` tableProperty `:` TC_1 `KEY={` tableKeyIR*{tableKeyIR <- tableKeyIR*} `}`
      -- if tableProperty matches `KEY={%}`
      -- let `KEY={` tableKeyList `}` = tableProperty
      -- let tableKey*{tableKey <- tableKey*} = $flatten_tableKeyList(tableKeyList)
      -- TableKeys_ok: C TC_0 `|-` tableKey*{tableKey <- tableKey*} `:` TC_1 tableKeyIR*{tableKeyIR <- tableKeyIR*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:242.1-246.67
   rule actions: C TC_0 `|-` tableProperty `:` TC_1 `ACTIONS={` tableActionIR*{tableActionIR <- tableActionIR*} `}`
      -- if tableProperty matches `ACTIONS={%}`
      -- let `ACTIONS={` tableActionList `}` = tableProperty
      -- let tableAction*{tableAction <- tableAction*} = $flatten_tableActionList(tableActionList)
      -- TableActions_ok: C TC_0 `|-` tableAction*{tableAction <- tableAction*} `:` TC_1 tableActionIR*{tableActionIR <- tableActionIR*}

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:252.1-262.78
   rule custom-default-action: C TC `|-` tableProperty `:` TC tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName initializer `;` = tableProperty
      -- if ("default_action" = $tableCustomName(tableCustomName))
      -- TableDefaultAction_ok: C TC `|-` initializer `:` tableActionReferenceIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR `DEFAULT_ACTION=` tableActionReferenceIR `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:264.1-278.67
   rule custom-size: C TC `|-` tableProperty `:` TC tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName `=` expression `;` = tableProperty
      -- if ("size" = $tableCustomName(tableCustomName))
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR "size" `=` typedExpressionIR `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:280.1-294.84
   rule custom-largest-priority-wins: C TC_0 `|-` tableProperty `:` TC_1 tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName `=` expression `;` = tableProperty
      -- if ("largest_priority_wins" = $tableCustomName(tableCustomName))
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if (typeIR = `BOOL` as typeIR)
      -- Eval_static: `BLOCK` C `|-` typedExpressionIR `~>` value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `B%`
      -- let `B` b_largest_priority_wins = primitiveValue
      -- let TC_1 = TC_0[PRIORITIES.LARGEST_WINS = b_largest_priority_wins]
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR "largest_priority_wins" `=` typedExpressionIR `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:296.1-315.77
   rule custom-priority-delta: C TC_0 `|-` tableProperty `:` TC_1 tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName `=` expression `;` = tableProperty
      -- if ("priority_delta" = $tableCustomName(tableCustomName))
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
      -- Eval_static: `BLOCK` C `|-` typedExpressionIR `~>` value
      -- let int = $to_number(value)
      -- if int <: nat
      -- let n_delta = int as nat
      -- if (n_delta > 0)
      -- let TC_1 = TC_0[PRIORITIES.DELTA = n_delta as int]
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR "priority_delta" `=` typedExpressionIR `;`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:317.1-330.67
   rule custom: C TC `|-` tableProperty `:` TC tablePropertyIR
      -- if tableProperty matches `%%%%;`
      -- let annotationList constOpt tableCustomName `=` expression `;` = tableProperty
      -- let nameIR = $tableCustomName(tableCustomName)
      -- if (((nameIR =/= "size") /\ (nameIR =/= "largest_priority_wins")) /\ (nameIR =/= "priority_delta"))
      -- Expr_ok: `BLOCK` C `|-` expression `:` typedExpressionIR
      -- let constOptIR = $flatten_constOpt(constOpt)
      -- let tablePropertyIR = annotationList constOptIR nameIR `=` typedExpressionIR `;`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:220.1-222.23
relation TableProperties_ok: context tblctx `|-` tableProperty* `:` tblctx tablePropertyListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:338.1-339.23
   rule nil: C TC `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC []
      -- if tableProperty*{tableProperty <- tableProperty*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:341.1-345.78
   rule cons: C TC_0 `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC_2 tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}
      -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
      -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
      -- TableProperty_ok: C TC_0 `|-` tableProperty_h `:` TC_1 tablePropertyIR_h
      -- TableProperties_ok: C TC_1 `|-` tableProperty_t*{tableProperty_t <- tableProperty_t*} `:` TC_2 tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:224.1-226.20
relation Table_ok: context `|-` tableProperty* `:` tblctx tablePropertyListIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:353.1-356.74
   rule : C `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
      -- let TC_0 = $empty_tblctx
      -- TableProperties_ok: C TC_0 `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:228.1-230.23
relation TableType_ok: context tblctx `|-` name `:` context typeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:358.1-379.59
   rule : C_0 TC `|-` name `:` C_1 typeIR_table
      -- let nameIR = $name(name)
      -- let tid_enum = "action_list(" ++ nameIR ++ ")"
      -- let (prefixedNameIR_action, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR)*{_argumentListIR <- _argumentListIR*, _parameterTypeIR* <- _parameterTypeIR**, prefixedNameIR_action <- prefixedNameIR_action*} = TC.ACTIONS
      -- (let id_enum_field = $flatten_prefixedNameIR(prefixedNameIR_action))*{id_enum_field <- id_enum_field*, prefixedNameIR_action <- prefixedNameIR_action*}
      -- let typeIR_table_enum = `TABLE_ENUM` tid_enum `{` id_enum_field*{id_enum_field <- id_enum_field*} `}` as typeIR
      -- (let value_enum_field = `TABLE_ENUM` tid_enum `.` id_enum_field as value)*{id_enum_field <- id_enum_field*, value_enum_field <- value_enum_field*}
      -- (let varTypeIR_enum_field = ``EMPTY` typeIR_table_enum `LCTK` ?(value_enum_field))*{value_enum_field <- value_enum_field*, varTypeIR_enum_field <- varTypeIR_enum_field*}
      -- let C_1 = $add_vars(`BLOCK`, C_0, id_enum_field*{id_enum_field <- id_enum_field*}, varTypeIR_enum_field*{varTypeIR_enum_field <- varTypeIR_enum_field*})
      -- let tid_struct = "apply_result(" ++ nameIR ++ ")"
      -- let typeIR_table_struct = `TABLE_STRUCT` tid_struct `{` [`BOOL` as typeIR "hit" `;`, `BOOL` as typeIR "miss" `;`, typeIR_table_enum "action_run" `;`] `}` as typeIR
      -- let typeIR_table = `TABLE` nameIR `#` typeIR_table_struct as typeIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:232.1-235.20
relation ControlLocalDecl_ok: context `|-` controlLocalDeclaration `:` context controlLocalDeclarationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:9.1-11.75
   rule constantDeclaration: C_0 `|-` controlLocalDeclaration `:` C_1 constantDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: constantDeclaration
      -- let constantDeclaration = controlLocalDeclaration as constantDeclaration
      -- Decl_ok: `BLOCK` C_0 `|-` constantDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:15.1-17.63
   rule instantiation: C_0 `|-` controlLocalDeclaration `:` C_1 instantiationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: instantiation
      -- let instantiation = controlLocalDeclaration as instantiation
      -- Decl_ok: `BLOCK` C_0 `|-` instantiation as declaration `:` C_1 declarationIR
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:23.1-34.44
   rule variableDeclaration-empty: C_0 `|-` controlLocalDeclaration `:` C_1 variableDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = controlLocalDeclaration as variableDeclaration
      -- if initializerOpt matches ``EMPTY`
      -- Type_ok: `BLOCK` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`BLOCK`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?() `;`

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:36.1-53.73
   rule variableDeclaration-initializer: C_0 `|-` controlLocalDeclaration `:` C_1 variableDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: variableDeclaration
      -- let annotationList type name initializerOpt `;` = controlLocalDeclaration as variableDeclaration
      -- if initializerOpt <: initializer
      -- let `=` expression_init = initializerOpt as initializer
      -- Type_ok: `BLOCK` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`BLOCK`, C_0) `|-` typeIR holds
      -- Expr_ok: `BLOCK` C_0 `|-` expression_init `:` typedExpressionIR_init
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(`BLOCK`, C_0, nameIR, `INOUT` typeIR `DYN` ?())
      -- let variableDeclarationIR = annotationList typeIR nameIR ?(`=` typedExpressionIR_init_cast) `;`

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:57.1-59.71
   rule actionDeclaration: C_0 `|-` controlLocalDeclaration `:` C_1 actionDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: actionDeclaration
      -- let actionDeclaration = controlLocalDeclaration as actionDeclaration
      -- Decl_ok: `BLOCK` C_0 `|-` actionDeclaration as declaration `:` C_1 declarationIR
      -- if declarationIR <: actionDeclarationIR
      -- let actionDeclarationIR = declarationIR as actionDeclarationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:65.1-77.58
   rule tableDeclaration: C_0 `|-` controlLocalDeclaration `:` C_2 tableDeclarationIR as controlLocalDeclarationIR
      -- if controlLocalDeclaration <: tableDeclaration
      -- let annotationList `TABLE` name `{` tablePropertyList `}` = controlLocalDeclaration as tableDeclaration
      -- let tableProperty*{tableProperty <- tableProperty*} = $flatten_tablePropertyList(tablePropertyList)
      -- Table_ok: C_0 `|-` tableProperty*{tableProperty <- tableProperty*} `:` TC tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
      -- let nameIR = $name(name)
      -- TableType_ok: C_0 TC `|-` name `:` C_1 typeIR_table
      -- let C_2 = $add_var(`BLOCK`, C_1, nameIR, ``EMPTY` typeIR_table `DYN` ?())
      -- let tableDeclarationIR = annotationList `TABLE` nameIR `{` tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} `}`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:237.1-240.20
relation ControlLocalDecls_ok: context `|-` controlLocalDeclaration* `:` context controlLocalDeclarationIR*

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:85.1-86.19
   rule nil: C `|-` controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} `:` C []
      -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches []

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:88.1-94.59
   rule cons: C_0 `|-` controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} `:` C_2 controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}
      -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches _ :: _
      -- let controlLocalDeclaration_h :: controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} = controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}
      -- ControlLocalDecl_ok: C_0 `|-` controlLocalDeclaration_h `:` C_1 controlLocalDeclarationIR_h
      -- ControlLocalDecls_ok: C_1 `|-` controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} `:` C_2 controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:246.1-248.23
relation Decl_ok: cursor context `|-` declaration `:` context declarationIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:9.1-29.57
   rule constantDeclaration: p C_0 `|-` declaration `:` C_1 constantDeclarationIR as declarationIR
      -- if declaration <: constantDeclaration
      -- let annotationList `CONST` type name `=` expression_value `;` = declaration as constantDeclaration
      -- Type_ok: p C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(p, C_0) `|-` typeIR holds
      -- Expr_ok: p C_0 `|-` expression_value `:` typedExpressionIR_value
      -- let _expressionIR `#` `(` _typeIR ctk `)` = typedExpressionIR_value
      -- if ctk matches `LCTK`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_value, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_value_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- Eval_static: p C_0 `|-` typedExpressionIR_value_cast `~>` value
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(p, C_0, nameIR, ``EMPTY` typeIR `LCTK` ?(value))
      -- let constantDeclarationIR = annotationList `CONST` typeIR nameIR `=` value `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:36.1-55.71
   rule instantiation-no-objectInitializer: p C_0 `|-` declaration `:` C_1 instantiationIR as declarationIR
      -- if declaration <: instantiation
      -- let instantiation = declaration as instantiation
      -- if instantiation matches `%%(%)%;`
      -- let annotationList type `(` argumentList `)` name `;` = instantiation
      -- if type <: prefixedTypeName
      -- let prefixedTypeName = type as prefixedTypeName
      -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
      -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
      -- ConstructorType_ok: p C_0 `|-` prefixedNameIR `<` [] `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- (Argument_ok: p C_0 `|-` argument `:` argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
      -- Inst_ok: p C_0 `|-` constructorTypeIR `<` [] `#` tid_impl*{tid_impl <- tid_impl*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let nameIR = $name(name)
      -- let C_1 = $add_var(p, C_0, nameIR, ``EMPTY` typeIR_object `CTK` ?())
      -- let instantiationIR = annotationList typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR*{argumentIR <- argumentIR*} `)` nameIR ?() `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:65.1-85.72
   rule actionDeclaration: p C_0 `|-` declaration `:` C_3 actionDeclarationIR as declarationIR
      -- if declaration <: actionDeclaration
      -- let annotationList `ACTION` name `(` parameterList `)` blockStatement = declaration as actionDeclaration
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: p C_0 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_1 = $add_parameters(`LOCAL`, C_0, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let C_2 = $set_return_type(C_1, `VOID` as typeIR)
      -- Block_ok: C_2 `CONT` `|-` blockStatement `:` _context _flow blockStatementIR
      -- let rid = $rid(name, parameterList)
      -- let functionTypeIR = `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- if RoutineTypeDef_wf: $bound(p, C_0) `|-` functionTypeIR as routineTypeDefIR holds
      -- let C_3 = $add_routine_non_overload(p, C_0, rid, functionTypeIR as routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let actionDeclarationIR = annotationList `ACTION` nameIR `(` parameterIR*{parameterIR <- parameterIR*} `)` blockStatementIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:90.1-100.86
   rule errorDeclaration: cursor C_0 `|-` declaration `:` C_1 `ERROR{` nameIR*{nameIR <- nameIR*} `}` as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: errorDeclaration
      -- let `ERROR{` nameList `}` = declaration as errorDeclaration
      -- let name*{name <- name*} = $flatten_nameList(nameList)
      -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
      -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
      -- (let nameIR_error = "error." ++ nameIR)*{nameIR <- nameIR*, nameIR_error <- nameIR_error*}
      -- (let value_error = `ERROR.` nameIR as value)*{nameIR <- nameIR*, value_error <- value_error*}
      -- let C_1 = $add_vars(`GLOBAL`, C_0, nameIR_error*{nameIR_error <- nameIR_error*}, ``EMPTY` `ERROR` as typeIR `LCTK` ?(value_error)*{value_error <- value_error*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:105.1-114.90
   rule matchKindDeclaration: cursor C_0 `|-` declaration `:` C_1 `MATCH_KIND{` nameIR*{nameIR <- nameIR*} `}` as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: matchKindDeclaration
      -- let `MATCH_KIND{` nameList _trailingCommaOpt `}` = declaration as matchKindDeclaration
      -- let name*{name <- name*} = $flatten_nameList(nameList)
      -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
      -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
      -- (let value_match_kind = `MATCH_KIND.` nameIR as value)*{nameIR <- nameIR*, value_match_kind <- value_match_kind*}
      -- let C_1 = $add_vars(`GLOBAL`, C_0, nameIR*{nameIR <- nameIR*}, ``EMPTY` `MATCH_KIND` as typeIR `LCTK` ?(value_match_kind)*{value_match_kind <- value_match_kind*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:123.1-148.79
   rule externDeclaration-externFunctionDeclaration: cursor C_0 `|-` declaration `:` C_3 externFunctionDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: externFunctionDeclaration
      -- let annotationList `EXTERN` typeOrVoid name typeParameterListOpt `(` parameterList `)` `;` = declaration as externFunctionDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`LOCAL`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `LOCAL` C_1 `|-` typeOrVoid `:` typeIR_ret `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `LOCAL` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`LOCAL`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameterList)
      -- let functionTypeIR = `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret
      -- let routineTypeDefIR = functionTypeIR as routineTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as routineTypeDefIR
      -- if RoutineTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` routineTypeDefIR holds
      -- let C_3 = $add_routine_overload(`GLOBAL`, C_0, rid, routineTypeDefIR)
      -- let nameIR = $name(name)
      -- let externFunctionDeclarationIR = annotationList `EXTERN` typeIR_ret nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `)` `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:176.1-204.73
   rule externDeclaration-externObjectDeclaration: cursor C_0 `|-` declaration `:` C_6 externObjectDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: externObjectDeclaration
      -- let annotationList `EXTERN` nonTypeName typeParameterListOpt `{` methodPrototypeList `}` = declaration as externObjectDeclaration
      -- let methodPrototype*{methodPrototype <- methodPrototype*} = $flatten_methodPrototypeList(methodPrototypeList)
      -- let (methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*}, methodPrototype_method*{methodPrototype_method <- methodPrototype_method*}) = $split_constructors(methodPrototype*{methodPrototype <- methodPrototype*})
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let nameIR = $name(nonTypeName as name)
      -- ExternMethods_ok: C_1 nameIR `|-` methodPrototype_method*{methodPrototype_method <- methodPrototype_method*} `:` C_2 methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}
      -- let typeIR_extern = `EXTERN` nameIR C_2.BLOCK.RDENV as typeIR
      -- let typeDefIR_extern = typeIR_extern `<` tid_expl*{tid_expl <- tid_expl*} `,` [] `>` as typeDefIR
      -- let C_3 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_extern)
      -- let C_4 = $add_types(`BLOCK`, C_3, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- ExternConstructors_ok: C_4 nameIR `|-` methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*} `:` C_5 methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*}
      -- let C_6 = C_3[GLOBAL.CDENV = C_5.GLOBAL.CDENV]
      -- let externObjectDeclarationIR = annotationList `EXTERN` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` [] `>{` methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*} ++ methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:212.1-255.56
   rule parserDeclaration: cursor C_0 `|-` declaration `:` C_4 parserDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: parserDeclaration
      -- let annotationList `PARSER` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` parserLocalDeclarationList parserStateList `}` = declaration as parserDeclaration
      -- if typeParameterListOpt matches ``EMPTY`
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
      -- ConstructorParameters_ok: `BLOCK` C_0 `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let C_1 = $add_parameters(`BLOCK`, C_0, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `BLOCK` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid'*{tid' <- tid'*}
      -- if tid'*{tid' <- tid'*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`BLOCK`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} = $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
      -- ParserLocalDecls_ok: C_2 `|-` parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} `:` C_3 parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
      -- let parserState*{parserState <- parserState*} = $flatten_parserStateList(parserStateList)
      -- ParserStates_ok: C_3 `|-` parserState*{parserState <- parserState*} `:` parserStateIR*{parserStateIR <- parserStateIR*}
      -- let methodTypeIR = `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- if RoutineTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` methodTypeIR as routineTypeDefIR holds
      -- let cid = $cid(name, constructorParameterListOpt)
      -- let typeIR_parser = `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeIR_parser_spec = typeIR_parser `<` [] `,` [] `>` `<` [] `>` as typeIR
      -- let constructorTypeIR = `CONSTRUCTOR(` constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} `)->` typeIR_parser_spec
      -- let constructorTypeDefIR = constructorTypeIR `<` [] `,` [] `>`
      -- if ConstructorTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` constructorTypeDefIR holds
      -- let C_4 = $add_constructor(C_0, cid, constructorTypeDefIR)
      -- let nameIR = $name(name)
      -- let parserDeclarationIR = annotationList `PARSER` nameIR `<` [] `>(` parameterIR*{parameterIR <- parameterIR*} `)(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:263.1-306.60
   rule controlDeclaration: cursor C_0 `|-` declaration `:` C_5 controlDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: controlDeclaration
      -- let annotationList `CONTROL` name typeParameterListOpt `(` parameterList `)` constructorParameterListOpt `{` controlLocalDeclarationList `APPLY` controlBody `}` = declaration as controlDeclaration
      -- if typeParameterListOpt matches ``EMPTY`
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
      -- ConstructorParameters_ok: `BLOCK` C_0 `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let C_1 = $add_parameters(`BLOCK`, C_0, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `BLOCK` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid'*{tid' <- tid'*}
      -- if tid'*{tid' <- tid'*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let C_2 = $add_parameters(`BLOCK`, C_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} = $flatten_controlLocalDeclarationList(controlLocalDeclarationList)
      -- ControlLocalDecls_ok: C_2 `|-` controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} `:` C_3 controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
      -- let C_4 = $set_return_type(C_3, `VOID` as typeIR)
      -- Block_ok: C_4 `CONT` `|-` controlBody `:` _context _flow controlBodyIR
      -- let methodTypeIR = `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- if RoutineTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` methodTypeIR as routineTypeDefIR holds
      -- let cid = $cid(name, constructorParameterListOpt)
      -- let typeIR_control = `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeIR_control_spec = typeIR_control `<` [] `,` [] `>` `<` [] `>` as typeIR
      -- let constructorTypeIR = `CONSTRUCTOR(` constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} `)->` typeIR_control_spec
      -- let constructorTypeDefIR = constructorTypeIR `<` [] `,` [] `>`
      -- if ConstructorTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` constructorTypeDefIR holds
      -- let C_5 = $add_constructor(C_0, cid, constructorTypeDefIR)
      -- let nameIR = $name(name)
      -- let controlDeclarationIR = annotationList `CONTROL` nameIR `<` [] `>(` parameterIR*{parameterIR <- parameterIR*} `)(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} `APPLY` controlBodyIR `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:319.1-338.54
   rule typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 enumTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: enumTypeDeclaration
      -- let enumTypeDeclaration = declaration as enumTypeDeclaration
      -- if enumTypeDeclaration matches `%ENUM%{%%}`
      -- let annotationList `ENUM` name `{` nameList _trailingCommaOpt `}` = enumTypeDeclaration
      -- let name_field*{name_field <- name_field*} = $flatten_nameList(nameList)
      -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
      -- if $distinct_<nameIR>(nameIR_field*{nameIR_field <- nameIR_field*})
      -- let nameIR = $name(name)
      -- let typeIR_enum = `ENUM` nameIR `{` nameIR_field*{nameIR_field <- nameIR_field*} `}` as typeIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeIR_enum as typeDefIR holds
      -- let C_1 = $add_type(`GLOBAL`, C_0, nameIR, typeIR_enum as typeDefIR)
      -- (let id_field = nameIR ++ "." ++ nameIR_field)*{id_field <- id_field*, nameIR_field <- nameIR_field*}
      -- (let value_field = nameIR `.` nameIR_field as value)*{nameIR_field <- nameIR_field*, value_field <- value_field*}
      -- let C_2 = $add_vars(`GLOBAL`, C_1, id_field*{id_field <- id_field*}, ``EMPTY` typeIR_enum `LCTK` ?(value_field)*{value_field <- value_field*})
      -- let enumTypeDeclarationIR = annotationList `ENUM` nameIR `{` nameIR_field*{nameIR_field <- nameIR_field*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:346.1-368.66
   rule typeDeclaration-derivedTypeDeclaration-structTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 structTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: structTypeDeclaration
      -- let annotationList `STRUCT` name typeParameterListOpt `{` typeFieldList `}` = declaration as structTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let annotationList_field type_field name_field `;`*{annotationList_field <- annotationList_field*, name_field <- name_field*, type_field <- type_field*} = $flatten_typeFieldList(typeFieldList)
      -- (Type_ok: `BLOCK` C_1 `|-` type_field as typeOrVoid `:` typeIR_field `#` tid_impl_field*{tid_impl_field <- tid_impl_field*})*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**})
      -- let nameIR = $name(name)
      -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
      -- let typeIR_struct = `STRUCT` nameIR `{` typeIR_field nameIR_field `;`*{nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} `}` as typeIR
      -- let typeDefIR_struct = typeIR_struct `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_struct holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_struct)
      -- let structTypeDeclarationIR = annotationList `STRUCT` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>{` annotationList_field typeIR_field nameIR_field `;`*{annotationList_field <- annotationList_field*, nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:374.1-396.54
   rule typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 headerTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: headerTypeDeclaration
      -- let annotationList `HEADER` name typeParameterListOpt `{` typeFieldList `}` = declaration as headerTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let annotationList_f type_f name_f `;`*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
      -- (Type_ok: `BLOCK` C_1 `|-` type_f as typeOrVoid `:` typeIR_f `#` tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
      -- let nameIR = $name(name)
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let typeIR_header = `HEADER` nameIR `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` as typeIR
      -- let typeDefIR_header = typeIR_header `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_header holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_header)
      -- let headerTypeDeclarationIR = annotationList `HEADER` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>{` annotationList_f typeIR_f nameIR_f `;`*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:402.1-424.54
   rule typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 headerUnionTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: headerUnionTypeDeclaration
      -- let annotationList `HEADER_UNION` name typeParameterListOpt `{` typeFieldList `}` = declaration as headerUnionTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let annotationList_f type_f name_f `;`*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
      -- (Type_ok: `BLOCK` C_1 `|-` type_f as typeOrVoid `:` typeIR_f `#` tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
      -- let nameIR = $name(name)
      -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
      -- let typeIR_union = `HEADER_UNION` nameIR `{` typeIR_f nameIR_f `;`*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}` as typeIR
      -- let typeDefIR_union = typeIR_union `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_union holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_union)
      -- let headerUnionTypeDeclarationIR = annotationList `HEADER_UNION` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>{` annotationList_f typeIR_f nameIR_f `;`*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} `}`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:434.1-447.48
   rule typeDeclaration-typedefDeclaration-typedef-type: cursor C_0 `|-` declaration `:` C_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPEDEF%%;`
      -- let annotationList `TYPEDEF` typedefType name `;` = typedefDeclaration
      -- if typedefType <: type
      -- let type = typedefType as type
      -- Type_ok: `GLOBAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`GLOBAL`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let typeIR_typedef = `TYPEDEF` nameIR typeIR as typeIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeIR_typedef as typeDefIR holds
      -- let C_1 = $add_type(`GLOBAL`, C_0, nameIR, typeIR_typedef as typeDefIR)
      -- let typedefDeclarationIR = annotationList `TYPEDEF` typeIR as typedefTypeIR nameIR `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:453.1-466.45
   rule typeDeclaration-typedefDeclaration-newtype: cursor C_0 `|-` declaration `:` C_1 typedefDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `%TYPE%%;`
      -- let annotationList `TYPE` type name `;` = typedefDeclaration
      -- Type_ok: `GLOBAL` C_0 `|-` type as typeOrVoid `:` typeIR `#` tid*{tid <- tid*}
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: $bound(`GLOBAL`, C_0) `|-` typeIR holds
      -- let nameIR = $name(name)
      -- let typeIR_newtype = `TYPE` nameIR typeIR as typeIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeIR_newtype as typeDefIR holds
      -- let C_1 = $add_type(`GLOBAL`, C_0, nameIR, typeIR_newtype as typeDefIR)
      -- let typedefDeclarationIR = annotationList `TYPE` typeIR nameIR `;`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:472.1-491.86
   rule typeDeclaration-parserTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 parserTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: parserTypeDeclaration
      -- let annotationList `PARSER` name typeParameterListOpt `(` parameterList `);` = declaration as parserTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `BLOCK` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let nameIR = $name(name)
      -- let typeIR_parser = `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeDefIR_parser = typeIR_parser `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_parser holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_parser)
      -- let parserTypeDeclarationIR = annotationList `PARSER` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `);`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:497.1-516.87
   rule typeDeclaration-controlTypeDeclaration: cursor C_0 `|-` declaration `:` C_2 controlTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: controlTypeDeclaration
      -- let annotationList `CONTROL` name typeParameterListOpt `(` parameterList `);` = declaration as controlTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
      -- Parameters_ok: `BLOCK` C_1 `|-` parameter*{parameter <- parameter*} `:` parameterIR*{parameterIR <- parameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let nameIR = $name(name)
      -- let typeIR_control = `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` as typeIR
      -- let typeDefIR_control = typeIR_control `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_control holds
      -- let C_2 = $add_type(`GLOBAL`, C_0, nameIR, typeDefIR_control)
      -- let controlTypeDeclarationIR = annotationList `CONTROL` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` parameterIR*{parameterIR <- parameterIR*} `);`

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:522.1-552.40
   rule typeDeclaration-packageTypeDeclaration: cursor C_0 `|-` declaration `:` C_3 packageTypeDeclarationIR as declarationIR
      -- if cursor matches `GLOBAL`
      -- if declaration <: packageTypeDeclaration
      -- let annotationList `PACKAGE` name typeParameterListOpt `(` parameterList `);` = declaration as packageTypeDeclaration
      -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
      -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let C_1 = $add_types(`BLOCK`, C_0, tid_expl*{tid_expl <- tid_expl*}, `TID` tid_expl as typeDefIR*{tid_expl <- tid_expl*})
      -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
      -- ConstructorParameters_ok: `BLOCK` C_1 `|-` constructorParameter*{constructorParameter <- constructorParameter*} `:` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `#` tid_impl*{tid_impl <- tid_impl*}
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let nameIR = $name(name)
      -- (let _direction typeIR_package_inner _id _value?{_value <- _value?} = constructorParameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, constructorParameterTypeIR <- constructorParameterTypeIR*, typeIR_package_inner <- typeIR_package_inner*}
      -- let typeIR_package = `PACKAGE<` typeIR_package_inner*{typeIR_package_inner <- typeIR_package_inner*} `>` as typeIR
      -- let typeDefIR_package = typeIR_package `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>` as typeDefIR
      -- if TypeDef_wf: $bound(`GLOBAL`, C_0) `|-` typeDefIR_package holds
      -- let C_2 = $add_type(`GLOBAL`, C_1, nameIR, typeDefIR_package)
      -- let cid = $cid(name, `(` parameterList `)`)
      -- let constructorTypeIR = `CONSTRUCTOR(` constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} `)->` typeIR_package
      -- let constructorTypeDefIR = constructorTypeIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>`
      -- if ConstructorTypeDef_wf: $bound(`GLOBAL`, C_0) `|-` constructorTypeDefIR holds
      -- let C_3 = $add_constructor(C_0, cid, constructorTypeDefIR)
      -- let packageTypeDeclarationIR = annotationList `PACKAGE` nameIR `<` tid_expl*{tid_expl <- tid_expl*} `,` tid_impl*{tid_impl <- tid_impl*} `>(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `);`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:250.1-252.23
relation Decls_ok: cursor context `|-` declaration* `:` context declarationIR*

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:558.1-559.21
   rule nil: p C `|-` declaration*{declaration <- declaration*} `:` C []
      -- if declaration*{declaration <- declaration*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:561.1-565.62
   rule cons: p C_0 `|-` declaration*{declaration <- declaration*} `:` C_2 declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*}
      -- if declaration*{declaration <- declaration*} matches _ :: _
      -- let declaration_h :: declaration_t*{declaration_t <- declaration_t*} = declaration*{declaration <- declaration*}
      -- Decl_ok: p C_0 `|-` declaration_h `:` C_1 declarationIR_h
      -- Decls_ok: p C_1 `|-` declaration_t*{declaration_t <- declaration_t*} `:` C_2 declarationIR_t*{declarationIR_t <- declarationIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:254.1-256.17
relation Program_ok: `|-` p4program `:` context p4programIR

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:571.1-575.63
   rule : `|-` p4program `:` C_1 declarationIR*{declarationIR <- declarationIR*} `;`
      -- let declaration*{declaration <- declaration*} = $flatten_p4program(p4program)
      -- let C_0 = $empty_context
      -- Decls_ok: `GLOBAL` C_0 `|-` declaration*{declaration <- declaration*} `:` C_1 declarationIR*{declarationIR <- declarationIR*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:266.1-269.29
relation FunctionType_ok: cursor context `|-` prefixedNameIR `<` typeArgumentListIR `>(` argument* `):` functionTypeIR `<#` tid* `>(#` id* `)`

   ;; ../../../../spec-concrete/5.15.2-typing-routine-call.watsup:5.1-11.70
   rule action: p C `|-` prefixedNameIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` functionTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_routine_overloaded(p, C, prefixedNameIR, argument*{argument <- argument*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- if (routineTypeDefIR, tid*) <: (functionTypeIR, tid*)
      -- let (functionTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (functionTypeIR, tid*)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:275.1-278.32
relation MethodType_ok: cursor context `|-` typedExpressionIR `.` nameIR `<` typeArgumentListIR `>(` argument* `):` methodTypeIR `<#` tid* `>(#` id* `)`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:284.1-287.29
relation RoutineType_Lvalue_ok: cursor context `|-` routineLvalueIR `<` typeArgumentListIR `>(` argument* `):` routineTypeIR `<#` tid* `>(#` id* `)`

   ;; ../../../../spec-concrete/5.08.2-typing-lvalue-routine.watsup:35.1-39.82
   rule function: p C `|-` routineLvalueIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` functionTypeIR as routineTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- if routineLvalueIR <: prefixedNameIR
      -- let prefixedNameIR = routineLvalueIR as prefixedNameIR
      -- FunctionType_ok: p C `|-` prefixedNameIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` functionTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`

   ;; ../../../../spec-concrete/5.08.2-typing-lvalue-routine.watsup:41.1-56.70
   rule extern-method: p C `|-` routineLvalueIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` routineTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- if routineLvalueIR matches `%.%`
      -- let typedLvalueIR_base `.` nameIR = routineLvalueIR
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid `{` rid_f `:` routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} `}` = typeIR as externObjectTypeIR
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(`{` rid_f `:` routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} `}`, nameIR, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- if (routineTypeDefIR, tid*) <: (routineTypeIR, tid*)
      -- let (routineTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (routineTypeIR, tid*)

   ;; ../../../../spec-concrete/5.08.2-typing-lvalue-routine.watsup:58.1-76.22
   rule parser-apply-method: p C `|-` routineLvalueIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` id_default*{id_default <- id_default*} `)`
      -- if routineLvalueIR matches `%.%`
      -- let typedLvalueIR_base `.` text = routineLvalueIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as parserObjectTypeIR
      -- let methodTypeIR = `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
      -- (let pid = id_param `#` (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
      -- let rid = "apply" `(` pid*{pid <- pid*} `)`
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>(`{` [rid `:` methodTypeIR as routineTypeDefIR] `}`, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
      -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
      -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
      -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
      -- if (rid' = rid)
      -- if (methodTypeIR' = methodTypeIR)

   ;; ../../../../spec-concrete/5.08.2-typing-lvalue-routine.watsup:78.1-96.22
   rule control-apply-method: p C `|-` routineLvalueIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` id_default*{id_default <- id_default*} `)`
      -- if routineLvalueIR matches `%.%`
      -- let typedLvalueIR_base `.` text = routineLvalueIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = typeIR as controlObjectTypeIR
      -- let methodTypeIR = `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)`
      -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
      -- (let pid = id_param `#` (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
      -- let rid = "apply" `(` pid*{pid <- pid*} `)`
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argument*{argument <- argument*})
      -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>(`{` [rid `:` methodTypeIR as routineTypeDefIR] `}`, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
      -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
      -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
      -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
      -- if (rid' = rid)
      -- if (methodTypeIR' = methodTypeIR)

   ;; ../../../../spec-concrete/5.08.2-typing-lvalue-routine.watsup:98.1-105.52
   rule table-apply-method: p C `|-` routineLvalueIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` methodTypeIR as routineTypeIR `<#` [] `>(#` [] `)`
      -- if routineLvalueIR matches `%.%`
      -- let typedLvalueIR_base `.` text = routineLvalueIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argument*{argument <- argument*} matches []
      -- let _lvalueIR `#(` typeIR_base `)` = typedLvalueIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: tableObjectTypeIR
      -- let `TABLE` _tid `#` typeIR_table = typeIR as tableObjectTypeIR
      -- let methodTypeIR = `TABLE_APPLY->` typeIR_table

;; ../../../../spec-concrete/5.04-typing-relation.watsup:297.1-300.29
relation ConstructorType_ok: cursor context `|-` prefixedNameIR `<` typeArgumentListIR `>(` argument* `):` constructorTypeIR `<#` tid* `>(#` id* `)`

   ;; ../../../../spec-concrete/5.12.2-typing-extern-constructor.watsup:5.1-11.78
   rule : p C `|-` prefixedNameIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argument*{argument <- argument*} `):` constructorTypeIR `<#` tid_impl*{tid_impl <- tid_impl*} `>(#` id_default*{id_default <- id_default*} `)`
      -- let (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} = $find_constructor_overloaded(C, prefixedNameIR, argument*{argument <- argument*})
      -- if (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} matches (_)
      -- let ?((cid, constructorTypeDefIR, id_default*{id_default <- id_default*})) = (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?}
      -- let (constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}) = $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:310.18-310.35
syntax actctxt = 
   | `ACTION`
   | `NOACTION`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:312.1-315.29
relation Call_convention_expr_ok: cursor context actctxt `|-` parameterTypeIR `@` typedExpressionIR `:` typedExpressionIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:51.1-56.59
   rule in: p C actctxt `|-` direction typeIR_param _id _value?{_value <- _value?} `@` typedExpressionIR_arg `:` typedExpressionIR_arg_cast
      -- if direction matches `IN`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:60.1-68.7
   rule out-inout: p C actctxt `|-` direction typeIR_param _id _value?{_value <- _value?} `@` typedExpressionIR_arg `:` typedExpressionIR_arg
      -- if ((direction = `OUT`) \/ (direction = `INOUT`))
      -- let _expressionIR `#` `(` typeIR_arg _ctk `)` = typedExpressionIR_arg
      -- if Type_alpha: typeIR_param `~~` typeIR_arg holds

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:72.1-77.59
   rule empty-action: p C actctxt `|-` direction typeIR_param _id _value?{_value <- _value?} `@` typedExpressionIR_arg `:` typedExpressionIR_arg_cast
      -- if actctxt matches `ACTION`
      -- if direction matches ``EMPTY`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:79.1-86.24
   rule empty-not-action: p C actctxt `|-` direction typeIR_param _id _value?{_value <- _value?} `@` typedExpressionIR_arg `:` typedExpressionIR_arg
      -- if actctxt matches `NOACTION`
      -- if direction matches ``EMPTY`
      -- let _expressionIR `#` `(` typeIR_arg ctk_arg `)` = typedExpressionIR_arg
      -- if Type_alpha: typeIR_param `~~` typeIR_arg holds
      -- if (ctk_arg =/= `DYN`)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:317.1-320.29
relation Call_convention_argument_ok: cursor context actctxt `|-` parameterTypeIR `@` argumentIR `:` argumentIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:92.1-97.44
   rule typedExpression: p C actctxt `|-` parameterTypeIR `@` argumentIR `:` typedExpressionIR_cast as argumentIR
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR
      -- Call_convention_expr_ok: p C actctxt `|-` parameterTypeIR `@` typedExpressionIR `:` typedExpressionIR_cast

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:101.1-106.44
   rule nameIR-typedExpression: p C actctxt `|-` parameterTypeIR `@` argumentIR `:` nameIR `=` typedExpressionIR_cast
      -- if argumentIR matches `%=%`
      -- let nameIR `=` typedExpressionIR = argumentIR
      -- Call_convention_expr_ok: p C actctxt `|-` parameterTypeIR `@` typedExpressionIR `:` typedExpressionIR_cast

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:110.1-113.36
   rule nameIR-dontcare: p C actctxt `|-` parameterTypeIR `@` argumentIR `:` nameIR `=_`
      -- if argumentIR matches `%=_`
      -- let nameIR `=_` = argumentIR
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
      -- if direction matches `OUT`

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:117.1-119.36
   rule dontcare: p C actctxt `|-` parameterTypeIR `@` argumentIR `:` `_`
      -- if argumentIR matches `_`
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
      -- if direction matches `OUT`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:322.1-325.29
relation Call_convention_ok: cursor context actctxt `|-` parameterTypeIR* `@` argumentListIR `:` argumentListIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:125.1-126.34
   rule nil: p C actctxt `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` []
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:128.1-137.40
   rule cons: p C actctxt `|-` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_h_cast :: argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
      -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
      -- Call_convention_argument_ok: p C actctxt `|-` parameterTypeIR_h `@` argumentIR_h `:` argumentIR_h_cast
      -- Call_convention_ok: p C actctxt `|-` parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} `@` argumentIR_t*{argumentIR_t <- argumentIR_t*} `:` argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:332.1-336.35
relation Call_ok: cursor context `|-` routineTypeIR `<` typeArgumentListIR `#` tid* `>(` argumentListIR `#` id* `):` typeIR `<` typeArgumentListIR `>(` argumentListIR `)`

   ;; ../../../../spec-concrete/5.15.2-typing-routine-call.watsup:21.1-35.37
   rule action: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` `VOID` as typeIR `<` [] `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `ACTION(%)`
      -- let `ACTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = functionTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `ACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.2-typing-routine-call.watsup:39.1-54.39
   rule externfunction-noinfer: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: functionTypeIR
      -- let functionTypeIR = routineTypeIR as functionTypeIR
      -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
      -- let `EXTERN_FUNCTION(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = functionTypeIR
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.2-typing-routine-call.watsup:58.1-86.39
   rule extern-method: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_ret_inferred `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_ret = methodTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let methodTypeIR_inferred = `EXTERN_METHOD(` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `)->` typeIR_ret_inferred
      -- if RoutineType_wf: $bound(p, C) `|-` methodTypeIR_inferred as routineTypeIR holds
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.2-typing-routine-call.watsup:88.1-103.39
   rule parser-apply-method: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` `VOID` as typeIR `<` [] `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `PARSER_APPLY(%)`
      -- let `PARSER_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.2-typing-routine-call.watsup:105.1-120.39
   rule control-apply-method: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` `VOID` as typeIR `<` [] `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `CONTROL_APPLY(%)`
      -- let `CONTROL_APPLY(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)` = methodTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.2-typing-routine-call.watsup:122.1-124.41
   rule table-apply-method: p C `|-` routineTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id*{id <- id*} `):` typeIR_table `<` [] `>(` [] `)`
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `TABLE_APPLY->%`
      -- let `TABLE_APPLY->` typeIR_table = methodTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if id*{id <- id*} matches []

;; ../../../../spec-concrete/5.04-typing-relation.watsup:343.1-347.35
relation Inst_ok: cursor context `|-` constructorTypeIR `<` typeArgumentListIR `#` tid* `>(` argumentListIR `#` id* `):` typeIR `<` typeArgumentListIR `>(` argumentListIR `)`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:7.1-25.45
   rule package-no-infer: cursor C_0 `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if cursor matches `GLOBAL`
      -- if tid*{tid <- tid*} matches []
      -- let `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- let typeIR = $canon(typeIR_object)
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: `BLOCK` C_0 `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:27.1-59.43
   rule package-infer: cursor C `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object_inferred `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if cursor matches `GLOBAL`
      -- let `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- let typeIR = $canon(typeIR_object)
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` _typeIR*{_typeIR <- _typeIR*} `>` = typeIR as packageObjectTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR'?{typeIR' <- typeIR'?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR'? <- typeIR'?*}
      -- (if typeIR'?{typeIR' <- typeIR'?} matches (_))*{typeIR'? <- typeIR'?*}
      -- (let ?(typeIR_inferred) = typeIR'?{typeIR' <- typeIR'?})*{typeIR'? <- typeIR'?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
      -- let constructorTypeIR_inferred = `CONSTRUCTOR(` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `)->` typeIR_object_inferred
      -- if ConstructorType_wf: $bound(`GLOBAL`, C) `|-` constructorTypeIR_inferred holds
      -- Call_convention_ok: `BLOCK` C `NOACTION` `|-` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:63.1-81.39
   rule no-package-no-infer: p C `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid*{tid <- tid*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- if tid*{tid <- tid*} matches []
      -- let `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- if ~$is_package_object_typeIR($canon(typeIR_object))
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:83.1-114.39
   rule no-package-infer: p C `|-` constructorTypeIR `<` typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} `#` tid_infer*{tid_infer <- tid_infer*} `>(` argumentIR*{argumentIR <- argumentIR*} `#` id_default*{id_default <- id_default*} `):` typeIR_object `<` typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} `>(` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} `)`
      -- let `CONSTRUCTOR(` parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} `)->` typeIR_object = constructorTypeIR
      -- if ~$is_package_object_typeIR($canon(typeIR_object))
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
      -- let constructorTypeIR_inferred = `CONSTRUCTOR(` parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} `)->` typeIR_object_inferred
      -- if ConstructorType_wf: $bound(p, C) `|-` constructorTypeIR_inferred holds
      -- Call_convention_ok: p C `NOACTION` `|-` parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} `@` argumentIR*{argumentIR <- argumentIR*} `:` argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../spec-concrete/5.05.2-subtype.watsup:333.1-337.23
def $reduce_serenum_unary(typedExpressionIR, $check(typeIR) : bool) : typedExpressionIR? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:340.1-343.23
   clause 0(typedExpressionIR, $check) = ?(typedExpressionIR)
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if $check(typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:345.1-351.79
   clause 1(typedExpressionIR, $check) = $reduce_serenum_unary(typedExpressionIR_cast, $check)
      -- let _expressionIR `#` `(` typeIR ctk `)` = typedExpressionIR
      -- if ~$check(typeIR)
      -- let typeIR' = typeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_underlying `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- let typedExpressionIR_cast = `(` typeIR_underlying `)` typedExpressionIR as expressionIR `#` `(` typeIR_underlying ctk `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:353.1-354.15
   clause 2(typedExpressionIR, $check) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:358.1-363.44
def $reduce_serenum_binary(typedExpressionIR, typedExpressionIR, $check(typeIR, typeIR) : bool) : (typedExpressionIR, typedExpressionIR)? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:365.1-369.35
   clause 0(typedExpressionIR_l, typedExpressionIR_r, $check) = ?((typedExpressionIR_l, typedExpressionIR_r))
      -- let _expressionIR `#` `(` typeIR_l _ctk `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r _ctk' `)` = typedExpressionIR_r
      -- if $check(typeIR_l, typeIR_r)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:371.1-379.87
   clause 1(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)
      -- let _expressionIR `#` `(` typeIR_l ctk_l `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r _ctk `)` = typedExpressionIR_r
      -- if ~$check(typeIR_l, typeIR_r)
      -- let typeIR = typeIR_l
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_l_underlying `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- let typedExpressionIR_l_cast = `(` typeIR_l_underlying `)` typedExpressionIR_l as expressionIR `#` `(` typeIR_l_underlying ctk_l `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:381.1-389.87
   clause 2(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)
      -- let _expressionIR `#` `(` typeIR_l _ctk `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r ctk_r `)` = typedExpressionIR_r
      -- if ~$check(typeIR_l, typeIR_r)
      -- let typeIR = typeIR_r
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR_r_underlying `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR
      -- let typedExpressionIR_r_cast = `(` typeIR_r_underlying `)` typedExpressionIR_r as expressionIR `#` `(` typeIR_r_underlying ctk_r `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:391.1-392.15
   clause 3(typedExpressionIR_l, typedExpressionIR_r, $check) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:403.1-403.66
def $coerce_unary(typedExpressionIR, typeIR) : typedExpressionIR? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:405.1-407.37
   clause 0(typedExpressionIR, typeIR_to) = ?(typedExpressionIR)
      -- let _expressionIR `#` `(` typeIR _ctk `)` = typedExpressionIR
      -- if Type_alpha: typeIR `~~` typeIR_to holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:409.1-414.63
   clause 1(typedExpressionIR, typeIR_to) = ?(typedExpressionIR_cast)
      -- let _expressionIR `#` `(` typeIR ctk `)` = typedExpressionIR
      -- if ~Type_alpha: typeIR `~~` typeIR_to holds
      -- if Sub_impl: typeIR `<:` typeIR_to holds
      -- let typedExpressionIR_cast = `(` typeIR_to `)` typedExpressionIR as expressionIR `#` `(` typeIR_to ctk `)`

;; ../../../../spec-concrete/5.05.2-subtype.watsup:418.1-419.44
def $coerce_binary(typedExpressionIR, typedExpressionIR) : (typedExpressionIR, typedExpressionIR)? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:421.1-425.38
   clause 0(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r))
      -- let _expressionIR `#` `(` typeIR_l _ctk `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r _ctk' `)` = typedExpressionIR_r
      -- if Type_alpha: typeIR_l `~~` typeIR_r holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:427.1-434.65
   clause 1(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l_cast, typedExpressionIR_r))
      -- let _expressionIR `#` `(` typeIR_l ctk_l `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r _ctk `)` = typedExpressionIR_r
      -- if ~Type_alpha: typeIR_l `~~` typeIR_r holds
      -- if Sub_impl: typeIR_l `<:` typeIR_r holds
      -- let typedExpressionIR_l_cast = `(` typeIR_r `)` typedExpressionIR_l as expressionIR `#` `(` typeIR_r ctk_l `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:436.1-444.65
   clause 2(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r_cast))
      -- let _expressionIR `#` `(` typeIR_l _ctk `)` = typedExpressionIR_l
      -- let _expressionIR' `#` `(` typeIR_r ctk_r `)` = typedExpressionIR_r
      -- if ~Type_alpha: typeIR_l `~~` typeIR_r holds
      -- if ~Sub_impl: typeIR_l `<:` typeIR_r holds
      -- if Sub_impl: typeIR_r `<:` typeIR_l holds
      -- let typedExpressionIR_r_cast = `(` typeIR_l `)` typedExpressionIR_r as expressionIR `#` `(` typeIR_l ctk_r `)`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:446.1-447.15
   clause 3(typedExpressionIR_l, typedExpressionIR_r) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:69.1-69.32
def $compat_lnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:72.1-72.57
   clause 0(typeIR) = $compat'_lnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:70.1-70.33
def $compat'_lnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:73.1-73.31
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:74.1-75.14
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:90.1-90.32
def $compat_bnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:93.1-93.57
   clause 0(typeIR) = $compat'_bnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:91.1-91.33
def $compat'_bnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:94.1-94.37
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:95.1-95.37
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:96.1-97.15
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:112.1-112.38
def $compat_uplusminus(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:115.1-115.69
   clause 0(typeIR) = $compat'_uplusminus($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:113.1-113.39
def $compat'_uplusminus(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:116.1-116.36
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:117.1-117.43
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:118.1-118.43
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:119.1-120.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:138.1-138.49
def $compat_plusminusmult(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:141.1-142.63
   clause 0(typeIR_l, typeIR_r) = $compat'_plusminusmult($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:139.1-139.50
def $compat'_plusminusmult(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:143.1-143.44
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:144.1-144.58
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:145.1-145.58
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:146.1-147.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:175.1-175.48
def $compat_satplusminus(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:178.1-179.62
   clause 0(typeIR_l, typeIR_r) = $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:176.1-176.49
def $compat'_satplusminus(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:180.1-180.57
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:181.1-181.57
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:182.1-183.15
   clause 2(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:211.1-211.42
def $compat_divmod(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:214.1-215.56
   clause 0(typeIR_l, typeIR_r) = $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:212.1-212.43
def $compat'_divmod(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:216.1-216.37
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:217.1-218.15
   clause 1(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:278.1-278.41
def $compat_shift(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:281.1-282.55
   clause 0(typeIR_l, typeIR_r) = $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:279.1-279.42
def $compat'_shift(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:283.1-283.36
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:284.1-284.43
   clause 1(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:285.1-285.43
   clause 2(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR = typeIR' as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:286.1-286.43
   clause 3(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:287.1-287.50
   clause 4(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:288.1-288.50
   clause 5(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:289.1-289.43
   clause 6(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:290.1-290.50
   clause 7(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:291.1-291.50
   clause 8(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:292.1-293.15
   clause 9(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:373.1-373.43
def $compat_compare(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:376.1-377.57
   clause 0(typeIR_l, typeIR_r) = $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:374.1-374.44
def $compat'_compare(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:378.1-378.38
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `INT` as typeIR)
      -- if (typeIR' = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:379.1-379.52
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:380.1-380.52
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:381.1-382.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:410.1-410.43
def $compat_bitwise(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:413.1-414.57
   clause 0(typeIR_l, typeIR_r) = $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:411.1-411.44
def $compat'_bitwise(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:415.1-415.52
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:416.1-416.52
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` w' `>` = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:417.1-418.15
   clause 2(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:446.1-446.42
def $compat_concat(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:449.1-450.56
   clause 0(typeIR_l, typeIR_r) = $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:447.1-447.43
def $compat'_concat(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:451.1-451.51
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:452.1-452.51
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:453.1-453.51
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `INT<%>`
      -- let `INT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:454.1-454.51
   clause 3(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `BIT<%>`
      -- let `BIT<` _nat' `>` = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:455.1-456.15
   clause 4(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:483.1-483.43
def $compat_logical(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:486.1-487.57
   clause 0(typeIR_l, typeIR_r) = $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:484.1-484.44
def $compat'_logical(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:488.1-488.40
   clause 0(typeIR, typeIR') = true
      -- if (typeIR = `BOOL` as typeIR)
      -- if (typeIR' = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:489.1-490.15
   clause 1(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:834.1-834.39
def $compat_array_index(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:837.1-838.40
   clause 0(typeIR) = $compat'_arrayindex($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:835.1-835.39
def $compat'_arrayindex(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:839.1-839.36
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:840.1-840.43
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:841.1-841.43
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:842.1-843.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:925.1-925.41
def $compat_bitslice_base(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:928.1-929.43
   clause 0(typeIR) = $compat'_bitslice_base($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:926.1-926.42
def $compat'_bitslice_base(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:930.1-930.39
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:931.1-931.50
   clause 1(typeIR) = (w > 0)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:932.1-932.46
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:933.1-934.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:936.1-936.42
def $compat_bitslice_index(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:939.1-940.44
   clause 0(typeIR) = $compat'_bitslice_index($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:937.1-937.43
def $compat'_bitslice_index(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:941.1-941.40
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:942.1-942.47
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:943.1-943.47
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:944.1-945.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:947.1-947.48
def $is_valid_bitslice(typeIR, nat, nat) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:950.1-951.71
   clause 0(typeIR, n_lo, n_hi) = ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:948.1-948.49
def $is_valid_bitslice'(typeIR, nat, nat) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:952.1-952.42
   clause 0(typeIR, _nat, _nat') = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:953.1-955.37
   clause 1(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` w `>` = numberTypeIR
      -- let w_slice = ((n_hi - n_lo) + 1)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:956.1-958.37
   clause 2(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` w `>` = numberTypeIR
      -- let w_slice = ((n_hi - n_lo) + 1)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:959.1-960.15
   clause 3(_typeIR, _nat, _nat') = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1144.1-1144.46
def $is_concrete_extern_object(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1149.1-1150.50
   clause 0(typeIR) = $is_concrete_extern_object'($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1145.1-1145.47
def $is_concrete_extern_object'(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1152.1-1153.42
   clause 0(typeIR) = true
      -- if ~$is_extern_object_typeIR(typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1154.1-1155.58
   clause 1(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` _tid `{` _rid `:` routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} `}` = typeIR as externObjectTypeIR
      -- (if $is_concrete_extern_object''(routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*}

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1156.1-1157.15
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1146.1-1146.58
def $is_concrete_extern_object''(routineTypeDefIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1159.1-1160.49
   clause 0(routineTypeDefIR) = $is_concrete_extern_object'''(routineTypeIR)
      -- if routineTypeDefIR <: routineTypeIR
      -- let routineTypeIR = routineTypeDefIR as routineTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1161.1-1162.50
   clause 1(routineTypeDefIR) = (true = $is_concrete_extern_object'''(routineTypeIR))
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` _tid*{_tid <- _tid*} `,` _tid'*{_tid' <- _tid'*} `>` = routineTypeDefIR as polyRoutineTypeDefIR

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1147.1-1147.56
def $is_concrete_extern_object'''(routineTypeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1164.1-1164.79
   clause 0(routineTypeIR) = false
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)->` _typeIR = methodTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1165.1-1166.15
   clause 1(_routineTypeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.10-typing-statement.watsup:88.1-88.46
def $compat_direct_application(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:91.1-92.48
   clause 0(typeIR) = $compat'_direct_application($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:89.1-89.47
def $compat'_direct_application(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:93.1-93.54
   clause 0(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:94.1-94.55
   clause 1(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} `)` = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:95.1-96.15
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:154.1-154.81
def $split_constructors(methodPrototype*) : (methodPrototype*, methodPrototype*) =

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:156.1-156.42
   clause 0(methodPrototype*{methodPrototype <- methodPrototype*}) = ([], [])
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:157.1-162.48
   clause 1(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_h :: methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `%%(%);`
      -- let _annotationList _typeIdentifier `(` _parameterList `);` = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:163.1-168.48
   clause 2(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `%%;`
      -- let _annotationList _functionPrototype `;` = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:169.1-174.48
   clause 3(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `%ABSTRACT%;`
      -- let _annotationList `ABSTRACT` _functionPrototype `;` = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:7.1-7.52
def $compat_table_exact_optional_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:10.1-11.54
   clause 0(typeIR) = $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:8.1-8.53
def $compat'_table_exact_optional_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:12.1-12.51
   clause 0(typeIR) = true
      -- if (typeIR = `BOOL` as typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:13.1-13.52
   clause 1(typeIR) = true
      -- if (typeIR = `ERROR` as typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:14.1-14.59
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:15.1-16.45
   clause 3(typeIR') = $compat_table_exact_optional_key(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:17.1-17.60
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `ENUM%{%}`
      -- let `ENUM` _tid `{` _id*{_id <- _id*} `}` = enumTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:18.1-19.45
   clause 5(typeIR') = $compat_table_exact_optional_key(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:21.1-21.55
def $compat_table_lpm_ternary_range_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:24.1-25.57
   clause 0(typeIR) = $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:22.1-22.56
def $compat'_table_lpm_ternary_range_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:26.1-26.53
   clause 0(typeIR) = true
      -- if (typeIR = `INT` as typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:27.1-27.60
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `INT<%>`
      -- let `INT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:28.1-28.60
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `BIT<%>`
      -- let `BIT<` _nat `>` = numberTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:29.1-30.48
   clause 3(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` _tid typeIR = aliasTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:31.1-32.48
   clause 4(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `ENUM%#%{%}`
      -- let `ENUM` _tid `#` typeIR `{` _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} `}` = enumTypeIR

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:34.1-34.45
def $compat_table_key(nameIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:36.1-38.49
   clause 0(nameIR, typeIR) = true
      -- if ((nameIR = "exact") \/ (nameIR = "optional"))
      -- if $compat_table_exact_optional_key(typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:40.1-42.52
   clause 1(nameIR, typeIR) = true
      -- if (((nameIR = "lpm") \/ (nameIR = "ternary")) \/ (nameIR = "range"))
      -- if $compat_table_lpm_ternary_range_key(typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:44.1-45.15
   clause 2(nameIR, typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:87.1-88.41
def $split_dataplane_parameters(parameterTypeIR*) : (parameterTypeIR*, parameterTypeIR*) =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:90.1-90.50
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = ([], [])
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:91.1-95.56
   clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_h :: parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
      -- if direction matches ``EMPTY`
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:96.1-101.56
   clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_h :: parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
      -- if (direction =/= ``EMPTY`)
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:7.1-7.73
def $filter_default_parameters(parameterTypeIR*, id*) : parameterTypeIR* =

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:9.1-9.55
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = []
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:10.1-16.28
   clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let _direction _typeIR id_h _value?{_value <- _value?} = parameterTypeIR_h
      -- if id_h <- id_default*{id_default <- id_default*}

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:17.1-22.15
   clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- otherwise

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:26.1-26.71
def $align_parameters(parameterTypeIR*, argumentIR*) : parameterTypeIR* =

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:29.1-32.90
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}
      -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- (let parameterTypeIR'*{parameterTypeIR' <- parameterTypeIR'*} = $align_parameters'(`{` id `:` parameterTypeIR*{id <- id*, parameterTypeIR <- parameterTypeIR*} `}`, [parameterTypeIR], [argumentIR]))*{argumentIR <- argumentIR*, parameterTypeIR <- parameterTypeIR*, parameterTypeIR'* <- parameterTypeIR'**}
      -- (if parameterTypeIR'*{parameterTypeIR' <- parameterTypeIR'*} matches [ _/1 ])*{parameterTypeIR'* <- parameterTypeIR'**}
      -- (let [parameterTypeIR_aligned] = parameterTypeIR'*{parameterTypeIR' <- parameterTypeIR'*})*{parameterTypeIR'* <- parameterTypeIR'**, parameterTypeIR_aligned <- parameterTypeIR_aligned*}

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:27.1-27.98
def $align_parameters'(map<id, parameterTypeIR>, parameterTypeIR*, argumentIR*) : parameterTypeIR* =

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:34.1-35.20
   clause 0(_map<id, parameterTypeIR>, parameterTypeIR'*{parameterTypeIR' <- parameterTypeIR'*}, argumentIR'*{argumentIR' <- argumentIR'*}) = [parameterTypeIR]
      -- if parameterTypeIR'*{parameterTypeIR' <- parameterTypeIR'*} matches [ _/1 ]
      -- let [parameterTypeIR] = parameterTypeIR'*{parameterTypeIR' <- parameterTypeIR'*}
      -- if argumentIR'*{argumentIR' <- argumentIR'*} matches [ _/1 ]
      -- let [argumentIR] = argumentIR'*{argumentIR' <- argumentIR'*}
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:36.1-37.80
   clause 1(`{` id_param `:` parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} `}`, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, argumentIR'*{argumentIR' <- argumentIR'*}) = $find_map<id, parameterTypeIR>(`{` id_param `:` parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} `}`, nameIR) as parameterTypeIR*
      -- if argumentIR'*{argumentIR' <- argumentIR'*} matches [ _/1 ]
      -- let [argumentIR] = argumentIR'*{argumentIR' <- argumentIR'*}
      -- if argumentIR matches `%=%`
      -- let nameIR `=` _typedExpressionIR = argumentIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:38.1-39.80
   clause 2(`{` id_param `:` parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} `}`, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, argumentIR'*{argumentIR' <- argumentIR'*}) = $find_map<id, parameterTypeIR>(`{` id_param `:` parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} `}`, nameIR) as parameterTypeIR*
      -- if argumentIR'*{argumentIR' <- argumentIR'*} matches [ _/1 ]
      -- let [argumentIR] = argumentIR'*{argumentIR' <- argumentIR'*}
      -- if argumentIR matches `%=_`
      -- let nameIR `=_` = argumentIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:40.1-41.20
   clause 3(_map<id, parameterTypeIR>, parameterTypeIR'*{parameterTypeIR' <- parameterTypeIR'*}, argumentIR*{argumentIR <- argumentIR*}) = [parameterTypeIR]
      -- if parameterTypeIR'*{parameterTypeIR' <- parameterTypeIR'*} matches [ _/1 ]
      -- let [parameterTypeIR] = parameterTypeIR'*{parameterTypeIR' <- parameterTypeIR'*}
      -- if (argumentIR*{argumentIR <- argumentIR*} = [`_`])

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:6.1-7.12
syntax infer = 
   | `KNOWNAS` typeIR
   | `UNKNOWN`

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:9.21-9.36
syntax constraint = map<tid, infer>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:11.1-11.41
def $empty_constraint(tid*) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:12.1-12.53
   clause 0(tid*{tid <- tid*}) = `{` tid `:` `UNKNOWN`*{tid <- tid*} `}`

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:14.20-14.36
syntax inference = map<tid, typeIR>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:20.1-20.60
def $infer(tid*, parameterTypeIR*, argumentIR*) : inference =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:44.1-52.61
   clause 0(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = inference
      -- let constraint_init = $empty_constraint(tid_infer*{tid_infer <- tid_infer*})
      -- (let constraint_pair = $infer'(constraint_init, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, constraint_pair <- constraint_pair*, parameterTypeIR <- parameterTypeIR*}
      -- let constraint_inferred = $merge_constraints(constraint_init, constraint_pair*{constraint_pair <- constraint_pair*})
      -- let inference = $resolve_constraint(constraint_inferred)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:21.1-21.66
def $infer'(constraint, parameterTypeIR, argumentIR) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:54.1-57.51
   clause 0(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if argumentIR <: typedExpressionIR
      -- let typedExpressionIR = argumentIR as typedExpressionIR
      -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
      -- let _expressionIR `#` `(` typeIR_arg _ctk `)` = typedExpressionIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:59.1-62.51
   clause 1(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if argumentIR matches `%=%`
      -- let nameIR `=` typedExpressionIR = argumentIR
      -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
      -- let _expressionIR `#` `(` typeIR_arg _ctk `)` = typedExpressionIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:64.1-64.68
   clause 2(constraint, parameterTypeIR, argumentIR) = constraint
      -- if argumentIR matches `%=_`
      -- let nameIR `=_` = argumentIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:66.1-66.58
   clause 3(constraint, parameterTypeIR, argumentIR) = constraint
      -- if argumentIR matches `_`

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:23.1-23.66
def $gen_constraint_type(constraint, typeIR, typeIR) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:74.1-76.66
   clause 0(constraint, typeIR, typeIR_arg) = $update_map<tid, infer>(constraint, tid_param, `KNOWNAS` typeIR_arg)
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `TID%`
      -- let `TID` tid_param = namedTypeIR
      -- if $in_set<tid>(tid_param, $dom_map<tid, infer>(constraint))

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:78.1-99.26
   clause 1(constraint_0, typeIR, typeIR') = constraint_2
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_param `<` typeIR_param*{typeIR_param <- typeIR_param*} `>` = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_arg `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR'
      -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
      -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if ($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))
      -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)
      -- let constraint_2 = $gen_constraint_types(constraint_1, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:101.1-117.26
   clause 2(constraint_0, typeIR, typeIR') = constraint_1
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `%<%>`
      -- let polyTypeDefIR_param `<` typeIR_param*{typeIR_param <- typeIR_param*} `>` = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `%<%>`
      -- let polyTypeDefIR_arg `<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = namedTypeIR'
      -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
      -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if (~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))
      -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:121.1-122.63
   clause 3(constraint, typeIR, typeIR_arg) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR_param = aliasTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:124.1-125.63
   clause 4(constraint, typeIR_param, typeIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPEDEF%%`
      -- let `TYPEDEF` _tid typeIR_arg = aliasTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:127.1-128.63
   clause 5(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `TYPE%%`
      -- let `TYPE` tid typeIR_param = aliasTypeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR' = typeIR' as aliasTypeIR
      -- if aliasTypeIR' matches `TYPE%%`
      -- let `TYPE` tid' typeIR_arg = aliasTypeIR'
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:132.1-137.63
   clause 6(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: listTypeIR
      -- let `LIST<` typeIR_param `>` = typeIR as listTypeIR
      -- if typeIR' <: listTypeIR
      -- let `LIST<` typeIR_arg `>` = typeIR' as listTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:139.1-144.66
   clause 7(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: tupleTypeIR
      -- let `TUPLE<` typeIR_param*{typeIR_param <- typeIR_param*} `>` = typeIR as tupleTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TUPLE<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:146.1-151.63
   clause 8(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: headerStackTypeIR
      -- let typeIR_param `[` n_size `]` = typeIR as headerStackTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let typeIR_arg `[` n_size' `]` = typeIR' as headerStackTypeIR
      -- if (n_size = n_size')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:153.1-158.66
   clause 9(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: structTypeIR
      -- let `STRUCT` tid `{` typeIR_param id_field `;`*{id_field <- id_field*, typeIR_param <- typeIR_param*} `}` = typeIR as structTypeIR
      -- if typeIR' <: structTypeIR
      -- let `STRUCT` tid' `{` typeIR_arg id_field' `;`*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} `}` = typeIR' as structTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:160.1-165.66
   clause 10(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: headerTypeIR
      -- let `HEADER` tid `{` typeIR_param id_field `;`*{id_field <- id_field*, typeIR_param <- typeIR_param*} `}` = typeIR as headerTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HEADER` tid' `{` typeIR_arg id_field' `;`*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} `}` = typeIR' as headerTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:167.1-172.66
   clause 11(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: headerUnionTypeIR
      -- let `HEADER_UNION` tid `{` typeIR_param id_field `;`*{id_field <- id_field*, typeIR_param <- typeIR_param*} `}` = typeIR as headerUnionTypeIR
      -- if typeIR' <: headerUnionTypeIR
      -- let `HEADER_UNION` tid' `{` typeIR_arg id_field' `;`*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} `}` = typeIR' as headerUnionTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:176.1-185.6
   clause 12(constraint, typeIR, typeIR') = $gen_constraint_routines(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*})
      -- if typeIR <: externObjectTypeIR
      -- let `EXTERN` tid `{` rid `:` routineTypeDefIR_param*{rid <- rid*, routineTypeDefIR_param <- routineTypeDefIR_param*} `}` = typeIR as externObjectTypeIR
      -- if typeIR' <: externObjectTypeIR
      -- let `EXTERN` tid' `{` rid' `:` routineTypeDefIR_arg*{rid' <- rid'*, routineTypeDefIR_arg <- routineTypeDefIR_arg*} `}` = typeIR' as externObjectTypeIR
      -- (if (rid = rid'))*{rid <- rid*, rid' <- rid'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:187.1-194.58
   clause 13(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} `)` = typeIR as parserObjectTypeIR
      -- if typeIR' <: parserObjectTypeIR
      -- let `PARSER(` parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} `)` = typeIR' as parserObjectTypeIR
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:196.1-203.58
   clause 14(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} `)` = typeIR as controlObjectTypeIR
      -- if typeIR' <: controlObjectTypeIR
      -- let `CONTROL(` parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} `)` = typeIR' as controlObjectTypeIR
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:205.1-210.66
   clause 15(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR_param*{typeIR_param <- typeIR_param*} `>` = typeIR as packageObjectTypeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let `PACKAGE<` typeIR_arg*{typeIR_arg <- typeIR_arg*} `>` = typeIR' as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:214.1-216.15
   clause 16(constraint, typeIR_param, typeIR_arg) = constraint
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:24.1-24.69
def $gen_constraint_types(constraint, typeIR*, typeIR*) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:220.1-223.69
   clause 0(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
      -- (let constraint_pair = $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*{constraint_pair <- constraint_pair*, typeIR_arg <- typeIR_arg*, typeIR_param <- typeIR_param*}

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:25.1-28.15
def $gen_constraint_routine(constraint, routineTypeDefIR, routineTypeDefIR) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:227.1-238.77
   clause 0(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` _tid*{_tid <- _tid*} `,` _tid'*{_tid' <- _tid'*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} `)->` typeIR_ret_param = methodTypeIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR' `<` _tid''*{_tid'' <- _tid''*} `,` _tid'''*{_tid''' <- _tid'''*} `>` = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
      -- let `EXTERN_METHOD(` parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} `)->` typeIR_ret_arg = methodTypeIR'
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
      -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:240.1-251.77
   clause 1(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let routineTypeIR `<` _tid*{_tid <- _tid*} `,` _tid'*{_tid' <- _tid'*} `>` = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeIR <: methodTypeIR
      -- let methodTypeIR = routineTypeIR as methodTypeIR
      -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} `)->` typeIR_ret_param = methodTypeIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let routineTypeIR' `<` _tid''*{_tid'' <- _tid''*} `,` _tid'''*{_tid''' <- _tid'''*} `>` = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR' <: methodTypeIR
      -- let methodTypeIR' = routineTypeIR' as methodTypeIR
      -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
      -- let `EXTERN_METHODABSTRACT(` parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} `)->` typeIR_ret_arg = methodTypeIR'
      -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
      -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:29.1-32.15
def $gen_constraint_routines(constraint, routineTypeDefIR*, routineTypeDefIR*) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:255.1-266.12
   clause 0(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
      -- (let constraint_pair = $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*{constraint_pair <- constraint_pair*, routineTypeDefIR_arg <- routineTypeDefIR_arg*, routineTypeDefIR_param <- routineTypeDefIR_param*}

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:34.1-34.59
def $merge_constraint(constraint, constraint) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:272.1-276.52
   clause 0(constraint_pre, constraint_post) = $merge_constraint'(constraint_pre, constraint_post, tid_pre*{tid_pre <- tid_pre*}, `{` [] `}`)
      -- let `{` tid_pre*{tid_pre <- tid_pre*} `}` = $dom_map<tid, infer>(constraint_pre)
      -- let `{` tid_post*{tid_post <- tid_post*} `}` = $dom_map<tid, infer>(constraint_post)
      -- if $eq_set<tid>(`{` tid_pre*{tid_pre <- tid_pre*} `}`, `{` tid_post*{tid_post <- tid_post*} `}`)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:35.1-35.78
def $merge_constraint'(constraint, constraint, tid*, constraint) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:278.1-281.15
   clause 0(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = constraint
      -- if tid*{tid <- tid*} matches []

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:283.1-292.60
   clause 1(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if (?(`UNKNOWN`) = $find_map<tid, infer>(constraint_pre, tid_h))
      -- if (?(`UNKNOWN`) = $find_map<tid, infer>(constraint_post, tid_h))
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `UNKNOWN`)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:294.1-303.73
   clause 2(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if (?(`UNKNOWN`) = $find_map<tid, infer>(constraint_pre, tid_h))
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_post = infer
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWNAS` typeIR_post)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:305.1-314.72
   clause 3(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_pre = infer
      -- if (?(`UNKNOWN`) = $find_map<tid, infer>(constraint_post, tid_h))
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWNAS` typeIR_pre)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:316.1-326.73
   clause 4(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_pre = infer
      -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'''?{infer''' <- infer'''?} matches (_)
      -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
      -- if infer'' matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_post = infer''
      -- if Sub_impl: typeIR_pre `<:` typeIR_post holds
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWNAS` typeIR_post)

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:328.1-339.72
   clause 5(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_pre = infer
      -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'''?{infer''' <- infer'''?} matches (_)
      -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
      -- if infer'' matches `KNOWNAS%`
      -- let `KNOWNAS` typeIR_post = infer''
      -- if ~Sub_impl: typeIR_pre `<:` typeIR_post holds
      -- if Sub_impl: typeIR_post `<:` typeIR_pre holds
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWNAS` typeIR_pre)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:36.1-36.61
def $merge_constraints(constraint, constraint*) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:341.1-341.61
   clause 0(constraint_pre, constraint*{constraint <- constraint*}) = constraint_pre
      -- if constraint*{constraint <- constraint*} matches []

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:343.1-351.65
   clause 1(constraint_pre_0, constraint*{constraint <- constraint*}) = constraint_pre_2
      -- if constraint*{constraint <- constraint*} matches _ :: _
      -- let constraint_post_h :: constraint_post_t*{constraint_post_t <- constraint_post_t*} = constraint*{constraint <- constraint*}
      -- let constraint_pre_1 = $merge_constraint(constraint_pre_0, constraint_post_h)
      -- let constraint_pre_2 = $merge_constraints(constraint_pre_1, constraint_post_t*{constraint_post_t <- constraint_post_t*})

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:38.1-38.48
def $resolve_constraint(constraint) : inference =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:357.1-359.35
   clause 0(`{` tid `:` infer*{infer <- infer*, tid <- tid*} `}`) = `{` tid `:` typeIR*{tid <- tid*, typeIR <- typeIR*} `}`
      -- (let infer' = infer)*{infer <- infer*, infer' <- infer'*}
      -- (if infer' matches `KNOWNAS%`)*{infer' <- infer'*}
      -- (let `KNOWNAS` typeIR = infer')*{infer' <- infer'*, typeIR <- typeIR*}

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:8.1-11.34
syntax lvalueDyn = 
   | ``` nameIR
   | `.` nameIR
   | lvalueDyn `.` nameIR
   | lvalueDyn `[` value `]`
   | lvalueDyn `[` value `:` value `]`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:13.19-13.35
syntax stateDyn = blockStatementIR

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:15.14-15.19
syntax oid = name*

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:17.15-17.31
syntax venv = map<name, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:18.15-18.34
syntax senv = map<name, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:32.1-35.96
syntax funcDyn = 
   | `BUILTIN_FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementListIR `}`
   | `FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementListIR `}`
   | `ACTION(` parameterListIR `){` blockStatementIR `}`
   | `EXTERN_FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementIR? `}`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:38.1-43.41
syntax methodDyn = 
   | `BUILTIN_METHOD(` parameterListIR `)#` lvalueDyn
   | `EXTERN_METHOD<` typeParameterListIR `>(` parameterListIR `)`
   | `EXTERN_METHODABSTRACT<` typeParameterListIR `>(` parameterListIR `)`
   | `PARSER_APPLY(` parameterListIR `){` parserLocalDeclarationListIR `;` senv `}`
   | `CONTROL_APPLY(` parameterListIR `){` controlLocalDeclarationListIR `;` renv `;` blockElementStatementListIR `}`
   | `TABLE_APPLY{` tablePropertyListIR `}`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:46.1-47.14
syntax routineDyn = 
   | `BUILTIN_FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementListIR `}`
   | `FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementListIR `}`
   | `ACTION(` parameterListIR `){` blockStatementIR `}`
   | `EXTERN_FUNCTION<` typeParameterListIR `>(` parameterListIR `){` blockElementStatementIR? `}`
   | `BUILTIN_METHOD(` parameterListIR `)#` lvalueDyn
   | `EXTERN_METHOD<` typeParameterListIR `>(` parameterListIR `)`
   | `EXTERN_METHODABSTRACT<` typeParameterListIR `>(` parameterListIR `)`
   | `PARSER_APPLY(` parameterListIR `){` parserLocalDeclarationListIR `;` senv `}`
   | `CONTROL_APPLY(` parameterListIR `){` controlLocalDeclarationListIR `;` renv `;` blockElementStatementListIR `}`
   | `TABLE_APPLY{` tablePropertyListIR `}`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:49.15-49.35
syntax renv = map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:59.1-63.42
syntax consDyn = 
   | `EXTERN` nameIR `<` typeParameterListIR `>(` constructorParameterListIR `){` methodPrototypeListIR `}`
   | `PARSER<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` parserLocalDeclarationListIR parserStateListIR `}`
   | `CONTROL<` typeParameterListIR `>(` parameterListIR `)(` constructorParameterListIR `){` controlLocalDeclarationListIR `APPLY` controlBodyIR `}`
   | `PACKAGE<` typeParameterListIR `>(` constructorParameterListIR `)`
   | `TABLE` nameIR `{` tablePropertyListIR `}`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:65.15-65.32
syntax cenv = map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:75.1-79.39
syntax objDyn = 
   | `EXTERN` tid theta venv renv
   | `PARSER` venv parameterListIR parserLocalDeclarationListIR senv
   | `CONTROL` venv parameterListIR controlLocalDeclarationListIR renv controlBodyIR
   | `PACKAGE` theta venv
   | `TABLE` tid venv tablePropertyListIR

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:81.14-81.30
syntax sto = map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:82.1-82.23
def $empty_sto : sto =

   ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:83.1-83.43
   clause 0 = $empty_map<oid, objDyn>

;; ../../../../spec-concrete/6.02-context-inst.watsup:4.3-7.16
syntax glayerDyn = {`CENV` cenv, `TDENV` tdenv, `RENV` renv, `VENV` venv}

;; ../../../../spec-concrete/6.02-context-inst.watsup:12.3-15.16
syntax blayerDyn = {`THETA` theta, `RENV` renv, `SENV` senv, `VENV` venv}

;; ../../../../spec-concrete/6.02-context-inst.watsup:20.3-21.18
syntax llayerDyn = {`THETA` theta, `VENVS` venv*}

;; ../../../../spec-concrete/6.02-context-inst.watsup:28.3-31.22
syntax contextInst = {`PATH` oid, `GLOBAL` glayerDyn, `BLOCK` blayerDyn, `LOCAL` llayerDyn}

;; ../../../../spec-concrete/6.02-context-inst.watsup:39.1-39.36
def $empty_ctx_inst : contextInst =

;; ../../../../spec-concrete/6.02-context-inst.watsup:41.1-41.44
def $refresh_ctx_inst_empty : contextInst =

;; ../../../../spec-concrete/6.02-context-inst.watsup:43.1-43.54
def $copy_ctx_inst(cursor, contextInst) : contextInst =

;; ../../../../spec-concrete/6.02-context-inst.watsup:45.1-45.49
def $enter_frame_inst(contextInst) : contextInst =

;; ../../../../spec-concrete/6.02-context-inst.watsup:47.1-47.59
def $find_value_inst(cursor, contextInst, nameIR) : value? =

;; ../../../../spec-concrete/6.02-context-inst.watsup:48.1-48.67
def $find_typedef_inst(cursor, contextInst, typeName) : typeDefIR? =

;; ../../../../spec-concrete/6.02-context-inst.watsup:50.1-50.69
def $add_value_inst(cursor, contextInst, nameIR, value) : contextInst =

;; ../../../../spec-concrete/6.02-context-inst.watsup:51.1-51.72
def $add_values_inst(cursor, contextInst, nameIR*, value*) : contextInst =

;; ../../../../spec-concrete/6.02-context-inst.watsup:52.1-52.80
def $add_func_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

;; ../../../../spec-concrete/6.02-context-inst.watsup:53.1-53.84
def $add_func_non_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

;; ../../../../spec-concrete/6.02-context-inst.watsup:54.1-54.68
def $add_cons_inst(cursor, contextInst, cid, consDyn) : contextInst =

;; ../../../../spec-concrete/6.02-context-inst.watsup:55.1-55.73
def $add_typdef_inst(cursor, contextInst, name, typeDefIR) : contextInst =

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:3.1-5.17
relation Instantiate: `|-` p4programIR `==>` cenv tdenv renv venv sto

   ;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:1.1-6.30
   rule program: `|-` declarationIR*{declarationIR <- declarationIR*} `;` `==>` Ci'.GLOBAL.CENV Ci'.GLOBAL.TDENV Ci'.GLOBAL.RENV Ci'.GLOBAL.VENV sto'
      -- let Ci = $refresh_ctx_inst_empty
      -- let sto = $empty_sto
      -- Decls_inst: `GLOBAL` Ci sto `|-` declarationIR*{declarationIR <- declarationIR*} `==>` Ci' sto' declarationIR'*{declarationIR' <- declarationIR'*}
      -- if (declarationIR'*{declarationIR' <- declarationIR'*} = [])

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:7.1-9.35
relation Constructor_inst: cursor contextInst sto `|-` consDyn typeArgumentListIR argumentListIR name* `==>` sto objDyn

   ;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:35.1-39.67
   rule extern: p Ci sto `|-` consDyn typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} name_default*{name_default <- name_default*} `==>` sto' `EXTERN` nameIR Ci'.BLOCK.THETA Ci'.BLOCK.VENV Ci'.BLOCK.RENV
      -- if consDyn matches `EXTERN%<%>(%){%}`
      -- let `EXTERN` nameIR `<` typeParameterIR*{typeParameterIR <- typeParameterIR*} `>(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} `}` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`BLOCK`, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*}, sto)
      -- Methods_inst: `BLOCK` Ci_callee `|-` methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} `==>` Ci'

   ;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:41.1-46.85
   rule parser: p Ci sto `|-` consDyn typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} name_default*{name_default <- name_default*} `==>` sto''' `PARSER` Ci_callee.BLOCK.VENV parameterIR*{parameterIR <- parameterIR*} parserLocalDeclarationIR'*{parserLocalDeclarationIR' <- parserLocalDeclarationIR'*} Ci_state.BLOCK.SENV
      -- if consDyn matches `PARSER<%>(%)(%){%%}`
      -- let `PARSER<` typeParameterIR*{typeParameterIR <- typeParameterIR*} `>(` parameterIR*{parameterIR <- parameterIR*} `)(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} `}` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`BLOCK`, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*}, sto)
      -- ParserLocalDecls_inst: `BLOCK` Ci_callee sto' `|-` parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} `==>` Ci_local sto'' parserLocalDeclarationIR'*{parserLocalDeclarationIR' <- parserLocalDeclarationIR'*}
      -- ParserStates_inst: `BLOCK` Ci_local sto'' `|-` parserStateIR*{parserStateIR <- parserStateIR*} `==>` Ci_state sto'''

   ;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:48.1-53.97
   rule control: p Ci sto `|-` consDyn typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} name_default*{name_default <- name_default*} `==>` sto''' `CONTROL` Ci_callee.BLOCK.VENV parameterIR*{parameterIR <- parameterIR*} controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*} Ci_local.BLOCK.RENV controlBodyIR'
      -- if consDyn matches `CONTROL<%>(%)(%){%APPLY%}`
      -- let `CONTROL<` typeParameterIR*{typeParameterIR <- typeParameterIR*} `>(` parameterIR*{parameterIR <- parameterIR*} `)(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `){` controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} `APPLY` controlBodyIR `}` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`BLOCK`, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*}, sto)
      -- ControlLocalDecls_inst: `BLOCK` Ci_callee sto' `|-` controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} `==>` Ci_local sto'' controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*}
      -- Block_inst: `LOCAL` Ci_local sto'' true `|-` controlBodyIR `==>` Ci_block sto''' controlBodyIR'

   ;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:55.1-58.162
   rule package: p Ci sto `|-` consDyn typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} name_default*{name_default <- name_default*} `==>` sto' `PACKAGE` Ci_callee.BLOCK.THETA Ci_callee.BLOCK.VENV
      -- if consDyn matches `PACKAGE<%>(%)`
      -- let `PACKAGE<` typeParameterIR*{typeParameterIR <- typeParameterIR*} `>(` constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} `)` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`BLOCK`, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*}, sto)

   ;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:62.1-69.65
   rule table: p Ci sto `|-` consDyn typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} name_default*{name_default <- name_default*} `==>` sto' `TABLE` nameIR venv tablePropertyListIR''
      -- if consDyn matches `TABLE%{%}`
      -- let `TABLE` nameIR `{` tablePropertyListIR `}` = consDyn
      -- let (Ci_callee, sto') = $add_params_and_args_to_ctx(`LOCAL`, Ci, [], [], typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*}, sto)
      -- let Ci_frame = $enter_frame_inst(Ci_callee)
      -- Table_inst: `LOCAL` Ci_frame sto' `|-` tablePropertyListIR `==>` Ci_table sto'' tablePropertyListIR'
      -- let tablePropertyListIR'' = $init_table(tablePropertyListIR')
      -- let (venv'*{venv' <- venv'*}, _venv*{_venv <- _venv*}) = $partition_<venv>(Ci_table.LOCAL.VENVS, 1)
      -- if venv'*{venv' <- venv'*} matches [ _/1 ]
      -- let [venv] = venv'*{venv' <- venv'*}

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:19.1-21.26
relation Exprs_inst: cursor contextInst sto `|-` expressionIR* `==>` sto value*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:23.1-25.26
relation Expr_inst: cursor contextInst sto `|-` expressionIR `==>` sto value

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:27.1-29.26
relation Arg_inst: cursor contextInst sto `|-` argumentIR `==>` sto value

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:35.1-37.26
relation Decls_inst: cursor contextInst sto `|-` declarationIR* `==>` contextInst sto declarationIR*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:39.1-41.26
relation Decl_inst: cursor contextInst sto `|-` declarationIR `==>` contextInst sto declarationIR?

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:43.1-45.26
relation ParserLocalDecl_inst: cursor contextInst sto `|-` parserLocalDeclarationIR `==>` contextInst sto parserLocalDeclarationIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:47.1-49.26
relation ParserLocalDecls_inst: cursor contextInst sto `|-` parserLocalDeclarationListIR `==>` contextInst sto parserLocalDeclarationListIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:51.1-53.26
relation ControlLocalDecl_inst: cursor contextInst sto `|-` controlLocalDeclarationIR `==>` contextInst sto controlLocalDeclarationIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:55.1-57.26
relation ControlLocalDecls_inst: cursor contextInst sto `|-` controlLocalDeclarationListIR `==>` contextInst sto controlLocalDeclarationListIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:63.1-65.23
relation Methods_inst: cursor contextInst `|-` methodPrototypeIR* `==>` contextInst

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:67.1-69.23
relation Method_inst: cursor contextInst `|-` methodPrototypeIR `==>` contextInst

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:75.1-77.26
relation Stmts_inst: cursor contextInst sto `|-` blockElementStatementListIR `==>` contextInst sto blockElementStatementListIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:79.1-81.26
relation Stmt_inst: cursor contextInst sto `|-` blockElementStatementIR `==>` contextInst sto blockElementStatementIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:83.1-85.29
relation SwitchCases_inst: cursor contextInst sto `|-` expressionIR switchCaseIR* `==>` contextInst sto switchCaseIR*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:87.1-89.26
relation SwitchCase_inst: cursor contextInst sto `|-` switchCaseIR `==>` contextInst sto switchCaseIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:95.1-97.26
relation ParserState_inst: cursor contextInst sto `|-` parserStateIR `==>` contextInst sto

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:99.1-101.26
relation ParserStates_inst: cursor contextInst sto `|-` parserStateIR* `==>` contextInst sto

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:104.1-106.29
relation Block_inst: cursor contextInst sto bool `|-` blockStatementIR `==>` contextInst sto blockStatementIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:108.1-110.26
relation Table_inst: cursor contextInst sto `|-` tablePropertyListIR `==>` contextInst sto tablePropertyListIR

;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:8.1-8.91
def $add_params_inst(cursor, typeParameterIR*, typeArgumentIR*, contextInst) : contextInst =

;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:9.1-9.140
def $align_cparams_with_args(constructorParameterIR*, argumentIR*, name*) : (constructorParameterIR*, argumentIR*, constructorParameterIR*) =

;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:10.1-10.103
def $add_eval_args_to_ctx(contextInst, sto, constructorParameterIR*, argumentIR*) : (contextInst, sto) =

;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:11.1-11.90
def $add_default_values_to_ctx(contextInst, constructorParameterIR*, name*) : contextInst =

;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:13.1-13.159
def $add_params_and_args_to_ctx(cursor, contextInst, typeParameterIR*, constructorParameterIR*, typeArgumentIR*, argumentIR*, name*, sto) : (contextInst, sto) =

   ;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:14.1-19.111
   clause 0(cursor, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*}, sto) = (Ci_callee''', sto')
      -- if cursor matches `GLOBAL`
      -- let Ci_callee = $empty_ctx_inst
      -- let Ci_callee' = $add_params_inst(`GLOBAL`, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, Ci_callee)
      -- let (constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, argumentIR'*{argumentIR' <- argumentIR'*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*})
      -- let (Ci_callee'', sto') = $add_eval_args_to_ctx(Ci_callee', sto, constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, argumentIR'*{argumentIR' <- argumentIR'*})
      -- let Ci_callee''' = $add_default_values_to_ctx(Ci_callee'', constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, name_default*{name_default <- name_default*})

   ;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:21.1-26.111
   clause 1(cursor, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*}, sto) = (Ci_callee''', sto')
      -- if cursor matches `BLOCK`
      -- let Ci_callee = $copy_ctx_inst(`GLOBAL`, Ci)
      -- let Ci_callee' = $add_params_inst(`BLOCK`, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, Ci_callee)
      -- let (constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, argumentIR'*{argumentIR' <- argumentIR'*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*})
      -- let (Ci_callee'', sto') = $add_eval_args_to_ctx(Ci_callee', sto, constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, argumentIR'*{argumentIR' <- argumentIR'*})
      -- let Ci_callee''' = $add_default_values_to_ctx(Ci_callee'', constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, name_default*{name_default <- name_default*})

   ;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:28.1-33.111
   clause 2(cursor, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*}, sto) = (Ci_callee''', sto')
      -- if cursor matches `LOCAL`
      -- let Ci_callee = $copy_ctx_inst(`BLOCK`, Ci)
      -- let Ci_callee' = $add_params_inst(`LOCAL`, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, Ci_callee)
      -- let (constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, argumentIR'*{argumentIR' <- argumentIR'*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, name_default*{name_default <- name_default*})
      -- let (Ci_callee'', sto') = $add_eval_args_to_ctx(Ci_callee', sto, constructorParameterIR'*{constructorParameterIR' <- constructorParameterIR'*}, argumentIR'*{argumentIR' <- argumentIR'*})
      -- let Ci_callee''' = $add_default_values_to_ctx(Ci_callee'', constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, name_default*{name_default <- name_default*})

;; ../../../../spec-concrete/6.04-instantiation-cons.watsup:60.1-60.59
def $init_table(tablePropertyListIR) : tablePropertyListIR =
