;; ../../../../spec/0-aux.watsup:18.1-18.21
def $sum


;; ../../../../spec/0-aux.watsup:19.1-19.21
def $max


;; ../../../../spec/0-aux.watsup:20.1-20.21
def $min


;; ../../../../spec/0-aux.watsup:26.1-27.17
def $int_to_text


;; ../../../../spec/0-aux.watsup:29.1-30.17
def $concat_text(text*)
1. If text* matches [], then
  1. Return ""
1. Else
  1. Let t :: t'*{t' <- t'*} = text*
  2. Return t ++ $concat_text(t'*{t' <- t'*})

;; ../../../../spec/0-aux.watsup:35.1-35.37
def $strip_prefix


;; ../../../../spec/0-aux.watsup:36.1-36.37
def $strip_suffix


;; ../../../../spec/0-aux.watsup:42.1-42.23
def $init_(nat')
1. If (nat' = 0), then
  1. Return []
2. If (nat' > 0), then
  1. Return (nat' - 1) :: $init_((nat' - 1))

;; ../../../../spec/0-aux.watsup:47.1-47.29
def $repeat_<X>(X, nat')
1. If (nat' = 0), then
  1. Return []
2. If (nat' > 0), then
  1. Return [X] ++ $repeat_<X>(X, (nat' - 1))

;; ../../../../spec/0-aux.watsup:53.1-54.18
def $opt_<X>(X*)
1. If X* matches [], then
  1. Return ?()
1. Else If X* matches [ _/1 ], then
  1. Let [X] = X*
  2. Return ?(X)

;; ../../../../spec/0-aux.watsup:58.1-59.26
def $rev_<X>


;; ../../../../spec/0-aux.watsup:61.1-62.23
def $concat_<X>


;; ../../../../spec/0-aux.watsup:64.1-64.39
def $partition_<X>


;; ../../../../spec/0-aux.watsup:66.1-67.23
def $assoc_<X, Y>


;; ../../../../spec/0-aux.watsup:69.1-70.28
def $distinct_<K>


;; ../../../../spec/0-aux.watsup:77.3-77.55
syntax set<K> = 
   | `SET%`(K*)

;; ../../../../spec/0-aux.watsup:79.1-80.43
def $empty_set<K>
1. Return `SET%`_set<K>([])

;; ../../../../spec/0-aux.watsup:83.1-84.36
def $in_set<K>(K, `SET%`_set<K>(K'*{K' <- K'*}))
1. Return K <- K'*{K' <- K'*}

;; ../../../../spec/0-aux.watsup:87.1-88.37
def $intersect_set<K>


;; ../../../../spec/0-aux.watsup:90.1-91.37
def $union_set<K>


;; ../../../../spec/0-aux.watsup:93.1-94.37
def $unions_set<K>


;; ../../../../spec/0-aux.watsup:96.1-97.42
def $diff_set<K>


;; ../../../../spec/0-aux.watsup:99.1-100.40
def $sub_set<K>


;; ../../../../spec/0-aux.watsup:102.1-103.33
def $eq_set<K>


;; ../../../../spec/0-aux.watsup:111.5-112.38
syntax pair<K, V> = 
   | `PAIR%%`(K, V)

;; ../../../../spec/0-aux.watsup:116.3-117.43
syntax map<K, V> = 
   | `MAP%`(pair<K, V>*)

;; ../../../../spec/0-aux.watsup:119.1-120.43
def $empty_map<K, V>
1. Return `MAP%`_map<K, V>([])

;; ../../../../spec/0-aux.watsup:124.1-125.55
def $dom_map<K, V>(`MAP%`_map<K, V>(`PAIR%%`_pair<K, V>(K, _V)*{K <- K*, _V <- _V*}))
1. Return `SET%`_set<K>(K*{K <- K*})

;; ../../../../spec/0-aux.watsup:129.1-130.25
def $find_map_opt<K, V>


;; ../../../../spec/0-aux.watsup:132.1-133.25
def $find_maps_opt<K, V>


;; ../../../../spec/0-aux.watsup:135.1-136.24
def $find_map<K, V>(`MAP%`_map<K, V>(`PAIR%%`_pair<K, V>(K, V)*{K <- K*, V <- V*}), K_key)
1. Let V? = $find_map_opt<K, V>(`MAP%`_map<K, V>(`PAIR%%`_pair<K, V>(K, V)*{K <- K*, V <- V*}), K_key)
2. If V? matches (_), then
  1. Let ?(V_key) = V?
  2. Return V_key

;; ../../../../spec/0-aux.watsup:141.1-142.71
def $add_map<K, V>


;; ../../../../spec/0-aux.watsup:144.1-145.71
def $adds_map<K, V>


;; ../../../../spec/0-aux.watsup:147.1-148.71
def $update_map<K, V>


;; ../../../../spec/1a-syntax-el.watsup:5.15-5.18
syntax bits = int

;; ../../../../spec/1a-syntax-el.watsup:6.16-6.19
syntax width = nat

;; ../../../../spec/1a-syntax-el.watsup:9.1-11.39
syntax num = 
   | `INT%`(int)
   | `FINT%%`(width, bits)
   | `FBIT%%`(width, bits)

;; ../../../../spec/1a-syntax-el.watsup:21.13-21.17
syntax id = text

;; ../../../../spec/1a-syntax-el.watsup:28.1-29.29
syntax name = 
   | `TOP%`(id)
   | `CURRENT%`(id)

;; ../../../../spec/1a-syntax-el.watsup:35.17-35.19
syntax member = id

;; ../../../../spec/1a-syntax-el.watsup:41.20-41.22
syntax matchkind = id

;; ../../../../spec/1a-syntax-el.watsup:47.21-47.23
syntax statelabel = id

;; ../../../../spec/1a-syntax-el.watsup:54.1-57.35
syntax unop = 
   | `BNOT`()
   | `LNOT`()
   | `UPLUS`()
   | `UMINUS`()

;; ../../../../spec/1a-syntax-el.watsup:64.1-84.36
syntax binop = 
   | `PLUS`()
   | `SPLUS`()
   | `MINUS`()
   | `SMINUS`()
   | `MUL`()
   | `DIV`()
   | `MOD`()
   | `SHL`()
   | `SHR`()
   | `LE`()
   | `GE`()
   | `LT`()
   | `GT`()
   | `EQ`()
   | `NE`()
   | `BAND`()
   | `BXOR`()
   | `BOR`()
   | `CONCAT`()
   | `LAND`()
   | `LOR`()

;; ../../../../spec/1a-syntax-el.watsup:90.14-90.37
syntax dir = 
   | `NO`()
   | `IN`()
   | `OUT`()
   | `INOUT`()

;; ../../../../spec/1a-syntax-el.watsup:103.1-117.36
syntax type = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(expr)
   | `FBitT%`(expr)
   | `VBitT%`(expr)
   | `StackT%%`(type, expr)
   | `ListT%`(type)
   | `TupleT%`(type*)
   | `NameT%`(name)
   | `SpecT%%`(name, type*)
   | `AnyT`()

;; ../../../../spec/1a-syntax-el.watsup:123.17-123.19
syntax tparam = id

;; ../../../../spec/1a-syntax-el.watsup:129.16-129.33
syntax param = 
   | `%%%%`(id, dir, type, expr?)

;; ../../../../spec/1a-syntax-el.watsup:135.17-135.22
syntax cparam = param

;; ../../../../spec/1a-syntax-el.watsup:141.15-141.19
syntax targ = type

;; ../../../../spec/1a-syntax-el.watsup:148.1-150.33
syntax arg = 
   | `ExprA%`(expr)
   | `NameA%%`(id, expr?)
   | `AnyA`()

;; ../../../../spec/1a-syntax-el.watsup:157.1-159.29
syntax keyset = 
   | `ExprK%`(expr)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec/1a-syntax-el.watsup:165.21-165.39
syntax selectcase = 
   | `%%`(keyset*, statelabel)

;; ../../../../spec/1a-syntax-el.watsup:173.1-198.108
syntax expr = 
   | `BoolE%`(bool)
   | `StrE%`(text)
   | `NumE%`(num)
   | `NameE%`(name)
   | `SeqE%`(expr*)
   | `SeqDefaultE%`(expr*)
   | `RecordE%`((member, expr)*)
   | `RecordDefaultE%`((member, expr)*)
   | `DefaultE`()
   | `InvalidE`()
   | `UnE%%`(unop, expr)
   | `BinE%%%`(binop, expr, expr)
   | `TernE%%%`(expr, expr, expr)
   | `CastE%%`(type, expr)
   | `MaskE%%`(expr, expr)
   | `RangeE%%`(expr, expr)
   | `SelectE%%`(expr*, selectcase*)
   | `ArrAccE%%`(expr, expr)
   | `BitAccE%%%`(expr, expr, expr)
   | `ErrAccE%`(member)
   | `TypeAccE%%`(name, member)
   | `ExprAccE%%`(expr, member)
   | `CallFuncE%%%`(name, targ*, arg*)
   | `CallMethodE%%%%`(expr, member, targ*, arg*)
   | `CallTypeE%%%%`(name, member, targ*, arg*)
   | `InstE%%%`(name, targ*, arg*)

;; ../../../../spec/1a-syntax-el.watsup:204.16-204.71
syntax block = 
   | `BlockB%`(stmt*)

;; ../../../../spec/1a-syntax-el.watsup:211.1-222.55
syntax stmt = 
   | `EmptyS`()
   | `AssignS%%`(expr, expr)
   | `SwitchS%%`(expr, switchcase*)
   | `IfS%%%`(expr, stmt, stmt)
   | `BlockS%`(block)
   | `ExitS`()
   | `RetS%`(expr?)
   | `CallFuncS%%%`(name, targ*, arg*)
   | `CallMethodS%%%%`(expr, member, targ*, arg*)
   | `CallInstS%%%`(name, targ*, arg*)
   | `TransS%`(expr)
   | `DeclS%`(decl)

;; ../../../../spec/1a-syntax-el.watsup:229.1-230.35
syntax switchlabel = 
   | `ExprL%`(expr)
   | `DefaultL`()

;; ../../../../spec/1a-syntax-el.watsup:233.1-234.48
syntax switchcase = 
   | `MatchC%%`(switchlabel, block)
   | `FallC%`(switchlabel)

;; ../../../../spec/1a-syntax-el.watsup:240.22-240.38
syntax parserstate = 
   | `%%`(statelabel, block)

;; ../../../../spec/1a-syntax-el.watsup:246.14-246.22
syntax tbl = tblprop*

;; ../../../../spec/1a-syntax-el.watsup:252.17-252.31
syntax tblkey = 
   | `%%`(expr, matchkind)

;; ../../../../spec/1a-syntax-el.watsup:253.21-253.28
syntax tblkeyprop = tblkey*

;; ../../../../spec/1a-syntax-el.watsup:259.20-259.29
syntax tblaction = 
   | `%%`(name, arg*)

;; ../../../../spec/1a-syntax-el.watsup:260.24-260.34
syntax tblactionprop = tblaction*

;; ../../../../spec/1a-syntax-el.watsup:266.19-266.47
syntax tblentry = 
   | `%%%%`(bool, keyset*, tblaction, expr?)

;; ../../../../spec/1a-syntax-el.watsup:267.23-267.37
syntax tblentryprop = 
   | `%%`(bool, tblentry*)

;; ../../../../spec/1a-syntax-el.watsup:273.25-273.39
syntax tbldefaultprop = 
   | `%%`(bool, tblaction)

;; ../../../../spec/1a-syntax-el.watsup:279.24-279.40
syntax tblcustomprop = 
   | `%%%`(bool, member, expr)

;; ../../../../spec/1a-syntax-el.watsup:286.1-290.78
syntax tblprop = 
   | `KeyP%`(tblkeyprop)
   | `ActionP%`(tblactionprop)
   | `EntryP%`(tblentryprop)
   | `DefaultP%`(tbldefaultprop)
   | `CustomP%`(tblcustomprop)

;; ../../../../spec/1a-syntax-el.watsup:297.1-299.120
syntax method = 
   | `ExternConsM%%`(id, cparam*)
   | `ExternAbstractM%%%%`(id, type, tparam*, param*)
   | `ExternM%%%%`(id, type, tparam*, param*)

;; ../../../../spec/1a-syntax-el.watsup:308.1-330.136
syntax decl = 
   | `ConstD%%%`(id, type, expr)
   | `VarD%%%`(id, type, expr?)
   | `ErrD%`(member*)
   | `MatchKindD%`(member*)
   | `InstD%%%%%`(id, name, targ*, arg*, decl*)
   | `StructD%%%`(id, tparam*, (member, type)*)
   | `HeaderD%%%`(id, tparam*, (member, type)*)
   | `UnionD%%%`(id, tparam*, (member, type)*)
   | `EnumD%%`(id, member*)
   | `SEnumD%%%`(id, type, (member, expr)*)
   | `NewTypeD%%`(id, typedef)
   | `TypeDefD%%`(id, typedef)
   | `ValueSetD%%%`(id, type, expr)
   | `ParserTypeD%%%`(id, tparam*, param*)
   | `ParserD%%%%%`(id, param*, cparam*, decl*, parserstate*)
   | `TableD%%`(id, tbl)
   | `ControlTypeD%%%`(id, tparam*, param*)
   | `ControlD%%%%%`(id, param*, cparam*, decl*, block)
   | `ActionD%%%`(id, param*, block)
   | `FuncD%%%%%`(id, type, tparam*, param*, block)
   | `ExternFuncD%%%%`(id, type, tparam*, param*)
   | `ExternObjectD%%%`(id, tparam*, method*)
   | `PackageTypeD%%%`(id, tparam*, cparam*)

;; ../../../../spec/1a-syntax-el.watsup:333.1-334.15
syntax typedef = 
   | `TypeD%`(type)
   | `DeclD%`(decl)

;; ../../../../spec/1a-syntax-el.watsup:340.18-340.23
syntax program = decl*

;; ../../../../spec/1b-syntax-el-aux.watsup:5.1-6.27
def $is_boole(expr')
1. If expr' matches `BoolE%`, then
  1. Let `BoolE%`_expr(_bool) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:11.1-12.26
def $is_stre(expr')
1. If expr' matches `StrE%`, then
  1. Let `StrE%`_expr(_text) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:17.1-18.26
def $is_nume(expr')
1. If expr' matches `NumE%`, then
  1. Let `NumE%`_expr(_num) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:23.1-24.27
def $is_namee(expr')
1. If expr' matches `NameE%`, then
  1. Let `NameE%`_expr(_name) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:29.1-30.26
def $is_seqe(expr')
1. If expr' matches `SeqE%`, then
  1. Let `SeqE%`_expr(_expr*) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:35.1-36.34
def $is_seq_defaulte(expr')
1. If expr' matches `SeqDefaultE%`, then
  1. Let `SeqDefaultE%`_expr(_expr*) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:41.1-42.29
def $is_recorde(expr')
1. If expr' matches `RecordE%`, then
  1. Let `RecordE%`_expr(_(member, expr)*) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:47.1-48.37
def $is_record_defaulte(expr')
1. If expr' matches `RecordDefaultE%`, then
  1. Let `RecordDefaultE%`_expr(_(member, expr)*) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:53.1-54.30
def $is_defaulte(expr')
1. If expr' matches `DefaultE`, then
  1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:59.1-60.30
def $is_invalide(expr')
1. If expr' matches `InvalidE`, then
  1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:65.1-66.25
def $is_une(expr')
1. If expr' matches `UnE%%`, then
  1. Let `UnE%%`_expr(_unop, _expr) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:71.1-72.26
def $is_bine(expr')
1. If expr' matches `BinE%%%`, then
  1. Let `BinE%%%`_expr(_binop, _expr, _expr') = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:77.1-78.27
def $is_terne(expr')
1. If expr' matches `TernE%%%`, then
  1. Let `TernE%%%`_expr(_expr, _expr', _expr'') = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:83.1-84.27
def $is_caste(expr')
1. If expr' matches `CastE%%`, then
  1. Let `CastE%%`_expr(_type, _expr) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:89.1-90.27
def $is_maske(expr')
1. If expr' matches `MaskE%%`, then
  1. Let `MaskE%%`_expr(_expr, _expr') = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:95.1-96.28
def $is_rangee(expr')
1. If expr' matches `RangeE%%`, then
  1. Let `RangeE%%`_expr(_expr, _expr') = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:101.1-102.29
def $is_selecte(expr')
1. If expr' matches `SelectE%%`, then
  1. Let `SelectE%%`_expr(_expr*, _selectcase*) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:107.1-108.29
def $is_arracce(expr')
1. If expr' matches `ArrAccE%%`, then
  1. Let `ArrAccE%%`_expr(_expr, _expr') = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:113.1-114.29
def $is_bitacce(expr')
1. If expr' matches `BitAccE%%%`, then
  1. Let `BitAccE%%%`_expr(_expr, _expr', _expr'') = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:119.1-120.29
def $is_erracce(expr')
1. If expr' matches `ErrAccE%`, then
  1. Let `ErrAccE%`_expr(_member) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:125.1-126.30
def $is_typacce(expr')
1. If expr' matches `TypeAccE%%`, then
  1. Let `TypeAccE%%`_expr(_name, _member) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:131.1-132.30
def $is_expracce(expr')
1. If expr' matches `ExprAccE%%`, then
  1. Let `ExprAccE%%`_expr(_expr, _member) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:137.1-138.31
def $is_callfunce(expr')
1. If expr' matches `CallFuncE%%%`, then
  1. Let `CallFuncE%%%`_expr(_name, _targ*, _arg*) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:143.1-144.33
def $is_callmethode(expr')
1. If expr' matches `CallMethodE%%%%`, then
  1. Let `CallMethodE%%%%`_expr(_expr, _member, _targ*, _arg*) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:149.1-150.31
def $is_calltype(expr')
1. If expr' matches `CallTypeE%%%%`, then
  1. Let `CallTypeE%%%%`_expr(_name, _member, _targ*, _arg*) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:155.1-156.27
def $is_inste(expr')
1. If expr' matches `InstE%%%`, then
  1. Let `InstE%%%`_expr(_name, _targ*, _arg*) = expr'
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:165.1-166.17
def $string_of_name(name)
1. If name matches `TOP%`, then
  1. Let `TOP%`_name(id) = name
  2. Return $concat_text("." :: [id])
1. Else If name matches `CURRENT%`, then
  1. Let `CURRENT%`_name(id) = name
  2. Return id

;; ../../../../spec/1b-syntax-el-aux.watsup:175.1-176.17
def $id_of_name(name)
1. If name matches `TOP%`, then
  1. Let `TOP%`_name(id) = name
  2. Return id
1. Else If name matches `CURRENT%`, then
  1. Let `CURRENT%`_name(id) = name
  2. Return id

;; ../../../../spec/2a-runtime-domain.watsup:10.14-10.16
syntax tid = id

;; ../../../../spec/2a-runtime-domain.watsup:11.51-11.59
syntax tidset = set<tid>

;; ../../../../spec/2a-runtime-domain.watsup:13.1-14.27
def $fresh_tid


;; ../../../../spec/2a-runtime-domain.watsup:16.1-17.28
def $fresh_tids(nat')
1. If (nat' = 0), then
  1. Return []
2. Return $fresh_tid :: $fresh_tids((nat' - 1))

;; ../../../../spec/2a-runtime-domain.watsup:28.14-28.28
syntax fid = 
   | `%%`(id, (id, bool)*)

;; ../../../../spec/2a-runtime-domain.watsup:29.14-29.17
syntax cid = fid

;; ../../../../spec/2a-runtime-domain.watsup:33.1-33.30
def $to_fid(id, param*{param <- param*})
1. Return `%%`_fid(id, $to_fid'(param*{param <- param*}))

;; ../../../../spec/2a-runtime-domain.watsup:34.1-34.35
def $to_fid'(param*)
1. If param* matches [], then
  1. Return []
1. Else
  1. Let param_h :: param_t*{param_t <- param_t*} = param*
  2. Let `%%%%`_param(id, dir, type, expr?) = param_h
  3. If expr? matches (_), then
    1. Let ?(expr) = expr?
    2. Return (id, true) :: $to_fid'(param_t*{param_t <- param_t*})
  3. Else
    1. Return (id, false) :: $to_fid'(param_t*{param_t <- param_t*})

;; ../../../../spec/2a-runtime-domain.watsup:45.1-45.30
def $to_cid(id, param*{param <- param*})
1. Return $to_fid(id, param*{param <- param*})

;; ../../../../spec/2a-runtime-domain.watsup:53.14-53.17
syntax oid = id*

;; ../../../../spec/2b1-runtime-bitstr.watsup:5.17-5.20
syntax bitstr = int

;; ../../../../spec/2b1-runtime-bitstr.watsup:10.1-10.31
def $to_int


;; ../../../../spec/2b1-runtime-bitstr.watsup:14.1-14.34
def $to_bitstr


;; ../../../../spec/2b2-runtime-value.watsup:9.1-37.57
syntax val = 
   | `ErrV%`(member)
   | `MatchKindV%`(member)
   | `StrV%`(text)
   | `BoolV%`(bool)
   | `IntV%`(int)
   | `FIntV%%`(width, bitstr)
   | `FBitV%%`(width, bitstr)
   | `VBitV%%%`(width, width, bitstr)
   | `EnumFieldV%%`(id, member)
   | `SEnumFieldV%%%`(id, member, val)
   | `ListV%`(val*)
   | `TupleV%`(val*)
   | `StackV%%%`(val*, int, int)
   | `StructV%%`(id, (member, val)*)
   | `HeaderV%%`(id, (member, val)*)
   | `UnionV%%`(id, (member, val)*)
   | `RefV%`(oid)
   | `TableEnumFieldV%%`(id, member)
   | `TableStructV%%`(id, (member, val)*)
   | `SeqV%`(val*)
   | `SeqDefaultV%`(val*)
   | `RecordV%`((member, val)*)
   | `RecordDefaultV%`((member, val)*)
   | `DefaultV`()
   | `InvalidV`()
   | `SetV%`(setval)

;; ../../../../spec/2b2-runtime-value.watsup:40.1-42.83
syntax setval = 
   | `SingletonSet%`(val)
   | `MaskSet%%`(val, val)
   | `RangeSet%%`(val, val)

;; ../../../../spec/2b3-runtime-value-aux.watsup:3.1-3.24
def $get_num(val)
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i) = val
  2. Return i
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs) = val
  2. Return $to_int(w as int, bs)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(_width, bs) = val
  2. Return bs
1. Else If val matches `VBitV%%%`, then
  1. Let `VBitV%%%`_val(_width, _width', bs) = val
  2. Return bs

;; ../../../../spec/2c1-runtime-type.watsup:12.3-12.18
syntax paramtyp = 
   | `%%%%`(id, dir, typ, val?)

;; ../../../../spec/2c1-runtime-type.watsup:25.1-29.38
syntax primtyp = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()

;; ../../../../spec/2c1-runtime-type.watsup:32.1-35.78
syntax numtyp = 
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)

;; ../../../../spec/2c1-runtime-type.watsup:38.1-38.21
syntax basetyp = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)

;; ../../../../spec/2c1-runtime-type.watsup:45.1-46.98
syntax abstyp = 
   | `VarT%`(id)
   | `SpecT%%`(polytypdef, typ*)

;; ../../../../spec/2c1-runtime-type.watsup:53.1-53.57
syntax aliastyp = 
   | `DefT%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:56.1-64.89
syntax datatyp = 
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)

;; ../../../../spec/2c1-runtime-type.watsup:67.1-71.59
syntax objtyp = 
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%`(paramtyp*)
   | `ControlT%`(paramtyp*)
   | `PackageT%`(typ*)
   | `TableT%%`(id, typ)

;; ../../../../spec/2c1-runtime-type.watsup:74.1-74.32
syntax deftyp = 
   | `DefT%`(typ)
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%`(paramtyp*)
   | `ControlT%`(paramtyp*)
   | `PackageT%`(typ*)
   | `TableT%%`(id, typ)

;; ../../../../spec/2c1-runtime-type.watsup:81.1-91.55
syntax synthtyp = 
   | `DefaultT`()
   | `SeqT%`(typ*)
   | `SeqDefaultT%`(typ*)
   | `RecordT%`((member, typ)*)
   | `RecordDefaultT%`((member, typ)*)
   | `InvalidT`()
   | `SetT%`(typ)
   | `StateT`()
   | `TableEnumT%%`(id, member*)
   | `TableStructT%%`(id, (member, typ)*)
   | `AnyT`()

;; ../../../../spec/2c1-runtime-type.watsup:94.1-94.41
syntax typ = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)
   | `VarT%`(id)
   | `SpecT%%`(polytypdef, typ*)
   | `DefT%`(typ)
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%`(paramtyp*)
   | `ControlT%`(paramtyp*)
   | `PackageT%`(typ*)
   | `TableT%%`(id, typ)
   | `DefaultT`()
   | `SeqT%`(typ*)
   | `SeqDefaultT%`(typ*)
   | `RecordT%`((member, typ)*)
   | `RecordDefaultT%`((member, typ)*)
   | `InvalidT`()
   | `SetT%`(typ)
   | `StateT`()
   | `TableEnumT%%`(id, member*)
   | `TableStructT%%`(id, (member, typ)*)
   | `AnyT`()

;; ../../../../spec/2c1-runtime-type.watsup:101.3-101.12
syntax monotypdef = 
   | `MonoD%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:103.3-103.34
syntax polytypdef = 
   | `PolyD%->%`((tparam*, tparam*), typ)

;; ../../../../spec/2c1-runtime-type.watsup:106.1-107.15
syntax typdef = 
   | `MonoD%`(typ)
   | `PolyD%->%`((tparam*, tparam*), typ)

;; ../../../../spec/2c1-runtime-type.watsup:118.1-126.82
syntax functyp = 
   | `ActionT%`(paramtyp*)
   | `ExternFuncT%%`(paramtyp*, typ)
   | `FuncT%%`(paramtyp*, typ)
   | `BuiltinMethodT%%`(paramtyp*, typ)
   | `ExternMethodT%%`(paramtyp*, typ)
   | `ExternAbstractMethodT%%`(paramtyp*, typ)
   | `ParserApplyMethodT%`(paramtyp*)
   | `ControlApplyMethodT%`(paramtyp*)
   | `TableApplyMethodT%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:135.3-135.65
syntax monofuncdef = 
   | `MonoFD%`(functyp)

;; ../../../../spec/2c1-runtime-type.watsup:138.3-138.69
syntax polyfuncdef = 
   | `PolyFD%->%`((tparam*, tparam*), functyp)

;; ../../../../spec/2c1-runtime-type.watsup:141.1-142.16
syntax funcdef = 
   | `MonoFD%`(functyp)
   | `PolyFD%->%`((tparam*, tparam*), functyp)

;; ../../../../spec/2c1-runtime-type.watsup:155.3-155.52
syntax constyp = 
   | `ConsT%%`(paramtyp*, typ)

;; ../../../../spec/2c1-runtime-type.watsup:164.3-164.38
syntax consdef = 
   | `ConsD%->%`((tparam*, tparam*), constyp)

;; ../../../../spec/2c2-runtime-type-aux.watsup:7.1-8.30
def $is_base(typ)
1. If typ <: basetyp, then
  1. Let basetyp = typ as basetyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:13.1-14.35
def $is_prim(typ)
1. If typ <: primtyp, then
  1. Let primtyp = typ as primtyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:19.1-20.27
def $is_voidt(typ)
1. If (typ = `VoidT`_primtyp() as typ), then
  1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:25.1-26.26
def $is_errt(typ)
1. If (typ = `ErrT`_primtyp() as typ), then
  1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:31.1-32.33
def $is_matchkindt(typ)
1. If (typ = `MatchKindT`_primtyp() as typ), then
  1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:37.1-38.26
def $is_strt(typ)
1. If (typ = `StrT`_primtyp() as typ), then
  1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:43.1-44.27
def $is_boolt(typ)
1. If (typ = `BoolT`_primtyp() as typ), then
  1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:49.1-50.33
def $is_num(typ)
1. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:55.1-56.24
def $is_intt(typ)
1. If (typ = `IntT`_numtyp() as typ), then
  1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:61.1-62.25
def $is_fintt(typ)
1. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:67.1-68.27
def $is_fbitt(typ)
1. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:73.1-74.27
def $is_vbitt(typ)
1. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `VBitT%`, then
    1. Let `VBitT%`_numtyp(_width) = numtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:79.1-80.34
def $is_abstract(typ)
1. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:85.1-86.26
def $is_vart(typ)
1. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:91.1-92.27
def $is_spect(typ)
1. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `SpecT%%`, then
    1. Let `SpecT%%`_abstyp(_polytypdef, _typ*) = abstyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:97.1-98.33
def $is_def(typ)
1. If typ <: deftyp, then
  1. Let deftyp = typ as deftyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:103.1-104.31
def $is_alias(typ)
1. If typ <: aliastyp, then
  1. Let aliastyp = typ as aliastyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:109.1-110.26
def $is_deft(typ)
1. If typ <: aliastyp, then
  1. Let `DefT%`_aliastyp(_typ) = typ as aliastyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:115.1-116.30
def $is_data(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:121.1-122.26
def $is_newt(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:127.1-128.27
def $is_enumt(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(_id, _member*) = datatyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:133.1-134.28
def $is_senumt(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, _typ, _(member, val)*) = datatyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:139.1-140.27
def $is_listt(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `ListT%`, then
    1. Let `ListT%`_datatyp(_typ) = datatyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:145.1-146.28
def $is_tuplet(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(_typ*) = datatyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:151.1-152.28
def $is_stackt(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(_typ, _int) = datatyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:157.1-158.29
def $is_structt(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:163.1-164.29
def $is_headert(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:169.1-170.28
def $is_uniont(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:175.1-176.32
def $is_obj(typ)
1. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:181.1-182.29
def $is_externt(typ)
1. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(_id, _map<fid, funcdef>) = objtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:187.1-188.29
def $is_parsert(typ)
1. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `ParserT%`, then
    1. Let `ParserT%`_objtyp(_paramtyp*) = objtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:193.1-194.30
def $is_controlt(typ)
1. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `ControlT%`, then
    1. Let `ControlT%`_objtyp(_paramtyp*) = objtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:199.1-200.30
def $is_packaget(typ)
1. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `PackageT%`, then
    1. Let `PackageT%`_objtyp(_typ*) = objtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:205.1-206.28
def $is_tablet(typ)
1. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `TableT%%`, then
    1. Let `TableT%%`_objtyp(_id, _typ) = objtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:211.1-212.37
def $is_synth(typ)
1. If typ <: synthtyp, then
  1. Let synthtyp = typ as synthtyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:217.1-218.26
def $is_seqt(typ)
1. If typ <: synthtyp, then
  1. Let synthtyp = typ as synthtyp
  2. If synthtyp matches `SeqT%`, then
    1. Let `SeqT%`_synthtyp(_typ*) = synthtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:223.1-224.29
def $is_recordt(typ)
1. If typ <: synthtyp, then
  1. Let synthtyp = typ as synthtyp
  2. If synthtyp matches `RecordT%`, then
    1. Let `RecordT%`_synthtyp(_(member, typ)*) = synthtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:229.1-230.26
def $is_sett(typ)
1. If typ <: synthtyp, then
  1. Let synthtyp = typ as synthtyp
  2. If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(_typ) = synthtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:235.1-236.35
def $is_table_structt(typ)
1. If typ <: synthtyp, then
  1. Let synthtyp = typ as synthtyp
  2. If synthtyp matches `TableStructT%%`, then
    1. Let `TableStructT%%`_synthtyp(_id, _(member, typ)*) = synthtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:247.1-248.29
def $is_actiont(functyp)
1. If functyp matches `ActionT%`, then
  1. Let `ActionT%`_functyp(_paramtyp*) = functyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:253.1-254.34
def $is_externfunct(functyp)
1. If functyp matches `ExternFuncT%%`, then
  1. Let `ExternFuncT%%`_functyp(_paramtyp*, _typ) = functyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:259.1-260.27
def $is_funct(functyp)
1. If functyp matches `FuncT%%`, then
  1. Let `FuncT%%`_functyp(_paramtyp*, _typ) = functyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:265.1-266.37
def $is_builtinmethodt(functyp)
1. If functyp matches `BuiltinMethodT%%`, then
  1. Let `BuiltinMethodT%%`_functyp(_paramtyp*, _typ) = functyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:271.1-272.36
def $is_externmethodt(functyp)
1. If functyp matches `ExternMethodT%%`, then
  1. Let `ExternMethodT%%`_functyp(_paramtyp*, _typ) = functyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:277.1-278.45
def $is_externabstractmethodt(functyp)
1. If functyp matches `ExternAbstractMethodT%%`, then
  1. Let `ExternAbstractMethodT%%`_functyp(_paramtyp*, _typ) = functyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:283.1-284.42
def $is_parserapplymethodt(functyp)
1. If functyp matches `ParserApplyMethodT%`, then
  1. Let `ParserApplyMethodT%`_functyp(_paramtyp*) = functyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:289.1-290.43
def $is_controlapplymethodt(functyp)
1. If functyp matches `ControlApplyMethodT%`, then
  1. Let `ControlApplyMethodT%`_functyp(_paramtyp*) = functyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:295.1-296.41
def $is_tableapplymethodt(functyp)
1. If functyp matches `TableApplyMethodT%`, then
  1. Let `TableApplyMethodT%`_functyp(_typ) = functyp
  2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:303.1-304.38
def $get_params_functyp(functyp)
1. If functyp matches `ActionT%`, then
  1. Let `ActionT%`_functyp(pt*{pt <- pt*}) = functyp
  2. Return pt*{pt <- pt*}
1. Else If functyp matches `ExternFuncT%%`, then
  1. Let `ExternFuncT%%`_functyp(pt*{pt <- pt*}, _typ) = functyp
  2. Return pt*{pt <- pt*}
1. Else If functyp matches `FuncT%%`, then
  1. Let `FuncT%%`_functyp(pt*{pt <- pt*}, _typ) = functyp
  2. Return pt*{pt <- pt*}
1. Else If functyp matches `ExternMethodT%%`, then
  1. Let `ExternMethodT%%`_functyp(pt*{pt <- pt*}, _typ) = functyp
  2. Return pt*{pt <- pt*}
1. Else If functyp matches `ExternAbstractMethodT%%`, then
  1. Let `ExternAbstractMethodT%%`_functyp(pt*{pt <- pt*}, _typ) = functyp
  2. Return pt*{pt <- pt*}
1. Else If functyp matches `ParserApplyMethodT%`, then
  1. Let `ParserApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
  2. Return pt*{pt <- pt*}
1. Else If functyp matches `ControlApplyMethodT%`, then
  1. Let `ControlApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
  2. Return pt*{pt <- pt*}
1. Else If functyp matches `BuiltinMethodT%%`, then
  1. Let `BuiltinMethodT%%`_functyp(pt*{pt <- pt*}, _typ) = functyp
  2. Return pt*{pt <- pt*}
1. Else If functyp matches `TableApplyMethodT%`, then
  1. Let `TableApplyMethodT%`_functyp(_typ) = functyp
  2. Return []

;; ../../../../spec/2c2-runtime-type-aux.watsup:315.1-316.39
def $get_typ_ret_functyp(functyp)
1. If functyp matches `ActionT%`, then
  1. Let `ActionT%`_functyp(_paramtyp*) = functyp
  2. Return `VoidT`_primtyp() as typ
1. Else If functyp matches `ExternFuncT%%`, then
  1. Let `ExternFuncT%%`_functyp(_paramtyp*, typ_r) = functyp
  2. Return typ_r
1. Else If functyp matches `FuncT%%`, then
  1. Let `FuncT%%`_functyp(_paramtyp*, typ_r) = functyp
  2. Return typ_r
1. Else If functyp matches `ExternMethodT%%`, then
  1. Let `ExternMethodT%%`_functyp(_paramtyp*, typ_r) = functyp
  2. Return typ_r
1. Else If functyp matches `ExternAbstractMethodT%%`, then
  1. Let `ExternAbstractMethodT%%`_functyp(_paramtyp*, typ_r) = functyp
  2. Return typ_r
1. Else If functyp matches `ParserApplyMethodT%`, then
  1. Let `ParserApplyMethodT%`_functyp(_paramtyp*) = functyp
  2. Return `VoidT`_primtyp() as typ
1. Else If functyp matches `ControlApplyMethodT%`, then
  1. Let `ControlApplyMethodT%`_functyp(_paramtyp*) = functyp
  2. Return `VoidT`_primtyp() as typ
1. Else If functyp matches `BuiltinMethodT%%`, then
  1. Let `BuiltinMethodT%%`_functyp(_paramtyp*, typ_r) = functyp
  2. Return typ_r
1. Else If functyp matches `TableApplyMethodT%`, then
  1. Let `TableApplyMethodT%`_functyp(typ_r) = functyp
  2. Return typ_r

;; ../../../../spec/2c2-runtime-type-aux.watsup:333.1-334.38
def $get_params_funcdef(funcdef)
1. If funcdef <: monofuncdef, then
  1. Let `MonoFD%`_monofuncdef(ft) = funcdef as monofuncdef
  2. Return $get_params_functyp(ft)
2. If funcdef <: polyfuncdef, then
  1. Let `PolyFD%->%`_polyfuncdef(_(tparam*, tparam*), ft) = funcdef as polyfuncdef
  2. Return $get_params_functyp(ft)

;; ../../../../spec/2c2-runtime-type-aux.watsup:338.1-339.39
def $get_typ_ret_funcdef(funcdef)
1. If funcdef <: monofuncdef, then
  1. Let `MonoFD%`_monofuncdef(ft) = funcdef as monofuncdef
  2. Return $get_typ_ret_functyp(ft)
2. If funcdef <: polyfuncdef, then
  1. Let `PolyFD%->%`_polyfuncdef(_(tparam*, tparam*), ft) = funcdef as polyfuncdef
  2. Return $get_typ_ret_functyp(ft)

;; ../../../../spec/2c3-runtime-type-subst.watsup:5.45-5.57
syntax theta = map<id, typ>

;; ../../../../spec/2c3-runtime-type-subst.watsup:7.1-8.44
def $free_typ(typ'')
1. If typ'' <: basetyp, then
  1. Let basetyp = typ'' as basetyp
  2. Return `SET%`_set<tid>([])
2. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(id) = abstyp
    2. Return `SET%`_set<tid>([id])
  2. Else If abstyp matches `SpecT%%`, then
    1. Let `SpecT%%`_abstyp(ptd, typ''*{typ'' <- typ''*}) = abstyp
    2. Let tidset_ptd = $free_typdef_poly(ptd)
    3. Let tidset_typs = $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
    4. Return $union_set<tid>(tidset_ptd, tidset_typs)
3. If typ'' <: aliastyp, then
  1. Let `DefT%`_aliastyp(typ'') = typ'' as aliastyp
  2. Return $free_typ(typ'')
4. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ'') = datatyp
    2. Return $free_typ(typ'')
  2. Else If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(_id, _member*) = datatyp
    2. Return `SET%`_set<tid>([])
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, typ'', _(member, val)*) = datatyp
    2. Return $free_typ(typ'')
  2. Else If datatyp matches `ListT%`, then
    1. Let `ListT%`_datatyp(typ'') = datatyp
    2. Return $free_typ(typ'')
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ''*{typ'' <- typ''*}) = datatyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ'', _int) = datatyp
    2. Return $free_typ(typ'')
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
5. If typ'' <: objtyp, then
  1. Let objtyp = typ'' as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(_id, `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(_fid, fd)*{_fid <- _fid*, fd <- fd*})) = objtyp
    2. Return $unions_set<tid>($free_funcdef(fd)*{fd <- fd*})
  2. Else If objtyp matches `ParserT%`, then
    1. Let `ParserT%`_objtyp(pt*{pt <- pt*}) = objtyp
    2. (Let `%%%%`_paramtyp(_id, _dir, typ'', _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ'' <- typ''*}
    3. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If objtyp matches `ControlT%`, then
    1. Let `ControlT%`_objtyp(pt*{pt <- pt*}) = objtyp
    2. (Let `%%%%`_paramtyp(_id, _dir, typ'', _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ'' <- typ''*}
    3. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If objtyp matches `PackageT%`, then
    1. Let `PackageT%`_objtyp(typ''*{typ'' <- typ''*}) = objtyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If objtyp matches `TableT%%`, then
    1. Let `TableT%%`_objtyp(_id, typ'') = objtyp
    2. Return $free_typ(typ'')
6. If (typ'' = `DefaultT`_synthtyp() as typ), then
  1. Return `SET%`_set<tid>([])
7. If typ'' <: synthtyp, then
  1. Let synthtyp = typ'' as synthtyp
  2. If synthtyp matches `SeqT%`, then
    1. Let `SeqT%`_synthtyp(typ''*{typ'' <- typ''*}) = synthtyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If synthtyp matches `SeqDefaultT%`, then
    1. Let `SeqDefaultT%`_synthtyp(typ''*{typ'' <- typ''*}) = synthtyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If synthtyp matches `RecordT%`, then
    1. Let `RecordT%`_synthtyp((_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = synthtyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If synthtyp matches `RecordDefaultT%`, then
    1. Let `RecordDefaultT%`_synthtyp((_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = synthtyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
  2. Else If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ'') = synthtyp
    2. Return $free_typ(typ'')
  2. Else If synthtyp matches `TableEnumT%%`, then
    1. Let `TableEnumT%%`_synthtyp(_id, _member*) = synthtyp
    2. Return `SET%`_set<tid>([])
  2. Else If synthtyp matches `TableStructT%%`, then
    1. Let `TableStructT%%`_synthtyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = synthtyp
    2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})
8. If (typ'' = `InvalidT`_synthtyp() as typ), then
  1. Return `SET%`_set<tid>([])
9. If (typ'' = `StateT`_synthtyp() as typ), then
  1. Return `SET%`_set<tid>([])
10. If (typ'' = `AnyT`_synthtyp() as typ), then
  1. Return `SET%`_set<tid>([])

;; ../../../../spec/2c3-runtime-type-subst.watsup:9.1-10.44
def $free_typdef_poly(`PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ))
1. Let tidset_typ = $free_typ(typ)
2. Let tidset_tparams = `SET%`_set<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})
3. Return $diff_set<tid>(tidset_typ, tidset_tparams)

;; ../../../../spec/2c3-runtime-type-subst.watsup:11.1-12.44
def $free_functyp(functyp)
1. If functyp matches `ActionT%`, then
  1. Let `ActionT%`_functyp(pt*{pt <- pt*}) = functyp
  2. (Let `%%%%`_paramtyp(_id, _dir, typ, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ <- typ*}
  3. Return $unions_set<tid>($free_typ(typ)*{typ <- typ*})
1. Else If functyp matches `ExternFuncT%%`, then
  1. Let `ExternFuncT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. (Let `%%%%`_paramtyp(_id, _dir, typ_p, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}
  3. Let tidset_params = $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*})
  4. Let tidset_return = $free_typ(typ_r)
  5. Return $union_set<tid>(tidset_params, tidset_return)
1. Else If functyp matches `FuncT%%`, then
  1. Let `FuncT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. (Let `%%%%`_paramtyp(_id, _dir, typ_p, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}
  3. Let tidset_params = $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*})
  4. Let tidset_return = $free_typ(typ_r)
  5. Return $union_set<tid>(tidset_params, tidset_return)
1. Else If functyp matches `BuiltinMethodT%%`, then
  1. Let `BuiltinMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. (Let `%%%%`_paramtyp(_id, _dir, typ_p, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}
  3. Let tidset_params = $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*})
  4. Let tidset_return = $free_typ(typ_r)
  5. Return $union_set<tid>(tidset_params, tidset_return)
1. Else If functyp matches `ExternMethodT%%`, then
  1. Let `ExternMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. (Let `%%%%`_paramtyp(_id, _dir, typ_p, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}
  3. Let tidset_params = $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*})
  4. Let tidset_return = $free_typ(typ_r)
  5. Return $union_set<tid>(tidset_params, tidset_return)
1. Else If functyp matches `ExternAbstractMethodT%%`, then
  1. Let `ExternAbstractMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. (Let `%%%%`_paramtyp(_id, _dir, typ_p, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}
  3. Let tidset_params = $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*})
  4. Let tidset_return = $free_typ(typ_r)
  5. Return $union_set<tid>(tidset_params, tidset_return)
1. Else If functyp matches `ParserApplyMethodT%`, then
  1. Let `ParserApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
  2. (Let `%%%%`_paramtyp(_id, _dir, typ, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ <- typ*}
  3. Return $unions_set<tid>($free_typ(typ)*{typ <- typ*})
1. Else If functyp matches `ControlApplyMethodT%`, then
  1. Let `ControlApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
  2. (Let `%%%%`_paramtyp(_id, _dir, typ, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ <- typ*}
  3. Return $unions_set<tid>($free_typ(typ)*{typ <- typ*})
1. Else If functyp matches `TableApplyMethodT%`, then
  1. Let `TableApplyMethodT%`_functyp(typ) = functyp
  2. Return $free_typ(typ)

;; ../../../../spec/2c3-runtime-type-subst.watsup:13.1-14.44
def $free_funcdef(funcdef)
1. If funcdef <: monofuncdef, then
  1. Let `MonoFD%`_monofuncdef(ft) = funcdef as monofuncdef
  2. Return $free_functyp(ft)
2. If funcdef <: polyfuncdef, then
  1. Let `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), ft) = funcdef as polyfuncdef
  2. Let tidset_ft = $free_functyp(ft)
  3. Let tidset_tparams = `SET%`_set<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})
  4. Return $diff_set<tid>(tidset_ft, tidset_tparams)

;; ../../../../spec/2c3-runtime-type-subst.watsup:16.1-17.33
def $subst_typ(theta, typ''')
1. If typ''' <: abstyp, then
  1. Let abstyp = typ''' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(id) = abstyp
    2. If $in_set<id>(id, $dom_map<id, typ>(theta)), then
      1. Return $find_map<id, typ>(theta, id)
  2. Else If abstyp matches `SpecT%%`, then
    1. Let `SpecT%%`_abstyp(ptd, typ'''*{typ''' <- typ'''*}) = abstyp
    2. Let ptd' = $subst_typdef_poly(theta, ptd)
    3. Let typ'*{typ' <- typ'*} = $subst_typ(theta, typ''')*{typ''' <- typ'''*}
    4. Return `SpecT%%`_abstyp(ptd', typ'*{typ' <- typ'*}) as typ
2. If typ''' <: aliastyp, then
  1. Let `DefT%`_aliastyp(typ''') = typ''' as aliastyp
  2. Return $subst_typ(theta, typ''')
3. If typ''' <: datatyp, then
  1. Let datatyp = typ''' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(id, typ''') = datatyp
    2. Return `NewT%%`_datatyp(id, $subst_typ(theta, typ''')) as typ
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(id, typ''', (member, val)*{member <- member*, val <- val*}) = datatyp
    2. Return `SEnumT%%%`_datatyp(id, $subst_typ(theta, typ'''), (member, val)*{member <- member*, val <- val*}) as typ
  2. Else If datatyp matches `ListT%`, then
    1. Let `ListT%`_datatyp(typ''') = datatyp
    2. Return `ListT%`_datatyp($subst_typ(theta, typ''')) as typ
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ'''*{typ''' <- typ'''*}) = datatyp
    2. Return `TupleT%`_datatyp($subst_typ(theta, typ''')*{typ''' <- typ'''*}) as typ
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ''', int) = datatyp
    2. Return `StackT%%`_datatyp($subst_typ(theta, typ'''), int) as typ
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(id, (member, typ''')*{member <- member*, typ''' <- typ'''*}) = datatyp
    2. Return `StructT%%`_datatyp(id, (member, $subst_typ(theta, typ'''))*{member <- member*, typ''' <- typ'''*}) as typ
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(id, (member, typ''')*{member <- member*, typ''' <- typ'''*}) = datatyp
    2. Return `HeaderT%%`_datatyp(id, (member, $subst_typ(theta, typ'''))*{member <- member*, typ''' <- typ'''*}) as typ
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(id, (member, typ''')*{member <- member*, typ''' <- typ'''*}) = datatyp
    2. Return `UnionT%%`_datatyp(id, (member, $subst_typ(theta, typ'''))*{member <- member*, typ''' <- typ'''*}) as typ
4. If typ''' <: objtyp, then
  1. Let objtyp = typ''' as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(id, fmap) = objtyp
    2. Let `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid, funcdef)*{fid <- fid*, funcdef <- funcdef*}) = fmap
    3. Let fmap' = `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid, $subst_funcdef(theta, funcdef))*{fid <- fid*, funcdef <- funcdef*})
    4. Return `ExternT%%`_objtyp(id, fmap') as typ
  2. Else If objtyp matches `ParserT%`, then
    1. Let `ParserT%`_objtyp(pt*{pt <- pt*}) = objtyp
    2. (Let `%%%%`_paramtyp(id, dir, typ''', val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ''' <- typ'''*, val? <- val?*}
    3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ'''), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ''' <- typ'''*, val? <- val?*}
    4. Return `ParserT%`_objtyp(pt'*{pt' <- pt'*}) as typ
  2. Else If objtyp matches `ControlT%`, then
    1. Let `ControlT%`_objtyp(pt*{pt <- pt*}) = objtyp
    2. (Let `%%%%`_paramtyp(id, dir, typ''', val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ''' <- typ'''*, val? <- val?*}
    3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ'''), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ''' <- typ'''*, val? <- val?*}
    4. Return `ControlT%`_objtyp(pt'*{pt' <- pt'*}) as typ
  2. Else If objtyp matches `PackageT%`, then
    1. Let `PackageT%`_objtyp(typ'''*{typ''' <- typ'''*}) = objtyp
    2. Return `PackageT%`_objtyp($subst_typ(theta, typ''')*{typ''' <- typ'''*}) as typ
  2. Else If objtyp matches `TableT%%`, then
    1. Let `TableT%%`_objtyp(id, typ''') = objtyp
    2. Return `TableT%%`_objtyp(id, $subst_typ(theta, typ''')) as typ
5. If typ''' <: synthtyp, then
  1. Let synthtyp = typ''' as synthtyp
  2. If synthtyp matches `TableStructT%%`, then
    1. Let `TableStructT%%`_synthtyp(id, (member, typ''')*{member <- member*, typ''' <- typ'''*}) = synthtyp
    2. Return `TableStructT%%`_synthtyp(id, (member, $subst_typ(theta, typ'''))*{member <- member*, typ''' <- typ'''*}) as typ
  2. Else If synthtyp matches `SeqT%`, then
    1. Let `SeqT%`_synthtyp(typ'''*{typ''' <- typ'''*}) = synthtyp
    2. Return `SeqT%`_synthtyp($subst_typ(theta, typ''')*{typ''' <- typ'''*}) as typ
  2. Else If synthtyp matches `SeqDefaultT%`, then
    1. Let `SeqDefaultT%`_synthtyp(typ'''*{typ''' <- typ'''*}) = synthtyp
    2. Return `SeqDefaultT%`_synthtyp($subst_typ(theta, typ''')*{typ''' <- typ'''*}) as typ
  2. Else If synthtyp matches `RecordT%`, then
    1. Let `RecordT%`_synthtyp((member, typ''')*{member <- member*, typ''' <- typ'''*}) = synthtyp
    2. Return `RecordT%`_synthtyp((member, $subst_typ(theta, typ'''))*{member <- member*, typ''' <- typ'''*}) as typ
  2. Else If synthtyp matches `RecordDefaultT%`, then
    1. Let `RecordDefaultT%`_synthtyp((member, typ''')*{member <- member*, typ''' <- typ'''*}) = synthtyp
    2. Return `RecordDefaultT%`_synthtyp((member, $subst_typ(theta, typ'''))*{member <- member*, typ''' <- typ'''*}) as typ
  2. Else If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ''') = synthtyp
    2. Return `SetT%`_synthtyp($subst_typ(theta, typ''')) as typ
6. Otherwise
  1. Return typ'''

;; ../../../../spec/2c3-runtime-type-subst.watsup:18.1-19.33
def $subst_typdef_poly(theta, `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ))
1. Let `SET%`_set<tid>(tid_free*{tid_free <- tid_free*}) = $diff_set<tid>($free_typ(typ), `SET%`_set<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))
2. Let tidset_capture = $unions_set<tid>($free_typ($find_map<tid, typ>(theta, tid_free))*{tid_free <- tid_free*})
3. Let tparam'*{tparam' <- tparam'*} = $fresh_tids(|tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}|)
4. If (~ $in_set<tid>(tparam', tidset_capture))*{tparam' <- tparam'*}, then
  1. Let tparam''*{tparam'' <- tparam''*} = tparam'*{tparam' <- tparam'*}[0 : |tparam*{tparam <- tparam*}|]
  2. Let tparam''_hidden*{tparam''_hidden <- tparam''_hidden*} = tparam'*{tparam' <- tparam'*}[|tparam*{tparam <- tparam*}| : |tparam_hidden*{tparam_hidden <- tparam_hidden*}|]
  3. Let theta' = $adds_map<tid, typ>(theta, tparam*{tparam <- tparam*}, `VarT%`_abstyp(tparam'') as typ*{tparam'' <- tparam''*})
  4. Let theta'' = $adds_map<tid, typ>(theta', tparam_hidden*{tparam_hidden <- tparam_hidden*}, `VarT%`_abstyp(tparam''_hidden) as typ*{tparam''_hidden <- tparam''_hidden*})
  5. Let typ' = $subst_typ(theta'', typ)
  6. Return `PolyD%->%`_polytypdef((tparam''*{tparam'' <- tparam''*}, tparam''_hidden*{tparam''_hidden <- tparam''_hidden*}), typ')

;; ../../../../spec/2c3-runtime-type-subst.watsup:20.1-21.33
def $subst_funcdef(theta, funcdef)
1. If funcdef <: monofuncdef, then
  1. Let `MonoFD%`_monofuncdef(ft) = funcdef as monofuncdef
  2. Return `MonoFD%`_monofuncdef($subst_functyp(theta, ft)) as funcdef
2. If funcdef <: polyfuncdef, then
  1. Let `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), ft) = funcdef as polyfuncdef
  2. Let `SET%`_set<tid>(tid_free*{tid_free <- tid_free*}) = $diff_set<tid>($free_functyp(ft), `SET%`_set<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))
  3. Let tidset_capture = $unions_set<tid>($free_typ($find_map<tid, typ>(theta, tid_free))*{tid_free <- tid_free*})
  4. Let tparam'*{tparam' <- tparam'*} = $fresh_tids(|tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}|)
  5. If (~ $in_set<tid>(tparam', tidset_capture))*{tparam' <- tparam'*}, then
    1. Let tparam''*{tparam'' <- tparam''*} = tparam'*{tparam' <- tparam'*}[0 : |tparam*{tparam <- tparam*}|]
    2. Let tparam''_hidden*{tparam''_hidden <- tparam''_hidden*} = tparam'*{tparam' <- tparam'*}[|tparam*{tparam <- tparam*}| : |tparam_hidden*{tparam_hidden <- tparam_hidden*}|]
    3. Let theta' = $adds_map<tid, typ>(theta, tparam*{tparam <- tparam*}, `VarT%`_abstyp(tparam') as typ*{tparam' <- tparam'*})
    4. Let theta'' = $adds_map<tid, typ>(theta', tparam_hidden*{tparam_hidden <- tparam_hidden*}, `VarT%`_abstyp(tparam''_hidden) as typ*{tparam''_hidden <- tparam''_hidden*})
    5. Let ft' = $subst_functyp(theta'', ft)
    6. Return `PolyFD%->%`_polyfuncdef((tparam''*{tparam'' <- tparam''*}, tparam''_hidden*{tparam''_hidden <- tparam''_hidden*}), ft') as funcdef

;; ../../../../spec/2c3-runtime-type-subst.watsup:22.1-23.33
def $subst_functyp(theta, functyp)
1. If functyp matches `BuiltinMethodT%%`, then
  1. Let `BuiltinMethodT%%`_functyp(pt*{pt <- pt*}, typ) = functyp
  2. (Let `%%%%`_paramtyp(id, dir, typ_p, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}
  3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ_p), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}
  4. Return `BuiltinMethodT%%`_functyp(pt'*{pt' <- pt'*}, $subst_typ(theta, typ))
1. Else If functyp matches `ActionT%`, then
  1. Let `ActionT%`_functyp(pt*{pt <- pt*}) = functyp
  2. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ <- typ*, val? <- val?*}
  4. Return `ActionT%`_functyp(pt'*{pt' <- pt'*})
1. Else If functyp matches `ParserApplyMethodT%`, then
  1. Let `ParserApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
  2. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ <- typ*, val? <- val?*}
  4. Return `ParserApplyMethodT%`_functyp(pt'*{pt' <- pt'*})
1. Else If functyp matches `ControlApplyMethodT%`, then
  1. Let `ControlApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
  2. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ <- typ*, val? <- val?*}
  4. Return `ControlApplyMethodT%`_functyp(pt'*{pt' <- pt'*})
1. Else If functyp matches `TableApplyMethodT%`, then
  1. Let `TableApplyMethodT%`_functyp(typ) = functyp
  2. Return `TableApplyMethodT%`_functyp($subst_typ(theta, typ))
1. Else If functyp matches `ExternFuncT%%`, then
  1. Let `ExternFuncT%%`_functyp(pt*{pt <- pt*}, typ) = functyp
  2. (Let `%%%%`_paramtyp(id, dir, typ_p, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}
  3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ_p), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}
  4. Return `ExternFuncT%%`_functyp(pt'*{pt' <- pt'*}, $subst_typ(theta, typ))
1. Else If functyp matches `FuncT%%`, then
  1. Let `FuncT%%`_functyp(pt*{pt <- pt*}, typ) = functyp
  2. (Let `%%%%`_paramtyp(id, dir, typ_p, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}
  3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ_p), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}
  4. Return `FuncT%%`_functyp(pt'*{pt' <- pt'*}, $subst_typ(theta, typ))
1. Else If functyp matches `ExternMethodT%%`, then
  1. Let `ExternMethodT%%`_functyp(pt*{pt <- pt*}, typ) = functyp
  2. (Let `%%%%`_paramtyp(id, dir, typ_p, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}
  3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ_p), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}
  4. Return `ExternMethodT%%`_functyp(pt'*{pt' <- pt'*}, $subst_typ(theta, typ))
1. Else If functyp matches `ExternAbstractMethodT%%`, then
  1. Let `ExternAbstractMethodT%%`_functyp(pt*{pt <- pt*}, typ) = functyp
  2. (Let `%%%%`_paramtyp(id, dir, typ_p, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}
  3. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ_p), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}
  4. Return `ExternAbstractMethodT%%`_functyp(pt'*{pt' <- pt'*}, $subst_typ(theta, typ))

;; ../../../../spec/2c3-runtime-type-subst.watsup:24.1-25.33
def $subst_constyp(theta, `ConsT%%`_constyp(pt*{pt <- pt*}, typ))
1. (Let `%%%%`_paramtyp(id, dir, typ_p, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}
2. (Let pt' = `%%%%`_paramtyp(id, dir, $subst_typ(theta, typ_p), val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}
3. Return `ConsT%%`_constyp(pt'*{pt' <- pt'*}, $subst_typ(theta, typ))

;; ../../../../spec/2c3-runtime-type-subst.watsup:312.1-313.57
def $specialize_typdef(typdef, typ*')
1. If typdef <: monotypdef, then
  1. Let `MonoD%`_monotypdef(typ) = typdef as monotypdef
  2. If typ*' matches [], then
    1. Return typ
2. Let typ_a*{typ_a <- typ_a*} = typ*'
3. If typdef <: polytypdef, then
  1. Let `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ) = typdef as polytypdef
  2. Let tparam'*{tparam' <- tparam'*} = tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}
  3. Let theta = `MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam', typ_a)*{tparam' <- tparam'*, typ_a <- typ_a*})
  4. Return $subst_typ(theta, typ)

;; ../../../../spec/2c3-runtime-type-subst.watsup:324.1-325.57
def $specialize_funcdef(funcdef, typ*')
1. If funcdef <: monofuncdef, then
  1. Let `MonoFD%`_monofuncdef(ft) = funcdef as monofuncdef
  2. If typ*' matches [], then
    1. Return (ft, [])
2. Let typ_a*{typ_a <- typ_a*} = typ*'
3. If funcdef <: polyfuncdef, then
  1. Let `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), ft) = funcdef as polyfuncdef
  2. Let tparam'*{tparam' <- tparam'*} = tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}
  3. If (|tparam'*{tparam' <- tparam'*}| = |typ_a*{typ_a <- typ_a*}|), then
    1. Return ($subst_functyp(`MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam', typ_a)*{tparam' <- tparam'*, typ_a <- typ_a*}), ft), [])
  4. If ((|typ_a*{typ_a <- typ_a*}| = 0) /\ (|tparam'*{tparam' <- tparam'*}| > 0)), then
    1. Let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tparam'*{tparam' <- tparam'*}|)
    2. Return ($subst_functyp(`MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam', `VarT%`_abstyp(tid_fresh) as typ)*{tid_fresh <- tid_fresh*, tparam' <- tparam'*}), ft), tid_fresh*{tid_fresh <- tid_fresh*})
  5. If (((|typ_a*{typ_a <- typ_a*}| > 0) /\ (|tparam*{tparam <- tparam*}| = |typ_a*{typ_a <- typ_a*}|)) /\ (|tparam_hidden*{tparam_hidden <- tparam_hidden*}| > 0)), then
    1. Let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tparam_hidden*{tparam_hidden <- tparam_hidden*}|)
    2. Let typ_a'*{typ_a' <- typ_a'*} = typ_a*{typ_a <- typ_a*} ++ `VarT%`_abstyp(tid_fresh) as typ*{tid_fresh <- tid_fresh*}
    3. Return ($subst_functyp(`MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam', typ_a')*{tparam' <- tparam'*, typ_a' <- typ_a'*}), ft), tid_fresh*{tid_fresh <- tid_fresh*})

;; ../../../../spec/2c3-runtime-type-subst.watsup:351.1-352.57
def $specialize_consdef(`ConsD%->%`_consdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), ct), typ_a*{typ_a <- typ_a*})
1. Let tparam'*{tparam' <- tparam'*} = tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}
2. If (|tparam'*{tparam' <- tparam'*}| = |typ_a*{typ_a <- typ_a*}|), then
  1. Return ($subst_constyp(`MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam', typ_a)*{tparam' <- tparam'*, typ_a <- typ_a*}), ct), [])
3. If ((|typ_a*{typ_a <- typ_a*}| = 0) /\ (|tparam'*{tparam' <- tparam'*}| > 0)), then
  1. Let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tparam'*{tparam' <- tparam'*}|)
  2. Return ($subst_constyp(`MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam', `VarT%`_abstyp(tid_fresh) as typ)*{tid_fresh <- tid_fresh*, tparam' <- tparam'*}), ct), tid_fresh*{tid_fresh <- tid_fresh*})
4. If (((|typ_a*{typ_a <- typ_a*}| > 0) /\ (|tparam*{tparam <- tparam*}| = |typ_a*{typ_a <- typ_a*}|)) /\ (|tparam_hidden*{tparam_hidden <- tparam_hidden*}| > 0)), then
  1. Let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tparam_hidden*{tparam_hidden <- tparam_hidden*}|)
  2. Let typ_a'*{typ_a' <- typ_a'*} = typ_a*{typ_a <- typ_a*} ++ `VarT%`_abstyp(tid_fresh) as typ*{tid_fresh <- tid_fresh*}
  3. Return ($subst_constyp(`MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam', typ_a')*{tparam' <- tparam'*, typ_a' <- typ_a'*}), ct), tid_fresh*{tid_fresh <- tid_fresh*})

;; ../../../../spec/2c3-runtime-type-subst.watsup:376.1-377.47
def $canon_typ(typ'')
1. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `SpecT%%`, then
    1. Let `SpecT%%`_abstyp(ptd, typ_a*{typ_a <- typ_a*}) = abstyp
    2. Let typ = $specialize_typdef(ptd as typdef, typ_a*{typ_a <- typ_a*})
    3. Return $canon_typ(typ)
2. If typ'' <: aliastyp, then
  1. Let `DefT%`_aliastyp(typ) = typ'' as aliastyp
  2. Return $canon_typ(typ)
3. Otherwise
  1. Return typ''

;; ../../../../spec/2c4-runtime-type-util.watsup:7.1-8.28
def $is_nominal(typ)
1. Return $is_nominal'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:9.1-9.29
def $is_nominal'(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
  2. Else If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(_id, _member*) = datatyp
    2. Return true
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, _typ, _(member, val)*) = datatyp
    2. Return true
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
2. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(_id, _map<fid, funcdef>) = objtyp
    2. Return true
  2. Else If objtyp matches `TableT%%`, then
    1. Let `TableT%%`_objtyp(_id, _typ) = objtyp
    2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/2c4-runtime-type-util.watsup:25.1-26.32
def $is_deftable(typ)
1. Return $is_deftable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:27.1-27.30
def $is_deftable'(typ'')
1. If (typ'' = `ErrT`_primtyp() as typ), then
  1. Return true
2. If (typ'' = `StrT`_primtyp() as typ), then
  1. Return true
3. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return true
4. If (typ'' = `IntT`_numtyp() as typ), then
  1. Return true
5. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `VBitT%`, then
    1. Let `VBitT%`_numtyp(_width) = numtyp
    2. Return true
6. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ') = datatyp
    2. Return $is_deftable(typ')
  2. Else If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(_id, _member*) = datatyp
    2. Return true
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, typ', _(member, val)*) = datatyp
    2. Return $is_deftable(typ')
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ'*{typ' <- typ'*}) = datatyp
    2. If ($is_deftable(typ'))*{typ' <- typ'*}, then
      1. Return true
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ'', _int) = datatyp
    2. Return $is_deftable(typ'')
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. If ($is_deftable(typ''))*{typ'' <- typ''*}, then
      1. Return true
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. If ($is_deftable(typ''))*{typ'' <- typ''*}, then
      1. Return true
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. If ($is_deftable(typ''))*{typ'' <- typ''*}, then
      1. Return true
7. Otherwise
  1. Return false

;; ../../../../spec/2c4-runtime-type-util.watsup:54.1-55.30
def $is_equalable(typ)
1. Return $is_equalable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:56.1-56.31
def $is_equalable'(typ)
1. If (typ = `VoidT`_primtyp() as typ), then
  1. Return false
2. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return false
3. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(_id, _map<fid, funcdef>) = objtyp
    2. Return false
  2. Else If objtyp matches `ParserT%`, then
    1. Let `ParserT%`_objtyp(_paramtyp*) = objtyp
    2. Return false
  2. Else If objtyp matches `ControlT%`, then
    1. Let `ControlT%`_objtyp(_paramtyp*) = objtyp
    2. Return false
  2. Else If objtyp matches `PackageT%`, then
    1. Let `PackageT%`_objtyp(_typ*) = objtyp
    2. Return false
  2. Else If objtyp matches `TableT%%`, then
    1. Let `TableT%%`_objtyp(_id, _typ) = objtyp
    2. Return false
4. If typ <: synthtyp, then
  1. Let synthtyp = typ as synthtyp
  2. Return ($is_seqt(synthtyp as typ) \/ $is_recordt(synthtyp as typ))
5. Otherwise
  1. Return true

;; ../../../../spec/2c4-runtime-type-util.watsup:72.1-73.31
def $is_assignable(typ)
1. Return $is_assignable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:74.1-74.32
def $is_assignable'(typ)
1. If (typ = `VoidT`_primtyp() as typ), then
  1. Return false
2. If (typ = `StrT`_primtyp() as typ), then
  1. Return false
3. If (typ = `IntT`_numtyp() as typ), then
  1. Return false
4. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. Return false
5. If typ <: synthtyp, then
  1. Let synthtyp = typ as synthtyp
  2. Return false
6. Otherwise
  1. Return true

;; ../../../../spec/2c4-runtime-type-util.watsup:89.1-89.26
def $get_width(typ)
1. Return $get_width'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:90.1-90.27
def $get_width'(typ'')
1. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. Return w
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. Return w
  2. Else If numtyp matches `VBitT%`, then
    1. Let `VBitT%`_numtyp(w) = numtyp
    2. Return w
2. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ'') = datatyp
    2. Return $get_width(typ'')

;; ../../../../spec/2c5-runtime-type-alpha.watsup:5.1-7.20
relation Type_alpha: typ'', typ'''
1. If typ'' <: basetyp, then
  1. Let basetyp = typ'' as basetyp
  2. If typ''' <: basetyp, then
    1. Let basetyp' = typ''' as basetyp
    2. If (basetyp = basetyp'), then
      1. Result in 
2. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(id) = abstyp
    2. If typ''' <: abstyp, then
      1. Let abstyp' = typ''' as abstyp
      2. If abstyp' matches `VarT%`, then
        1. Let `VarT%`_abstyp(id') = abstyp'
        2. If (id = id'), then
          1. Result in 
  2. Else If abstyp matches `SpecT%%`, then
    1. Let `SpecT%%`_abstyp(ptd_a, typ_a*{typ_a <- typ_a*}) = abstyp
    2. If typ''' <: abstyp, then
      1. Let abstyp' = typ''' as abstyp
      2. If abstyp' matches `SpecT%%`, then
        1. Let `SpecT%%`_abstyp(ptd_b, typ_b*{typ_b <- typ_b*}) = abstyp'
        2. Let typ_a' = $specialize_typdef(ptd_a as typdef, typ_a*{typ_a <- typ_a*})
        3. Let typ_b' = $specialize_typdef(ptd_b as typdef, typ_b*{typ_b <- typ_b*})
        4. Type_alpha: `%~~%`(typ_a', typ_b')
        5. If ($is_nominal(typ_a') /\ $is_nominal(typ_b')), then
          1. (Type_alpha: `%~~%`(typ_a, typ_b))*{typ_a <- typ_a*, typ_b <- typ_b*}
          2. Result in 
        6. If (~ $is_nominal(typ_a') /\ ~ $is_nominal(typ_b')), then
          1. Result in 
3. If typ'' <: aliastyp, then
  1. Let `DefT%`_aliastyp(typ_a) = typ'' as aliastyp
  2. Type_alpha: `%~~%`(typ_a, typ''')
  3. Result in 
4. If typ''' <: aliastyp, then
  1. Let `DefT%`_aliastyp(typ''') = typ''' as aliastyp
  2. Type_alpha: `%~~%`(typ'', typ''')
  3. Result in 
5. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(id, typ'') = datatyp
    2. If typ''' <: datatyp, then
      1. Let datatyp' = typ''' as datatyp
      2. If datatyp' matches `NewT%%`, then
        1. Let `NewT%%`_datatyp(id', typ''') = datatyp'
        2. If (id = id'), then
          1. Type_alpha: `%~~%`(typ'', typ''')
          2. Result in 
  2. Else If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(id, member*{member <- member*}) = datatyp
    2. If typ''' <: datatyp, then
      1. Let datatyp' = typ''' as datatyp
      2. If datatyp' matches `EnumT%%`, then
        1. Let `EnumT%%`_datatyp(id', member'*{member' <- member'*}) = datatyp'
        2. If (id = id'), then
          1. If ((member = member'))*{member <- member*, member' <- member'*}, then
            1. Result in 
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(id, typ'', (member, val_a)*{member <- member*, val_a <- val_a*}) = datatyp
    2. If typ''' <: datatyp, then
      1. Let datatyp' = typ''' as datatyp
      2. If datatyp' matches `SEnumT%%%`, then
        1. Let `SEnumT%%%`_datatyp(id', typ''', (member', val_b)*{member' <- member'*, val_b <- val_b*}) = datatyp'
        2. If (id = id'), then
          1. If ((member = member'))*{member <- member*, member' <- member'*}, then
            1. Type_alpha: `%~~%`(typ'', typ''')
            2. If ((val_a = val_b))*{val_a <- val_a*, val_b <- val_b*}, then
              1. Result in 
  2. Else If datatyp matches `ListT%`, then
    1. Let `ListT%`_datatyp(typ'') = datatyp
    2. If typ''' <: datatyp, then
      1. Let datatyp' = typ''' as datatyp
      2. If datatyp' matches `ListT%`, then
        1. Let `ListT%`_datatyp(typ''') = datatyp'
        2. Type_alpha: `%~~%`(typ'', typ''')
        3. Result in 
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ''*{typ'' <- typ''*}) = datatyp
    2. If typ''' <: datatyp, then
      1. Let datatyp' = typ''' as datatyp
      2. If datatyp' matches `TupleT%`, then
        1. Let `TupleT%`_datatyp(typ'''*{typ''' <- typ'''*}) = datatyp'
        2. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
        3. Result in 
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ'', i_size) = datatyp
    2. If typ''' <: datatyp, then
      1. Let datatyp' = typ''' as datatyp
      2. If datatyp' matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ''', int) = datatyp'
        2. If (i_size = int), then
          1. Type_alpha: `%~~%`(typ'', typ''')
          2. Result in 
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(id, (member, typ'')*{member <- member*, typ'' <- typ''*}) = datatyp
    2. If typ''' <: datatyp, then
      1. Let datatyp' = typ''' as datatyp
      2. If datatyp' matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(id', (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) = datatyp'
        2. If (id = id'), then
          1. If ((member = member'))*{member <- member*, member' <- member'*}, then
            1. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
            2. Result in 
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(id, (member, typ'')*{member <- member*, typ'' <- typ''*}) = datatyp
    2. If typ''' <: datatyp, then
      1. Let datatyp' = typ''' as datatyp
      2. If datatyp' matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(id', (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) = datatyp'
        2. If (id = id'), then
          1. If ((member = member'))*{member <- member*, member' <- member'*}, then
            1. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
            2. Result in 
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(id, (member, typ'')*{member <- member*, typ'' <- typ''*}) = datatyp
    2. If typ''' <: datatyp, then
      1. Let datatyp' = typ''' as datatyp
      2. If datatyp' matches `UnionT%%`, then
        1. Let `UnionT%%`_datatyp(id', (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) = datatyp'
        2. If (id = id'), then
          1. If ((member = member'))*{member <- member*, member' <- member'*}, then
            1. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
            2. Result in 
6. If typ'' <: objtyp, then
  1. Let objtyp = typ'' as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(id, fmap_a) = objtyp
    2. If typ''' <: objtyp, then
      1. Let objtyp' = typ''' as objtyp
      2. If objtyp' matches `ExternT%%`, then
        1. Let `ExternT%%`_objtyp(id', fmap_b) = objtyp'
        2. If (id = id'), then
          1. Let `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid_a, fd_a)*{fd_a <- fd_a*, fid_a <- fid_a*}) = fmap_a
          2. Let `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid_b, fd_b)*{fd_b <- fd_b*, fid_b <- fid_b*}) = fmap_b
          3. If $eq_set<fid>(`SET%`_set<fid>(fid_a*{fid_a <- fid_a*}), `SET%`_set<fid>(fid_b*{fid_b <- fid_b*})), then
            1. (FuncDef_alpha: `%~~%`($find_map<fid, funcdef>(fmap_a, fid_a), $find_map<fid, funcdef>(fmap_b, fid_a)))*{fid_a <- fid_a*}
            2. Result in 
  2. Else If objtyp matches `ParserT%`, then
    1. Let `ParserT%`_objtyp(pt_a*{pt_a <- pt_a*}) = objtyp
    2. If typ''' <: objtyp, then
      1. Let objtyp' = typ''' as objtyp
      2. If objtyp' matches `ParserT%`, then
        1. Let `ParserT%`_objtyp(pt_b*{pt_b <- pt_b*}) = objtyp'
        2. (Let `%%%%`_paramtyp(_id, dir_a, typ'', _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ'' <- typ''*}
        3. (Let `%%%%`_paramtyp(_id', dir_b, typ''', _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ''' <- typ'''*}
        4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
          1. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
          2. Result in 
  2. Else If objtyp matches `ControlT%`, then
    1. Let `ControlT%`_objtyp(pt_a*{pt_a <- pt_a*}) = objtyp
    2. If typ''' <: objtyp, then
      1. Let objtyp' = typ''' as objtyp
      2. If objtyp' matches `ControlT%`, then
        1. Let `ControlT%`_objtyp(pt_b*{pt_b <- pt_b*}) = objtyp'
        2. (Let `%%%%`_paramtyp(_id, dir_a, typ'', _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ'' <- typ''*}
        3. (Let `%%%%`_paramtyp(_id', dir_b, typ''', _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ''' <- typ'''*}
        4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
          1. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
          2. Result in 
  2. Else If objtyp matches `PackageT%`, then
    1. Let `PackageT%`_objtyp(typ''*{typ'' <- typ''*}) = objtyp
    2. If typ''' <: objtyp, then
      1. Let objtyp' = typ''' as objtyp
      2. If objtyp' matches `PackageT%`, then
        1. Let `PackageT%`_objtyp(typ'''*{typ''' <- typ'''*}) = objtyp'
        2. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
        3. Result in 
  2. Else If objtyp matches `TableT%%`, then
    1. Let `TableT%%`_objtyp(id, typ'') = objtyp
    2. If typ''' <: objtyp, then
      1. Let objtyp' = typ''' as objtyp
      2. If objtyp' matches `TableT%%`, then
        1. Let `TableT%%`_objtyp(id', typ''') = objtyp'
        2. If (id = id'), then
          1. Type_alpha: `%~~%`(typ'', typ''')
          2. Result in 
7. If (typ'' = `DefaultT`_synthtyp() as typ), then
  1. If (typ''' = `DefaultT`_synthtyp() as typ), then
    1. Result in 
8. If typ'' <: synthtyp, then
  1. Let synthtyp = typ'' as synthtyp
  2. If synthtyp matches `SeqT%`, then
    1. Let `SeqT%`_synthtyp(typ''*{typ'' <- typ''*}) = synthtyp
    2. If typ''' <: synthtyp, then
      1. Let synthtyp' = typ''' as synthtyp
      2. If synthtyp' matches `SeqT%`, then
        1. Let `SeqT%`_synthtyp(typ'''*{typ''' <- typ'''*}) = synthtyp'
        2. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
        3. Result in 
  2. Else If synthtyp matches `SeqDefaultT%`, then
    1. Let `SeqDefaultT%`_synthtyp(typ''*{typ'' <- typ''*}) = synthtyp
    2. If typ''' <: synthtyp, then
      1. Let synthtyp' = typ''' as synthtyp
      2. If synthtyp' matches `SeqDefaultT%`, then
        1. Let `SeqDefaultT%`_synthtyp(typ'''*{typ''' <- typ'''*}) = synthtyp'
        2. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
        3. Result in 
  2. Else If synthtyp matches `RecordT%`, then
    1. Let `RecordT%`_synthtyp((member, typ'')*{member <- member*, typ'' <- typ''*}) = synthtyp
    2. If typ''' <: synthtyp, then
      1. Let synthtyp' = typ''' as synthtyp
      2. If synthtyp' matches `RecordT%`, then
        1. Let `RecordT%`_synthtyp((member', typ''')*{member' <- member'*, typ''' <- typ'''*}) = synthtyp'
        2. If ((member = member'))*{member <- member*, member' <- member'*}, then
          1. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
          2. Result in 
  2. Else If synthtyp matches `RecordDefaultT%`, then
    1. Let `RecordDefaultT%`_synthtyp((member, typ'')*{member <- member*, typ'' <- typ''*}) = synthtyp
    2. If typ''' <: synthtyp, then
      1. Let synthtyp' = typ''' as synthtyp
      2. If synthtyp' matches `RecordDefaultT%`, then
        1. Let `RecordDefaultT%`_synthtyp((member', typ''')*{member' <- member'*, typ''' <- typ'''*}) = synthtyp'
        2. If ((member = member'))*{member <- member*, member' <- member'*}, then
          1. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
          2. Result in 
  2. Else If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ'') = synthtyp
    2. If typ''' <: synthtyp, then
      1. Let synthtyp' = typ''' as synthtyp
      2. If synthtyp' matches `SetT%`, then
        1. Let `SetT%`_synthtyp(typ''') = synthtyp'
        2. Type_alpha: `%~~%`(typ'', typ''')
        3. Result in 
  2. Else If synthtyp matches `TableEnumT%%`, then
    1. Let `TableEnumT%%`_synthtyp(id, member*{member <- member*}) = synthtyp
    2. If typ''' <: synthtyp, then
      1. Let synthtyp' = typ''' as synthtyp
      2. If synthtyp' matches `TableEnumT%%`, then
        1. Let `TableEnumT%%`_synthtyp(id', member'*{member' <- member'*}) = synthtyp'
        2. If (id = id'), then
          1. If ((member = member'))*{member <- member*, member' <- member'*}, then
            1. Result in 
  2. Else If synthtyp matches `TableStructT%%`, then
    1. Let `TableStructT%%`_synthtyp(id, (member, typ'')*{member <- member*, typ'' <- typ''*}) = synthtyp
    2. If typ''' <: synthtyp, then
      1. Let synthtyp' = typ''' as synthtyp
      2. If synthtyp' matches `TableStructT%%`, then
        1. Let `TableStructT%%`_synthtyp(id', (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) = synthtyp'
        2. If (id = id'), then
          1. If ((member = member'))*{member <- member*, member' <- member'*}, then
            1. (Type_alpha: `%~~%`(typ'', typ'''))*{typ'' <- typ''*, typ''' <- typ'''*}
            2. Result in 
9. If (typ'' = `InvalidT`_synthtyp() as typ), then
  1. If (typ''' = `InvalidT`_synthtyp() as typ), then
    1. Result in 
10. If (typ'' = `StateT`_synthtyp() as typ), then
  1. If (typ''' = `StateT`_synthtyp() as typ), then
    1. Result in 
11. If (typ'' = `AnyT`_synthtyp() as typ), then
  1. If (typ''' = `AnyT`_synthtyp() as typ), then
    1. Result in 

;; ../../../../spec/2c5-runtime-type-alpha.watsup:9.1-11.20
relation FuncType_alpha: functyp, functyp'
1. If functyp matches `BuiltinMethodT%%`, then
  1. Let `BuiltinMethodT%%`_functyp(pt_a*{pt_a <- pt_a*}, typ_r_a) = functyp
  2. If functyp' matches `BuiltinMethodT%%`, then
    1. Let `BuiltinMethodT%%`_functyp(pt_b*{pt_b <- pt_b*}, typ_r_b) = functyp'
    2. (Let `%%%%`_paramtyp(_id, dir_a, typ_a, _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}
    3. (Let `%%%%`_paramtyp(_id', dir_b, typ_b, _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}
    4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
      1. (Type_alpha: `%~~%`(typ_a, typ_b))*{typ_a <- typ_a*, typ_b <- typ_b*}
      2. Type_alpha: `%~~%`(typ_r_a, typ_r_b)
      3. Result in 
1. Else If functyp matches `ActionT%`, then
  1. Let `ActionT%`_functyp(pt_a*{pt_a <- pt_a*}) = functyp
  2. If functyp' matches `ActionT%`, then
    1. Let `ActionT%`_functyp(pt_b*{pt_b <- pt_b*}) = functyp'
    2. (Let `%%%%`_paramtyp(_id, dir_a, typ_a, _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}
    3. (Let `%%%%`_paramtyp(_id', dir_b, typ_b, _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}
    4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
      1. (Type_alpha: `%~~%`(typ_a, typ_b))*{typ_a <- typ_a*, typ_b <- typ_b*}
      2. Result in 
1. Else If functyp matches `ParserApplyMethodT%`, then
  1. Let `ParserApplyMethodT%`_functyp(pt_a*{pt_a <- pt_a*}) = functyp
  2. If functyp' matches `ParserApplyMethodT%`, then
    1. Let `ParserApplyMethodT%`_functyp(pt_b*{pt_b <- pt_b*}) = functyp'
    2. (Let `%%%%`_paramtyp(_id, dir_a, typ_a, _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}
    3. (Let `%%%%`_paramtyp(_id', dir_b, typ_b, _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}
    4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
      1. (Type_alpha: `%~~%`(typ_a, typ_b))*{typ_a <- typ_a*, typ_b <- typ_b*}
      2. Result in 
1. Else If functyp matches `ControlApplyMethodT%`, then
  1. Let `ControlApplyMethodT%`_functyp(pt_a*{pt_a <- pt_a*}) = functyp
  2. If functyp' matches `ControlApplyMethodT%`, then
    1. Let `ControlApplyMethodT%`_functyp(pt_b*{pt_b <- pt_b*}) = functyp'
    2. (Let `%%%%`_paramtyp(_id, dir_a, typ_a, _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}
    3. (Let `%%%%`_paramtyp(_id', dir_b, typ_b, _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}
    4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
      1. (Type_alpha: `%~~%`(typ_a, typ_b))*{typ_a <- typ_a*, typ_b <- typ_b*}
      2. Result in 
1. Else If functyp matches `TableApplyMethodT%`, then
  1. Let `TableApplyMethodT%`_functyp(typ_a) = functyp
  2. If functyp' matches `TableApplyMethodT%`, then
    1. Let `TableApplyMethodT%`_functyp(typ_b) = functyp'
    2. Type_alpha: `%~~%`(typ_a, typ_b)
    3. Result in 
1. Else If functyp matches `ExternFuncT%%`, then
  1. Let `ExternFuncT%%`_functyp(pt_a*{pt_a <- pt_a*}, typ_r_a) = functyp
  2. If functyp' matches `ExternFuncT%%`, then
    1. Let `ExternFuncT%%`_functyp(pt_b*{pt_b <- pt_b*}, typ_r_b) = functyp'
    2. (Let `%%%%`_paramtyp(_id, dir_a, typ_a, _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}
    3. (Let `%%%%`_paramtyp(_id', dir_b, typ_b, _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}
    4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
      1. (Type_alpha: `%~~%`(typ_a, typ_b))*{typ_a <- typ_a*, typ_b <- typ_b*}
      2. Type_alpha: `%~~%`(typ_r_a, typ_r_b)
      3. Result in 
1. Else If functyp matches `FuncT%%`, then
  1. Let `FuncT%%`_functyp(pt_a*{pt_a <- pt_a*}, typ_r_a) = functyp
  2. If functyp' matches `FuncT%%`, then
    1. Let `FuncT%%`_functyp(pt_b*{pt_b <- pt_b*}, typ_r_b) = functyp'
    2. (Let `%%%%`_paramtyp(_id, dir_a, typ_a, _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}
    3. (Let `%%%%`_paramtyp(_id', dir_b, typ_b, _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}
    4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
      1. (Type_alpha: `%~~%`(typ_a, typ_b))*{typ_a <- typ_a*, typ_b <- typ_b*}
      2. Type_alpha: `%~~%`(typ_r_a, typ_r_b)
      3. Result in 
1. Else If functyp matches `ExternMethodT%%`, then
  1. Let `ExternMethodT%%`_functyp(pt_a*{pt_a <- pt_a*}, typ_r_a) = functyp
  2. If functyp' matches `ExternMethodT%%`, then
    1. Let `ExternMethodT%%`_functyp(pt_b*{pt_b <- pt_b*}, typ_r_b) = functyp'
    2. (Let `%%%%`_paramtyp(_id, dir_a, typ_a, _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}
    3. (Let `%%%%`_paramtyp(_id', dir_b, typ_b, _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}
    4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
      1. (Type_alpha: `%~~%`(typ_a, typ_b))*{typ_a <- typ_a*, typ_b <- typ_b*}
      2. Type_alpha: `%~~%`(typ_r_a, typ_r_b)
      3. Result in 
1. Else If functyp matches `ExternAbstractMethodT%%`, then
  1. Let `ExternAbstractMethodT%%`_functyp(pt_a*{pt_a <- pt_a*}, typ_r_a) = functyp
  2. If functyp' matches `ExternAbstractMethodT%%`, then
    1. Let `ExternAbstractMethodT%%`_functyp(pt_b*{pt_b <- pt_b*}, typ_r_b) = functyp'
    2. (Let `%%%%`_paramtyp(_id, dir_a, typ_a, _val?) = pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}
    3. (Let `%%%%`_paramtyp(_id', dir_b, typ_b, _val?') = pt_b)*{_id' <- _id'*, _val?' <- _val?'*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}
    4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then
      1. (Type_alpha: `%~~%`(typ_a, typ_b))*{typ_a <- typ_a*, typ_b <- typ_b*}
      2. Type_alpha: `%~~%`(typ_r_a, typ_r_b)
      3. Result in 

;; ../../../../spec/2c5-runtime-type-alpha.watsup:13.1-15.20
relation FuncDef_alpha: funcdef, funcdef'
1. If funcdef <: monofuncdef, then
  1. Let `MonoFD%`_monofuncdef(ft_a) = funcdef as monofuncdef
  2. If funcdef' <: monofuncdef, then
    1. Let `MonoFD%`_monofuncdef(ft_b) = funcdef' as monofuncdef
    2. FuncType_alpha: `%~~%`(ft_a, ft_b)
    3. Result in 
2. If funcdef <: polyfuncdef, then
  1. Let `PolyFD%->%`_polyfuncdef((tparam_a*{tparam_a <- tparam_a*}, tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*}), ft_a) = funcdef as polyfuncdef
  2. If funcdef' <: polyfuncdef, then
    1. Let `PolyFD%->%`_polyfuncdef((tparam_b*{tparam_b <- tparam_b*}, tparam_hidden_b*{tparam_hidden_b <- tparam_hidden_b*}), ft_b) = funcdef' as polyfuncdef
    2. If (|tparam_a*{tparam_a <- tparam_a*}| = |tparam_b*{tparam_b <- tparam_b*}|), then
      1. If (|tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*}| = |tparam_hidden_b*{tparam_hidden_b <- tparam_hidden_b*}|), then
        1. Let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tparam_a*{tparam_a <- tparam_a*} ++ tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*}|)
        2. Let tparam_a'*{tparam_a' <- tparam_a'*} = tparam_a*{tparam_a <- tparam_a*} ++ tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*}
        3. Let ft_a' = $subst_functyp(`MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam_a', `VarT%`_abstyp(tid_fresh) as typ)*{tid_fresh <- tid_fresh*, tparam_a' <- tparam_a'*}), ft_a)
        4. Let tparam_b'*{tparam_b' <- tparam_b'*} = tparam_b*{tparam_b <- tparam_b*} ++ tparam_hidden_b*{tparam_hidden_b <- tparam_hidden_b*}
        5. Let ft_b' = $subst_functyp(`MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam_b', `VarT%`_abstyp(tid_fresh) as typ)*{tid_fresh <- tid_fresh*, tparam_b' <- tparam_b'*}), ft_b)
        6. FuncType_alpha: `%~~%`(ft_a', ft_b')
        7. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:5.1-5.39
relation Type_wf: tidset, typ'''''
1. If typ''''' <: basetyp, then
  1. Let basetyp = typ''''' as basetyp
  2. Result in 
2. If typ''''' <: abstyp, then
  1. Let abstyp = typ''''' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(tid) = abstyp
    2. If $in_set<tid>(tid, tidset), then
      1. Result in 
  2. Else If abstyp matches `SpecT%%`, then
    1. Let `SpecT%%`_abstyp(ptd, typ_a*{typ_a <- typ_a*}) = abstyp
    2. Let typ''''' = $specialize_typdef(ptd as typdef, typ_a*{typ_a <- typ_a*})
    3. Type_wf: `%|-%`(tidset, typ''''')
    4. Result in 
3. If typ''''' <: aliastyp, then
  1. Let `DefT%`_aliastyp(typ''''') = typ''''' as aliastyp
  2. If $nestable_deft(typ'''''), then
    1. Type_wf: `%|-%`(tidset, typ''''')
    2. Result in 
4. If typ''''' <: datatyp, then
  1. Let datatyp = typ''''' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ''''') = datatyp
    2. If $nestable_newt(typ'''''), then
      1. Type_wf: `%|-%`(tidset, typ''''')
      2. Result in 
  2. Else If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(_id, member*{member <- member*}) = datatyp
    2. If $distinct_<member>(member*{member <- member*}), then
      1. Result in 
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, typ''''', (member, val)*{member <- member*, val <- val*}) = datatyp
    2. If $distinct_<member>(member*{member <- member*}), then
      1. If $nestable_senumt(typ'''''), then
        1. Type_wf: `%|-%`(tidset, typ''''')
        2. Result in 
  2. Else If datatyp matches `ListT%`, then
    1. Let `ListT%`_datatyp(typ''''') = datatyp
    2. If $nestable_listt(typ'''''), then
      1. Type_wf: `%|-%`(tidset, typ''''')
      2. Result in 
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ'''''*{typ''''' <- typ'''''*}) = datatyp
    2. If ($nestable_tuplet(typ'''''))*{typ''''' <- typ'''''*}, then
      1. (Type_wf: `%|-%`(tidset, typ'''''))*{typ''''' <- typ'''''*}
      2. Result in 
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ''''', i_size) = datatyp
    2. If (i_size >= 0 as int), then
      1. If $nestable_stackt(typ'''''), then
        1. Type_wf: `%|-%`(tidset, typ''''')
        2. Result in 
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, (member, typ''''')*{member <- member*, typ''''' <- typ'''''*}) = datatyp
    2. If $distinct_<member>(member*{member <- member*}), then
      1. If ($nestable_structt(typ'''''))*{typ''''' <- typ'''''*}, then
        1. (Type_wf: `%|-%`(tidset, typ'''''))*{typ''''' <- typ'''''*}
        2. Result in 
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, (member, typ''''')*{member <- member*, typ''''' <- typ'''''*}) = datatyp
    2. If $distinct_<member>(member*{member <- member*}), then
      1. If ($nestable_headert(typ'''''))*{typ''''' <- typ'''''*}, then
        1. (Type_wf: `%|-%`(tidset, typ'''''))*{typ''''' <- typ'''''*}
        2. Result in 
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(_id, (member, typ''''')*{member <- member*, typ''''' <- typ'''''*}) = datatyp
    2. If $distinct_<member>(member*{member <- member*}), then
      1. If ($nestable_uniont(typ'''''))*{typ''''' <- typ'''''*}, then
        1. (Type_wf: `%|-%`(tidset, typ'''''))*{typ''''' <- typ'''''*}
        2. Result in 
5. If typ''''' <: objtyp, then
  1. Let objtyp = typ''''' as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(_id, fmap) = objtyp
    2. Let `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid, funcdef)*{fid <- fid*, funcdef <- funcdef*}) = fmap
    3. (FuncDef_wf: `%|-%`(tidset, funcdef))*{funcdef <- funcdef*}
    4. Result in 
  2. Else If objtyp matches `ParserT%`, then
    1. Let `ParserT%`_objtyp(pt*{pt <- pt*}) = objtyp
    2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
    3. Result in 
  2. Else If objtyp matches `ControlT%`, then
    1. Let `ControlT%`_objtyp(pt*{pt <- pt*}) = objtyp
    2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
    3. Result in 
  2. Else If objtyp matches `PackageT%`, then
    1. Let `PackageT%`_objtyp(typ'''''*{typ''''' <- typ'''''*}) = objtyp
    2. (Type_wf: `%|-%`(tidset, typ'''''))*{typ''''' <- typ'''''*}
    3. Result in 
  2. Else If objtyp matches `TableT%%`, then
    1. Let `TableT%%`_objtyp(_id, typ''''') = objtyp
    2. Let typ''''' = $canon_typ(typ''''')
    3. If $is_table_structt(typ'''''), then
      1. Type_wf: `%|-%`(tidset, typ''''')
      2. Result in 
6. If (typ''''' = `DefaultT`_synthtyp() as typ), then
  1. Result in 
7. If typ''''' <: synthtyp, then
  1. Let synthtyp = typ''''' as synthtyp
  2. If synthtyp matches `SeqT%`, then
    1. Let `SeqT%`_synthtyp(typ'''''*{typ''''' <- typ'''''*}) = synthtyp
    2. (Type_wf: `%|-%`(tidset, typ'''''))*{typ''''' <- typ'''''*}
    3. Result in 
  2. Else If synthtyp matches `SeqDefaultT%`, then
    1. Let `SeqDefaultT%`_synthtyp(typ'''''*{typ''''' <- typ'''''*}) = synthtyp
    2. (Type_wf: `%|-%`(tidset, typ'''''))*{typ''''' <- typ'''''*}
    3. Result in 
  2. Else If synthtyp matches `RecordT%`, then
    1. Let `RecordT%`_synthtyp((member, typ''''')*{member <- member*, typ''''' <- typ'''''*}) = synthtyp
    2. If $distinct_<member>(member*{member <- member*}), then
      1. (Type_wf: `%|-%`(tidset, typ'''''))*{typ''''' <- typ'''''*}
      2. Result in 
  2. Else If synthtyp matches `RecordDefaultT%`, then
    1. Let `RecordDefaultT%`_synthtyp((member, typ''''')*{member <- member*, typ''''' <- typ'''''*}) = synthtyp
    2. If $distinct_<member>(member*{member <- member*}), then
      1. (Type_wf: `%|-%`(tidset, typ'''''))*{typ''''' <- typ'''''*}
      2. Result in 
  2. Else If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ''''') = synthtyp
    2. Let typ''''' = $canon_typ(typ''''')
    3. If $nestable_sett(typ'''''), then
      1. Type_wf: `%|-%`(tidset, typ''''')
      2. Result in 
  2. Else If synthtyp matches `TableEnumT%%`, then
    1. Let `TableEnumT%%`_synthtyp(_id, member*{member <- member*}) = synthtyp
    2. If $distinct_<member>(member*{member <- member*}), then
      1. Result in 
  2. Else If synthtyp matches `TableStructT%%`, then
    1. Let `TableStructT%%`_synthtyp(_id, (member, typ''''')*{member <- member*, typ''''' <- typ'''''*}) = synthtyp
    2. If (member*{member <- member*} = ["hit", "miss", "action_run"]), then
      1. Let typ* = typ'''''*{typ''''' <- typ'''''*}
      2. If typ* matches [ _/3 ], then
        1. Let [typ''''', typ''', typ''''] = typ*
        2. If (typ''''' = `BoolT`_primtyp() as typ), then
          1. If (typ''' = `BoolT`_primtyp() as typ), then
            1. If typ'''' <: synthtyp, then
              1. Let synthtyp' = typ'''' as synthtyp
              2. If synthtyp' matches `TableEnumT%%`, then
                1. Let `TableEnumT%%`_synthtyp(id_e, member_e*{member_e <- member_e*}) = synthtyp'
                2. Type_wf: `%|-%`(tidset, `TableEnumT%%`_synthtyp(id_e, member_e*{member_e <- member_e*}) as typ)
                3. Result in 
8. If (typ''''' = `InvalidT`_synthtyp() as typ), then
  1. Result in 
9. If (typ''''' = `StateT`_synthtyp() as typ), then
  1. Result in 
10. If (typ''''' = `AnyT`_synthtyp() as typ), then
  1. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:6.1-6.42
relation TypeDef_wf: tidset, typdef
1. If typdef <: monotypdef, then
  1. Let `MonoD%`_monotypdef(typ) = typdef as monotypdef
  2. If $nestable_monod(typ), then
    1. Type_wf: `%|-%`(tidset, typ)
    2. Result in 
2. If typdef <: polytypdef, then
  1. Let `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ) = typdef as polytypdef
  2. If $nestable_polyd(typ), then
    1. If $distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}), then
      1. Let tidset' = $union_set<tid>(tidset, `SET%`_set<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))
      2. Type_wf: `%|-%`(tidset', typ)
      3. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:8.1-8.44
relation ParamType_wf: tidset, `%%%%`_paramtyp(_id, dir, typ, val?)
1. If val? matches (), then
  1. Type_wf: `%|-%`(tidset, typ)
  2. If ($is_externt($canon_typ(typ)) => (dir = `NO`_dir())), then
    1. Result in 
1. Else
  1. Let ?(val) = val?
  2. Type_wf: `%|-%`(tidset, typ)
  3. If ($is_externt($canon_typ(typ)) => (dir = `NO`_dir())), then
    1. If ((dir = `IN`_dir()) \/ (dir = `NO`_dir())), then
      1. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:9.1-9.45
relation ParamTypes_wf: tidset, pt*{pt <- pt*}
1. (Let `%%%%`_paramtyp(id, _dir, _typ, _val?) = pt)*{_dir <- _dir*, _typ <- _typ*, _val? <- _val?*, id <- id*, pt <- pt*}
2. If $distinct_<id>(id*{id <- id*}), then
  1. (ParamType_wf: `%|-%`(tidset, pt))*{pt <- pt*}
  2. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:11.1-11.43
relation FuncType_wf: tidset, functyp
1. If functyp matches `BuiltinMethodT%%`, then
  1. Let `BuiltinMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
  3. Type_wf: `%|-%`(tidset, typ_r)
  4. Result in 
1. Else If functyp matches `ActionT%`, then
  1. Let `ActionT%`_functyp(pt*{pt <- pt*}) = functyp
  2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
  3. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  4. If $is_trailing_action(dir*{dir <- dir*}), then
    1. (Let typ' = $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}
    2. If (((((~ $is_deft(typ') /\ ~ $is_spect(typ')) /\ ~ $is_intt(typ')) /\ ~ $is_obj(typ')) /\ (~ $is_strt(typ') \/ (dir = `NO`_dir()))))*{dir <- dir*, typ' <- typ'*}, then
      1. Result in 
1. Else If functyp matches `ParserApplyMethodT%`, then
  1. Let `ParserApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
  2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
  3. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  4. (Let typ' = $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}
  5. If ((((~ $is_deft(typ') /\ ~ $is_spect(typ')) /\ ~ ($is_obj(typ') /\ ~ $is_externt(typ'))) /\ (~ ($is_strt(typ') \/ $is_intt(typ')) \/ (dir = `NO`_dir()))))*{dir <- dir*, typ' <- typ'*}, then
    1. Result in 
1. Else If functyp matches `ControlApplyMethodT%`, then
  1. Let `ControlApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
  2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
  3. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  4. (Let typ' = $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}
  5. Result in 
1. Else If functyp matches `TableApplyMethodT%`, then
  1. Let `TableApplyMethodT%`_functyp(typ) = functyp
  2. If typ <: synthtyp, then
    1. Let synthtyp = typ as synthtyp
    2. If synthtyp matches `TableStructT%%`, then
      1. Let `TableStructT%%`_synthtyp(_id, _(member, typ)*) = synthtyp
      2. Result in 
1. Else If functyp matches `ExternFuncT%%`, then
  1. Let `ExternFuncT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
  3. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  4. (Let typ' = $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}
  5. If ((((~ $is_deft(typ') /\ ~ $is_spect(typ')) /\ ~ ($is_obj(typ') /\ ~ $is_externt(typ'))) /\ (~ ($is_strt(typ') \/ $is_intt(typ')) \/ (dir = `NO`_dir()))))*{dir <- dir*, typ' <- typ'*}, then
    1. Type_wf: `%|-%`(tidset, typ_r)
    2. Result in 
1. Else If functyp matches `FuncT%%`, then
  1. Let `FuncT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
  3. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  4. (Let typ' = $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}
  5. If ((((~ $is_deft(typ') /\ ~ $is_spect(typ')) /\ ~ $is_obj(typ')) /\ (~ ($is_strt(typ') \/ $is_intt(typ')) \/ (dir = `NO`_dir()))))*{dir <- dir*, typ' <- typ'*}, then
    1. Type_wf: `%|-%`(tidset, typ_r)
    2. Result in 
1. Else If functyp matches `ExternMethodT%%`, then
  1. Let `ExternMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
  3. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  4. (Let typ' = $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}
  5. If ((((~ $is_deft(typ') /\ ~ $is_spect(typ')) /\ ~ ($is_obj(typ') /\ ~ $is_externt(typ'))) /\ (~ ($is_strt(typ') \/ $is_intt(typ')) \/ (dir = `NO`_dir()))))*{dir <- dir*, typ' <- typ'*}, then
    1. Type_wf: `%|-%`(tidset, typ_r)
    2. Result in 
1. Else If functyp matches `ExternAbstractMethodT%%`, then
  1. Let `ExternAbstractMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. ParamTypes_wf: `%|-%`(tidset, pt*{pt <- pt*})
  3. (Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}
  4. (Let typ' = $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}
  5. If ((((~ $is_deft(typ') /\ ~ $is_spect(typ')) /\ ~ ($is_obj(typ') /\ ~ $is_externt(typ'))) /\ (~ ($is_strt(typ') \/ $is_intt(typ')) \/ (dir = `NO`_dir()))))*{dir <- dir*, typ' <- typ'*}, then
    1. Type_wf: `%|-%`(tidset, typ_r)
    2. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:12.1-12.43
relation FuncDef_wf: tidset, funcdef
1. If funcdef <: monofuncdef, then
  1. Let `MonoFD%`_monofuncdef(ft) = funcdef as monofuncdef
  2. If (((($is_builtinmethodt(ft) \/ $is_actiont(ft)) \/ $is_parserapplymethodt(ft)) \/ $is_controlapplymethodt(ft)) \/ $is_tableapplymethodt(ft)), then
    1. FuncType_wf: `%|-%`(tidset, ft)
    2. Result in 
2. If funcdef <: polyfuncdef, then
  1. Let `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), ft) = funcdef as polyfuncdef
  2. If ((($is_externfunct(ft) \/ $is_funct(ft)) \/ $is_externmethodt(ft)) \/ $is_externabstractmethodt(ft)), then
    1. If $distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}), then
      1. Let tidset' = $union_set<tid>(tidset, `SET%`_set<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))
      2. FuncType_wf: `%|-%`(tidset', ft)
      3. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:14.52-14.60
syntax consctxt = 
   | `CONSCTXT`()

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:15.1-15.53
relation CParamType_wf: tidset, consctxt, `%%%%`_paramtyp(id, dir, typ, val?{val <- val?})
1. If dir matches `NO`, then
  1. Type_wf: `%|-%`(tidset, typ)
  2. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:16.1-16.54
relation CParamTypes_wf: tidset, consctxt, pt*{pt <- pt*}
1. (Let `%%%%`_paramtyp(id, _dir, _typ, _val?) = pt)*{_dir <- _dir*, _typ <- _typ*, _val? <- _val?*, id <- id*, pt <- pt*}
2. If $distinct_<id>(id*{id <- id*}), then
  1. (CParamType_wf: `%%|-%`(tidset, consctxt, pt))*{pt <- pt*}
  2. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:18.1-18.43
relation ConsType_wf: tidset, `ConsT%%`_constyp(pt*{pt <- pt*}, typ)
1. CParamTypes_wf: `%%|-%`(tidset, `CONSCTXT`_consctxt(), pt*{pt <- pt*})
2. Type_wf: `%|-%`(tidset, typ)
3. Let typ'' = $canon_typ(typ)
4. If typ'' <: objtyp, then
  1. Let objtyp = typ'' as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(id, fmap) = objtyp
    2. (Let `%%%%`_paramtyp(_id, _dir, typ_p, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}
    3. (Let typ' = $canon_typ(typ_p))*{typ' <- typ'*, typ_p <- typ_p*}
    4. If (((~ $is_deft(typ') /\ ~ $is_spect(typ')) /\ ~ ($is_obj(typ') /\ ~ $is_externt(typ'))))*{typ' <- typ'*}, then
      1. Result in 
5. Let typ' = $canon_typ(typ)
6. If typ' <: objtyp, then
  1. Let objtyp = typ' as objtyp
  2. If objtyp matches `ParserT%`, then
    1. Let `ParserT%`_objtyp(_paramtyp*) = objtyp
    2. (Let `%%%%`_paramtyp(_id, _dir, typ_p, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}
    3. (Let typ_p' = $canon_typ(typ_p))*{typ_p <- typ_p*, typ_p' <- typ_p'*}
    4. If (((((~ $is_deft(typ_p') /\ ~ $is_spect(typ_p')) /\ ~ $is_controlt(typ_p')) /\ ~ $is_packaget(typ_p')) /\ ~ $is_tablet(typ_p')))*{typ_p' <- typ_p'*}, then
      1. Result in 
  2. Else If objtyp matches `ControlT%`, then
    1. Let `ControlT%`_objtyp(_paramtyp*) = objtyp
    2. (Let `%%%%`_paramtyp(_id, _dir, typ_p, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}
    3. (Let typ_p' = $canon_typ(typ_p))*{typ_p <- typ_p*, typ_p' <- typ_p'*}
    4. If (((((~ $is_deft(typ_p') /\ ~ $is_spect(typ_p')) /\ ~ $is_parsert(typ_p')) /\ ~ $is_packaget(typ_p')) /\ ~ $is_tablet(typ_p')))*{typ_p' <- typ_p'*}, then
      1. Result in 
  2. Else If objtyp matches `PackageT%`, then
    1. Let `PackageT%`_objtyp(_typ*) = objtyp
    2. (Let `%%%%`_paramtyp(_id, _dir, typ_p, _val?) = pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}
    3. (Let typ_p' = $canon_typ(typ_p))*{typ_p <- typ_p*, typ_p' <- typ_p'*}
    4. If (((~ $is_deft(typ_p') /\ ~ $is_spect(typ_p')) /\ ~ $is_tablet(typ_p')))*{typ_p' <- typ_p'*}, then
      1. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:19.1-19.43
relation ConsDef_wf: tidset, `ConsD%->%`_consdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), constyp)
1. Let `ConsT%%`_constyp(_paramtyp*, typ_r) = constyp
2. Let typ_r' = $canon_typ(typ_r)
3. If ((($is_externt(typ_r') \/ $is_parsert(typ_r')) \/ $is_controlt(typ_r')) \/ $is_packaget(typ_r')), then
  1. If $distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}), then
    1. Let tidset' = $union_set<tid>(tidset, `SET%`_set<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))
    2. ConsType_wf: `%|-%`(tidset', constyp)
    3. Result in 

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:37.1-37.31
def $nestable_deft(typ)
1. Return $nestable'_deft($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:38.1-38.32
def $nestable'_deft(typ)
1. If typ <: basetyp, then
  1. Let basetyp = typ as basetyp
  2. Return (~ $is_voidt(basetyp as typ) /\ ~ $is_matchkindt(basetyp as typ))
2. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
3. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. Return true
4. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:52.1-52.31
def $nestable_newt(typ)
1. Return $nestable'_newt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:53.1-53.32
def $nestable'_newt(typ)
1. If (typ = `BoolT`_primtyp() as typ), then
  1. Return true
2. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
3. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
4. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
5. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:73.1-73.33
def $nestable_senumt(typ)
1. Return $nestable'_senumt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:74.1-74.34
def $nestable'_senumt(typ'')
1. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
2. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
3. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ'') = datatyp
    2. Return $nestable_newt_in_senumt(typ'')
4. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:75.1-75.41
def $nestable_newt_in_senumt(typ)
1. Return $nestable_newt_in_senumt'($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:76.1-76.42
def $nestable_newt_in_senumt'(typ)
1. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
2. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
3. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
4. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:100.1-100.32
def $nestable_listt(typ)
1. Return $nestable'_listt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:101.1-101.33
def $nestable'_listt(typ)
1. If typ <: basetyp, then
  1. Let basetyp = typ as basetyp
  2. Return ~ $is_voidt(basetyp as typ)
2. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
3. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. Return true
4. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:114.1-114.33
def $nestable_tuplet(typ)
1. Return $nestable'_tuplet($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:115.1-115.34
def $nestable'_tuplet(typ)
1. If (typ = `ErrT`_primtyp() as typ), then
  1. Return true
2. If (typ = `BoolT`_primtyp() as typ), then
  1. Return true
3. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. Return ~ $is_intt(numtyp as typ)
4. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
5. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. Return ~ $is_listt(datatyp as typ)
6. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:131.1-131.33
def $nestable_stackt(typ)
1. Return $nestable'_stackt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:132.1-132.34
def $nestable'_stackt(typ)
1. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(tid) = abstyp
    2. Return true
2. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:147.1-147.34
def $nestable_structt(typ)
1. Return $nestable'_structt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:148.1-148.35
def $nestable'_structt(typ)
1. If (typ = `ErrT`_primtyp() as typ), then
  1. Return true
2. If (typ = `BoolT`_primtyp() as typ), then
  1. Return true
3. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. Return ~ $is_intt(numtyp as typ)
4. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
5. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. Return ~ $is_listt(datatyp as typ)
6. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:165.1-165.34
def $nestable_headert(typ)
1. Return $nestable'_headert($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:166.1-166.35
def $nestable'_headert(typ'')
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return true
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. Return ~ $is_intt(numtyp as typ)
3. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
4. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, _typ, _(member, val)*) = datatyp
    2. Return true
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. If ($nestable_structt_in_headert(typ''))*{typ'' <- typ''*}, then
      1. Return true
5. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:167.1-167.45
def $nestable_structt_in_headert(typ)
1. Return $nestable'_structt_in_headert($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:168.1-168.46
def $nestable'_structt_in_headert(typ'')
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return true
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
3. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
4. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, _typ, _(member, val)*) = datatyp
    2. Return true
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. If ($nestable_structt_in_headert(typ''))*{typ'' <- typ''*}, then
      1. Return true
5. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:199.1-199.33
def $nestable_uniont(typ)
1. Return $nestable'_uniont($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:200.1-200.34
def $nestable'_uniont(typ)
1. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
2. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:262.1-262.31
def $nestable_sett(typ)
1. Return $nestable'_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:263.1-263.32
def $nestable'_sett(typ'')
1. If (typ'' = `ErrT`_primtyp() as typ), then
  1. Return true
2. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return true
3. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
4. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
5. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
  2. Else If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(_id, _member*) = datatyp
    2. Return true
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, _typ, _(member, val)*) = datatyp
    2. Return true
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ''*{typ'' <- typ''*}) = datatyp
    2. If ($nestable_tuplet_in_sett(typ''))*{typ'' <- typ''*}, then
      1. Return true
6. If typ'' <: synthtyp, then
  1. Let synthtyp = typ'' as synthtyp
  2. If synthtyp matches `SeqT%`, then
    1. Let `SeqT%`_synthtyp(typ''*{typ'' <- typ''*}) = synthtyp
    2. If ($nestable_seqt_in_sett(typ''))*{typ'' <- typ''*}, then
      1. Return true
7. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:264.1-264.41
def $nestable_tuplet_in_sett(typ)
1. Return $nestable'_tuplet_in_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:265.1-265.42
def $nestable'_tuplet_in_sett(typ'')
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return true
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
3. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
4. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
  2. Else If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(_id, _member*) = datatyp
    2. Return true
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, _typ, _(member, val)*) = datatyp
    2. Return true
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ''*{typ'' <- typ''*}) = datatyp
    2. If ($nestable_tuplet_in_sett(typ''))*{typ'' <- typ''*}, then
      1. Return true
5. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:266.1-266.39
def $nestable_seqt_in_sett(typ)
1. Return $nestable'_seqt_in_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:267.1-267.40
def $nestable'_seqt_in_sett(typ'')
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return true
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
3. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
4. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
  2. Else If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(_id, _member*) = datatyp
    2. Return true
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, _typ, _(member, val)*) = datatyp
    2. Return true
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ''*{typ'' <- typ''*}) = datatyp
    2. If ($nestable_seqt_in_sett(typ''))*{typ'' <- typ''*}, then
      1. Return true
5. If typ'' <: synthtyp, then
  1. Let synthtyp = typ'' as synthtyp
  2. If synthtyp matches `SeqT%`, then
    1. Let `SeqT%`_synthtyp(typ''*{typ'' <- typ''*}) = synthtyp
    2. If ($nestable_seqt_in_sett(typ''))*{typ'' <- typ''*}, then
      1. Return true
6. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:339.1-339.32
def $nestable_monod(typ)
1. If typ <: abstyp, then
  1. Let abstyp = typ as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(_id) = abstyp
    2. Return true
2. If typ <: aliastyp, then
  1. Let `DefT%`_aliastyp(_typ) = typ as aliastyp
  2. Return true
3. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, _typ) = datatyp
    2. Return true
  2. Else If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(_id, _member*) = datatyp
    2. Return true
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, _typ, _(member, val)*) = datatyp
    2. Return true
4. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `TableT%%`, then
    1. Let `TableT%%`_objtyp(_id, _typ) = objtyp
    2. Return true
5. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:355.1-355.32
def $nestable_polyd(typ)
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(_typ*) = datatyp
    2. Return true
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(_typ, _int) = datatyp
    2. Return true
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(_id, _(member, typ)*) = datatyp
    2. Return true
2. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(_id, _map<fid, funcdef>) = objtyp
    2. Return true
  2. Else If objtyp matches `ParserT%`, then
    1. Let `ParserT%`_objtyp(_paramtyp*) = objtyp
    2. Return true
  2. Else If objtyp matches `ControlT%`, then
    1. Let `ControlT%`_objtyp(_paramtyp*) = objtyp
    2. Return true
  2. Else If objtyp matches `PackageT%`, then
    1. Let `PackageT%`_objtyp(_typ*) = objtyp
    2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:406.1-407.38
def $is_trailing_action(dir*{dir <- dir*})
1. Return $is_trailing_action'(true, $rev_<dir>(dir*{dir <- dir*}))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:408.1-408.44
def $is_trailing_action'(_bool', dir*)
1. If dir* matches [], then
  1. Return true
1. Else
  1. Let dir_h :: dir_t*{dir_t <- dir_t*} = dir*
  2. If (dir_h =/= `NO`_dir()), then
    1. Return $is_trailing_action'(false, dir_t*{dir_t <- dir_t*})
2. If (_bool' = true), then
  1. If dir* matches _ :: _, then
    1. Let dir :: dir_t*{dir_t <- dir_t*} = dir*
    2. If dir matches `NO`, then
      1. Return $is_trailing_action'(true, dir_t*{dir_t <- dir_t*})
2. Else If (_bool' = false), then
  1. If dir* matches _ :: _, then
    1. Let dir :: dir_t*{dir_t <- dir_t*} = dir*
    2. If dir matches `NO`, then
      1. Return false

;; ../../../../spec/2d1-runtime-numerics.watsup:5.1-5.21
def $pow2


;; ../../../../spec/2d1-runtime-numerics.watsup:7.1-7.25
def $shl


;; ../../../../spec/2d1-runtime-numerics.watsup:8.1-8.25
def $shr


;; ../../../../spec/2d1-runtime-numerics.watsup:9.1-9.36
def $shr_arith


;; ../../../../spec/2d1-runtime-numerics.watsup:11.1-11.21
def $bneg


;; ../../../../spec/2d1-runtime-numerics.watsup:12.1-12.26
def $band


;; ../../../../spec/2d1-runtime-numerics.watsup:13.1-13.26
def $bxor


;; ../../../../spec/2d1-runtime-numerics.watsup:14.1-14.25
def $bor


;; ../../../../spec/2d1-runtime-numerics.watsup:16.1-16.33
def $bitacc


;; ../../../../spec/2d1-runtime-numerics.watsup:22.1-23.32
def $un_op(unop, val)
1. If unop matches `BNOT`, then
  1. Return $un_bnot(val)
1. Else If unop matches `LNOT`, then
  1. Return $un_lnot(val)
1. Else If unop matches `UPLUS`, then
  1. Return $un_plus(val)
1. Else If unop matches `UMINUS`, then
  1. Return $un_minus(val)

;; ../../../../spec/2d1-runtime-numerics.watsup:27.1-27.24
def $un_bnot(val)
1. If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs) = val
  2. Let i = $bneg(bs)
  3. Return `FBitV%%`_val(w, $to_bitstr(w as int, $bneg(bs)))

;; ../../../../spec/2d1-runtime-numerics.watsup:36.1-36.24
def $un_lnot(val)
1. If val matches `BoolV%`, then
  1. Let `BoolV%`_val(b) = val
  2. Return `BoolV%`_val(~ b)

;; ../../../../spec/2d1-runtime-numerics.watsup:44.1-44.24
def $un_plus(val)
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i) = val
  2. Return `IntV%`_val(i)
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs) = val
  2. Return `FIntV%%`_val(w, bs)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs) = val
  2. Return `FBitV%%`_val(w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:54.1-54.25
def $un_minus(val)
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i) = val
  2. Return `IntV%`_val(- i)
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs) = val
  2. Let bs' = $to_bitstr(w as int, $to_int(w as int, - bs))
  3. Return `FIntV%%`_val(w, bs')
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs) = val
  2. Let bs' = ($pow2(w) - bs)
  3. Return `FBitV%%`_val(w, bs')

;; ../../../../spec/2d1-runtime-numerics.watsup:70.1-71.24
def $bin_op(binop, val_l, val_r)
1. If binop matches `PLUS`, then
  1. Return $bin_plus(val_l, val_r)
1. Else If binop matches `MINUS`, then
  1. Return $bin_minus(val_l, val_r)
1. Else If binop matches `MUL`, then
  1. Return $bin_mul(val_l, val_r)
1. Else If binop matches `DIV`, then
  1. Return $bin_div(val_l, val_r)
1. Else If binop matches `MOD`, then
  1. Return $bin_mod(val_l, val_r)
1. Else If binop matches `SHL`, then
  1. Return $bin_shl(val_l, val_r)
1. Else If binop matches `SHR`, then
  1. Return $bin_shr(val_l, val_r)
1. Else If binop matches `LE`, then
  1. Return `BoolV%`_val($bin_le(val_l, val_r))
1. Else If binop matches `GE`, then
  1. Return `BoolV%`_val($bin_ge(val_l, val_r))
1. Else If binop matches `LT`, then
  1. Return `BoolV%`_val($bin_lt(val_l, val_r))
1. Else If binop matches `GT`, then
  1. Return `BoolV%`_val($bin_gt(val_l, val_r))
1. Else If binop matches `EQ`, then
  1. Return `BoolV%`_val($bin_eq(val_l, val_r))
1. Else If binop matches `NE`, then
  1. Return `BoolV%`_val(~ $bin_eq(val_l, val_r))
1. Else If binop matches `BAND`, then
  1. Return $bin_band(val_l, val_r)
1. Else If binop matches `BXOR`, then
  1. Return $bin_bxor(val_l, val_r)
1. Else If binop matches `BOR`, then
  1. Return $bin_bor(val_l, val_r)
1. Else If binop matches `CONCAT`, then
  1. Return $bin_concat(val_l, val_r)
1. Else If binop matches `LAND`, then
  1. Return $bin_land(val_l, val_r)
1. Else If binop matches `LOR`, then
  1. Return $bin_lor(val_l, val_r)

;; ../../../../spec/2d1-runtime-numerics.watsup:75.1-75.30
def $bin_plus(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return `IntV%`_val((i_l + i_r))
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Let bs = $to_bitstr(w as int, (i_l + i_r))
      4. Return `FIntV%%`_val(w, bs)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Let bs = $to_bitstr(w as int, (i_l + i_r))
      4. Return `FBitV%%`_val(w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:93.1-93.31
def $bin_minus(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return `IntV%`_val((i_l - i_r))
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Let bs = $to_bitstr(w as int, (i_l - i_r))
      4. Return `FIntV%%`_val(w, bs)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Let bs = $to_bitstr(w as int, (i_l - i_r))
      4. Return `FBitV%%`_val(w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:111.1-111.29
def $bin_mul(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return `IntV%`_val((i_l * i_r))
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Let bs = $to_bitstr(w as int, (i_l * i_r))
      4. Return `FIntV%%`_val(w, bs)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Let bs = $to_bitstr(w as int, (i_l * i_r))
      4. Return `FBitV%%`_val(w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:127.1-127.29
def $bin_div(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return `IntV%`_val((i_l / i_r))

;; ../../../../spec/2d1-runtime-numerics.watsup:135.1-135.29
def $bin_mod(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return `IntV%`_val((i_l \ i_r))

;; ../../../../spec/2d1-runtime-numerics.watsup:143.1-143.29
def $bin_shl(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return `IntV%`_val($shl(i_l, i_r))
  2. Else If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(w_r, bs_r) = val'
    2. Let i_r = $to_int(w_r as int, bs_r)
    3. Return `IntV%`_val($shl(i_l, i_r))
  2. Else If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(w_r, bs_r) = val'
    2. Return `IntV%`_val($shl(i_l, bs_r))
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w_l, bs_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Let val_r = `FIntV%%`_val(w_l, $to_int(w_l as int, i_r))
    3. Return $bin_shl(`FIntV%%`_val(w_l, bs_l), val_r)
  2. Else If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(w_r, bs_r) = val'
    2. Let i_l = $to_int(w_l as int, bs_l)
    3. Let i_r = $to_int(w_r as int, bs_r)
    4. Let i = $shl(i_l, i_r)
    5. Return `FIntV%%`_val(w_l, $to_bitstr(w_l as int, i))
  2. Else If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(w_r, bs_r) = val'
    2. Let i_l = $to_int(w_l as int, bs_l)
    3. Let i = $shl(i_l, bs_r)
    4. Return `FIntV%%`_val(w_l, $to_bitstr(w_l as int, i))
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w_l, bs_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Let val_r = `FBitV%%`_val(w_l, $to_int(w_l as int, i_r))
    3. Return $bin_shl(`FBitV%%`_val(w_l, bs_l), val_r)
  2. Else If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(w_r, bs_r) = val'
    2. Let i_r = $to_int(w_r as int, bs_r)
    3. Let i = $shl(bs_l, i_r)
    4. Return `FBitV%%`_val(w_l, $to_bitstr(w_l as int, i))
  2. Else If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(w_r, bs_r) = val'
    2. Let i = $shl(bs_l, bs_r)
    3. Return `FBitV%%`_val(w_l, $to_bitstr(w_l as int, i))

;; ../../../../spec/2d1-runtime-numerics.watsup:176.1-176.29
def $bin_shr(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return `IntV%`_val($shr(i_l, i_r))
  2. Else If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(w_r, bs_r) = val'
    2. Let i_r = $to_int(w_r as int, bs_r)
    3. Return `IntV%`_val($shr(i_l, i_r))
  2. Else If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(w_r, bs_r) = val'
    2. Return `IntV%`_val($shr(i_l, bs_r))
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w_l, bs_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Let i_l = $to_int(w_l as int, bs_l)
    3. If (i_l < 0 as int), then
      1. Let i = $shr_arith(bs_l, i_r, ($pow2(w_l) - 1 as int))
      2. Return `FIntV%%`_val(w_l, $to_bitstr(w_l as int, i))
    4. If (i_l >= 0 as int), then
      1. Let i = $shr(bs_l, i_r)
      2. Return `FIntV%%`_val(w_l, $to_bitstr(w_l as int, i))
  2. Else If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(w_r, bs_r) = val'
    2. Let i_l = $to_int(w_l as int, bs_l)
    3. Let i_r = $to_int(w_r as int, bs_r)
    4. If (i_l < 0 as int), then
      1. Let i = $shr_arith(bs_l, i_r, ($pow2(w_l) - 1 as int))
      2. Return `FIntV%%`_val(w_l, $to_bitstr(w_l as int, i))
    5. If (i_l >= 0 as int), then
      1. Let i = $shr(bs_l, i_r)
      2. Return `FIntV%%`_val(w_l, $to_bitstr(w_l as int, i))
  2. Else If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(w_r, bs_r) = val'
    2. Let i_l = $to_int(w_l as int, bs_l)
    3. If (i_l < 0 as int), then
      1. Let i = $shr_arith(bs_l, bs_r, ($pow2(w_l) - 1 as int))
      2. Return `FIntV%%`_val(w_l, $to_bitstr(w_l as int, i))
    4. If (i_l >= 0 as int), then
      1. Let i = $shr(bs_l, bs_r)
      2. Return `FIntV%%`_val(w_l, $to_bitstr(w_l as int, i))
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w_l, bs_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Let val_r = `FBitV%%`_val(w_l, $to_int(w_l as int, i_r))
    3. Return $bin_shr(`FBitV%%`_val(w_l, bs_l), val_r)
  2. Else If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(w_r, bs_r) = val'
    2. Let i_r = $to_int(w_r as int, bs_r)
    3. Let i = $shr(bs_l, i_r)
    4. Return `FBitV%%`_val(w_l, $to_bitstr(w_l as int, i))
  2. Else If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(w_r, bs_r) = val'
    2. Let i = $shr(bs_l, bs_r)
    3. Return `FBitV%%`_val(w_l, $to_bitstr(w_l as int, i))

;; ../../../../spec/2d1-runtime-numerics.watsup:229.1-229.29
def $bin_le(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return (i_l <= i_r)
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Return (i_l <= i_r)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Return (bs_l <= bs_r)

;; ../../../../spec/2d1-runtime-numerics.watsup:241.1-241.29
def $bin_ge(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return (i_l >= i_r)
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Return (i_l >= i_r)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Return (bs_l >= bs_r)

;; ../../../../spec/2d1-runtime-numerics.watsup:253.1-253.29
def $bin_lt(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return (i_l < i_r)
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Return (i_l < i_r)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Return (bs_l < bs_r)

;; ../../../../spec/2d1-runtime-numerics.watsup:265.1-265.29
def $bin_gt(val, val')
1. If val matches `IntV%`, then
  1. Let `IntV%`_val(i_l) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_r) = val'
    2. Return (i_l > i_r)
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Return (i_l > i_r)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Return (bs_l > bs_r)

;; ../../../../spec/2d1-runtime-numerics.watsup:277.1-277.29
def $bin_eq(val, val')
1. If val matches `ErrV%`, then
  1. Let `ErrV%`_val(member_a) = val
  2. If val' matches `ErrV%`, then
    1. Let `ErrV%`_val(member_b) = val'
    2. Return (member_a = member_b)
1. Else If val matches `MatchKindV%`, then
  1. Let `MatchKindV%`_val(member_a) = val
  2. If val' matches `MatchKindV%`, then
    1. Let `MatchKindV%`_val(member_b) = val'
    2. Return (member_a = member_b)
1. Else If val matches `StrV%`, then
  1. Let `StrV%`_val(text_a) = val
  2. If val' matches `StrV%`, then
    1. Let `StrV%`_val(text_b) = val'
    2. Return (text_a = text_b)
1. Else If val matches `BoolV%`, then
  1. Let `BoolV%`_val(b_a) = val
  2. If val' matches `BoolV%`, then
    1. Let `BoolV%`_val(b_b) = val'
    2. Return (b_a = b_b)
1. Else If val matches `IntV%`, then
  1. Let `IntV%`_val(i_a) = val
  2. If val' matches `IntV%`, then
    1. Let `IntV%`_val(i_b) = val'
    2. Return (i_a = i_b)
1. Else If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_a) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_b) = val'
    2. If (w = nat), then
      1. Return (bs_a = bs_b)
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_a) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_b) = val'
    2. If (w = nat), then
      1. Return (bs_a = bs_b)
1. Else If val matches `VBitV%%%`, then
  1. Let `VBitV%%%`_val(w, _width, bs_a) = val
  2. If val' matches `VBitV%%%`, then
    1. Let `VBitV%%%`_val(nat, _width', bs_b) = val'
    2. If (w = nat), then
      1. Return (bs_a = bs_b)
1. Else If val matches `EnumFieldV%%`, then
  1. Let `EnumFieldV%%`_val(id_a, member_a) = val
  2. If val' matches `EnumFieldV%%`, then
    1. Let `EnumFieldV%%`_val(id_b, member_b) = val'
    2. Return ((id_a = id_b) /\ (member_a = member_b))
1. Else If val matches `SEnumFieldV%%%`, then
  1. Let `SEnumFieldV%%%`_val(id_a, member_a, val_a) = val
  2. If val' matches `SEnumFieldV%%%`, then
    1. Let `SEnumFieldV%%%`_val(id_b, member_b, val_b) = val'
    2. Return (((id_a = id_b) /\ (member_a = member_b)) /\ $bin_eq(val_a, val_b))
1. Else If val matches `ListV%`, then
  1. Let `ListV%`_val(val_a*{val_a <- val_a*}) = val
  2. If val' matches `ListV%`, then
    1. Let `ListV%`_val(val_b*{val_b <- val_b*}) = val'
    2. Return $bin_eqs(val_a*{val_a <- val_a*}, val_b*{val_b <- val_b*})
1. Else If val matches `TupleV%`, then
  1. Let `TupleV%`_val(val_a*{val_a <- val_a*}) = val
  2. If val' matches `TupleV%`, then
    1. Let `TupleV%`_val(val_b*{val_b <- val_b*}) = val'
    2. Return $bin_eqs(val_a*{val_a <- val_a*}, val_b*{val_b <- val_b*})
1. Else If val matches `StackV%%%`, then
  1. Let `StackV%%%`_val(val_a*{val_a <- val_a*}, _int, i_size_a) = val
  2. If val' matches `StackV%%%`, then
    1. Let `StackV%%%`_val(val_b*{val_b <- val_b*}, _int', i_size_b) = val'
    2. Return ($bin_eqs(val_a*{val_a <- val_a*}, val_b*{val_b <- val_b*}) /\ (i_size_a = i_size_b))
1. Else If val matches `StructV%%`, then
  1. Let `StructV%%`_val(id_a, (member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}) = val
  2. If val' matches `StructV%%`, then
    1. Let `StructV%%`_val(id_b, (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}) = val'
    2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}, (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}))
1. Else If val matches `HeaderV%%`, then
  1. Let `HeaderV%%`_val(id_a, (member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}) = val
  2. If val' matches `StructV%%`, then
    1. Let `StructV%%`_val(id_b, (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}) = val'
    2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}, (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}))
1. Else If val matches `UnionV%%`, then
  1. Let `UnionV%%`_val(id_a, (member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}) = val
  2. If val' matches `StructV%%`, then
    1. Let `StructV%%`_val(id_b, (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}) = val'
    2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}, (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}))
1. Else If val matches `InvalidV`, then
  1. If val' matches `InvalidV`, then
    1. Return true

;; ../../../../spec/2d1-runtime-numerics.watsup:278.1-278.32
def $bin_eqs(val*, val*')
1. If val* matches [], then
  1. If val*' matches [], then
    1. Return true
  1. Else
    1. Let _val :: _val* = val*'
    2. Return false
1. Else
  1. Let _val :: _val* = val*
  2. If val*' matches [], then
    1. Return false
  3. Let val_ah :: val_at*{val_at <- val_at*} = val*
  4. If val*' matches _ :: _, then
    1. Let val_bh :: val_bt*{val_bt <- val_bt*} = val*'
    2. Return ($bin_eq(val_ah, val_bh) /\ $bin_eqs(val_at*{val_at <- val_at*}, val_bt*{val_bt <- val_bt*}))

;; ../../../../spec/2d1-runtime-numerics.watsup:279.1-279.53
def $bin_eqs_((member, val)*, (member, val)*')
1. If (member, val)* matches [], then
  1. If (member, val)*' matches [], then
    1. Return true
  1. Else
    1. Let _(member, val) :: _(member, val)* = (member, val)*'
    2. Return false
1. Else
  1. Let _(member, val) :: _(member, val)* = (member, val)*
  2. If (member, val)*' matches [], then
    1. Return false
  3. Let (member, val_a) :: (member_at, val_at)*{member_at <- member_at*, val_at <- val_at*} = (member, val)*
  4. If (member, val)*' matches _ :: _, then
    1. Let (member', val_b) :: (member_bt, val_bt)*{member_bt <- member_bt*, val_bt <- val_bt*} = (member, val)*'
    2. If (member = member'), then
      1. Return ($bin_eq(val_a, val_b) /\ $bin_eqs_((member_at, val_at)*{member_at <- member_at*, val_at <- val_at*}, (member_bt, val_bt)*{member_bt <- member_bt*, val_bt <- val_bt*}))

;; ../../../../spec/2d1-runtime-numerics.watsup:325.1-325.30
def $bin_band(val, val')
1. If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Let i = $band(i_l, i_r)
      4. Return `FIntV%%`_val(w, $to_bitstr(w as int, i))
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i = $band(bs_l, bs_r)
      2. Return `FBitV%%`_val(w, $to_bitstr(w as int, i))

;; ../../../../spec/2d1-runtime-numerics.watsup:341.1-341.30
def $bin_bxor(val, val')
1. If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Let i = $bxor(i_l, i_r)
      4. Return `FIntV%%`_val(w, $to_bitstr(w as int, i))
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i = $bxor(bs_l, bs_r)
      2. Return `FBitV%%`_val(w, $to_bitstr(w as int, i))

;; ../../../../spec/2d1-runtime-numerics.watsup:357.1-357.29
def $bin_bor(val, val')
1. If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i_l = $to_int(w as int, bs_l)
      2. Let i_r = $to_int(w as int, bs_r)
      3. Let i = $bor(i_l, i_r)
      4. Return `FIntV%%`_val(w, $to_bitstr(w as int, i))
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs_l) = val
  2. If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(nat, bs_r) = val'
    2. If (w = nat), then
      1. Let i = $bor(bs_l, bs_r)
      2. Return `FBitV%%`_val(w, $to_bitstr(w as int, i))

;; ../../../../spec/2d1-runtime-numerics.watsup:373.1-373.32
def $bin_concat(val, val')
1. If val matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w_l, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(w_r, bs_r) = val'
    2. Let i_l = $to_int(w_l as int, bs_l)
    3. Let i_l' = $shl(i_l, w_r as int)
    4. Let i_l'' = (i_l' + bs_r)
    5. Let w = (w_l + w_r)
    6. Return `FIntV%%`_val(w, $to_bitstr(w as int, i_l''))
  2. Else If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(w_r, bs_r) = val'
    2. Let i_l = $to_int(w_l as int, bs_l)
    3. Let i_l' = $shl(i_l, w_r as int)
    4. Let i_l'' = (i_l' + bs_r)
    5. Let w = (w_l + w_r)
    6. Return `FIntV%%`_val(w, $to_bitstr(w as int, i_l''))
1. Else If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w_l, bs_l) = val
  2. If val' matches `FIntV%%`, then
    1. Let `FIntV%%`_val(w_r, bs_r) = val'
    2. Let i_l = $shl(bs_l, w_r as int)
    3. Let i_l' = (i_l + bs_r)
    4. Let w = (w_l + w_r)
    5. Return `FBitV%%`_val(w, $to_bitstr(w as int, i_l'))
  2. Else If val' matches `FBitV%%`, then
    1. Let `FBitV%%`_val(w_r, bs_r) = val'
    2. Let i_l = $shl(bs_l, w_r as int)
    3. Let i_l' = (i_l + bs_r)
    4. Let w = (w_l + w_r)
    5. Return `FBitV%%`_val(w, $to_bitstr(w as int, i_l'))

;; ../../../../spec/2d1-runtime-numerics.watsup:402.1-402.30
def $bin_land(val, val')
1. If val matches `BoolV%`, then
  1. Let `BoolV%`_val(b_l) = val
  2. If val' matches `BoolV%`, then
    1. Let `BoolV%`_val(b_r) = val'
    2. Return `BoolV%`_val((b_l /\ b_r))

;; ../../../../spec/2d1-runtime-numerics.watsup:410.1-410.29
def $bin_lor(val, val')
1. If val matches `BoolV%`, then
  1. Let `BoolV%`_val(b_l) = val
  2. If val' matches `BoolV%`, then
    1. Let `BoolV%`_val(b_r) = val'
    2. Return `BoolV%`_val((b_l \/ b_r))

;; ../../../../spec/2d1-runtime-numerics.watsup:420.1-421.21
def $cast_op(typ, val'')
1. If val'' matches `BoolV%`, then
  1. Let `BoolV%`_val(b) = val''
  2. Return $cast_bool(typ, b)
1. Else If val'' matches `IntV%`, then
  1. Let `IntV%`_val(i) = val''
  2. Return $cast_int(typ, i)
1. Else If val'' matches `FIntV%%`, then
  1. Let `FIntV%%`_val(w, bs) = val''
  2. Return $cast_fint(typ, w, bs)
1. Else If val'' matches `FBitV%%`, then
  1. Let `FBitV%%`_val(w, bs) = val''
  2. Return $cast_fbit(typ, w, bs)
1. Else If val'' matches `SEnumFieldV%%%`, then
  1. Let `SEnumFieldV%%%`_val(_id, _member, val'') = val''
  2. Return $cast_op(typ, val'')
1. Else If val'' matches `StructV%%`, then
  1. Let `StructV%%`_val(id, (member, val'')*{member <- member*, val'' <- val''*}) = val''
  2. Return $cast_struct(typ, id, (member, val'')*{member <- member*, val'' <- val''*})
1. Else If val'' matches `HeaderV%%`, then
  1. Let `HeaderV%%`_val(id, (member, val'')*{member <- member*, val'' <- val''*}) = val''
  2. Return $cast_header(typ, id, (member, val'')*{member <- member*, val'' <- val''*})
1. Else If val'' matches `SeqV%`, then
  1. Let `SeqV%`_val(val''*{val'' <- val''*}) = val''
  2. Return $cast_seq(typ, val''*{val'' <- val''*})
1. Else If val'' matches `RecordV%`, then
  1. Let `RecordV%`_val((member, val'')*{member <- member*, val'' <- val''*}) = val''
  2. Return $cast_record(typ, (member, val'')*{member <- member*, val'' <- val''*})
1. Else If val'' matches `DefaultV`, then
  1. Return $default(typ)
1. Else If val'' matches `SetV%`, then
  1. Let `SetV%`_val(setval) = val''
  2. If setval matches `SingletonSet%`, then
    1. Let `SingletonSet%`_setval(val'') = setval
    2. Return $cast_set_singleton(typ, val'')
  2. Else If setval matches `MaskSet%%`, then
    1. Let `MaskSet%%`_setval(val_b, val_m) = setval
    2. Return $cast_set_mask(typ, val_b, val_m)
  2. Else If setval matches `RangeSet%%`, then
    1. Let `RangeSet%%`_setval(val_l, val_u) = setval
    2. Return $cast_set_range(typ, val_l, val_u)

;; ../../../../spec/2d1-runtime-numerics.watsup:423.1-423.24
def $default(typ)
1. Return $default'($canon_typ(typ))

;; ../../../../spec/2d1-runtime-numerics.watsup:424.1-424.25
def $default'(typ'')
1. If (typ'' = `ErrT`_primtyp() as typ), then
  1. Return `ErrV%`_val("NoError")
2. If (typ'' = `StrT`_primtyp() as typ), then
  1. Return `StrV%`_val("")
3. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return `BoolV%`_val(false)
4. If (typ'' = `IntT`_numtyp() as typ), then
  1. Return `IntV%`_val(0 as int)
5. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. Return `FIntV%%`_val(w, 0 as bitstr)
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. Return `FBitV%%`_val(w, 0 as bitstr)
  2. Else If numtyp matches `VBitT%`, then
    1. Let `VBitT%`_numtyp(w) = numtyp
    2. Return `VBitV%%%`_val(w, 0, 0 as bitstr)
6. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `EnumT%%`, then
    1. Let `EnumT%%`_datatyp(id, member*) = datatyp
    2. If member* matches _ :: _, then
      1. Let member_h :: _member* = member*
      2. Return `EnumFieldV%%`_val(id, member_h)
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(id, typ'', (member, val)*{member <- member*, val <- val*}) = datatyp
    2. Let val_zero = $cast_int(typ'', 0 as int)
    3. Let member? = $assoc_<val, member>(val_zero, (val, member)*{member <- member*, val <- val*})
    4. If member? matches (_), then
      1. Let ?(member_zero) = member?
      2. Return `SEnumFieldV%%%`_val(id, member_zero, val_zero)
    5. If (?() = $assoc_<val, member>(val_zero, (val, member)*{member <- member*, val <- val*})), then
      1. Return `SEnumFieldV%%%`_val(id, "__UNSPECIFIED", val_zero)
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ''*{typ'' <- typ''*}) = datatyp
    2. Return `TupleV%`_val($default(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ'', int) = datatyp
    2. If int <: nat, then
      1. Let n_s = int as nat
      2. Let val*{val <- val*} = $repeat_<val>($default(typ''), n_s)
      3. Return `StackV%%%`_val(val*{val <- val*}, 0 as int, n_s as int)
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(id, (member, typ'')*{member <- member*, typ'' <- typ''*}) = datatyp
    2. Return `StructV%%`_val(id, (member, $default(typ''))*{member <- member*, typ'' <- typ''*})
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(id, (member, typ'')*{member <- member*, typ'' <- typ''*}) = datatyp
    2. Return `HeaderV%%`_val(id, (member, $default(typ''))*{member <- member*, typ'' <- typ''*})
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(id, (member, typ'')*{member <- member*, typ'' <- typ''*}) = datatyp
    2. Return `UnionV%%`_val(id, (member, $default(typ''))*{member <- member*, typ'' <- typ''*})

;; ../../../../spec/2d1-runtime-numerics.watsup:428.1-428.32
def $cast_bool(typ, b)
1. Return $cast_bool'($canon_typ(typ), b)

;; ../../../../spec/2d1-runtime-numerics.watsup:429.1-429.33
def $cast_bool'(typ'', b')
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return `BoolV%`_val(b')
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. If (b' = true), then
      1. Return `FBitV%%`_val(w, 1 as bitstr)
    2. Else If (b' = false), then
      1. Return `FBitV%%`_val(w, 0 as bitstr)
3. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ'') = datatyp
    2. Return $cast_bool(typ'', b')

;; ../../../../spec/2d1-runtime-numerics.watsup:442.1-442.30
def $cast_int(typ, i)
1. Return $cast_int'($canon_typ(typ), i)

;; ../../../../spec/2d1-runtime-numerics.watsup:443.1-443.31
def $cast_int'(typ'', i)
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return `BoolV%`_val((i = 0 as int))
2. If (typ'' = `IntT`_numtyp() as typ), then
  1. Return `IntV%`_val(i)
3. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. Return `FIntV%%`_val(w, $to_bitstr(w as int, i))
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. Return `FBitV%%`_val(w, $to_bitstr(w as int, i))
4. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ'') = datatyp
    2. Return $cast_int(typ'', i)
5. If typ'' <: synthtyp, then
  1. Let synthtyp = typ'' as synthtyp
  2. If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ'') = synthtyp
    2. Let val = $cast_int(typ'', i)
    3. Return `SetV%`_val(`SingletonSet%`_setval(val))

;; ../../../../spec/2d1-runtime-numerics.watsup:459.1-459.41
def $cast_fint(typ, w, bs)
1. Return $cast_fint'($canon_typ(typ), w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:460.1-460.42
def $cast_fint'(typ'', w', bs)
1. If (typ'' = `IntT`_numtyp() as typ), then
  1. Return `IntV%`_val($to_int(w' as int, bs))
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w_to) = numtyp
    2. Let bs' = $to_bitstr(w_to as int, $to_int(w' as int, bs))
    3. Return `FIntV%%`_val(w_to, bs')
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w_to) = numtyp
    2. Let bs' = $to_bitstr(w_to as int, $to_int(w' as int, bs))
    3. Return `FBitV%%`_val(w_to, bs')
3. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ'') = datatyp
    2. Return $cast_fint(typ'', w', bs)
4. If typ'' <: synthtyp, then
  1. Let synthtyp = typ'' as synthtyp
  2. If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ'') = synthtyp
    2. Let val = $cast_fint(typ'', w', bs)
    3. Return `SetV%`_val(`SingletonSet%`_setval(val))

;; ../../../../spec/2d1-runtime-numerics.watsup:477.1-477.41
def $cast_fbit(typ, w, bs)
1. Return $cast_fbit'($canon_typ(typ), w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:478.1-478.42
def $cast_fbit'(typ'', w', bs)
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return `BoolV%`_val((bs = 1 as bitstr))
2. If (typ'' = `IntT`_numtyp() as typ), then
  1. Return `IntV%`_val(bs)
3. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w_to) = numtyp
    2. Let bs' = $to_bitstr(w_to as int, bs)
    3. Return `FIntV%%`_val(w_to, bs')
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w_to) = numtyp
    2. Let bs' = $to_bitstr(w_to as int, bs)
    3. Return `FBitV%%`_val(w_to, bs')
4. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ'') = datatyp
    2. Return $cast_fbit(typ'', w', bs)
5. If typ'' <: synthtyp, then
  1. Let synthtyp = typ'' as synthtyp
  2. If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ'') = synthtyp
    2. Let val = $cast_fbit(typ'', w', bs)
    3. Return `SetV%`_val(`SingletonSet%`_setval(val))

;; ../../../../spec/2d1-runtime-numerics.watsup:500.1-500.48
def $cast_struct(typ, id, (member, val)*{member <- member*, val <- val*})
1. Return $cast_struct'($canon_typ(typ), id, (member, val)*{member <- member*, val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:501.1-501.49
def $cast_struct'(typ, id', (member, val)*{member <- member*, val <- val*})
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(id, _(member, typ)*) = datatyp
    2. If (id = id'), then
      1. Return `StructV%%`_val(id, (member, val)*{member <- member*, val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:513.1-513.48
def $cast_header(typ, id, (member, val)*{member <- member*, val <- val*})
1. Return $cast_header'($canon_typ(typ), id, (member, val)*{member <- member*, val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:514.1-514.49
def $cast_header'(typ, id', (member, val)*{member <- member*, val <- val*})
1. If typ <: datatyp, then
  1. Let datatyp = typ as datatyp
  2. If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(id, _(member, typ)*) = datatyp
    2. If (id = id'), then
      1. Return `HeaderV%%`_val(id, (member, val)*{member <- member*, val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:526.1-526.31
def $cast_seq(typ, val*{val <- val*})
1. Return $cast_seq'($canon_typ(typ), val*{val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:527.1-527.32
def $cast_seq'(typ', val*{val <- val*})
1. If typ' <: datatyp, then
  1. Let datatyp = typ' as datatyp
  2. If datatyp matches `ListT%`, then
    1. Let `ListT%`_datatyp(typ) = datatyp
    2. (Let val' = $cast_op(typ, val))*{val <- val*, val' <- val'*}
    3. Return `ListV%`_val(val'*{val' <- val'*})
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ*{typ <- typ*}) = datatyp
    2. (Let val' = $cast_op(typ, val))*{typ <- typ*, val <- val*, val' <- val'*}
    3. Return `TupleV%`_val(val'*{val' <- val'*})
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ, i_size) = datatyp
    2. (Let val' = $cast_op(typ, val))*{val <- val*, val' <- val'*}
    3. Let i_idx = |val*{val <- val*}| as int
    4. Return `StackV%%%`_val(val'*{val' <- val'*}, i_idx, i_size)
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(id, (member, typ)*{member <- member*, typ <- typ*}) = datatyp
    2. (Let val' = $cast_op(typ, val))*{typ <- typ*, val <- val*, val' <- val'*}
    3. Return `StructV%%`_val(id, (member, val')*{member <- member*, val' <- val'*})
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(id, (member, typ)*{member <- member*, typ <- typ*}) = datatyp
    2. (Let val' = $cast_op(typ, val))*{typ <- typ*, val <- val*, val' <- val'*}
    3. Return `HeaderV%%`_val(id, (member, val')*{member <- member*, val' <- val'*})

;; ../../../../spec/2d1-runtime-numerics.watsup:553.1-553.44
def $cast_record(typ, (member, val)*{member <- member*, val <- val*})
1. Return $cast_record'($canon_typ(typ), (member, val)*{member <- member*, val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:554.1-554.45
def $cast_record'(typ', (member, val)*{member <- member*, val <- val*})
1. If typ' <: datatyp, then
  1. Let datatyp = typ' as datatyp
  2. If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(id, (member_t, typ)*{member_t <- member_t*, typ <- typ*}) = datatyp
    2. (Let val' = $find_map<member, val>(`MAP%`_map<member, val>(`PAIR%%`_pair<member, val>(member, val)*{member <- member*, val <- val*}), member_t))*{member_t <- member_t*, val' <- val'*}
    3. (Let val'' = $cast_op(typ, val'))*{typ <- typ*, val' <- val'*, val'' <- val''*}
    4. Return `StructV%%`_val(id, (member_t, val'')*{member_t <- member_t*, val'' <- val''*})
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(id, (member_t, typ)*{member_t <- member_t*, typ <- typ*}) = datatyp
    2. (Let val' = $find_map<member, val>(`MAP%`_map<member, val>(`PAIR%%`_pair<member, val>(member, val)*{member <- member*, val <- val*}), member_t))*{member_t <- member_t*, val' <- val'*}
    3. (Let val'' = $cast_op(typ, val'))*{typ <- typ*, val' <- val'*, val'' <- val''*}
    4. Return `HeaderV%%`_val(id, (member_t, val'')*{member_t <- member_t*, val'' <- val''*})

;; ../../../../spec/2d1-runtime-numerics.watsup:581.1-581.40
def $cast_set_singleton(typ, val)
1. Return $cast_set_singleton'($canon_typ(typ), val)

;; ../../../../spec/2d1-runtime-numerics.watsup:582.1-582.41
def $cast_set_singleton'(typ', val)
1. If typ' <: synthtyp, then
  1. Let synthtyp = typ' as synthtyp
  2. If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ) = synthtyp
    2. Let val' = $cast_op(typ, val)
    3. Return `SetV%`_val(`SingletonSet%`_setval(val'))

;; ../../../../spec/2d1-runtime-numerics.watsup:589.1-589.40
def $cast_set_mask(typ, val_b, val_m)
1. Return $cast_set_mask'($canon_typ(typ), val_b, val_m)

;; ../../../../spec/2d1-runtime-numerics.watsup:590.1-590.41
def $cast_set_mask'(typ', val_b, val_m)
1. If typ' <: synthtyp, then
  1. Let synthtyp = typ' as synthtyp
  2. If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ) = synthtyp
    2. Let val_b' = $cast_op(typ, val_b)
    3. Let val_m' = $cast_op(typ, val_m)
    4. Return `SetV%`_val(`MaskSet%%`_setval(val_b', val_m'))

;; ../../../../spec/2d1-runtime-numerics.watsup:598.1-598.41
def $cast_set_range(typ, val_l, val_u)
1. Return $cast_set_range'($canon_typ(typ), val_l, val_u)

;; ../../../../spec/2d1-runtime-numerics.watsup:599.1-599.42
def $cast_set_range'(typ', val_l, val_u)
1. If typ' <: synthtyp, then
  1. Let synthtyp = typ' as synthtyp
  2. If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ) = synthtyp
    2. Let val_l' = $cast_op(typ, val_l)
    3. Let val_u' = $cast_op(typ, val_u)
    4. Return `SetV%`_val(`RangeSet%%`_setval(val_l', val_u'))

;; ../../../../spec/2d1-runtime-numerics.watsup:650.1-650.58
def $bitacc_op(val_b, val_h, val_l)
1. Let i_b = $get_num(val_b)
2. Let i_h = $get_num(val_h)
3. Let i_l = $get_num(val_l)
4. Let int = ((i_h + 1 as int) - i_l)
5. If int <: nat, then
  1. Let w = int as nat
  2. Let i = $bitacc(i_b, i_h, i_l)
  3. Return `FBitV%%`_val(w, i)

;; ../../../../spec/2d2-runtime-builtins.watsup:5.1-6.34
def $size(typ, text)
1. If (text = "minSizeInBits"), then
  1. Return $size_minSizeInBits(typ)
1. Else If (text = "minSizeInBytes"), then
  1. Return $size_minSizeInBytes(typ)
1. Else If (text = "maxSizeInBits"), then
  1. Return $size_maxSizeInBits(typ)
1. Else If (text = "maxSizeInBytes"), then
  1. Return $size_maxSizeInBytes(typ)

;; ../../../../spec/2d2-runtime-builtins.watsup:8.1-8.35
def $size_minSizeInBits(typ)
1. Return `IntV%`_val($size_minSizeInBits'(typ) as int)

;; ../../../../spec/2d2-runtime-builtins.watsup:9.1-9.36
def $size_minSizeInBits'(typ)
1. Return $size_minSizeInBits''($canon_typ(typ))

;; ../../../../spec/2d2-runtime-builtins.watsup:10.1-10.37
def $size_minSizeInBits''(typ'')
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return 1
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. Return w
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. Return w
  2. Else If numtyp matches `VBitT%`, then
    1. Let `VBitT%`_numtyp(_width) = numtyp
    2. Return 0
3. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ'') = datatyp
    2. Return $size_minSizeInBits'(typ'')
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, typ'', _(member, val)*) = datatyp
    2. Return $size_minSizeInBits'(typ'')
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ''*{typ'' <- typ''*}) = datatyp
    2. Return $sum($size_minSizeInBits'(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ'', int) = datatyp
    2. If int <: nat, then
      1. Let n_s = int as nat
      2. Return ($size_minSizeInBits'(typ'') * n_s)
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. Return $sum($size_minSizeInBits'(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. Return $sum($size_minSizeInBits'(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. Return $min($size_minSizeInBits'(typ'')*{typ'' <- typ''*})

;; ../../../../spec/2d2-runtime-builtins.watsup:12.1-12.36
def $size_minSizeInBytes(typ)
1. Let n = $size_minSizeInBits'(typ)
2. Return `IntV%`_val((n / 8) as int)

;; ../../../../spec/2d2-runtime-builtins.watsup:14.1-14.35
def $size_maxSizeInBits(typ)
1. Return `IntV%`_val($size_maxSizeInBits'(typ) as int)

;; ../../../../spec/2d2-runtime-builtins.watsup:15.1-15.36
def $size_maxSizeInBits'(typ)
1. Return $size_maxSizeInBits''($canon_typ(typ))

;; ../../../../spec/2d2-runtime-builtins.watsup:16.1-16.37
def $size_maxSizeInBits''(typ'')
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. Return 1
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. Return w
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. Return w
  2. Else If numtyp matches `VBitT%`, then
    1. Let `VBitT%`_numtyp(w) = numtyp
    2. Return w
3. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ'') = datatyp
    2. Return $size_maxSizeInBits'(typ'')
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, typ'', _(member, val)*) = datatyp
    2. Return $size_maxSizeInBits'(typ'')
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ''*{typ'' <- typ''*}) = datatyp
    2. Return $sum($size_maxSizeInBits'(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ'', int) = datatyp
    2. If int <: nat, then
      1. Let n_s = int as nat
      2. Return ($size_maxSizeInBits'(typ'') * n_s)
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. Return $sum($size_maxSizeInBits'(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. Return $sum($size_maxSizeInBits'(typ'')*{typ'' <- typ''*})
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(_id, (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) = datatyp
    2. Return $max($size_maxSizeInBits'(typ'')*{typ'' <- typ''*})

;; ../../../../spec/2d2-runtime-builtins.watsup:18.1-18.36
def $size_maxSizeInBytes(typ)
1. Let n = $size_maxSizeInBits'(typ)
2. Return `IntV%`_val((n / 8) as int)

;; ../../../../spec/2e-runtime-env.watsup:11.15-11.31
syntax styp = 
   | `%%%%`(typ, dir, ctk, val?)

;; ../../../../spec/2e-runtime-env.watsup:18.45-18.58
syntax frame = map<id, styp>

;; ../../../../spec/2e-runtime-env.watsup:20.1-20.27
def $empty_frame
1. Return $empty_map<id, styp>

;; ../../../../spec/2e-runtime-env.watsup:24.57-24.73
syntax tdenv = map<tid, typdef>

;; ../../../../spec/2e-runtime-env.watsup:26.1-26.27
def $empty_tdenv
1. Return $empty_map<tid, typdef>

;; ../../../../spec/2e-runtime-env.watsup:30.57-30.74
syntax fdenv = map<fid, funcdef>

;; ../../../../spec/2e-runtime-env.watsup:32.1-32.27
def $empty_fdenv
1. Return $empty_map<fid, funcdef>

;; ../../../../spec/2e-runtime-env.watsup:36.57-36.74
syntax cdenv = map<fid, consdef>

;; ../../../../spec/2e-runtime-env.watsup:38.1-38.27
def $empty_cdenv
1. Return $empty_map<cid, consdef>

;; ../../../../spec/2e-runtime-env.watsup:45.1-45.36
def $check_func_name(id_l, id_r)
1. Return (id_l = id_r)

;; ../../../../spec/2e-runtime-env.watsup:49.1-49.42
def $check_arity_more(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})
1. Return (|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| > |id_p*{id_p <- id_p*}|)

;; ../../../../spec/2e-runtime-env.watsup:53.1-53.37
def $check_arity(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})
1. Return (|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| = |id_p*{id_p <- id_p*}|)

;; ../../../../spec/2e-runtime-env.watsup:57.1-57.42
def $check_arity_less(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})
1. Return (|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| < |id_p*{id_p <- id_p*}|)

;; ../../../../spec/2e-runtime-env.watsup:61.1-61.46
def $get_params_missing_names(id*, id_a*{id_a <- id_a*})
1. If id* matches [], then
  1. Return []
1. Else
  1. Let id_p_h :: id_p_t*{id_p_t <- id_p_t*} = id*
  2. If ~ $in_set<id>(id_p_h, `SET%`_set<id>(id_a*{id_a <- id_a*})), then
    1. Return id_p_h :: $get_params_missing_names(id_p_t*{id_p_t <- id_p_t*}, id_a*{id_a <- id_a*})
  3. Otherwise
    1. Return $get_params_missing_names(id_p_t*{id_p_t <- id_p_t*}, id_a*{id_a <- id_a*})

;; ../../../../spec/2e-runtime-env.watsup:73.1-73.68
def $find_match_named<V>(fid, V, id_a*{id_a <- id_a*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})
1. If $eq_set<id>(`SET%`_set<id>(id_a*{id_a <- id_a*}), `SET%`_set<id>(id_p*{id_p <- id_p*})), then
  1. Return ?((fid, V, []))
2. Otherwise
  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:83.1-84.59
def $find_match_named_default<V>(fid, V, id_a*{id_a <- id_a*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})
1. Let id_deft*{id_deft <- id_deft*} = $get_params_missing_names(id_p*{id_p <- id_p*}, id_a*{id_a <- id_a*})
2. If ($find_match_named<V>(fid, V, id_a*{id_a <- id_a*} ++ id_deft*{id_deft <- id_deft*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}) =/= ?()), then
  1. Return ?((fid, V, id_deft*{id_deft <- id_deft*}))
3. Otherwise
  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:94.1-95.61
def $find_match_unnamed_default<V>(fid, V, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})
1. Let ((id, bool)*{bool <- bool*, id <- id*}, (id_deft, bool')*{bool' <- bool'*, id_deft <- id_deft*}) = $partition_<(id, bool)>((id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}, |id_a?{id_a <- id_a?}*{id_a? <- id_a?*}|)
2. If ((bool' = true))*{bool' <- bool'*}, then
  1. Return ?((fid, V, id_deft*{id_deft <- id_deft*}))
3. Otherwise
  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:104.1-105.57
def $find_matching_func<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id*', `%%`_fid(id_f', (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V)
1. Let id_a'*{id_a' <- id_a'*} = id*'
2. If ~ $check_func_name(id_f, id_f'), then
  1. Return ?()
2. Else If $check_arity_more(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}), then
  1. Return ?()
3. If (|id_a'*{id_a' <- id_a'*}| > 0), then
  1. If $check_func_name(id_f, id_f'), then
    1. If $check_arity(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}), then
      1. Return $find_match_named<V>(`%%`_fid(id_f', (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V, id_a'*{id_a' <- id_a'*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})
    2. If $check_arity_less(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}), then
      1. Return $find_match_named_default<V>(`%%`_fid(id_f', (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V, id_a'*{id_a' <- id_a'*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})
4. If id*' matches [], then
  1. If $check_func_name(id_f, id_f'), then
    1. If $check_arity(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}), then
      1. Return ?((`%%`_fid(id_f', (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V, []))
    2. If $check_arity_less(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}), then
      1. Return $find_match_unnamed_default<V>(`%%`_fid(id_f', (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})

;; ../../../../spec/2e-runtime-env.watsup:142.1-143.58
def $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid*, V*)
1. If fid* matches [], then
  1. If V* matches [], then
    1. Return []
1. Else
  1. Let fid_h :: fid_t*{fid_t <- fid_t*} = fid*
  2. If V* matches _ :: _, then
    1. Let V_h :: V_t*{V_t <- V_t*} = V*
    2. If ($find_matching_func<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid_h, V_h) = ?()), then
      1. Return $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid_t*{fid_t <- fid_t*}, V_t*{V_t <- V_t*})
    3. Let (fid, V, id*)? = $find_matching_func<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid_h, V_h)
    4. If (fid, V, id*)? matches (_), then
      1. Let ?((fid, V, id_deft*{id_deft <- id_deft*})) = (fid, V, id*)?
      2. Return (fid, V, id_deft*{id_deft <- id_deft*}) :: $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid_t*{fid_t <- fid_t*}, V_t*{V_t <- V_t*})

;; ../../../../spec/2e-runtime-env.watsup:156.1-157.41
def $find_func_opt<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, `MAP%`_map<fid, V>(`PAIR%%`_pair<fid, V>(fid, V)*{V <- V*, fid <- fid*}))
1. If (|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| > 0), then
  1. (Let id? = id_a?{id_a <- id_a?})*{id? <- id?*, id_a? <- id_a?*}
  2. If (id? matches (_))*{id? <- id?*}, then
    1. (Let ?(id_a') = id?)*{id? <- id?*, id_a' <- id_a'*}
    2. If ($find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid*{fid <- fid*}, V*{V <- V*}) = []), then
      1. Return ?()
    3. Let (fid, V, id*)* = $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid*{fid <- fid*}, V*{V <- V*})
    4. If (fid, V, id*)* matches [ _/1 ], then
      1. Let [(fid', V', id_deft*{id_deft <- id_deft*})] = (fid, V, id*)*
      2. Return ?((fid', V', id_deft*{id_deft <- id_deft*}))
2. If ((id_a?{id_a <- id_a?} = ?()))*{id_a? <- id_a?*}, then
  1. If ($find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, [], fid*{fid <- fid*}, V*{V <- V*}) = []), then
    1. Return ?()
  2. Let (fid, V, id*)* = $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, [], fid*{fid <- fid*}, V*{V <- V*})
  3. If (fid, V, id*)* matches [ _/1 ], then
    1. Let [(fid', V', id_deft*{id_deft <- id_deft*})] = (fid, V, id*)*
    2. Return ?((fid', V', id_deft*{id_deft <- id_deft*}))

;; ../../../../spec/2e-runtime-env.watsup:180.1-181.37
def $find_func<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, `MAP%`_map<fid, V>(`PAIR%%`_pair<fid, V>(fid, V)*{V <- V*, fid <- fid*}))
1. Let (fid, V, id*)? = $find_func_opt<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, `MAP%`_map<fid, V>(`PAIR%%`_pair<fid, V>(fid, V)*{V <- V*, fid <- fid*}))
2. If (fid, V, id*)? matches (_), then
  1. Let ?((fid', V', id_deft*{id_deft <- id_deft*})) = (fid, V, id*)?
  2. Return (fid', V', id_deft*{id_deft <- id_deft*})

;; ../../../../spec/2e-runtime-env.watsup:187.1-187.55
def $find_funcs_by_name(id_f, fid*, funcdef*)
1. If fid* matches [], then
  1. If funcdef* matches [], then
    1. Return []
1. Else
  1. Let `%%`_fid(id_h, _(id, bool)*) :: fid_t*{fid_t <- fid_t*} = fid*
  2. If funcdef* matches _ :: _, then
    1. Let fd_h :: fd_t*{fd_t <- fd_t*} = funcdef*
    2. If (id_f = id_h), then
      1. Return fd_h :: $find_funcs_by_name(id_f, fid_t*{fid_t <- fid_t*}, fd_t*{fd_t <- fd_t*})
  3. Let _fid :: fid_t*{fid_t <- fid_t*} = fid*
  4. If funcdef* matches _ :: _, then
    1. Let _funcdef :: fd_t*{fd_t <- fd_t*} = funcdef*
    2. Otherwise
      1. Return $find_funcs_by_name(id_f, fid_t*{fid_t <- fid_t*}, fd_t*{fd_t <- fd_t*})

;; ../../../../spec/2e-runtime-env.watsup:199.1-200.23
def $find_func_by_name_opt(id_f, `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid, fd)*{fd <- fd*, fid <- fid*}))
1. If ([] = $find_funcs_by_name(id_f, fid*{fid <- fid*}, fd*{fd <- fd*})), then
  1. Return ?()
2. Let funcdef* = $find_funcs_by_name(id_f, fid*{fid <- fid*}, fd*{fd <- fd*})
3. If funcdef* matches [ _/1 ], then
  1. Let [fd_f] = funcdef*
  2. Return ?(fd_f)

;; ../../../../spec/2e-runtime-env.watsup:208.1-209.23
def $find_func_by_name(id_f, `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid, fd)*{fd <- fd*, fid <- fid*}))
1. Let funcdef? = $find_func_by_name_opt(id_f, `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid, fd)*{fd <- fd*, fid <- fid*}))
2. If funcdef? matches (_), then
  1. Let ?(fd_f) = funcdef?
  2. Return fd_f

;; ../../../../spec/2f-runtime-ctk.watsup:5.14-5.30
syntax ctk = 
   | `LCTK`()
   | `CTK`()
   | `DYN`()

;; ../../../../spec/2f-runtime-ctk.watsup:7.1-7.81
def $join_ctk(ctk'', ctk''')
1. If ctk'' matches `LCTK`, then
  1. If ctk''' matches `LCTK`, then
    1. Return `LCTK`_ctk()
  1. Else If ctk''' matches `CTK`, then
    1. Return `CTK`_ctk()
1. Else If ctk'' matches `CTK`, then
  1. If ctk''' matches `LCTK`, then
    1. Return `CTK`_ctk()
  1. Else If ctk''' matches `CTK`, then
    1. Return `CTK`_ctk()
2. Otherwise
  1. Return `DYN`_ctk()

;; ../../../../spec/2f-runtime-ctk.watsup:16.1-16.75
def $joins_ctk(ctk*'')
1. If ctk*'' matches [], then
  1. Return `DYN`_ctk()
1. Else
  1. If ctk*'' matches [ _/1 ], then
    1. Let [ctk] = ctk*''
    2. Return ctk
  2. Let ctk_a :: ctk*'' = ctk*''
  3. If ctk*'' matches [ _/1 ], then
    1. Let [ctk_b] = ctk*''
    2. Return $join_ctk(ctk_a, ctk_b)
  3. Else If ctk*'' matches _ :: _, then
    1. Let ctk_b :: ctk_c*{ctk_c <- ctk_c*} = ctk*''
    2. Let ctk_d = $join_ctk(ctk_a, ctk_b)
    3. Return $joins_ctk(ctk_d :: ctk_c*{ctk_c <- ctk_c*})

;; ../../../../spec/2g-runtime-flow.watsup:5.15-5.25
syntax flow = 
   | `CONT`()
   | `RET`()

;; ../../../../spec/2g-runtime-flow.watsup:9.1-9.85
def $join_flow(flow'', flow''')
1. If flow'' matches `RET`, then
  1. If flow''' matches `RET`, then
    1. Return `RET`_flow()
2. Return `CONT`_flow()

;; ../../../../spec/3-syntax-il.watsup:5.16-5.19
syntax numIL = num

;; ../../../../spec/3-syntax-il.watsup:15.15-15.17
syntax idIL = id

;; ../../../../spec/3-syntax-il.watsup:21.17-21.21
syntax nameIL = name

;; ../../../../spec/3-syntax-il.watsup:27.19-27.23
syntax memberIL = idIL

;; ../../../../spec/3-syntax-il.watsup:33.22-33.26
syntax matchkindIL = idIL

;; ../../../../spec/3-syntax-il.watsup:39.23-39.27
syntax statelabelIL = idIL

;; ../../../../spec/3-syntax-il.watsup:45.17-45.21
syntax unopIL = unop

;; ../../../../spec/3-syntax-il.watsup:51.18-51.23
syntax binopIL = binop

;; ../../../../spec/3-syntax-il.watsup:57.16-57.19
syntax dirIL = dir

;; ../../../../spec/3-syntax-il.watsup:69.17-69.20
syntax typeIL = typ

;; ../../../../spec/3-syntax-il.watsup:75.19-75.21
syntax tparamIL = id

;; ../../../../spec/3-syntax-il.watsup:81.18-81.40
syntax paramIL = 
   | `%%%%`(idIL, dirIL, typeIL, val?)

;; ../../../../spec/3-syntax-il.watsup:87.19-87.26
syntax cparamIL = paramIL

;; ../../../../spec/3-syntax-il.watsup:93.17-93.23
syntax targIL = typeIL

;; ../../../../spec/3-syntax-il.watsup:100.1-102.39
syntax argIL = 
   | `ExprA%`(exprIL)
   | `NameA%%`(idIL, exprIL?)
   | `AnyA`()

;; ../../../../spec/3-syntax-il.watsup:109.1-111.33
syntax keysetIL = 
   | `ExprK%`(exprIL)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec/3-syntax-il.watsup:117.23-117.45
syntax selectcaseIL = 
   | `%%`(keysetIL*, statelabelIL)

;; ../../../../spec/3-syntax-il.watsup:123.18-123.29
syntax annotIL = 
   | `(%;%)`(typ, ctk)

;; ../../../../spec/3-syntax-il.watsup:125.1-145.128
syntax exprIL = 
   | `ValueE%%`(val, annotIL)
   | `NameE%%`(nameIL, annotIL)
   | `SeqE%%`(exprIL*, annotIL)
   | `SeqDefaultE%%`(exprIL*, annotIL)
   | `RecordE%%`((memberIL, exprIL)*, annotIL)
   | `RecordDefaultE%%`((memberIL, exprIL)*, annotIL)
   | `DefaultE%`(annotIL)
   | `UnE%%%`(unopIL, exprIL, annotIL)
   | `BinE%%%%`(binopIL, exprIL, exprIL, annotIL)
   | `TernE%%%%`(exprIL, exprIL, exprIL, annotIL)
   | `CastE%%%`(typeIL, exprIL, annotIL)
   | `MaskE%%%`(exprIL, exprIL, annotIL)
   | `RangeE%%%`(exprIL, exprIL, annotIL)
   | `SelectE%%%`(exprIL*, selectcaseIL*, annotIL)
   | `ArrAccE%%%`(exprIL, exprIL, annotIL)
   | `BitAccE%%%%`(exprIL, exprIL, exprIL, annotIL)
   | `ExprAccE%%%`(exprIL, memberIL, annotIL)
   | `CallFuncE%%%%`(nameIL, targIL*, argIL*, annotIL)
   | `CallMethodE%%%%%`(exprIL, memberIL, targIL*, argIL*, annotIL)
   | `CallTypeE%%%%%`(nameIL, memberIL, targIL*, argIL*, annotIL)
   | `InstE%%%%`(nameIL, targIL*, argIL*, annotIL)

;; ../../../../spec/3-syntax-il.watsup:151.18-151.75
syntax blockIL = 
   | `BlockB%`(stmtIL*)

;; ../../../../spec/3-syntax-il.watsup:158.1-169.67
syntax stmtIL = 
   | `EmptyS`()
   | `AssignS%%`(exprIL, exprIL)
   | `SwitchS%%`(exprIL, switchcaseIL*)
   | `IfS%%%`(exprIL, stmtIL, stmtIL)
   | `BlockS%`(blockIL)
   | `ExitS`()
   | `RetS%`(exprIL?)
   | `CallFuncS%%%`(nameIL, targIL*, argIL*)
   | `CallMethodS%%%%`(exprIL, memberIL, targIL*, argIL*)
   | `CallInstS%%%%`(typeIL, nameIL, targIL*, argIL*)
   | `TransS%`(exprIL)
   | `DeclS%`(declIL)

;; ../../../../spec/3-syntax-il.watsup:176.1-177.39
syntax switchlabelIL = 
   | `ExprL%`(exprIL)
   | `DefaultL`()

;; ../../../../spec/3-syntax-il.watsup:180.1-181.56
syntax switchcaseIL = 
   | `MatchC%%`(switchlabelIL, blockIL)
   | `FallC%`(switchlabelIL)

;; ../../../../spec/3-syntax-il.watsup:187.24-187.44
syntax parserstateIL = 
   | `%%`(statelabelIL, blockIL)

;; ../../../../spec/3-syntax-il.watsup:193.16-193.26
syntax tblIL = tblpropIL*

;; ../../../../spec/3-syntax-il.watsup:199.19-199.37
syntax tblkeyIL = 
   | `%%`(exprIL, matchkindIL)

;; ../../../../spec/3-syntax-il.watsup:200.23-200.32
syntax tblkeypropIL = tblkeyIL*

;; ../../../../spec/3-syntax-il.watsup:206.22-206.53
syntax tblactionIL = 
   | `%%%%`(nameIL, argIL*, paramIL*, paramIL*)

;; ../../../../spec/3-syntax-il.watsup:207.26-207.38
syntax tblactionpropIL = tblactionIL*

;; ../../../../spec/3-syntax-il.watsup:213.21-213.52
syntax tblentryIL = 
   | `%%%%`(bool, keysetIL*, tblactionIL, val?)

;; ../../../../spec/3-syntax-il.watsup:214.25-214.41
syntax tblentrypropIL = 
   | `%%`(bool, tblentryIL*)

;; ../../../../spec/3-syntax-il.watsup:220.27-220.43
syntax tbldefaultpropIL = 
   | `%%`(bool, tblactionIL)

;; ../../../../spec/3-syntax-il.watsup:226.26-226.46
syntax tblcustompropIL = 
   | `%%%`(bool, memberIL, exprIL)

;; ../../../../spec/3-syntax-il.watsup:233.1-237.80
syntax tblpropIL = 
   | `KeyP%`(tblkeypropIL)
   | `ActionP%`(tblactionpropIL)
   | `EntryP%`(tblentrypropIL)
   | `DefaultP%`(tbldefaultpropIL)
   | `CustomP%`(tblcustompropIL)

;; ../../../../spec/3-syntax-il.watsup:244.1-246.53
syntax methodIL = 
   | `ExternConsM%%%`(idIL, tparamIL*, cparamIL*)
   | `ExternAbstractM%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)
   | `ExternM%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)

;; ../../../../spec/3-syntax-il.watsup:255.1-277.52
syntax declIL = 
   | `ConstD%%%`(idIL, typeIL, val)
   | `VarD%%%`(idIL, typeIL, exprIL?)
   | `ErrD%`(memberIL*)
   | `MatchKindD%`(memberIL*)
   | `InstD%%%%%%`(idIL, typeIL, nameIL, targIL*, argIL*, declIL*)
   | `StructD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `HeaderD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `UnionD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `EnumD%%`(idIL, memberIL*)
   | `SEnumD%%%`(idIL, typeIL, (memberIL, val)*)
   | `NewTypeD%%`(idIL, typedefIL)
   | `TypeDefD%%`(idIL, typedefIL)
   | `ValueSetD%%%`(idIL, typeIL, exprIL)
   | `ParserTypeD%%%%`(idIL, tparamIL*, tparamIL*, paramIL*)
   | `ParserD%%%%%`(idIL, paramIL*, cparamIL*, declIL*, parserstateIL*)
   | `TableD%%%`(idIL, typeIL, tblIL)
   | `ControlTypeD%%%%`(idIL, tparamIL*, tparamIL*, paramIL*)
   | `ControlD%%%%%`(idIL, paramIL*, cparamIL*, declIL*, blockIL)
   | `ActionD%%%`(idIL, paramIL*, blockIL)
   | `FuncD%%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*, blockIL)
   | `ExternFuncD%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)
   | `ExternObjectD%%%`(idIL, tparamIL*, methodIL*)
   | `PackageTypeD%%%%`(idIL, tparamIL*, tparamIL*, cparamIL*)

;; ../../../../spec/3-syntax-il.watsup:280.1-281.17
syntax typedefIL = 
   | `TypeD%`(typeIL)
   | `DeclD%`(declIL)

;; ../../../../spec/3-syntax-il.watsup:287.20-287.27
syntax programIL = declIL*

;; ../../../../spec/4a1-typing-context.watsup:5.17-5.39
syntax cursor = 
   | `GLOBAL`()
   | `BLOCK`()
   | `LOCAL`()

;; ../../../../spec/4a1-typing-context.watsup:16.3-19.18
syntax glayer = {`CDENV%`(cdenv), `TDENV%`(tdenv), `FDENV%`(fdenv), `FRAME%`(frame)}

;; ../../../../spec/4a1-typing-context.watsup:23.16-23.59
syntax bkind = 
   | `EMPTY`()
   | `EXTERN`()
   | `PARSER`()
   | `CONTROL`()
   | `PACKAGE`()

;; ../../../../spec/4a1-typing-context.watsup:26.3-30.18
syntax blayer = {`ID%`(id), `KIND%`(bkind), `TDENV%`(tdenv), `FDENV%`(fdenv), `FRAME%`(frame)}

;; ../../../../spec/4a1-typing-context.watsup:35.1-43.21
syntax lkind = 
   | `EMPTY`()
   | `EXTERNFUNC`()
   | `FUNC%`(typ)
   | `ACTION`()
   | `EXTERNMETHOD`()
   | `EXTERNABSTRACTMETHOD%`(typ)
   | `PARSERSTATE`()
   | `CONTROLAPPLYMETHOD`()
   | `TABLEAPPLYMETHOD`()

;; ../../../../spec/4a1-typing-context.watsup:46.3-49.20
syntax llayer = {`ID%`(id), `KIND%`(lkind), `TDENV%`(tdenv), `FRAMES%`(frame*)}

;; ../../../../spec/4a1-typing-context.watsup:56.3-58.19
syntax context = {`GLOBAL%`(glayer), `BLOCK%`(blayer), `LOCAL%`(llayer)}

;; ../../../../spec/4a1-typing-context.watsup:66.1-66.29
def $empty_context
1. Let glayer = {CDENV $empty_map<cid, consdef>, TDENV $empty_map<tid, typdef>, FDENV $empty_map<fid, funcdef>, FRAME $empty_map<id, styp>}
2. Let blayer = {ID "", KIND `EMPTY`_bkind(), TDENV $empty_map<tid, typdef>, FDENV $empty_map<fid, funcdef>, FRAME $empty_map<id, styp>}
3. Let llayer = {ID "", KIND `EMPTY`_lkind(), TDENV $empty_map<tid, typdef>, FRAMES [$empty_map<id, styp>]}
4. Let C = {GLOBAL glayer, BLOCK blayer, LOCAL llayer}
5. Return C

;; ../../../../spec/4a1-typing-context.watsup:91.1-92.23
def $enter(C)
1. Return C[LOCAL.FRAMES = $empty_map<id, styp> :: C.LOCAL.FRAMES]

;; ../../../../spec/4a1-typing-context.watsup:96.1-97.22
def $exit(C)
1. Let frame* = C.LOCAL.FRAMES
2. If frame* matches _ :: _, then
  1. Let frame_h :: frame_t*{frame_t <- frame_t*} = frame*
  2. Return C[LOCAL.FRAMES = frame_t*{frame_t <- frame_t*}]

;; ../../../../spec/4a1-typing-context.watsup:106.1-107.34
def $set_blockkind(C, bkind)
1. Return C[BLOCK.KIND = bkind]

;; ../../../../spec/4a1-typing-context.watsup:111.1-112.35
def $set_localkind(C, lkind)
1. Return C[LOCAL.KIND = lkind]

;; ../../../../spec/4a1-typing-context.watsup:116.1-117.63
def $set_blockframe


;; ../../../../spec/4a1-typing-context.watsup:123.1-124.32
def $get_typ_ret_lkind(lkind)
1. If lkind matches `FUNC%`, then
  1. Let `FUNC%`_lkind(typ) = lkind
  2. Return typ
1. Else If lkind matches `ACTION`, then
  1. Return `VoidT`_primtyp() as typ
1. Else If lkind matches `EXTERNABSTRACTMETHOD%`, then
  1. Let `EXTERNABSTRACTMETHOD%`_lkind(typ) = lkind
  2. Return typ
1. Else If lkind matches `CONTROLAPPLYMETHOD`, then
  1. Return `VoidT`_primtyp() as typ

;; ../../../../spec/4a1-typing-context.watsup:135.1-135.42
def $bound_tids(cursor, C)
1. If cursor matches `GLOBAL`, then
  1. Return $empty_set<tid>
1. Else If cursor matches `BLOCK`, then
  1. Return $dom_map<tid, typdef>(C.BLOCK.TDENV)
1. Else If cursor matches `LOCAL`, then
  1. Return $union_set<tid>($dom_map<tid, typdef>(C.LOCAL.TDENV), $bound_tids(`BLOCK`_cursor(), C))

;; ../../../../spec/4a1-typing-context.watsup:147.1-148.84
def $add_styp(cursor, C, id, styp)
1. If cursor matches `GLOBAL`, then
  1. If ~ $in_set<id>(id, $dom_map<id, styp>(C.GLOBAL.FRAME)), then
    1. Let frame = $add_map<id, styp>(C.GLOBAL.FRAME, id, styp)
    2. Return C[GLOBAL.FRAME = frame]
1. Else If cursor matches `BLOCK`, then
  1. If ~ $in_set<id>(id, $dom_map<id, styp>(C.BLOCK.FRAME)), then
    1. Let frame = $add_map<id, styp>(C.BLOCK.FRAME, id, styp)
    2. Return C[BLOCK.FRAME = frame]
1. Else If cursor matches `LOCAL`, then
  1. Let frame* = C.LOCAL.FRAMES
  2. If frame* matches _ :: _, then
    1. Let frame_h :: frame_t*{frame_t <- frame_t*} = frame*
    2. If ~ $in_set<id>(id, $dom_map<id, styp>(frame_h)), then
      1. Let frame_h' = $add_map<id, styp>(frame_h, id, styp)
      2. Let frame*{frame <- frame*} = frame_h' :: frame_t*{frame_t <- frame_t*}
      3. Return C[LOCAL.FRAMES = frame*{frame <- frame*}]

;; ../../../../spec/4a1-typing-context.watsup:162.1-163.88
def $add_styps(cursor, C, id*, styp*)
1. If id* matches [], then
  1. If styp* matches [], then
    1. Return C
1. Else
  1. Let id_h :: id_t*{id_t <- id_t*} = id*
  2. If styp* matches _ :: _, then
    1. Let styp_h :: styp_t*{styp_t <- styp_t*} = styp*
    2. Let C' = $add_styp(cursor, C, id_h, styp_h)
    3. Let C'' = $add_styps(cursor, C', id_t*{id_t <- id_t*}, styp_t*{styp_t <- styp_t*})
    4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:172.1-172.52
def $add_param(p, C, pt)
1. Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt
2. If dir matches `NO`, then
  1. Let C' = $add_styp(p, C, id, `%%%%`_styp(typ, `NO`_dir(), `CTK`_ctk(), ?()))
  2. Return C'
3. If (((dir = `IN`_dir()) \/ (dir = `OUT`_dir())) \/ (dir = `INOUT`_dir())), then
  1. Let C' = $add_styp(p, C, id, `%%%%`_styp(typ, dir, `DYN`_ctk(), ?()))
  2. Return C'

;; ../../../../spec/4a1-typing-context.watsup:182.1-182.54
def $add_params(p, C, paramtyp*)
1. If paramtyp* matches [], then
  1. Return C
1. Else
  1. Let pt_h :: pt_t*{pt_t <- pt_t*} = paramtyp*
  2. Let C' = $add_param(p, C, pt_h)
  3. Let C'' = $add_params(p, C', pt_t*{pt_t <- pt_t*})
  4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:191.1-192.80
def $add_typdef(cursor, C, tid, td)
1. If cursor matches `GLOBAL`, then
  1. If ~ $in_set<tid>(tid, $dom_map<tid, typdef>(C.GLOBAL.TDENV)), then
    1. Let tdenv = $add_map<tid, typdef>(C.GLOBAL.TDENV, tid, td)
    2. Return C[GLOBAL.TDENV = tdenv]
1. Else If cursor matches `BLOCK`, then
  1. If ~ $in_set<tid>(tid, $dom_map<tid, typdef>(C.BLOCK.TDENV)), then
    1. Let tdenv = $add_map<tid, typdef>(C.BLOCK.TDENV, tid, td)
    2. Return C[BLOCK.TDENV = tdenv]
1. Else If cursor matches `LOCAL`, then
  1. If ~ $in_set<tid>(tid, $dom_map<tid, typdef>(C.LOCAL.TDENV)), then
    1. Let tdenv = $add_map<tid, typdef>(C.LOCAL.TDENV, tid, td)
    2. Return C[LOCAL.TDENV = tdenv]

;; ../../../../spec/4a1-typing-context.watsup:204.1-205.84
def $add_typdefs(p, C, tid*, typdef*)
1. If tid* matches [], then
  1. If typdef* matches [], then
    1. Return C
1. Else
  1. Let tid_h :: tid_t*{tid_t <- tid_t*} = tid*
  2. If typdef* matches _ :: _, then
    1. Let td_h :: td_t*{td_t <- td_t*} = typdef*
    2. Let C' = $add_typdef(p, C, tid_h, td_h)
    3. Let C'' = $add_typdefs(p, C', tid_t*{tid_t <- tid_t*}, td_t*{td_t <- td_t*})
    4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:214.1-214.51
def $add_tparam(cursor, C, tparam)
1. If cursor matches `BLOCK`, then
  1. Let td = `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef
  2. If ~ $in_set<tid>(tparam, $dom_map<tid, typdef>(C.BLOCK.TDENV)), then
    1. Let tdenv = $add_map<tid, typdef>(C.BLOCK.TDENV, tparam, td)
    2. Return C[BLOCK.TDENV = tdenv]
1. Else If cursor matches `LOCAL`, then
  1. Let td = `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef
  2. If ~ $in_set<tid>(tparam, $dom_map<tid, typdef>(C.LOCAL.TDENV)), then
    1. Let tdenv = $add_map<tid, typdef>(C.LOCAL.TDENV, tparam, td)
    2. Return C[LOCAL.TDENV = tdenv]

;; ../../../../spec/4a1-typing-context.watsup:225.1-225.53
def $add_tparams(p, C, tparam*)
1. If tparam* matches [], then
  1. Return C
1. Else
  1. Let tparam_h :: tparam_t*{tparam_t <- tparam_t*} = tparam*
  2. Let C' = $add_tparam(p, C, tparam_h)
  3. Let C'' = $add_tparams(p, C', tparam_t*{tparam_t <- tparam_t*})
  4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:234.1-235.80
def $add_funcdef(cursor, C, fid, fd)
1. If cursor matches `GLOBAL`, then
  1. If ~ $in_set<fid>(fid, $dom_map<fid, funcdef>(C.GLOBAL.FDENV)), then
    1. Let fdenv = $add_map<fid, funcdef>(C.GLOBAL.FDENV, fid, fd)
    2. Return C[GLOBAL.FDENV = fdenv]
1. Else If cursor matches `BLOCK`, then
  1. If ~ $in_set<fid>(fid, $dom_map<fid, funcdef>(C.BLOCK.FDENV)), then
    1. Let fdenv = $add_map<fid, funcdef>(C.BLOCK.FDENV, fid, fd)
    2. Return C[BLOCK.FDENV = fdenv]

;; ../../../../spec/4a1-typing-context.watsup:244.1-245.80
def $add_funcdef_non_overload(cursor, C, fid, fd)
1. If cursor matches `GLOBAL`, then
  1. Let `SET%`_set<fid>(`%%`_fid(id_k, _(id, bool)*)*{_(id, bool)* <- _(id, bool)**, id_k <- id_k*}) = $dom_map<fid, funcdef>(C.GLOBAL.FDENV)
  2. Let `%%`_fid(id, _(id, bool)*') = fid
  3. If ~ id <- id_k*{id_k <- id_k*}, then
    1. Let fdenv = $add_map<fid, funcdef>(C.GLOBAL.FDENV, fid, fd)
    2. Return C[GLOBAL.FDENV = fdenv]
1. Else If cursor matches `BLOCK`, then
  1. Let `SET%`_set<fid>(`%%`_fid(id_k, _(id, bool)*)*{_(id, bool)* <- _(id, bool)**, id_k <- id_k*}) = $dom_map<fid, funcdef>(C.BLOCK.FDENV)
  2. Let `%%`_fid(id, _(id, bool)*') = fid
  3. If ~ id <- id_k*{id_k <- id_k*}, then
    1. Let fdenv = $add_map<fid, funcdef>(C.BLOCK.FDENV, fid, fd)
    2. Return C[BLOCK.FDENV = fdenv]

;; ../../../../spec/4a1-typing-context.watsup:260.1-261.80
def $add_consdef(cursor, C, cid, cd)
1. If cursor matches `GLOBAL`, then
  1. If ~ $in_set<cid>(cid, $dom_map<cid, consdef>(C.GLOBAL.CDENV)), then
    1. Let cdenv = $add_map<cid, consdef>(C.GLOBAL.CDENV, cid, cd)
    2. Return C[GLOBAL.CDENV = cdenv]

;; ../../../../spec/4a1-typing-context.watsup:273.1-274.57
def $find_styp(p', C, name)
1. If name matches `TOP%`, then
  1. Let `TOP%`_name(id) = name
  2. Return $find_map<id, styp>(C.GLOBAL.FRAME, id)
2. If p' matches `GLOBAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Return $find_map<id, styp>(C.GLOBAL.FRAME, id)
2. Else If p' matches `BLOCK`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Let styp? = $find_map_opt<id, styp>(C.BLOCK.FRAME, id)
    3. If styp? matches (_), then
      1. Let ?(styp) = styp?
      2. Return styp
    4. If (?() = $find_map_opt<id, styp>(C.BLOCK.FRAME, id)), then
      1. Return $find_styp(`GLOBAL`_cursor(), C, `CURRENT%`_name(id))
2. Else If p' matches `LOCAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Let styp? = $find_maps_opt<id, styp>(C.LOCAL.FRAMES, id)
    3. If styp? matches (_), then
      1. Let ?(styp) = styp?
      2. Return styp
    4. If (?() = $find_maps_opt<id, styp>(C.LOCAL.FRAMES, id)), then
      1. Return $find_styp(`BLOCK`_cursor(), C, `CURRENT%`_name(id))

;; ../../../../spec/4a1-typing-context.watsup:289.1-290.44
def $find_val(p, C, name)
1. Let `%%%%`_styp(typ, dir, ctk, val?) = $find_styp(p, C, name)
2. If val? matches (_), then
  1. Let ?(val) = val?
  2. Return val

;; ../../../../spec/4a1-typing-context.watsup:297.1-298.44
def $find_typdef(p', C, name)
1. If name matches `TOP%`, then
  1. Let `TOP%`_name(id) = name
  2. Return $find_map<tid, typdef>(C.GLOBAL.TDENV, id)
2. If p' matches `GLOBAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Return $find_map<tid, typdef>(C.GLOBAL.TDENV, id)
2. Else If p' matches `BLOCK`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Let typdef? = $find_map_opt<tid, typdef>(C.BLOCK.TDENV, id)
    3. If typdef? matches (_), then
      1. Let ?(td) = typdef?
      2. Return td
    4. If (?() = $find_map_opt<tid, typdef>(C.BLOCK.TDENV, id)), then
      1. Return $find_typdef(`GLOBAL`_cursor(), C, `CURRENT%`_name(id))
2. Else If p' matches `LOCAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Let typdef? = $find_map_opt<tid, typdef>(C.LOCAL.TDENV, id)
    3. If typdef? matches (_), then
      1. Let ?(td) = typdef?
      2. Return td
    4. If (?() = $find_map_opt<tid, typdef>(C.LOCAL.TDENV, id)), then
      1. Return $find_typdef(`BLOCK`_cursor(), C, `CURRENT%`_name(id))

;; ../../../../spec/4a1-typing-context.watsup:313.1-313.28
def $to_fkey(arg*)
1. If arg* matches [], then
  1. Return []
1. Else
  1. Let arg_h :: arg_t*{arg_t <- arg_t*} = arg*
  2. Let arg = arg_h
  3. If arg matches `NameA%%`, then
    1. Let `NameA%%`_arg(id, _expr?) = arg
    2. Return ?(id) :: $to_fkey(arg_t*{arg_t <- arg_t*})
  4. Otherwise
    1. Return ?() :: $to_fkey(arg_t*{arg_t <- arg_t*})

;; ../../../../spec/4a1-typing-context.watsup:321.1-322.58
def $find_funcdef(p', C, name, arg*{arg <- arg*})
1. If name matches `TOP%`, then
  1. Let `TOP%`_name(id) = name
  2. Return $find_func<funcdef>(id, $to_fkey(arg*{arg <- arg*}), C.GLOBAL.FDENV)
2. If p' matches `GLOBAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Return $find_func<funcdef>(id, $to_fkey(arg*{arg <- arg*}), C.GLOBAL.FDENV)
2. Else If p' matches `BLOCK`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Let (fid, funcdef, id*)? = $find_func_opt<funcdef>(id, $to_fkey(arg*{arg <- arg*}), C.BLOCK.FDENV)
    3. If (fid, funcdef, id*)? matches (_), then
      1. Let ?((fid, fd, id_deft*{id_deft <- id_deft*})) = (fid, funcdef, id*)?
      2. Return (fid, fd, id_deft*{id_deft <- id_deft*})
    4. If (?() = $find_func_opt<funcdef>(id, $to_fkey(arg*{arg <- arg*}), C.BLOCK.FDENV)), then
      1. Return $find_funcdef(`GLOBAL`_cursor(), C, `CURRENT%`_name(id), arg*{arg <- arg*})
2. Else If p' matches `LOCAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Return $find_funcdef(`BLOCK`_cursor(), C, `CURRENT%`_name(id), arg*{arg <- arg*})

;; ../../../../spec/4a1-typing-context.watsup:332.1-333.44
def $find_funcdef_by_name(p', C, name)
1. If name matches `TOP%`, then
  1. Let `TOP%`_name(id) = name
  2. Return $find_func_by_name(id, C.GLOBAL.FDENV)
2. If p' matches `GLOBAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Return $find_func_by_name(id, C.GLOBAL.FDENV)
2. Else If p' matches `BLOCK`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Let funcdef? = $find_func_by_name_opt(id, C.BLOCK.FDENV)
    3. If funcdef? matches (_), then
      1. Let ?(fd) = funcdef?
      2. Return fd
    4. If (?() = $find_func_by_name_opt(id, C.BLOCK.FDENV)), then
      1. Return $find_funcdef_by_name(`GLOBAL`_cursor(), C, `CURRENT%`_name(id))
2. Else If p' matches `LOCAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Return $find_funcdef_by_name(`BLOCK`_cursor(), C, `CURRENT%`_name(id))

;; ../../../../spec/4a1-typing-context.watsup:345.1-346.58
def $find_consdef(p', C, name, arg*{arg <- arg*})
1. If name matches `TOP%`, then
  1. Let `TOP%`_name(id) = name
  2. Return $find_func<consdef>(id, $to_fkey(arg*{arg <- arg*}), C.GLOBAL.CDENV)
2. If p' matches `GLOBAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Return $find_func<consdef>(id, $to_fkey(arg*{arg <- arg*}), C.GLOBAL.CDENV)
2. Else If p' matches `BLOCK`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Return $find_consdef(`GLOBAL`_cursor(), C, `CURRENT%`_name(id), arg*{arg <- arg*})
2. Else If p' matches `LOCAL`, then
  1. If name matches `CURRENT%`, then
    1. Let `CURRENT%`_name(id) = name
    2. Return $find_consdef(`BLOCK`_cursor(), C, `CURRENT%`_name(id), arg*{arg <- arg*})

;; ../../../../spec/4a2-typing-tblctx.watsup:6.1-9.11
syntax mode = 
   | `NOPRI`()
   | `NOPRILPM%`(nat)
   | `PRI`()
   | `PRILPM`()

;; ../../../../spec/4a2-typing-tblctx.watsup:12.3-15.24
syntax priority = {`VALUES%`(int*), `INIT%`(bool), `DELTA%`(int), `LARGEST_WINS%`(bool)}

;; ../../../../spec/4a2-typing-tblctx.watsup:18.3-19.17
syntax entry = {`SIZE%`(int), `CONST%`(bool)}

;; ../../../../spec/4a2-typing-tblctx.watsup:24.14-24.30
syntax key = (typ, matchkind)

;; ../../../../spec/4a2-typing-tblctx.watsup:25.17-25.42
syntax action = (name, paramtyp*, argIL*)

;; ../../../../spec/4a2-typing-tblctx.watsup:28.3-32.16
syntax tblctx = {`KEYS%`(key*), `ACTIONS%`(action*), `PRIORITIES%`(priority), `ENTRIES%`(entry), `MODE%`(mode)}

;; ../../../../spec/4a2-typing-tblctx.watsup:39.1-40.10
syntax tblstate = 
   | `LPM%`(nat)
   | `NOLPM`()

;; ../../../../spec/4a2-typing-tblctx.watsup:46.1-46.26
def $empty_pt
1. Return {VALUES [], INIT false, DELTA 1 as int, LARGEST_WINS true}

;; ../../../../spec/4a2-typing-tblctx.watsup:53.1-53.23
def $empty_et
1. Return {SIZE 0 as int, CONST true}

;; ../../../../spec/4a2-typing-tblctx.watsup:58.1-58.28
def $empty_tblctx
1. Return {KEYS [], ACTIONS [], PRIORITIES $empty_pt, ENTRIES $empty_et, MODE `NOPRI`_mode()}

;; ../../../../spec/4a2-typing-tblctx.watsup:70.1-70.35
def $add_key(key, tblctx)
1. Return tblctx[KEYS = tblctx.KEYS ++ [key]]

;; ../../../../spec/4a2-typing-tblctx.watsup:74.1-74.41
def $add_action(action, tblctx)
1. Return tblctx[ACTIONS = tblctx.ACTIONS ++ [action]]

;; ../../../../spec/4a2-typing-tblctx.watsup:78.1-78.40
def $add_priority(i, tblctx)
1. Return tblctx[PRIORITIES.VALUES = tblctx.PRIORITIES.VALUES ++ [i]]

;; ../../../../spec/4a2-typing-tblctx.watsup:87.1-87.36
def $get_lpm_prefix(val)
1. Return `LPM%`_tblstate($get_lpm_prefix'(val, 0))

;; ../../../../spec/4a2-typing-tblctx.watsup:88.1-88.37
def $get_lpm_prefix'(val, n_prefix')
1. If val matches `FBitV%%`, then
  1. Let `FBitV%%`_val(nat, _bitstr) = val
  2. If (nat = 0), then
    1. Return n_prefix'
  3. Let `FBitV%%`_val(w, bitstr) = val
  4. If bitstr <: nat, then
    1. Let n = bitstr as nat
    2. If (w > 0), then
      1. If ((n \ 2) =/= 0), then
        1. Let val' = `FBitV%%`_val((w - 1), ((n - 1) / 2) as bitstr)
        2. Return $get_lpm_prefix'(val', (n_prefix' + 1))
    3. If (n_prefix' = 0), then
      1. If (w > 0), then
        1. If ((n \ 2) = 0), then
          1. Let val' = `FBitV%%`_val((w - 1), (n / 2) as bitstr)
          2. Return $get_lpm_prefix'(val', 0)

;; ../../../../spec/4a2-typing-tblctx.watsup:107.1-107.45
def $update_mode(text', typ', tblctx)
1. If (text' = "lpm"), then
  1. If (tblctx.MODE = `NOPRI`_mode()), then
    1. Let w = $get_width(typ')
    2. Return tblctx[MODE = `NOPRILPM%`_mode(w)]
  2. If (tblctx.MODE = `PRI`_mode()), then
    1. Return tblctx[MODE = `PRILPM`_mode()]
1. Else If (text' = "range"), then
  1. If (tblctx.MODE = `NOPRI`_mode()), then
    1. Return tblctx[MODE = `PRI`_mode()]
  2. Let mode = tblctx.MODE
  3. If mode matches `NOPRILPM%`, then
    1. Let `NOPRILPM%`_mode(_nat) = mode
    2. Return tblctx[MODE = `PRILPM`_mode()]
1. Else If (text' = "ternary"), then
  1. If (tblctx.MODE = `NOPRI`_mode()), then
    1. Return tblctx[MODE = `PRI`_mode()]
  2. Let mode = tblctx.MODE
  3. If mode matches `NOPRILPM%`, then
    1. Let `NOPRILPM%`_mode(_nat) = mode
    2. Return tblctx[MODE = `PRILPM`_mode()]
1. Else If (text' = "optional"), then
  1. If (tblctx.MODE = `NOPRI`_mode()), then
    1. Return tblctx[MODE = `PRI`_mode()]
  2. Let mode = tblctx.MODE
  3. If mode matches `NOPRILPM%`, then
    1. Let `NOPRILPM%`_mode(_nat) = mode
    2. Return tblctx[MODE = `PRILPM`_mode()]
2. Otherwise
  1. Return tblctx

;; ../../../../spec/4a2-typing-tblctx.watsup:129.1-129.49
def $update_state(tblstate, tblstate')
1. If tblstate matches `NOLPM`, then
  1. If tblstate' matches `LPM%`, then
    1. Let `LPM%`_tblstate(nat) = tblstate'
    2. Return `LPM%`_tblstate(nat)
  1. Else If tblstate' matches `NOLPM`, then
    1. Return `NOLPM`_tblstate()
1. Else If tblstate matches `LPM%`, then
  1. Let `LPM%`_tblstate(nat) = tblstate
  2. If tblstate' matches `NOLPM`, then
    1. Return `LPM%`_tblstate(nat)

;; ../../../../spec/4a2-typing-tblctx.watsup:139.1-139.54
def $find_action(tblctx, name)
1. Let (name_a, pt_a*{pt_a <- pt_a*}, argIL_a*{argIL_a <- argIL_a*})*{argIL_a* <- argIL_a**, name_a <- name_a*, pt_a* <- pt_a**} = tblctx.ACTIONS
2. Return $assoc_<name, (paramtyp*, argIL*)>(name, (name_a, (pt_a*{pt_a <- pt_a*}, argIL_a*{argIL_a <- argIL_a*}))*{argIL_a* <- argIL_a**, name_a <- name_a*, pt_a* <- pt_a**})

;; ../../../../spec/4a2-typing-tblctx.watsup:145.1-145.38
def $find_last_priority(tblctx)
1. Let i_pri*{i_pri <- i_pri*} = tblctx.PRIORITIES.VALUES
2. Return i_pri*{i_pri <- i_pri*}[(|i_pri*{i_pri <- i_pri*}| - 1)]

;; ../../../../spec/4a2-typing-tblctx.watsup:154.1-154.38
def $keys_of_table(tblprop*)
1. If tblprop* matches [], then
  1. Return []
1. Else
  1. Let tblprop :: tblprop_t*{tblprop_t <- tblprop_t*} = tblprop*
  2. If tblprop matches `KeyP%`, then
    1. Let `KeyP%`_tblprop(tblkeyprop) = tblprop
    2. Return tblkeyprop :: $keys_of_table(tblprop_t*{tblprop_t <- tblprop_t*})
  3. Let tblprop_h :: tblprop_t*{tblprop_t <- tblprop_t*} = tblprop*
  4. Otherwise
    1. Return $keys_of_table(tblprop_t*{tblprop_t <- tblprop_t*})

;; ../../../../spec/4a2-typing-tblctx.watsup:161.1-161.44
def $actions_of_table(tblprop*)
1. If tblprop* matches [], then
  1. Return []
1. Else
  1. Let tblprop :: tblprop_t*{tblprop_t <- tblprop_t*} = tblprop*
  2. If tblprop matches `ActionP%`, then
    1. Let `ActionP%`_tblprop(tblactionprop) = tblprop
    2. Return tblactionprop :: $actions_of_table(tblprop_t*{tblprop_t <- tblprop_t*})
  3. Let tblprop_h :: tblprop_t*{tblprop_t <- tblprop_t*} = tblprop*
  4. Otherwise
    1. Return $actions_of_table(tblprop_t*{tblprop_t <- tblprop_t*})

;; ../../../../spec/4b-typing-relation.watsup:5.1-5.29
def $annot(exprIL)
1. If exprIL matches `ValueE%%`, then
  1. Let `ValueE%%`_exprIL(_val, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `NameE%%`, then
  1. Let `NameE%%`_exprIL(_nameIL, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `SeqE%%`, then
  1. Let `SeqE%%`_exprIL(_exprIL*, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `SeqDefaultE%%`, then
  1. Let `SeqDefaultE%%`_exprIL(_exprIL*, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `RecordE%%`, then
  1. Let `RecordE%%`_exprIL(_(memberIL, exprIL)*, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `RecordDefaultE%%`, then
  1. Let `RecordDefaultE%%`_exprIL(_(memberIL, exprIL)*, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `DefaultE%`, then
  1. Let `DefaultE%`_exprIL(annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `UnE%%%`, then
  1. Let `UnE%%%`_exprIL(_unopIL, _exprIL, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `BinE%%%%`, then
  1. Let `BinE%%%%`_exprIL(_binopIL, _exprIL, _exprIL', annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `TernE%%%%`, then
  1. Let `TernE%%%%`_exprIL(_exprIL, _exprIL', _exprIL'', annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `CastE%%%`, then
  1. Let `CastE%%%`_exprIL(_typeIL, _exprIL, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `MaskE%%%`, then
  1. Let `MaskE%%%`_exprIL(_exprIL, _exprIL', annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `RangeE%%%`, then
  1. Let `RangeE%%%`_exprIL(_exprIL, _exprIL', annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `SelectE%%%`, then
  1. Let `SelectE%%%`_exprIL(_exprIL*, _selectcaseIL*, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `ArrAccE%%%`, then
  1. Let `ArrAccE%%%`_exprIL(_exprIL, _exprIL', annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `BitAccE%%%%`, then
  1. Let `BitAccE%%%%`_exprIL(_exprIL, _exprIL', _exprIL'', annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `ExprAccE%%%`, then
  1. Let `ExprAccE%%%`_exprIL(_exprIL, _memberIL, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `CallFuncE%%%%`, then
  1. Let `CallFuncE%%%%`_exprIL(_nameIL, _targIL*, _argIL*, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `CallMethodE%%%%%`, then
  1. Let `CallMethodE%%%%%`_exprIL(_exprIL, _memberIL, _targIL*, _argIL*, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `CallTypeE%%%%%`, then
  1. Let `CallTypeE%%%%%`_exprIL(_nameIL, _memberIL, _targIL*, _argIL*, annotIL) = exprIL
  2. Return annotIL
1. Else If exprIL matches `InstE%%%%`, then
  1. Let `InstE%%%%`_exprIL(_nameIL, _targIL*, _argIL*, annotIL) = exprIL
  2. Return annotIL

;; ../../../../spec/4b-typing-relation.watsup:34.1-36.23
relation Eval_static: p, C, exprIL''
1. If exprIL'' matches `ValueE%%`, then
  1. Let `ValueE%%`_exprIL(val, _annotIL) = exprIL''
  2. Result in val
1. Else If exprIL'' matches `NameE%%`, then
  1. Let `NameE%%`_exprIL(name, _annotIL) = exprIL''
  2. Let val = $find_val(p, C, name)
  3. Result in val
1. Else If exprIL'' matches `SeqE%%`, then
  1. Let `SeqE%%`_exprIL(exprIL''*{exprIL'' <- exprIL''*}, _annotIL) = exprIL''
  2. (Eval_static: `%%|-%~>%`(p, C, exprIL'', val))*{exprIL'' <- exprIL''*, val <- val*}
  3. Result in `SeqV%`_val(val*{val <- val*})
1. Else If exprIL'' matches `SeqDefaultE%%`, then
  1. Let `SeqDefaultE%%`_exprIL(exprIL''*{exprIL'' <- exprIL''*}, _annotIL) = exprIL''
  2. (Eval_static: `%%|-%~>%`(p, C, exprIL'', val))*{exprIL'' <- exprIL''*, val <- val*}
  3. Result in `SeqDefaultV%`_val(val*{val <- val*})
1. Else If exprIL'' matches `RecordE%%`, then
  1. Let `RecordE%%`_exprIL((member, exprIL'')*{exprIL'' <- exprIL''*, member <- member*}, _annotIL) = exprIL''
  2. (Eval_static: `%%|-%~>%`(p, C, exprIL'', val))*{exprIL'' <- exprIL''*, val <- val*}
  3. Result in `RecordV%`_val((member, val)*{member <- member*, val <- val*})
1. Else If exprIL'' matches `RecordDefaultE%%`, then
  1. Let `RecordDefaultE%%`_exprIL((member, exprIL'')*{exprIL'' <- exprIL''*, member <- member*}, _annotIL) = exprIL''
  2. (Eval_static: `%%|-%~>%`(p, C, exprIL'', val))*{exprIL'' <- exprIL''*, val <- val*}
  3. Result in `RecordDefaultV%`_val((member, val)*{member <- member*, val <- val*})
1. Else If exprIL'' matches `DefaultE%`, then
  1. Let `DefaultE%`_exprIL(_annotIL) = exprIL''
  2. Result in `DefaultV`_val()
1. Else If exprIL'' matches `UnE%%%`, then
  1. Let `UnE%%%`_exprIL(unop, exprIL'', _annotIL) = exprIL''
  2. Eval_static: `%%|-%~>%`(p, C, exprIL'', val)
  3. Result in $un_op(unop, val)
1. Else If exprIL'' matches `BinE%%%%`, then
  1. Let `BinE%%%%`_exprIL(binop, exprIL_l, exprIL_r, _annotIL) = exprIL''
  2. Eval_static: `%%|-%~>%`(p, C, exprIL_l, val_l)
  3. Eval_static: `%%|-%~>%`(p, C, exprIL_r, val_r)
  4. Result in $bin_op(binop, val_l, val_r)
1. Else If exprIL'' matches `TernE%%%%`, then
  1. Let `TernE%%%%`_exprIL(exprIL_c, exprIL_t, exprIL_f, _annotIL) = exprIL''
  2. Eval_static: `%%|-%~>%`(p, C, exprIL_c, val')
  3. If (val' = `BoolV%`_val(true)), then
    1. Eval_static: `%%|-%~>%`(p, C, exprIL_t, val)
    2. Result in val
  4. If (val' = `BoolV%`_val(false)), then
    1. Eval_static: `%%|-%~>%`(p, C, exprIL_f, val)
    2. Result in val
1. Else If exprIL'' matches `CastE%%%`, then
  1. Let `CastE%%%`_exprIL(typ, exprIL'', _annotIL) = exprIL''
  2. Eval_static: `%%|-%~>%`(p, C, exprIL'', val)
  3. Result in $cast_op(typ, val)
1. Else If exprIL'' matches `BitAccE%%%%`, then
  1. Let `BitAccE%%%%`_exprIL(exprIL_b, exprIL_l, exprIL_h, _annotIL) = exprIL''
  2. Eval_static: `%%|-%~>%`(p, C, exprIL_b, val_b)
  3. Eval_static: `%%|-%~>%`(p, C, exprIL_l, val_l)
  4. Eval_static: `%%|-%~>%`(p, C, exprIL_h, val_h)
  5. Result in $bitacc_op(val_b, val_h, val_l)
1. Else If exprIL'' matches `ExprAccE%%%`, then
  1. Let `ExprAccE%%%`_exprIL(exprIL_b, text, _annotIL) = exprIL''
  2. If (text = "size"), then
    1. Eval_static: `%%|-%~>%`(p, C, exprIL_b, val')
    2. If val' matches `StackV%%%`, then
      1. Let `StackV%%%`_val(val*{val <- val*}, i_size, i_idx) = val'
      2. Result in `IntV%`_val(i_size)
1. Else If exprIL'' matches `CallMethodE%%%%%`, then
  1. Let `CallMethodE%%%%%`_exprIL(exprIL_b, member, targIL*, argIL*, _annotIL) = exprIL''
  2. If targIL* matches [], then
    1. If argIL* matches [], then
      1. If ((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes")), then
        1. Let `(%;%)`_annotIL(typ_b, _ctk) = $annot(exprIL_b)
        2. Let val = $size(typ_b, member)
        3. Result in val
1. Else If exprIL'' matches `CallTypeE%%%%%`, then
  1. Let `CallTypeE%%%%%`_exprIL(name, member, targIL*, argIL*, _annotIL) = exprIL''
  2. If targIL* matches [], then
    1. If argIL* matches [], then
      1. If ((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes")), then
        1. Let typdef = $find_typdef(p, C, name)
        2. If typdef <: monotypdef, then
          1. Let `MonoD%`_monotypdef(typ) = typdef as monotypdef
          2. Result in $size(typ, member)

;; ../../../../spec/4b-typing-relation.watsup:43.1-45.23
relation Type_ok: p, C, type''
1. If type'' matches `VoidT`, then
  1. Result in `VoidT`_primtyp() as typ, []
1. Else If type'' matches `ErrT`, then
  1. Result in `ErrT`_primtyp() as typ, []
1. Else If type'' matches `MatchKindT`, then
  1. Result in `MatchKindT`_primtyp() as typ, []
1. Else If type'' matches `StrT`, then
  1. Result in `StrT`_primtyp() as typ, []
1. Else If type'' matches `BoolT`, then
  1. Result in `BoolT`_primtyp() as typ, []
1. Else If type'' matches `IntT`, then
  1. Result in `IntT`_numtyp() as typ, []
1. Else If type'' matches `FIntT%`, then
  1. Let `FIntT%`_type(expr) = type''
  2. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  3. Let `(%;%)`_annotIL(_typ, ctk) = $annot(exprIL)
  4. If ctk matches `LCTK`, then
    1. Eval_static: `%%|-%~>%`(p, C, exprIL, val)
    2. Let int = $get_num(val)
    3. If int <: nat, then
      1. Let w = int as nat
      2. Result in `FIntT%`_numtyp(w) as typ, []
1. Else If type'' matches `FBitT%`, then
  1. Let `FBitT%`_type(expr) = type''
  2. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  3. Let `(%;%)`_annotIL(_typ, ctk) = $annot(exprIL)
  4. If ctk matches `LCTK`, then
    1. Eval_static: `%%|-%~>%`(p, C, exprIL, val)
    2. Let int = $get_num(val)
    3. If int <: nat, then
      1. Let w = int as nat
      2. Result in `FBitT%`_numtyp(w) as typ, []
1. Else If type'' matches `VBitT%`, then
  1. Let `VBitT%`_type(expr) = type''
  2. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  3. Let `(%;%)`_annotIL(_typ, ctk) = $annot(exprIL)
  4. If ctk matches `LCTK`, then
    1. Eval_static: `%%|-%~>%`(p, C, exprIL, val)
    2. Let int = $get_num(val)
    3. If int <: nat, then
      1. Let w = int as nat
      2. Result in `VBitT%`_numtyp(w) as typ, []
1. Else If type'' matches `StackT%%`, then
  1. Let `StackT%%`_type(type'', expr) = type''
  2. Type_ok: `%%|-%:%%`(p, C, type'', typ, tid_fresh*{tid_fresh <- tid_fresh*})
  3. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  4. Let `(%;%)`_annotIL(_typ, ctk) = $annot(exprIL)
  5. If ctk matches `LCTK`, then
    1. Eval_static: `%%|-%~>%`(p, C, exprIL, val)
    2. Let i_size = $get_num(val)
    3. Let ptd = `PolyD%->%`_polytypdef((["T"], []), `StackT%%`_datatyp(`VarT%`_abstyp("T") as typ, i_size) as typ)
    4. Result in `SpecT%%`_abstyp(ptd, [typ]) as typ, tid_fresh*{tid_fresh <- tid_fresh*}
1. Else If type'' matches `ListT%`, then
  1. Let `ListT%`_type(type'') = type''
  2. Type_ok: `%%|-%:%%`(p, C, type'', typ, tid_fresh*{tid_fresh <- tid_fresh*})
  3. Let ptd = `PolyD%->%`_polytypdef((["T"], []), `ListT%`_datatyp(`VarT%`_abstyp("T") as typ) as typ)
  4. Result in `SpecT%%`_abstyp(ptd, [typ]) as typ, tid_fresh*{tid_fresh <- tid_fresh*}
1. Else If type'' matches `TupleT%`, then
  1. Let `TupleT%`_type(type''*{type'' <- type''*}) = type''
  2. (Type_ok: `%%|-%:%%`(p, C, type'', typ, tid_fresh_i*{tid_fresh_i <- tid_fresh_i*}))*{tid_fresh_i* <- tid_fresh_i**, typ <- typ*, type'' <- type''*}
  3. Let tid_fresh*{tid_fresh <- tid_fresh*} = $concat_<tid>(tid_fresh_i*{tid_fresh_i <- tid_fresh_i*}*{tid_fresh_i* <- tid_fresh_i**})
  4. Let i_idx*{i_idx <- i_idx*} = $init_(|typ*{typ <- typ*}|) as int*
  5. (Let tid = $concat_text(["T", $int_to_text(i_idx)]))*{i_idx <- i_idx*, tid <- tid*}
  6. Let ptd = `PolyD%->%`_polytypdef((tid*{tid <- tid*}, []), `TupleT%`_datatyp(`VarT%`_abstyp(tid) as typ*{tid <- tid*}) as typ)
  7. Result in `SpecT%%`_abstyp(ptd, typ*{typ <- typ*}) as typ, tid_fresh*{tid_fresh <- tid_fresh*}
1. Else If type'' matches `NameT%`, then
  1. Let `NameT%`_type(name) = type''
  2. Let typdef = $find_typdef(p, C, name)
  3. If typdef <: monotypdef, then
    1. Let `MonoD%`_monotypdef(typ) = typdef as monotypdef
    2. Result in typ, []
  4. If typdef <: polytypdef, then
    1. Let `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ) = typdef as polytypdef
    2. Let ptd = `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ)
    3. Result in `SpecT%%`_abstyp(ptd, []) as typ, []
1. Else If type'' matches `SpecT%%`, then
  1. Let `SpecT%%`_type(name, type*) = type''
  2. If type* matches [], then
    1. Let typdef = $find_typdef(p, C, name)
    2. If typdef <: monotypdef, then
      1. Let `MonoD%`_monotypdef(typ) = typdef as monotypdef
      2. Result in typ, []
  3. Let `SpecT%%`_type(name, type''*{type'' <- type''*}) = type''
  4. Let typdef = $find_typdef(p, C, name)
  5. If typdef <: polytypdef, then
    1. Let ptd = typdef as polytypdef
    2. Let `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ) = ptd
    3. (Type_ok: `%%|-%:%%`(p, C, type'', typ_a, tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}))*{tid_fresh_a* <- tid_fresh_a**, typ_a <- typ_a*, type'' <- type''*}
    4. Let tid_fresh*{tid_fresh <- tid_fresh*} = $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**})
    5. Result in `SpecT%%`_abstyp(ptd, typ_a*{typ_a <- typ_a*}) as typ, tid_fresh*{tid_fresh <- tid_fresh*}
1. Else If type'' matches `AnyT`, then
  1. Let tid = $fresh_tid
  2. Result in `VarT%`_abstyp(tid) as typ, [tid]

;; ../../../../spec/4b-typing-relation.watsup:48.1-50.20
relation Sub_expl: typ_a, typ_b
1. Sub_expl_canon: `%<:%`($canon_typ(typ_a), $canon_typ(typ_b))
2. Result in 

;; ../../../../spec/4b-typing-relation.watsup:51.1-53.20
relation Sub_expl_canon: typ_a', typ_b'
1. Type_alpha: `%~~%`(typ_a', typ_b')
2. Result in 
3. If (typ_a' = `FBitT%`_numtyp(1) as typ), then
  1. If (typ_b' = `BoolT`_primtyp() as typ), then
    1. Result in 
4. If (typ_a' = `BoolT`_primtyp() as typ), then
  1. If (typ_b' = `FBitT%`_numtyp(1) as typ), then
    1. Result in 
5. If (typ_a' = `IntT`_numtyp() as typ), then
  1. If (typ_b' = `BoolT`_primtyp() as typ), then
    1. Result in 
  2. If typ_b' <: numtyp, then
    1. Let numtyp = typ_b' as numtyp
    2. If numtyp matches `FBitT%`, then
      1. Let `FBitT%`_numtyp(width) = numtyp
      2. Result in 
    2. Else If numtyp matches `FIntT%`, then
      1. Let `FIntT%`_numtyp(width) = numtyp
      2. Result in 
6. If typ_a' <: numtyp, then
  1. Let numtyp = typ_a' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(width_a) = numtyp
    2. If typ_b' <: numtyp, then
      1. Let numtyp' = typ_b' as numtyp
      2. If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(width_b) = numtyp'
        2. Result in 
      2. Else If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(width_b) = numtyp'
        2. Result in 
    3. Let `FIntT%`_numtyp(width) = numtyp
    4. If (typ_b' = `IntT`_numtyp() as typ), then
      1. Result in 
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(width_a) = numtyp
    2. If typ_b' <: numtyp, then
      1. Let numtyp' = typ_b' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(width_b) = numtyp'
        2. Result in 
      2. Else If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(width_b) = numtyp'
        2. Result in 
    3. Let `FBitT%`_numtyp(width) = numtyp
    4. If (typ_b' = `IntT`_numtyp() as typ), then
      1. Result in 
7. If typ_a' <: datatyp, then
  1. Let datatyp = typ_a' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ_a') = datatyp
    2. Sub_impl: `%<<%`(typ_a', typ_b')
    3. Result in 
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, typ_a', _(member, val)*) = datatyp
    2. Sub_impl: `%<<%`(typ_a', typ_b')
    3. Result in 
8. If typ_b' <: datatyp, then
  1. Let datatyp = typ_b' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(_id, typ_b') = datatyp
    2. Sub_impl: `%<<%`(typ_a', typ_b')
    3. Result in 
  2. Else If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, typ_b', _(member, val)*) = datatyp
    2. Sub_impl: `%<<%`(typ_a', typ_b')
    3. Result in 
9. If typ_a' <: synthtyp, then
  1. Let synthtyp = typ_a' as synthtyp
  2. If synthtyp matches `SeqT%`, then
    1. Let `SeqT%`_synthtyp(typ_a'*{typ_a' <- typ_a'*}) = synthtyp
    2. If typ_b' <: datatyp, then
      1. Let datatyp = typ_b' as datatyp
      2. If datatyp matches `ListT%`, then
        1. Let `ListT%`_datatyp(typ_b') = datatyp
        2. (Sub_expl: `%<:%`(typ_a', typ_b'))*{typ_a' <- typ_a'*}
        3. Result in 
      2. Else If datatyp matches `TupleT%`, then
        1. Let `TupleT%`_datatyp(typ_b'*{typ_b' <- typ_b'*}) = datatyp
        2. (Sub_expl: `%<:%`(typ_a', typ_b'))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}
        3. Result in 
      2. Else If datatyp matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_b', i_size) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| as int <= i_size), then
          1. (Sub_expl: `%<:%`(typ_a', typ_b'))*{typ_a' <- typ_a'*}
          2. Result in 
      2. Else If datatyp matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(_id, (_member, typ_b')*{_member <- _member*, typ_b' <- typ_b'*}) = datatyp
        2. (Sub_expl: `%<:%`(typ_a', typ_b'))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}
        3. Result in 
      2. Else If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(_id, (_member, typ_b')*{_member <- _member*, typ_b' <- typ_b'*}) = datatyp
        2. (Sub_expl: `%<:%`(typ_a', typ_b'))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}
        3. Result in 
  2. Else If synthtyp matches `RecordT%`, then
    1. Let `RecordT%`_synthtyp((member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) = synthtyp
    2. If typ_b' <: datatyp, then
      1. Let datatyp = typ_b' as datatyp
      2. If datatyp matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(_id, (member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}) = datatyp
        2. If $eq_set<member>(`SET%`_set<member>(member_a*{member_a <- member_a*}), `SET%`_set<member>(member_b*{member_b <- member_b*})), then
          1. (Sub_expl: `%<:%`($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}), member_a), $find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_a)))*{member_a <- member_a*}
          2. Result in 
      2. Else If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(_id, (member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}) = datatyp
        2. If $eq_set<member>(`SET%`_set<member>(member_a*{member_a <- member_a*}), `SET%`_set<member>(member_b*{member_b <- member_b*})), then
          1. (Sub_expl: `%<:%`($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}), member_a), $find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_a)))*{member_a <- member_a*}
          2. Result in 
  2. Else If synthtyp matches `SeqDefaultT%`, then
    1. Let `SeqDefaultT%`_synthtyp(typ_a'*{typ_a' <- typ_a'*}) = synthtyp
    2. If typ_b' <: datatyp, then
      1. Let datatyp = typ_b' as datatyp
      2. If datatyp matches `TupleT%`, then
        1. Let `TupleT%`_datatyp(typ_b'*{typ_b' <- typ_b'*}) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| < |typ_b'*{typ_b' <- typ_b'*}|), then
          1. Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) = $partition_<typ>(typ_b'*{typ_b' <- typ_b'*}, |typ_a'*{typ_a' <- typ_a'*}|)
          2. (Sub_expl: `%<:%`(typ_a', typ_c))*{typ_a' <- typ_a'*, typ_c <- typ_c*}
          3. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then
            1. Result in 
      2. Else If datatyp matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_b', i_size) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| as int < i_size), then
          1. (Sub_expl: `%<:%`(typ_a', typ_b'))*{typ_a' <- typ_a'*}
          2. If $is_deftable(typ_b'), then
            1. Result in 
      2. Else If datatyp matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(_id, (_member, typ_b')*{_member <- _member*, typ_b' <- typ_b'*}) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| < |typ_b'*{typ_b' <- typ_b'*}|), then
          1. Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) = $partition_<typ>(typ_b'*{typ_b' <- typ_b'*}, |typ_a'*{typ_a' <- typ_a'*}|)
          2. (Sub_expl: `%<:%`(typ_a', typ_c))*{typ_a' <- typ_a'*, typ_c <- typ_c*}
          3. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then
            1. Result in 
      2. Else If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(_id, (_member, typ_b')*{_member <- _member*, typ_b' <- typ_b'*}) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| < |typ_b'*{typ_b' <- typ_b'*}|), then
          1. Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) = $partition_<typ>(typ_b'*{typ_b' <- typ_b'*}, |typ_a'*{typ_a' <- typ_a'*}|)
          2. (Sub_expl: `%<:%`(typ_a', typ_c))*{typ_a' <- typ_a'*, typ_c <- typ_c*}
          3. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then
            1. Result in 
  2. Else If synthtyp matches `RecordDefaultT%`, then
    1. Let `RecordDefaultT%`_synthtyp((member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) = synthtyp
    2. If typ_b' <: datatyp, then
      1. Let datatyp = typ_b' as datatyp
      2. If datatyp matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(_id, (member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}) = datatyp
        2. If $sub_set<member>(`SET%`_set<member>(member_a*{member_a <- member_a*}), `SET%`_set<member>(member_b*{member_b <- member_b*})), then
          1. Let `SET%`_set<member>(member_c*{member_c <- member_c*}) = $diff_set<member>(`SET%`_set<member>(member_b*{member_b <- member_b*}), `SET%`_set<member>(member_a*{member_a <- member_a*}))
          2. (Sub_expl: `%<:%`($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}), member_a), $find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_a)))*{member_a <- member_a*}
          3. If ($is_deftable($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_c)))*{member_c <- member_c*}, then
            1. Result in 
      2. Else If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(_id, (member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}) = datatyp
        2. If $sub_set<member>(`SET%`_set<member>(member_a*{member_a <- member_a*}), `SET%`_set<member>(member_a*{member_a <- member_a*})), then
          1. Let `SET%`_set<member>(member_c*{member_c <- member_c*}) = $diff_set<member>(`SET%`_set<member>(member_b*{member_b <- member_b*}), `SET%`_set<member>(member_a*{member_a <- member_a*}))
          2. (Sub_expl: `%<:%`($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}), member_a), $find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_a)))*{member_a <- member_a*}
          3. If ($is_deftable($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_c)))*{member_c <- member_c*}, then
            1. Result in 
  2. Else If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ_a') = synthtyp
    2. If typ_b' <: synthtyp, then
      1. Let synthtyp' = typ_b' as synthtyp
      2. If synthtyp' matches `SetT%`, then
        1. Let `SetT%`_synthtyp(typ_b') = synthtyp'
        2. Sub_expl: `%<:%`(typ_a', typ_b')
        3. Result in 
10. If (typ_a' = `DefaultT`_synthtyp() as typ), then
  1. If $is_deftable(typ_b'), then
    1. Result in 
11. If (typ_a' = `InvalidT`_synthtyp() as typ), then
  1. If typ_b' <: datatyp, then
    1. Let datatyp = typ_b' as datatyp
    2. If datatyp matches `HeaderT%%`, then
      1. Let `HeaderT%%`_datatyp(_id, _(member, typ)*) = datatyp
      2. Result in 
    2. Else If datatyp matches `UnionT%%`, then
      1. Let `UnionT%%`_datatyp(_id, _(member, typ)*) = datatyp
      2. Result in 
12. If typ_b' <: synthtyp, then
  1. Let synthtyp = typ_b' as synthtyp
  2. If synthtyp matches `SetT%`, then
    1. Let `SetT%`_synthtyp(typ_b') = synthtyp
    2. Sub_expl: `%<:%`(typ_a', typ_b')
    3. Result in 

;; ../../../../spec/4b-typing-relation.watsup:54.1-56.20
relation Sub_impl: typ_a, typ_b
1. Sub_impl_canon: `%<<%`($canon_typ(typ_a), $canon_typ(typ_b))
2. Result in 

;; ../../../../spec/4b-typing-relation.watsup:57.1-59.20
relation Sub_impl_canon: typ_a', typ_b'
1. Type_alpha: `%~~%`(typ_a', typ_b')
2. Result in 
3. If (typ_a' = `IntT`_numtyp() as typ), then
  1. If typ_b' <: numtyp, then
    1. Let numtyp = typ_b' as numtyp
    2. If numtyp matches `FBitT%`, then
      1. Let `FBitT%`_numtyp(_width) = numtyp
      2. Result in 
    2. Else If numtyp matches `FIntT%`, then
      1. Let `FIntT%`_numtyp(_width) = numtyp
      2. Result in 
4. If typ_a' <: datatyp, then
  1. Let datatyp = typ_a' as datatyp
  2. If datatyp matches `SEnumT%%%`, then
    1. Let `SEnumT%%%`_datatyp(_id, typ_a', _(member, val)*) = datatyp
    2. Sub_impl: `%<<%`(typ_a', typ_b')
    3. Result in 
5. If typ_a' <: synthtyp, then
  1. Let synthtyp = typ_a' as synthtyp
  2. If synthtyp matches `SeqT%`, then
    1. Let `SeqT%`_synthtyp(typ_a'*{typ_a' <- typ_a'*}) = synthtyp
    2. If typ_b' <: datatyp, then
      1. Let datatyp = typ_b' as datatyp
      2. If datatyp matches `ListT%`, then
        1. Let `ListT%`_datatyp(typ_b') = datatyp
        2. (Sub_impl: `%<<%`(typ_a', typ_b'))*{typ_a' <- typ_a'*}
        3. Result in 
      2. Else If datatyp matches `TupleT%`, then
        1. Let `TupleT%`_datatyp(typ_b'*{typ_b' <- typ_b'*}) = datatyp
        2. (Sub_impl: `%<<%`(typ_a', typ_b'))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}
        3. Result in 
      2. Else If datatyp matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_b', i_size) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| as int <= i_size), then
          1. (Sub_impl: `%<<%`(typ_a', typ_b'))*{typ_a' <- typ_a'*}
          2. Result in 
      2. Else If datatyp matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(_id, (_member, typ_b')*{_member <- _member*, typ_b' <- typ_b'*}) = datatyp
        2. (Sub_impl: `%<<%`(typ_a', typ_b'))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}
        3. Result in 
      2. Else If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(_id, (_member, typ_b')*{_member <- _member*, typ_b' <- typ_b'*}) = datatyp
        2. (Sub_impl: `%<<%`(typ_a', typ_b'))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}
        3. Result in 
    3. If typ_b' <: synthtyp, then
      1. Let synthtyp' = typ_b' as synthtyp
      2. If synthtyp' matches `SeqT%`, then
        1. Let `SeqT%`_synthtyp(typ_b'*{typ_b' <- typ_b'*}) = synthtyp'
        2. (Sub_impl: `%<<%`(typ_a', typ_b'))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}
        3. Result in 
  2. Else If synthtyp matches `RecordT%`, then
    1. Let `RecordT%`_synthtyp((member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) = synthtyp
    2. If typ_b' <: datatyp, then
      1. Let datatyp = typ_b' as datatyp
      2. If datatyp matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(_id, (member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}) = datatyp
        2. If $eq_set<member>(`SET%`_set<member>(member_a*{member_a <- member_a*}), `SET%`_set<member>(member_b*{member_b <- member_b*})), then
          1. (Sub_impl: `%<<%`($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}), member_a), $find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_a)))*{member_a <- member_a*}
          2. Result in 
      2. Else If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(_id, (member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}) = datatyp
        2. If $eq_set<member>(`SET%`_set<member>(member_a*{member_a <- member_a*}), `SET%`_set<member>(member_b*{member_b <- member_b*})), then
          1. (Sub_impl: `%<<%`($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}), member_a), $find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_a)))*{member_a <- member_a*}
          2. Result in 
  2. Else If synthtyp matches `SeqDefaultT%`, then
    1. Let `SeqDefaultT%`_synthtyp(typ_a'*{typ_a' <- typ_a'*}) = synthtyp
    2. If typ_b' <: datatyp, then
      1. Let datatyp = typ_b' as datatyp
      2. If datatyp matches `TupleT%`, then
        1. Let `TupleT%`_datatyp(typ_b'*{typ_b' <- typ_b'*}) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| < |typ_b'*{typ_b' <- typ_b'*}|), then
          1. Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) = $partition_<typ>(typ_b'*{typ_b' <- typ_b'*}, |typ_a'*{typ_a' <- typ_a'*}|)
          2. (Sub_impl: `%<<%`(typ_a', typ_c))*{typ_a' <- typ_a'*, typ_c <- typ_c*}
          3. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then
            1. Result in 
      2. Else If datatyp matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_b', i_size) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| as int < i_size), then
          1. (Sub_impl: `%<<%`(typ_a', typ_b'))*{typ_a' <- typ_a'*}
          2. If $is_deftable(typ_b'), then
            1. Result in 
      2. Else If datatyp matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(_id, (_member, typ_b')*{_member <- _member*, typ_b' <- typ_b'*}) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| < |typ_b'*{typ_b' <- typ_b'*}|), then
          1. Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) = $partition_<typ>(typ_b'*{typ_b' <- typ_b'*}, |typ_a'*{typ_a' <- typ_a'*}|)
          2. (Sub_impl: `%<<%`(typ_a', typ_c))*{typ_a' <- typ_a'*, typ_c <- typ_c*}
          3. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then
            1. Result in 
      2. Else If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(_id, (_member, typ_b')*{_member <- _member*, typ_b' <- typ_b'*}) = datatyp
        2. If (|typ_a'*{typ_a' <- typ_a'*}| < |typ_b'*{typ_b' <- typ_b'*}|), then
          1. Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) = $partition_<typ>(typ_b'*{typ_b' <- typ_b'*}, |typ_a'*{typ_a' <- typ_a'*}|)
          2. (Sub_impl: `%<<%`(typ_a', typ_c))*{typ_a' <- typ_a'*, typ_c <- typ_c*}
          3. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then
            1. Result in 
  2. Else If synthtyp matches `RecordDefaultT%`, then
    1. Let `RecordDefaultT%`_synthtyp((member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) = synthtyp
    2. If typ_b' <: datatyp, then
      1. Let datatyp = typ_b' as datatyp
      2. If datatyp matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(_id, (member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}) = datatyp
        2. If $sub_set<member>(`SET%`_set<member>(member_a*{member_a <- member_a*}), `SET%`_set<member>(member_b*{member_b <- member_b*})), then
          1. Let `SET%`_set<member>(member_c*{member_c <- member_c*}) = $diff_set<member>(`SET%`_set<member>(member_b*{member_b <- member_b*}), `SET%`_set<member>(member_a*{member_a <- member_a*}))
          2. (Sub_impl: `%<<%`($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}), member_a), $find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_a)))*{member_a <- member_a*}
          3. If ($is_deftable($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_c)))*{member_c <- member_c*}, then
            1. Result in 
      2. Else If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(id, (member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}) = datatyp
        2. If $sub_set<member>(`SET%`_set<member>(member_a*{member_a <- member_a*}), `SET%`_set<member>(member_b*{member_b <- member_b*})), then
          1. Let `SET%`_set<member>(member_c*{member_c <- member_c*}) = $diff_set<member>(`SET%`_set<member>(member_b*{member_b <- member_b*}), `SET%`_set<member>(member_a*{member_a <- member_a*}))
          2. (Sub_impl: `%<<%`($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}), member_a), $find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_a)))*{member_a <- member_a*}
          3. If ($is_deftable($find_map<member, typ>(`MAP%`_map<member, typ>(`PAIR%%`_pair<member, typ>(member_b, typ_b')*{member_b <- member_b*, typ_b' <- typ_b'*}), member_c)))*{member_c <- member_c*}, then
            1. Result in 
6. If (typ_a' = `DefaultT`_synthtyp() as typ), then
  1. If $is_deftable(typ_b'), then
    1. Result in 
7. If (typ_a' = `InvalidT`_synthtyp() as typ), then
  1. If typ_b' <: datatyp, then
    1. Let datatyp = typ_b' as datatyp
    2. If datatyp matches `HeaderT%%`, then
      1. Let `HeaderT%%`_datatyp(_id, _(member, typ)*) = datatyp
      2. Result in 
    2. Else If datatyp matches `UnionT%%`, then
      1. Let `UnionT%%`_datatyp(_id, _(member, typ)*) = datatyp
      2. Result in 

;; ../../../../spec/4b-typing-relation.watsup:69.1-71.23
relation Expr_ok: p', C, expr''
1. If expr'' matches `BoolE%`, then
  1. Let `BoolE%`_expr(b) = expr''
  2. Result in `ValueE%%`_exprIL(`BoolV%`_val(b), `(%;%)`_annotIL(`BoolT`_primtyp() as typ, `LCTK`_ctk()))
1. Else If expr'' matches `StrE%`, then
  1. Let `StrE%`_expr(t) = expr''
  2. Result in `ValueE%%`_exprIL(`StrV%`_val(t), `(%;%)`_annotIL(`StrT`_primtyp() as typ, `LCTK`_ctk()))
1. Else If expr'' matches `NumE%`, then
  1. Let `NumE%`_expr(num) = expr''
  2. If num matches `INT%`, then
    1. Let `INT%`_num(i) = num
    2. Result in `ValueE%%`_exprIL(`IntV%`_val(i), `(%;%)`_annotIL(`IntT`_numtyp() as typ, `LCTK`_ctk()))
  2. Else If num matches `FINT%%`, then
    1. Let `FINT%%`_num(w, i) = num
    2. Let bs = $to_bitstr(w as int, i)
    3. Result in `ValueE%%`_exprIL(`FIntV%%`_val(w, bs), `(%;%)`_annotIL(`FIntT%`_numtyp(w) as typ, `LCTK`_ctk()))
  2. Else If num matches `FBIT%%`, then
    1. Let `FBIT%%`_num(w, i) = num
    2. Let bs = $to_bitstr(w as int, i)
    3. Result in `ValueE%%`_exprIL(`FBitV%%`_val(w, bs), `(%;%)`_annotIL(`FBitT%`_numtyp(w) as typ, `LCTK`_ctk()))
1. Else If expr'' matches `NameE%`, then
  1. Let `NameE%`_expr(name) = expr''
  2. Let `%%%%`_styp(typ, _dir, ctk, _val?) = $find_styp(p', C, name)
  3. Result in `NameE%%`_exprIL(name, `(%;%)`_annotIL(typ, ctk))
1. Else If expr'' matches `SeqE%`, then
  1. Let `SeqE%`_expr(expr''*{expr'' <- expr''*}) = expr''
  2. (Expr_ok: `%%|-%:%`(p', C, expr'', exprIL))*{expr'' <- expr''*, exprIL <- exprIL*}
  3. (Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL))*{ctk <- ctk*, exprIL <- exprIL*, typ <- typ*}
  4. Let ctk_e = $joins_ctk(ctk*{ctk <- ctk*})
  5. Result in `SeqE%%`_exprIL(exprIL*{exprIL <- exprIL*}, `(%;%)`_annotIL(`SeqT%`_synthtyp(typ*{typ <- typ*}) as typ, ctk_e))
1. Else If expr'' matches `SeqDefaultE%`, then
  1. Let `SeqDefaultE%`_expr(expr''*{expr'' <- expr''*}) = expr''
  2. (Expr_ok: `%%|-%:%`(p', C, expr'', exprIL))*{expr'' <- expr''*, exprIL <- exprIL*}
  3. (Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL))*{ctk <- ctk*, exprIL <- exprIL*, typ <- typ*}
  4. Let ctk_e = $joins_ctk(ctk*{ctk <- ctk*})
  5. Result in `SeqDefaultE%%`_exprIL(exprIL*{exprIL <- exprIL*}, `(%;%)`_annotIL(`SeqDefaultT%`_synthtyp(typ*{typ <- typ*}) as typ, ctk_e))
1. Else If expr'' matches `RecordE%`, then
  1. Let `RecordE%`_expr((member, expr'')*{expr'' <- expr''*, member <- member*}) = expr''
  2. (Expr_ok: `%%|-%:%`(p', C, expr'', exprIL))*{expr'' <- expr''*, exprIL <- exprIL*}
  3. (Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL))*{ctk <- ctk*, exprIL <- exprIL*, typ <- typ*}
  4. Let ctk_e = $joins_ctk(ctk*{ctk <- ctk*})
  5. Result in `RecordE%%`_exprIL((member, exprIL)*{exprIL <- exprIL*, member <- member*}, `(%;%)`_annotIL(`RecordT%`_synthtyp((member, typ)*{member <- member*, typ <- typ*}) as typ, ctk_e))
1. Else If expr'' matches `RecordDefaultE%`, then
  1. Let `RecordDefaultE%`_expr((member, expr'')*{expr'' <- expr''*, member <- member*}) = expr''
  2. (Expr_ok: `%%|-%:%`(p', C, expr'', exprIL))*{expr'' <- expr''*, exprIL <- exprIL*}
  3. (Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL))*{ctk <- ctk*, exprIL <- exprIL*, typ <- typ*}
  4. Let ctk_e = $joins_ctk(ctk*{ctk <- ctk*})
  5. Result in `RecordE%%`_exprIL((member, exprIL)*{exprIL <- exprIL*, member <- member*}, `(%;%)`_annotIL(`RecordDefaultT%`_synthtyp((member, typ)*{member <- member*, typ <- typ*}) as typ, ctk_e))
1. Else If expr'' matches `DefaultE`, then
  1. Result in `DefaultE%`_exprIL(`(%;%)`_annotIL(`DefaultT`_synthtyp() as typ, `LCTK`_ctk()))
1. Else If expr'' matches `InvalidE`, then
  1. Result in `ValueE%%`_exprIL(`InvalidV`_val(), `(%;%)`_annotIL(`InvalidT`_synthtyp() as typ, `LCTK`_ctk()))
1. Else If expr'' matches `UnE%%`, then
  1. Let `UnE%%`_expr(unop, expr'') = expr''
  2. If unop matches `BNOT`, then
    1. Expr_ok: `%%|-%:%`(p', C, expr'', exprIL)
    2. Let exprIL_e = $reduce_senum_unary(exprIL, $compatible_bnot)
    3. Let `(%;%)`_annotIL(typ_e, ctk_e) = $annot(exprIL_e)
    4. Result in `UnE%%%`_exprIL(`BNOT`_unop(), exprIL_e, `(%;%)`_annotIL(typ_e, ctk_e))
  2. Else If unop matches `LNOT`, then
    1. Expr_ok: `%%|-%:%`(p', C, expr'', exprIL)
    2. Let exprIL_e = $reduce_senum_unary(exprIL, $compatible_lnot)
    3. Let `(%;%)`_annotIL(typ_e, ctk_e) = $annot(exprIL_e)
    4. Result in `UnE%%%`_exprIL(`LNOT`_unop(), exprIL_e, `(%;%)`_annotIL(typ_e, ctk_e))
  2. Else If unop matches `UPLUS`, then
    1. Expr_ok: `%%|-%:%`(p', C, expr'', exprIL)
    2. Let exprIL_e = $reduce_senum_unary(exprIL, $compatible_uplus)
    3. Let `(%;%)`_annotIL(typ_e, ctk_e) = $annot(exprIL_e)
    4. Result in `UnE%%%`_exprIL(`UPLUS`_unop(), exprIL_e, `(%;%)`_annotIL(typ_e, ctk_e))
  2. Else If unop matches `UMINUS`, then
    1. Expr_ok: `%%|-%:%`(p', C, expr'', exprIL)
    2. Let exprIL_e = $reduce_senum_unary(exprIL, $compatible_uminus)
    3. Let `(%;%)`_annotIL(typ_e, ctk_e) = $annot(exprIL_e)
    4. Result in `UnE%%%`_exprIL(`UMINUS`_unop(), exprIL_e, `(%;%)`_annotIL(typ_e, ctk_e))
1. Else If expr'' matches `BinE%%%`, then
  1. Let `BinE%%%`_expr(binop, expr_l, expr_r) = expr''
  2. If $in_set<binop>(binop, `SET%`_set<binop>([`PLUS`_binop(), `MINUS`_binop(), `MUL`_binop()])), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let (exprIL_l', exprIL_r') = $coerce_binary(exprIL_l, exprIL_r)
    4. Let (exprIL_l'', exprIL_r'') = $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_plusminusmult)
    5. Let `(%;%)`_annotIL(typ'', ctk_l'') = $annot(exprIL_l'')
    6. Let `(%;%)`_annotIL(_typ, ctk_r'') = $annot(exprIL_r'')
    7. Let ctk = $join_ctk(ctk_l'', ctk_r'')
    8. Result in `BinE%%%%`_exprIL(binop, exprIL_l'', exprIL_r'', `(%;%)`_annotIL(typ'', ctk))
  3. If $in_set<binop>(binop, `SET%`_set<binop>([`SPLUS`_binop(), `SMINUS`_binop()])), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let (exprIL_l', exprIL_r') = $coerce_binary(exprIL_l, exprIL_r)
    4. Let (exprIL_l'', exprIL_r'') = $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_satplusminus)
    5. Let `(%;%)`_annotIL(typ'', ctk_l'') = $annot(exprIL_l'')
    6. Let `(%;%)`_annotIL(_typ, ctk_r'') = $annot(exprIL_r'')
    7. Let ctk = $join_ctk(ctk_l'', ctk_r'')
    8. Result in `BinE%%%%`_exprIL(binop, exprIL_l'', exprIL_r'', `(%;%)`_annotIL(typ'', ctk))
  4. If $in_set<binop>(binop, `SET%`_set<binop>([`DIV`_binop(), `MOD`_binop()])), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let (exprIL_l', exprIL_r') = $coerce_binary(exprIL_l, exprIL_r)
    4. Let (exprIL_l'', exprIL_r'') = $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_divmod)
    5. Let `(%;%)`_annotIL(typ'', ctk_l'') = $annot(exprIL_l'')
    6. Let `(%;%)`_annotIL(_typ, ctk') = $annot(exprIL_r'')
    7. If ctk' matches `LCTK`, then
      1. Eval_static: `%%|-%~>%`(p', C, exprIL_r'', val_r)
      2. Let int = $get_num(val_r)
      3. If int <: nat, then
        1. Let n_r = int as nat
        2. If (n_r > 0), then
          1. Let ctk = $join_ctk(ctk_l'', `LCTK`_ctk())
          2. Result in `BinE%%%%`_exprIL(binop, exprIL_l'', exprIL_r'', `(%;%)`_annotIL(typ'', ctk))
    8. Let `(%;%)`_annotIL(_typ, ctk_r'') = $annot(exprIL_r'')
    9. If (ctk_r'' =/= `LCTK`_ctk()), then
      1. Let ctk = $join_ctk(ctk_l'', ctk_r'')
      2. Result in `BinE%%%%`_exprIL(binop, exprIL_l'', exprIL_r'', `(%;%)`_annotIL(typ'', ctk))
  5. If $in_set<binop>(binop, `SET%`_set<binop>([`SHL`_binop(), `SHR`_binop()])), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let (exprIL_l', exprIL_r') = $reduce_senums_binary(exprIL_l, exprIL_r, $compatible_shift)
    4. Let `(%;%)`_annotIL(typ_l', ctk_l') = $annot(exprIL_l')
    5. Let `(%;%)`_annotIL(typ_r', ctk_r') = $annot(exprIL_r')
    6. If (($is_fintt(typ_r') \/ $is_intt(typ_r')) => (ctk_r' = `LCTK`_ctk())), then
      1. Let ctk = $join_ctk(ctk_l', ctk_r')
      2. Result in `BinE%%%%`_exprIL(binop, exprIL_l', exprIL_r', `(%;%)`_annotIL(typ_l', ctk))
  6. If $in_set<binop>(binop, `SET%`_set<binop>([`EQ`_binop(), `NE`_binop()])), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let (exprIL_l', exprIL_r') = $coerce_binary(exprIL_l, exprIL_r)
    4. Let `(%;%)`_annotIL(typ', ctk_l') = $annot(exprIL_l')
    5. Let `(%;%)`_annotIL(_typ, ctk_r') = $annot(exprIL_r')
    6. If $is_equalable(typ'), then
      1. Let ctk = $join_ctk(ctk_l', ctk_r')
      2. Result in `BinE%%%%`_exprIL(binop, exprIL_l', exprIL_r', `(%;%)`_annotIL(`BoolT`_primtyp() as typ, ctk))
  7. If $in_set<binop>(binop, `SET%`_set<binop>([`LE`_binop(), `GE`_binop(), `LT`_binop(), `GT`_binop()])), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let (exprIL_l', exprIL_r') = $coerce_binary(exprIL_l, exprIL_r)
    4. Let (exprIL_l'', exprIL_r'') = $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_compare)
    5. Let `(%;%)`_annotIL(_typ, ctk_l'') = $annot(exprIL_l'')
    6. Let `(%;%)`_annotIL(_typ', ctk_r'') = $annot(exprIL_r'')
    7. Let ctk = $join_ctk(ctk_l'', ctk_r'')
    8. Result in `BinE%%%%`_exprIL(binop, exprIL_l'', exprIL_r'', `(%;%)`_annotIL(`BoolT`_primtyp() as typ, ctk))
  8. If $in_set<binop>(binop, `SET%`_set<binop>([`BAND`_binop(), `BXOR`_binop(), `BOR`_binop()])), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let (exprIL_l', exprIL_r') = $coerce_binary(exprIL_l, exprIL_r)
    4. Let (exprIL_l'', exprIL_r'') = $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_bitwise)
    5. Let `(%;%)`_annotIL(typ'', ctk_l'') = $annot(exprIL_l'')
    6. Let `(%;%)`_annotIL(_typ, ctk_r'') = $annot(exprIL_r'')
    7. Let ctk = $join_ctk(ctk_l'', ctk_r'')
    8. Result in `BinE%%%%`_exprIL(binop, exprIL_l'', exprIL_r'', `(%;%)`_annotIL(typ'', ctk))
  9. If binop matches `CONCAT`, then
    1. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let (exprIL_l', exprIL_r') = $reduce_senums_binary(exprIL_l, exprIL_r, $compatible_concat)
    4. Let `(%;%)`_annotIL(typ_l', ctk_l') = $annot(exprIL_l')
    5. Let `(%;%)`_annotIL(typ_r', ctk_r') = $annot(exprIL_r')
    6. Let w = ($get_width(typ_l') + $get_width(typ_r'))
    7. If $is_fintt(typ_l'), then
      1. Let typ'' = `FIntT%`_numtyp(w) as typ
      2. Let ctk = $join_ctk(ctk_l', ctk_r')
      3. Result in `BinE%%%%`_exprIL(`CONCAT`_binop(), exprIL_l', exprIL_r', `(%;%)`_annotIL(typ'', ctk))
    8. If $is_fbitt(typ_l'), then
      1. Let typ'' = `FBitT%`_numtyp(w) as typ
      2. Let ctk = $join_ctk(ctk_l', ctk_r')
      3. Result in `BinE%%%%`_exprIL(`CONCAT`_binop(), exprIL_l', exprIL_r', `(%;%)`_annotIL(typ'', ctk))
  10. If $in_set<binop>(binop, `SET%`_set<binop>([`LAND`_binop(), `LOR`_binop()])), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let (exprIL_l', exprIL_r') = $coerce_binary(exprIL_l, exprIL_r)
    4. Let (exprIL_l'', exprIL_r'') = $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_logical)
    5. Let `(%;%)`_annotIL(_typ, ctk_l'') = $annot(exprIL_l'')
    6. Let `(%;%)`_annotIL(_typ', ctk_r'') = $annot(exprIL_r'')
    7. Let ctk = $join_ctk(ctk_l'', ctk_r'')
    8. Result in `BinE%%%%`_exprIL(binop, exprIL_l, exprIL_r, `(%;%)`_annotIL(`BoolT`_primtyp() as typ, ctk))
1. Else If expr'' matches `TernE%%%`, then
  1. Let `TernE%%%`_expr(expr_c, expr_t, expr_f) = expr''
  2. Expr_ok: `%%|-%:%`(p', C, expr_c, exprIL_c)
  3. Let `(%;%)`_annotIL(typ, ctk_c) = $annot(exprIL_c)
  4. If (typ = `BoolT`_primtyp() as typ), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_t, exprIL_t)
    2. Expr_ok: `%%|-%:%`(p', C, expr_f, exprIL_f)
    3. Let (exprIL_t', exprIL_f') = $coerce_binary(exprIL_t, exprIL_f)
    4. Let `(%;%)`_annotIL(typ', ctk_t) = $annot(exprIL_t')
    5. Let `(%;%)`_annotIL(_typ, ctk_f) = $annot(exprIL_f')
    6. If ($is_intt(typ') => ((ctk_c = `CTK`_ctk()) \/ (ctk_c = `LCTK`_ctk()))), then
      1. Let ctk = $joins_ctk([ctk_c, ctk_t, ctk_f])
      2. Result in `TernE%%%%`_exprIL(exprIL_c, exprIL_t', exprIL_f', `(%;%)`_annotIL(typ', ctk))
1. Else If expr'' matches `CastE%%`, then
  1. Let `CastE%%`_expr(type, expr_b) = expr''
  2. Type_ok: `%%|-%:%%`(p', C, type, typ, tid*)
  3. If tid* matches [], then
    1. Type_wf: `%|-%`($bound_tids(p', C), typ)
    2. Expr_ok: `%%|-%:%`(p', C, expr_b, exprIL_b)
    3. Let `(%;%)`_annotIL(typ_b, ctk_b) = $annot(exprIL_b)
    4. Sub_expl: `%<:%`(typ_b, typ)
    5. Result in `CastE%%%`_exprIL(typ, exprIL_b, `(%;%)`_annotIL(typ, ctk_b))
1. Else If expr'' matches `MaskE%%`, then
  1. Let `MaskE%%`_expr(expr_b, expr_m) = expr''
  2. Expr_ok: `%%|-%:%`(p', C, expr_b, exprIL_b)
  3. Expr_ok: `%%|-%:%`(p', C, expr_m, exprIL_m)
  4. Let (exprIL_b', exprIL_m') = $coerce_binary(exprIL_b, exprIL_m)
  5. Let (exprIL_b'', exprIL_m'') = $reduce_senums_binary(exprIL_b', exprIL_m', $compatible_mask)
  6. Let `(%;%)`_annotIL(typ'', _ctk) = $annot(exprIL_b'')
  7. Result in `MaskE%%%`_exprIL(exprIL_b'', exprIL_m'', `(%;%)`_annotIL(`SetT%`_synthtyp(typ'') as typ, `DYN`_ctk()))
1. Else If expr'' matches `RangeE%%`, then
  1. Let `RangeE%%`_expr(expr_lb, expr_ub) = expr''
  2. Expr_ok: `%%|-%:%`(p', C, expr_lb, exprIL_lb)
  3. Expr_ok: `%%|-%:%`(p', C, expr_ub, exprIL_ub)
  4. Let (exprIL_ub', exprIL_lb') = $coerce_binary(exprIL_lb, exprIL_ub)
  5. Let (exprIL_lb'', exprIL_ub'') = $reduce_senums_binary(exprIL_lb', exprIL_ub', $compatible_range)
  6. Let `(%;%)`_annotIL(typ'', _ctk) = $annot(exprIL_lb'')
  7. Result in `RangeE%%%`_exprIL(exprIL_lb'', exprIL_ub'', `(%;%)`_annotIL(`SetT%`_synthtyp(typ'') as typ, `DYN`_ctk()))
1. Else If expr'' matches `ArrAccE%%`, then
  1. Let `ArrAccE%%`_expr(expr_b, expr_i) = expr''
  2. Expr_ok: `%%|-%:%`(p', C, expr_b, exprIL_b)
  3. Let `(%;%)`_annotIL(typ_b, ctk_b) = $annot(exprIL_b)
  4. Expr_ok: `%%|-%:%`(p', C, expr_i, exprIL_i)
  5. Let `(%;%)`_annotIL(typ_i, ctk) = $annot(exprIL_i)
  6. If ctk matches `LCTK`, then
    1. Let exprIL_i' = $reduce_senum_unary(exprIL_i, $compatible_arrayindex)
    2. Let typ' = $canon_typ(typ_b)
    3. If typ' <: datatyp, then
      1. Let datatyp = typ' as datatyp
      2. If datatyp matches `TupleT%`, then
        1. Let `TupleT%`_datatyp(typ_b'*{typ_b' <- typ_b'*}) = datatyp
        2. Eval_static: `%%|-%~>%`(p', C, exprIL_i', val_i)
        3. Let int = $get_num(val_i)
        4. If int <: nat, then
          1. Let n = int as nat
          2. Let typ = typ_b'*{typ_b' <- typ_b'*}[n]
          3. Result in `ArrAccE%%%`_exprIL(exprIL_b, exprIL_i', `(%;%)`_annotIL(typ, `DYN`_ctk()))
  7. Let `(%;%)`_annotIL(typ_b, _ctk) = $annot(exprIL_b)
  8. If ctk matches `LCTK`, then
    1. Let exprIL_i' = $reduce_senum_unary(exprIL_i, $compatible_arrayindex)
    2. Let typ = $canon_typ(typ_b)
    3. If typ <: datatyp, then
      1. Let datatyp = typ as datatyp
      2. If datatyp matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_b', i_s) = datatyp
        2. Eval_static: `%%|-%~>%`(p', C, exprIL_i', val_i)
        3. Let i = $get_num(val_i)
        4. If ((0 as int <= i) /\ (i <= i_s)), then
          1. Result in `ArrAccE%%%`_exprIL(exprIL_b, exprIL_i', `(%;%)`_annotIL(typ_b', `DYN`_ctk()))
  9. Let `(%;%)`_annotIL(typ_i, ctk_i) = $annot(exprIL_i)
  10. If (ctk_i =/= `LCTK`_ctk()), then
    1. Let exprIL_i' = $reduce_senum_unary(exprIL_i, $compatible_arrayindex)
    2. Let typ = $canon_typ(typ_b)
    3. If typ <: datatyp, then
      1. Let datatyp = typ as datatyp
      2. If datatyp matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_b', _int) = datatyp
        2. Result in `ArrAccE%%%`_exprIL(exprIL_b, exprIL_i', `(%;%)`_annotIL(typ_b', `DYN`_ctk()))
1. Else If expr'' matches `BitAccE%%%`, then
  1. Let `BitAccE%%%`_expr(expr_b, expr_l, expr_h) = expr''
  2. Expr_ok: `%%|-%:%`(p', C, expr_b, exprIL_b)
  3. Let exprIL_b' = $reduce_senum_unary(exprIL_b, $compatible_bitstringbase)
  4. Let `(%;%)`_annotIL(typ_b', ctk_b') = $annot(exprIL_b')
  5. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
  6. Let `(%;%)`_annotIL(typ_l, ctk) = $annot(exprIL_l)
  7. If ctk matches `LCTK`, then
    1. Let exprIL_l' = $reduce_senum_unary(exprIL_l, $compatible_bitstringindex)
    2. Eval_static: `%%|-%~>%`(p', C, exprIL_l', val_l)
    3. Let int = $get_num(val_l)
    4. If int <: nat, then
      1. Let n_l = int as nat
      2. Let exprIL_l'' = `ValueE%%`_exprIL(val_l, `(%;%)`_annotIL(typ_l, `LCTK`_ctk()))
      3. Expr_ok: `%%|-%:%`(p', C, expr_h, exprIL_h)
      4. Let `(%;%)`_annotIL(typ_h, ctk') = $annot(exprIL_h)
      5. If ctk' matches `LCTK`, then
        1. Let exprIL_h' = $reduce_senum_unary(exprIL_h, $compatible_bitstringindex)
        2. Eval_static: `%%|-%~>%`(p', C, exprIL_h', val_h)
        3. Let int' = $get_num(val_h)
        4. If int' <: nat, then
          1. Let n_h = int' as nat
          2. Let exprIL_h'' = `ValueE%%`_exprIL(val_h, `(%;%)`_annotIL(typ_h, `LCTK`_ctk()))
          3. If $is_valid_bitstring_slice(typ_b', n_l, n_h), then
            1. Let typ = `FBitT%`_numtyp(((n_h - n_l) + 1)) as typ
            2. Result in `BitAccE%%%%`_exprIL(exprIL_b', exprIL_l'', exprIL_h'', `(%;%)`_annotIL(typ, ctk_b'))
1. Else If expr'' matches `ErrAccE%`, then
  1. Let `ErrAccE%`_expr(member) = expr''
  2. Let id = $concat_text(["error.", member])
  3. If (`ErrV%`_val(member) = $find_val(p', C, `TOP%`_name(id))), then
    1. Result in `ValueE%%`_exprIL(`ErrV%`_val(member), `(%;%)`_annotIL(`ErrT`_primtyp() as typ, `LCTK`_ctk()))
1. Else If expr'' matches `TypeAccE%%`, then
  1. Let `TypeAccE%%`_expr(name, member) = expr''
  2. Let typdef = $find_typdef(p', C, name)
  3. If typdef <: monotypdef, then
    1. Let `MonoD%`_monotypdef(typ) = typdef as monotypdef
    2. Let typ' = $canon_typ(typ)
    3. If typ' <: datatyp, then
      1. Let datatyp = typ' as datatyp
      2. If datatyp matches `EnumT%%`, then
        1. Let `EnumT%%`_datatyp(id_t, member_t*{member_t <- member_t*}) = datatyp
        2. If member <- member_t*{member_t <- member_t*}, then
          1. Result in `ValueE%%`_exprIL(`EnumFieldV%%`_val(id_t, member), `(%;%)`_annotIL(typ, `LCTK`_ctk()))
      2. Else If datatyp matches `SEnumT%%%`, then
        1. Let `SEnumT%%%`_datatyp(id_t, typ_t, (member_t, val_t)*{member_t <- member_t*, val_t <- val_t*}) = datatyp
        2. Let val? = $assoc_<member, val>(member, (member_t, val_t)*{member_t <- member_t*, val_t <- val_t*})
        3. If val? matches (_), then
          1. Let ?(val) = val?
          2. Result in `ValueE%%`_exprIL(`SEnumFieldV%%%`_val(id_t, member, val), `(%;%)`_annotIL(typ, `LCTK`_ctk()))
1. Else If expr'' matches `ExprAccE%%`, then
  1. Let `ExprAccE%%`_expr(expr_b, text) = expr''
  2. If (text = "size"), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_b, exprIL_b)
    2. Let `(%;%)`_annotIL(typ_b, ctk_b) = $annot(exprIL_b)
    3. Let typ = $canon_typ(typ_b)
    4. If typ <: datatyp, then
      1. Let datatyp = typ as datatyp
      2. If datatyp matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_s, int_s) = datatyp
        2. Result in `ExprAccE%%%`_exprIL(exprIL_b, "size", `(%;%)`_annotIL(`FBitT%`_numtyp(32) as typ, `LCTK`_ctk()))
  2. Else If (text = "lastIndex"), then
    1. If (((p' = `BLOCK`_cursor()) /\ (C.BLOCK.KIND = `PARSER`_bkind())) \/ ((p' = `LOCAL`_cursor()) /\ (C.LOCAL.KIND = `PARSERSTATE`_lkind()))), then
      1. Expr_ok: `%%|-%:%`(p', C, expr_b, exprIL_b)
      2. Let `(%;%)`_annotIL(typ_b, ctk_b) = $annot(exprIL_b)
      3. Let typ = $canon_typ(typ_b)
      4. If typ <: datatyp, then
        1. Let datatyp = typ as datatyp
        2. If datatyp matches `StackT%%`, then
          1. Let `StackT%%`_datatyp(typ_s, int_s) = datatyp
          2. Result in `ExprAccE%%%`_exprIL(exprIL_b, "lastIndex", `(%;%)`_annotIL(`FBitT%`_numtyp(32) as typ, `DYN`_ctk()))
  2. Else If (text = "last"), then
    1. If (((p' = `BLOCK`_cursor()) /\ (C.BLOCK.KIND = `PARSER`_bkind())) \/ ((p' = `LOCAL`_cursor()) /\ (C.LOCAL.KIND = `PARSERSTATE`_lkind()))), then
      1. Expr_ok: `%%|-%:%`(p', C, expr_b, exprIL_b)
      2. Let `(%;%)`_annotIL(typ_b, ctk_b) = $annot(exprIL_b)
      3. Let typ = $canon_typ(typ_b)
      4. If typ <: datatyp, then
        1. Let datatyp = typ as datatyp
        2. If datatyp matches `StackT%%`, then
          1. Let `StackT%%`_datatyp(typ_s, int_s) = datatyp
          2. Result in `ExprAccE%%%`_exprIL(exprIL_b, "last", `(%;%)`_annotIL(typ_s, `DYN`_ctk()))
  2. Else If (text = "next"), then
    1. Expr_ok: `%%|-%:%`(p', C, expr_b, exprIL_b)
    2. Let `(%;%)`_annotIL(typ_b, ctk_b) = $annot(exprIL_b)
    3. Let typ = $canon_typ(typ_b)
    4. If typ <: datatyp, then
      1. Let datatyp = typ as datatyp
      2. If datatyp matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_s, int_s) = datatyp
        2. Result in `ExprAccE%%%`_exprIL(exprIL_b, "next", `(%;%)`_annotIL(typ_s, `DYN`_ctk()))
  3. Let `ExprAccE%%`_expr(expr_b, member) = expr''
  4. Expr_ok: `%%|-%:%`(p', C, expr_b, exprIL_b)
  5. Let `(%;%)`_annotIL(typ_b, ctk_b) = $annot(exprIL_b)
  6. Let typ' = $canon_typ(typ_b)
  7. If typ' <: datatyp, then
    1. Let datatyp = typ' as datatyp
    2. If datatyp matches `StructT%%`, then
      1. Let `StructT%%`_datatyp(id_s, (member_s, typ_s)*{member_s <- member_s*, typ_s <- typ_s*}) = datatyp
      2. Let typ? = $assoc_<member, typ>(member, (member_s, typ_s)*{member_s <- member_s*, typ_s <- typ_s*})
      3. If typ? matches (_), then
        1. Let ?(typ) = typ?
        2. Result in `ExprAccE%%%`_exprIL(exprIL_b, member, `(%;%)`_annotIL(typ, `DYN`_ctk()))
    2. Else If datatyp matches `HeaderT%%`, then
      1. Let `HeaderT%%`_datatyp(id_h, (member_h, typ_h)*{member_h <- member_h*, typ_h <- typ_h*}) = datatyp
      2. Let typ? = $assoc_<member, typ>(member, (member_h, typ_h)*{member_h <- member_h*, typ_h <- typ_h*})
      3. If typ? matches (_), then
        1. Let ?(typ) = typ?
        2. Result in `ExprAccE%%%`_exprIL(exprIL_b, member, `(%;%)`_annotIL(typ, `DYN`_ctk()))
    2. Else If datatyp matches `UnionT%%`, then
      1. Let `UnionT%%`_datatyp(id_u, (member_u, typ_u)*{member_u <- member_u*, typ_u <- typ_u*}) = datatyp
      2. Let typ? = $assoc_<member, typ>(member, (member_u, typ_u)*{member_u <- member_u*, typ_u <- typ_u*})
      3. If typ? matches (_), then
        1. Let ?(typ) = typ?
        2. Result in `ExprAccE%%%`_exprIL(exprIL_b, member, `(%;%)`_annotIL(typ, `DYN`_ctk()))
  8. If typ' <: synthtyp, then
    1. Let synthtyp = typ' as synthtyp
    2. If synthtyp matches `TableStructT%%`, then
      1. Let `TableStructT%%`_synthtyp(id_t, (member_t, typ_t)*{member_t <- member_t*, typ_t <- typ_t*}) = synthtyp
      2. Let typ? = $assoc_<member, typ>(member, (member_t, typ_t)*{member_t <- member_t*, typ_t <- typ_t*})
      3. If typ? matches (_), then
        1. Let ?(typ) = typ?
        2. Result in `ExprAccE%%%`_exprIL(exprIL_b, member, `(%;%)`_annotIL(typ, `DYN`_ctk()))
1. Else If expr'' matches `CallFuncE%%%`, then
  1. Let `CallFuncE%%%`_expr(name, targ*{targ <- targ*}, arg*{arg <- arg*}) = expr''
  2. (Type_ok: `%%|-%:%%`(p', C, targ, targIL, tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}))*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}
  3. Let tid_fresh*{tid_fresh <- tid_fresh*} = $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**})
  4. FuncType_ok: `%%|-%%%:%%%`(p', C, name, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, ft, tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, id_deft*{id_deft <- id_deft*})
  5. Let tid_fresh'*{tid_fresh' <- tid_fresh'*} = $concat_<tid>(tid_fresh*{tid_fresh <- tid_fresh*} :: [tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}])
  6. Call_ok: `%%%|-%%%%:%%%`(p', C, tid_fresh'*{tid_fresh' <- tid_fresh'*}, ft, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft*{id_deft <- id_deft*}, typ, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
  7. If (typ =/= `VoidT`_primtyp() as typ), then
    1. Result in `CallFuncE%%%%`_exprIL(name, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*}, `(%;%)`_annotIL(typ, `DYN`_ctk()))
1. Else If expr'' matches `CallMethodE%%%%`, then
  1. Let `CallMethodE%%%%`_expr(expr_b, member, targ*, arg*) = expr''
  2. If targ* matches [], then
    1. If arg* matches [], then
      1. If $in_set<member>(member, `SET%`_set<member>(["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])), then
        1. MethodType_ok: `%%|-%%%%:%%%%`(p', C, expr_b, member, [], [], ft, exprIL_b, tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, id_deft*{id_deft <- id_deft*})
        2. Call_ok: `%%%|-%%%%:%%%`(p', C, [], ft, [], [], [], typ, targIL*, argIL*)
        3. If (typ = `IntT`_numtyp() as typ), then
          1. If targIL* matches [], then
            1. If argIL* matches [], then
              1. Result in `CallMethodE%%%%%`_exprIL(exprIL_b, member, [], [], `(%;%)`_annotIL(`IntT`_numtyp() as typ, `LCTK`_ctk()))
  3. Let `CallMethodE%%%%`_expr(expr_b, member, targ*{targ <- targ*}, arg*{arg <- arg*}) = expr''
  4. If ~ $in_set<member>(member, `SET%`_set<member>(["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])), then
    1. (Type_ok: `%%|-%:%%`(p', C, targ, targIL, tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}))*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}
    2. Let tid_fresh*{tid_fresh <- tid_fresh*} = $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**})
    3. MethodType_ok: `%%|-%%%%:%%%%`(p', C, expr_b, member, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, ft, exprIL_b, tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, id_deft*{id_deft <- id_deft*})
    4. Let tid_fresh'*{tid_fresh' <- tid_fresh'*} = $concat_<tid>([tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}])
    5. Call_ok: `%%%|-%%%%:%%%`(p', C, tid_fresh'*{tid_fresh' <- tid_fresh'*}, ft, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft*{id_deft <- id_deft*}, typ, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
    6. If (typ =/= `VoidT`_primtyp() as typ), then
      1. Result in `CallMethodE%%%%%`_exprIL(exprIL_b, member, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*}, `(%;%)`_annotIL(typ, `DYN`_ctk()))
1. Else If expr'' matches `CallTypeE%%%%`, then
  1. Let `CallTypeE%%%%`_expr(name, member, targ*, arg*) = expr''
  2. If targ* matches [], then
    1. If arg* matches [], then
      1. Let typdef = $find_typdef(p', C, name)
      2. If $in_set<member>(member, `SET%`_set<member>(["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])), then
        1. Let ft = `BuiltinMethodT%%`_functyp([], `IntT`_numtyp() as typ)
        2. Call_ok: `%%%|-%%%%:%%%`(p', C, [], ft, [], [], [], typ, targIL*, argIL*)
        3. If (typ = `IntT`_numtyp() as typ), then
          1. If targIL* matches [], then
            1. If argIL* matches [], then
              1. Result in `CallTypeE%%%%%`_exprIL(name, member, [], [], `(%;%)`_annotIL(`IntT`_numtyp() as typ, `LCTK`_ctk()))
1. Else If expr'' matches `InstE%%%`, then
  1. Let `InstE%%%`_expr(name, targ*{targ <- targ*}, arg*{arg <- arg*}) = expr''
  2. (Type_ok: `%%|-%:%%`(p', C, targ, targIL, tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}))*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}
  3. Let tid_fresh*{tid_fresh <- tid_fresh*} = $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**})
  4. ConsType_ok: `%%|-%%%:%%%`(p', C, name, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, ct, tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, id_deft*{id_deft <- id_deft*})
  5. Let tid_fresh'*{tid_fresh' <- tid_fresh'*} = $concat_<tid>([tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}])
  6. Inst_ok: `%%%|-%%%%:%%%`(p', C, tid_fresh'*{tid_fresh' <- tid_fresh'*}, ct, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft*{id_deft <- id_deft*}, typ, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
  7. If $not_abstract_extern_object(typ), then
    1. Result in `InstE%%%%`_exprIL(name, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*}, `(%;%)`_annotIL(typ, `CTK`_ctk()))
2. If p' matches `LOCAL`, then
  1. If expr'' matches `SelectE%%`, then
    1. Let `SelectE%%`_expr(expr_k*{expr_k <- expr_k*}, selectcase*{selectcase <- selectcase*}) = expr''
    2. If (C.LOCAL.KIND = `PARSERSTATE`_lkind()), then
      1. (Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), C, expr_k, exprIL_k))*{exprIL_k <- exprIL_k*, expr_k <- expr_k*}
      2. (Let `(%;%)`_annotIL(typ_k, ctk_k) = $annot(exprIL_k))*{ctk_k <- ctk_k*, exprIL_k <- exprIL_k*, typ_k <- typ_k*}
      3. (Type_wf: `%|-%`($bound_tids(`LOCAL`_cursor(), C), `SetT%`_synthtyp(typ_k) as typ))*{typ_k <- typ_k*}
      4. (Select_case_ok: `%%%|-%:%`(`LOCAL`_cursor(), C, typ_k*{typ_k <- typ_k*}, selectcase, selectcaseIL))*{selectcase <- selectcase*, selectcaseIL <- selectcaseIL*}
      5. Result in `SelectE%%%`_exprIL(exprIL_k*{exprIL_k <- exprIL_k*}, selectcaseIL*{selectcaseIL <- selectcaseIL*}, `(%;%)`_annotIL(`StateT`_synthtyp() as typ, `DYN`_ctk()))

;; ../../../../spec/4b-typing-relation.watsup:75.1-77.23
relation Arg_ok: p, C, arg
1. If arg matches `ExprA%`, then
  1. Let `ExprA%`_arg(expr) = arg
  2. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  3. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
  4. Result in `ExprA%`_argIL(exprIL), typ
1. Else If arg matches `NameA%%`, then
  1. Let `NameA%%`_arg(id, expr?) = arg
  2. If expr? matches (_), then
    1. Let ?(expr) = expr?
    2. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
    3. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
    4. Result in `NameA%%`_argIL(id, ?(exprIL)), typ
  2. Else
    1. Result in `NameA%%`_argIL(id, ?()), `AnyT`_synthtyp() as typ
1. Else If arg matches `AnyA`, then
  1. Result in `AnyA`_argIL(), `AnyT`_synthtyp() as typ

;; ../../../../spec/4b-typing-relation.watsup:80.1-82.23
relation Lval_ok: p, C, exprIL
1. If exprIL matches `NameE%%`, then
  1. Let `NameE%%`_exprIL(name, _annotIL) = exprIL
  2. Let `%%%%`_styp(typ, dir, _ctk, _val?) = $find_styp(p, C, name)
  3. If ((dir = `OUT`_dir()) \/ (dir = `INOUT`_dir())), then
    1. If $is_assignable(typ), then
      1. Result in 
1. Else If exprIL matches `ArrAccE%%%`, then
  1. Let `ArrAccE%%%`_exprIL(exprIL_b, exprIL_i, _annotIL) = exprIL
  2. Lval_ok: `%%|-%`(p, C, exprIL_b)
  3. Result in 
1. Else If exprIL matches `BitAccE%%%%`, then
  1. Let `BitAccE%%%%`_exprIL(exprIL_b, exprIL_l, exprIL_h, _annotIL) = exprIL
  2. Lval_ok: `%%|-%`(p, C, exprIL_b)
  3. Result in 
1. Else If exprIL matches `ExprAccE%%%`, then
  1. Let `ExprAccE%%%`_exprIL(exprIL_b, member, _annotIL) = exprIL
  2. Lval_ok: `%%|-%`(p, C, exprIL_b)
  3. Result in 

;; ../../../../spec/4b-typing-relation.watsup:87.18-87.31
syntax blkctxt = 
   | `INIT`()
   | `NOINIT`()

;; ../../../../spec/4b-typing-relation.watsup:88.1-90.29
relation Block_ok: cursor, C, f, blkctxt, `BlockB%`_block(stmt*{stmt <- stmt*})
1. If cursor matches `LOCAL`, then
  1. If blkctxt matches `INIT`, then
    1. Stmts_ok: `%%%|-%:%%%`(`LOCAL`_cursor(), C, f, stmt*{stmt <- stmt*}, C', f', stmtIL*{stmtIL <- stmtIL*})
    2. Result in C', f', `BlockB%`_blockIL(stmtIL*{stmtIL <- stmtIL*})
  1. Else If blkctxt matches `NOINIT`, then
    1. Let C' = $enter(C)
    2. Stmts_ok: `%%%|-%:%%%`(`LOCAL`_cursor(), C', f, stmt*{stmt <- stmt*}, C'', f', stmtIL*{stmtIL <- stmtIL*})
    3. Let C''' = $exit(C'')
    4. Result in C''', f', `BlockB%`_blockIL(stmtIL*{stmtIL <- stmtIL*})

;; ../../../../spec/4b-typing-relation.watsup:91.1-93.26
relation Stmt_ok: p', C, f, stmt
1. If stmt matches `EmptyS`, then
  1. Result in C, f, `EmptyS`_stmtIL()
1. Else If stmt matches `AssignS%%`, then
  1. Let `AssignS%%`_stmt(expr_l, expr_r) = stmt
  2. Expr_ok: `%%|-%:%`(p', C, expr_l, exprIL_l)
  3. Let `(%;%)`_annotIL(typ_l, ctk) = $annot(exprIL_l)
  4. If ctk matches `DYN`, then
    1. Lval_ok: `%%|-%`(p', C, exprIL_l)
    2. Expr_ok: `%%|-%:%`(p', C, expr_r, exprIL_r)
    3. Let `(%;%)`_annotIL(typ_r, _ctk) = $annot(exprIL_r)
    4. Let exprIL_r' = $coerce_assign(exprIL_r, typ_l)
    5. Result in C, f, `AssignS%%`_stmtIL(exprIL_l, exprIL_r')
1. Else If stmt matches `IfS%%%`, then
  1. Let `IfS%%%`_stmt(expr_c, stmt_t, stmt_f) = stmt
  2. Expr_ok: `%%|-%:%`(p', C, expr_c, exprIL_c)
  3. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL_c)
  4. If (typ = `BoolT`_primtyp() as typ), then
    1. Stmt_ok: `%%%|-%:%%%`(p', C, f, stmt_t, C_t, f_t, stmtIL_t)
    2. Stmt_ok: `%%%|-%:%%%`(p', C, f, stmt_f, C_f, f_f, stmtIL_f)
    3. Let f' = $join_flow(f_t, f_f)
    4. Result in C, f', `IfS%%%`_stmtIL(exprIL_c, stmtIL_t, stmtIL_f)
1. Else If stmt matches `ExitS`, then
  1. Result in C, f, `ExitS`_stmtIL()
1. Else If stmt matches `CallFuncS%%%`, then
  1. Let `CallFuncS%%%`_stmt(name, targ*{targ <- targ*}, arg*{arg <- arg*}) = stmt
  2. If ((name = `CURRENT%`_name("verify")) => (((p' = `BLOCK`_cursor()) /\ (C.BLOCK.KIND = `PARSER`_bkind())) \/ ((p' = `LOCAL`_cursor()) /\ (C.LOCAL.KIND = `PARSERSTATE`_lkind())))), then
    1. (Type_ok: `%%|-%:%%`(p', C, targ, targIL, tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}))*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}
    2. Let tid_fresh*{tid_fresh <- tid_fresh*} = $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**})
    3. FuncType_ok: `%%|-%%%:%%%`(p', C, name, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, ft, tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, id_deft*{id_deft <- id_deft*})
    4. Let tid_fresh'*{tid_fresh' <- tid_fresh'*} = $concat_<tid>([tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}])
    5. Call_ok: `%%%|-%%%%:%%%`(p', C, tid_fresh'*{tid_fresh' <- tid_fresh'*}, ft, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft*{id_deft <- id_deft*}, typ, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
    6. Result in C, f, `CallFuncS%%%`_stmtIL(name, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
1. Else If stmt matches `CallMethodS%%%%`, then
  1. Let `CallMethodS%%%%`_stmt(expr_b, member, targ*{targ <- targ*}, arg*{arg <- arg*}) = stmt
  2. (Arg_ok: `%%|-%:%%`(p', C, arg, argIL, typ_arg))*{arg <- arg*, argIL <- argIL*, typ_arg <- typ_arg*}
  3. (Type_ok: `%%|-%:%%`(p', C, targ, targIL, tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}))*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}
  4. Let tid_fresh*{tid_fresh <- tid_fresh*} = $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**})
  5. MethodType_ok: `%%|-%%%%:%%%%`(p', C, expr_b, member, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, ft, exprIL_b, tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, id_deft*{id_deft <- id_deft*})
  6. Let tid_fresh'*{tid_fresh' <- tid_fresh'*} = $concat_<tid>([tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}])
  7. Call_ok: `%%%|-%%%%:%%%`(p', C, tid_fresh'*{tid_fresh' <- tid_fresh'*}, ft, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft*{id_deft <- id_deft*}, typ, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
  8. Result in C, f, `CallMethodS%%%%`_stmtIL(exprIL_b, member, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
1. Else If stmt matches `CallInstS%%%`, then
  1. Let `CallInstS%%%`_stmt(name, targ*{targ <- targ*}, arg*{arg <- arg*}) = stmt
  2. ConsType_ok: `%%|-%%%:%%%`(p', C, name, [], [], ct, tid*, id*)
  3. If tid* matches [], then
    1. If id* matches [], then
      1. Inst_ok: `%%%|-%%%%:%%%`(p', C, [], ct, [], [], [], typ, targIL*, argIL*)
      2. If targIL* matches [], then
        1. If argIL* matches [], then
          1. Let typ' = $canon_typ(typ)
          2. If ($is_parsert(typ') \/ $is_controlt(typ')), then
            1. Let id = $id_of_name(name)
            2. Let C' = $add_styp(p', C, id, `%%%%`_styp(typ, `NO`_dir(), `CTK`_ctk(), ?()))
            3. Stmt_ok: `%%%|-%:%%%`(p', C', f, `CallMethodS%%%%`_stmt(`NameE%`_expr(`CURRENT%`_name(id)), "apply", targ*{targ <- targ*}, arg*{arg <- arg*}), context, f', stmtIL)
            4. If (context = C'), then
              1. Let stmtIL' = stmtIL
              2. If stmtIL' matches `CallMethodS%%%%`, then
                1. Let `CallMethodS%%%%`_stmtIL(exprIL, text, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*}) = stmtIL'
                2. If exprIL matches `NameE%%`, then
                  1. Let `NameE%%`_exprIL(name', _annotIL) = exprIL
                  2. If (name' = `CURRENT%`_name(id)), then
                    1. If (text = "apply"), then
                      1. Result in C, f, `CallInstS%%%%`_stmtIL(typ, name, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
1. Else If stmt matches `TransS%`, then
  1. Let `TransS%`_stmt(expr) = stmt
  2. Expr_ok: `%%|-%:%`(p', C, expr, exprIL)
  3. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
  4. If (typ = `StateT`_synthtyp() as typ), then
    1. Result in C, f, `TransS%`_stmtIL(exprIL)
1. Else If stmt matches `DeclS%`, then
  1. Let `DeclS%`_stmt(decl) = stmt
  2. Decl_ok: `%%|-%:%%`(p', C, decl, C', declIL)
  3. Result in C', f, `DeclS%`_stmtIL(declIL)
2. If p' matches `LOCAL`, then
  1. If stmt matches `SwitchS%%`, then
    1. Let `SwitchS%%`_stmt(expr, switchcase*{switchcase <- switchcase*}) = stmt
    2. If (C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind()), then
      1. Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), C, expr, exprIL)
      2. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
      3. If typ <: synthtyp, then
        1. Let synthtyp = typ as synthtyp
        2. If synthtyp matches `TableEnumT%%`, then
          1. Let `TableEnumT%%`_synthtyp(id, _member*) = synthtyp
          2. Let id_t = $strip_prefix($strip_suffix(id, ")"), "action_list(")
          3. Switch_tbl_cases_ok: `%%%%|-%:%%%`(`LOCAL`_cursor(), C, f, id_t, switchcase*{switchcase <- switchcase*}, f', switchcaseIL*{switchcaseIL <- switchcaseIL*}, switchlabel*{switchlabel <- switchlabel*})
          4. If $distinct_<switchlabel>(switchlabel*{switchlabel <- switchlabel*}), then
            1. Result in C, f', `SwitchS%%`_stmtIL(exprIL, switchcaseIL*{switchcaseIL <- switchcaseIL*})
      4. Let typ' = $canon_typ(typ)
      5. If (((($is_errt(typ') \/ $is_fintt(typ')) \/ $is_fbitt(typ')) \/ $is_enumt(typ')) \/ $is_senumt(typ')), then
        1. Switch_gen_cases_ok: `%%%%|-%:%%%`(`LOCAL`_cursor(), C, f, typ, switchcase*{switchcase <- switchcase*}, f', switchcaseIL*{switchcaseIL <- switchcaseIL*}, switchlabel*{switchlabel <- switchlabel*})
        2. If $distinct_<switchlabel>(switchlabel*{switchlabel <- switchlabel*}), then
          1. Result in C, f', `SwitchS%%`_stmtIL(exprIL, switchcaseIL*{switchcaseIL <- switchcaseIL*})
  1. Else If stmt matches `BlockS%`, then
    1. Let `BlockS%`_stmt(block) = stmt
    2. Block_ok: `%%%%|-%:%%%`(`LOCAL`_cursor(), C, f, `NOINIT`_blkctxt(), block, C', f', blockIL)
    3. Result in C', f', `BlockS%`_stmtIL(blockIL)
  1. Else If stmt matches `RetS%`, then
    1. Let `RetS%`_stmt(expr?) = stmt
    2. If expr? matches (_), then
      1. Let ?(expr) = expr?
      2. Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), C, expr, exprIL)
      3. Let typ_r = $get_typ_ret_lkind(C.LOCAL.KIND)
      4. Let exprIL' = $coerce_assign(exprIL, typ_r)
      5. Result in C, `RET`_flow(), `RetS%`_stmtIL(?(exprIL'))
  2. If (stmt = `RetS%`_stmt(?())), then
    1. If (`VoidT`_primtyp() as typ = $get_typ_ret_lkind(C.LOCAL.KIND)), then
      1. Result in C, `RET`_flow(), `RetS%`_stmtIL(?())

;; ../../../../spec/4b-typing-relation.watsup:94.1-96.26
relation Stmts_ok: p, C, f, stmt*
1. If stmt* matches [], then
  1. Result in C, f, []
1. Else
  1. Let stmt_h :: stmt_t*{stmt_t <- stmt_t*} = stmt*
  2. Stmt_ok: `%%%|-%:%%%`(p, C, f, stmt_h, C', f', stmtIL_h)
  3. Stmts_ok: `%%%|-%:%%%`(p, C', f', stmt_t*{stmt_t <- stmt_t*}, C'', f'', stmtIL_t*{stmtIL_t <- stmtIL_t*})
  4. Result in C'', f'', stmtIL_h :: stmtIL_t*{stmtIL_t <- stmtIL_t*}

;; ../../../../spec/4b-typing-relation.watsup:101.1-103.23
relation Param_ok: p, C, `%%%%`_param(id, dir, type, expr?)
1. If expr? matches (_), then
  1. Let ?(expr) = expr?
  2. Type_ok: `%%|-%:%%`(p, C, type, typ_p, tid_fresh*{tid_fresh <- tid_fresh*})
  3. Let tidset = $union_set<tid>($bound_tids(p, C), `SET%`_set<tid>(tid_fresh*{tid_fresh <- tid_fresh*}))
  4. Type_wf: `%|-%`(tidset, typ_p)
  5. Expr_ok: `%%|-%:%`(p, C, expr, exprIL_e)
  6. Let `(%;%)`_annotIL(typ_e, ctk) = $annot(exprIL_e)
  7. If ctk matches `LCTK`, then
    1. Sub_impl: `%<<%`(typ_e, typ_p)
    2. Eval_static: `%%|-%~>%`(p, C, exprIL_e, val)
    3. Result in `%%%%`_paramIL(id, dir, typ_p, ?(val)), tid_fresh*{tid_fresh <- tid_fresh*}
1. Else
  1. Type_ok: `%%|-%:%%`(p, C, type, typ_p, tid_fresh*{tid_fresh <- tid_fresh*})
  2. Let tidset = $union_set<tid>($bound_tids(p, C), `SET%`_set<tid>(tid_fresh*{tid_fresh <- tid_fresh*}))
  3. Type_wf: `%|-%`(tidset, typ_p)
  4. Result in `%%%%`_paramIL(id, dir, typ_p, ?()), tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../spec/4b-typing-relation.watsup:104.1-106.23
relation CParam_ok: p, C, `%%%%`_param(id, dir, type, expr?)
1. If expr? matches (_), then
  1. Let ?(expr) = expr?
  2. Type_ok: `%%|-%:%%`(p, C, type, typ_p, tid_fresh*{tid_fresh <- tid_fresh*})
  3. Let tidset = $union_set<tid>($bound_tids(p, C), `SET%`_set<tid>(tid_fresh*{tid_fresh <- tid_fresh*}))
  4. Type_wf: `%|-%`(tidset, typ_p)
  5. Expr_ok: `%%|-%:%`(p, C, expr, exprIL_e)
  6. Let `(%;%)`_annotIL(typ_e, ctk) = $annot(exprIL_e)
  7. If ctk matches `LCTK`, then
    1. Sub_impl: `%<<%`(typ_e, typ_p)
    2. Eval_static: `%%|-%~>%`(p, C, exprIL_e, val)
    3. Result in `%%%%`_paramIL(id, dir, typ_p, ?(val)), tid_fresh*{tid_fresh <- tid_fresh*}
1. Else
  1. Type_ok: `%%|-%:%%`(p, C, type, typ_p, tid_fresh*{tid_fresh <- tid_fresh*})
  2. Let tidset = $union_set<tid>($bound_tids(p, C), `SET%`_set<tid>(tid_fresh*{tid_fresh <- tid_fresh*}))
  3. Type_wf: `%|-%`(tidset, typ_p)
  4. Result in `%%%%`_paramIL(id, dir, typ_p, ?()), tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../spec/4b-typing-relation.watsup:110.1-112.23
relation Decl_ok: p', C'''', decl''
1. If decl'' matches `ConstD%%%`, then
  1. Let `ConstD%%%`_decl(id, type, expr) = decl''
  2. Type_ok: `%%|-%:%%`(p', C'''', type, typ_c, tid*)
  3. If tid* matches [], then
    1. Type_wf: `%|-%`($bound_tids(p', C''''), typ_c)
    2. Expr_ok: `%%|-%:%`(p', C'''', expr, exprIL)
    3. Let `(%;%)`_annotIL(_typ, ctk) = $annot(exprIL)
    4. If ctk matches `LCTK`, then
      1. Let exprIL' = $coerce_assign(exprIL, typ_c)
      2. Eval_static: `%%|-%~>%`(p', C'''', exprIL', val)
      3. Let C' = $add_styp(p', C'''', id, `%%%%`_styp(typ_c, `NO`_dir(), `LCTK`_ctk(), ?(val)))
      4. Result in C', `ConstD%%%`_declIL(id, typ_c, val)
1. Else If decl'' matches `VarD%%%`, then
  1. Let `VarD%%%`_decl(id, type, expr?) = decl''
  2. If expr? matches (), then
    1. Type_ok: `%%|-%:%%`(p', C'''', type, typ, tid*)
    2. If tid* matches [], then
      1. Type_wf: `%|-%`($bound_tids(p', C''''), typ)
      2. If $is_assignable(typ), then
        1. Let C' = $add_styp(p', C'''', id, `%%%%`_styp(typ, `INOUT`_dir(), `DYN`_ctk(), ?()))
        2. Result in C', `VarD%%%`_declIL(id, typ, ?())
  2. Else
    1. Let ?(expr) = expr?
    2. Type_ok: `%%|-%:%%`(p', C'''', type, typ, tid*)
    3. If tid* matches [], then
      1. Type_wf: `%|-%`($bound_tids(p', C''''), typ)
      2. If $is_assignable(typ), then
        1. Expr_ok: `%%|-%:%`(p', C'''', expr, exprIL)
        2. Let exprIL' = $coerce_assign(exprIL, typ)
        3. Let C' = $add_styp(p', C'''', id, `%%%%`_styp(typ, `INOUT`_dir(), `DYN`_ctk(), ?()))
        4. Result in C', `VarD%%%`_declIL(id, typ, ?(exprIL'))
1. Else If decl'' matches `InstD%%%%%`, then
  1. Let `InstD%%%%%`_decl(id, name_inst, targ*{targ <- targ*}, arg*{arg <- arg*}, decl''*{decl'' <- decl''*}) = decl''
  2. If (|decl''*{decl'' <- decl''*}| > 0), then
    1. (Type_ok: `%%|-%:%%`(p', C'''', targ, targIL, tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}))*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}
    2. Let tid_fresh*{tid_fresh <- tid_fresh*} = $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**})
    3. ConsType_ok: `%%|-%%%:%%%`(p', C'''', name_inst, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, ct, tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, id_deft*{id_deft <- id_deft*})
    4. Inst_ok: `%%%|-%%%%:%%%`(p', C'''', tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, ct, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft*{id_deft <- id_deft*}, typ, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
    5. Let typ''' = typ
    6. If typ''' <: abstyp, then
      1. Let abstyp = typ''' as abstyp
      2. If abstyp matches `SpecT%%`, then
        1. Let `SpecT%%`_abstyp(`PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ''), typ_a*{typ_a <- typ_a*}) = abstyp
        2. If typ'' <: objtyp, then
          1. Let objtyp = typ'' as objtyp
          2. If objtyp matches `ExternT%%`, then
            1. Let `ExternT%%`_objtyp(id_ext, fdenv_ext) = objtyp
            2. Let C' = $add_styp(`LOCAL`_cursor(), C'''', "this", `%%%%`_styp(typ, `NO`_dir(), `CTK`_ctk(), ?()))
            3. Inst_init_decls_ok: `%%%|-%:%%%`(C', $empty_frame, $empty_fdenv, decl''*{decl'' <- decl''*}, frame_abs, fdenv_abs, declIL*{declIL <- declIL*})
            4. Let `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid_abs, fd_abs)*{fd_abs <- fd_abs*, fid_abs <- fid_abs*}) = fdenv_abs
            5. Let tparam'*{tparam' <- tparam'*} = tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}
            6. Let theta = `MAP%`_map<id, typ>(`PAIR%%`_pair<id, typ>(tparam', typ_a)*{tparam' <- tparam'*, typ_a <- typ_a*})
            7. Let fdenv_ext' = $update_fdenv_extern(fdenv_ext, theta, fid_abs*{fid_abs <- fid_abs*}, fd_abs*{fd_abs <- fd_abs*})
            8. Let `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid_ext, fd_ext)*{fd_ext <- fd_ext*, fid_ext <- fid_ext*}) = fdenv_ext'
            9. Let funcdef*{funcdef <- funcdef*} = fd_ext*{fd_ext <- fd_ext*}
            10. If (funcdef <: polyfuncdef)*{funcdef <- funcdef*}, then
              1. (Let `PolyFD%->%`_polyfuncdef(_(tparam*, tparam*), ft) = funcdef as polyfuncdef)*{_(tparam*, tparam*) <- _(tparam*, tparam*)*, ft <- ft*, funcdef <- funcdef*}
              2. If (~ $is_externabstractmethodt(ft))*{ft <- ft*}, then
                1. Let typ' = `SpecT%%`_abstyp(`PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ExternT%%`_objtyp(id_ext, fdenv_ext') as typ), typ_a*{typ_a <- typ_a*}) as typ
                2. Let C'' = $add_styp(p', C'''', id, `%%%%`_styp(typ', `NO`_dir(), `CTK`_ctk(), ?()))
                3. Result in C'', `InstD%%%%%%`_declIL(id, typ, name_inst, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*}, declIL*{declIL <- declIL*})
  3. Let `InstD%%%%%`_decl(id, name_inst, targ*{targ <- targ*}, arg*{arg <- arg*}, decl*) = decl''
  4. If decl* matches [], then
    1. (Type_ok: `%%|-%:%%`(p', C'''', targ, targIL, tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}))*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}
    2. Let tid_fresh*{tid_fresh <- tid_fresh*} = $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**})
    3. ConsType_ok: `%%|-%%%:%%%`(p', C'''', name_inst, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, ct, tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, id_deft*{id_deft <- id_deft*})
    4. Inst_ok: `%%%|-%%%%:%%%`(p', C'''', tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}, ct, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft*{id_deft <- id_deft*}, typ, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*})
    5. Let C' = $add_styp(p', C'''', id, `%%%%`_styp(typ, `NO`_dir(), `CTK`_ctk(), ?()))
    6. Result in C', `InstD%%%%%%`_declIL(id, typ, name_inst, targIL'*{targIL' <- targIL'*}, argIL'*{argIL' <- argIL'*}, [])
1. Else If decl'' matches `ActionD%%%`, then
  1. Let `ActionD%%%`_decl(id, param*{param <- param*}, block) = decl''
  2. If ((p' = `GLOBAL`_cursor()) \/ ((p' = `BLOCK`_cursor()) /\ (C''''.BLOCK.KIND = `CONTROL`_bkind()))), then
    1. Let fid = $to_fid(id, param*{param <- param*})
    2. Let C_1 = $set_localkind(C'''', `ACTION`_lkind())
    3. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_1, param, paramIL, tid*))*{param <- param*, paramIL <- paramIL*, tid* <- tid**}
    4. If (tid* matches [])*{tid* <- tid**}, then
      1. Let C_2 = $add_params(`LOCAL`_cursor(), C_1, paramIL*{paramIL <- paramIL*} as paramtyp*)
      2. Block_ok: `%%%%|-%:%%%`(`LOCAL`_cursor(), C_2, `CONT`_flow(), `INIT`_blkctxt(), block, _context, _flow, blockIL)
      3. Let fd = `MonoFD%`_monofuncdef(`ActionT%`_functyp(paramIL*{paramIL <- paramIL*} as paramtyp*)) as funcdef
      4. FuncDef_wf: `%|-%`($bound_tids(p', C''''), fd)
      5. Let C_4 = $add_funcdef_non_overload(p', C'''', fid, fd)
      6. Result in C_4, `ActionD%%%`_declIL(id, paramIL*{paramIL <- paramIL*}, blockIL)
1. Else If decl'' matches `ValueSetD%%%`, then
  1. Let `ValueSetD%%%`_decl(id, type, expr) = decl''
  2. If ((p' = `GLOBAL`_cursor()) \/ ((p' = `BLOCK`_cursor()) /\ (C''''.BLOCK.KIND = `PARSER`_bkind()))), then
    1. Type_ok: `%%|-%:%%`(p', C'''', type, typ_s, tid*)
    2. If tid* matches [], then
      1. Type_wf: `%|-%`($bound_tids(p', C''''), `SetT%`_synthtyp(typ_s) as typ)
      2. Expr_ok: `%%|-%:%`(p', C'''', expr, exprIL)
      3. Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL)
      4. If ((ctk = `CTK`_ctk()) \/ (ctk = `LCTK`_ctk())), then
        1. Let C' = $add_styp(p', C'''', id, `%%%%`_styp(`SetT%`_synthtyp(typ_s) as typ, `NO`_dir(), `CTK`_ctk(), ?()))
        2. Result in C', `ValueSetD%%%`_declIL(id, typ, exprIL)
2. If p' matches `GLOBAL`, then
  1. If decl'' matches `ErrD%`, then
    1. Let `ErrD%`_decl(member*{member <- member*}) = decl''
    2. If $distinct_<member>(member*{member <- member*}), then
      1. (Let id_e = $concat_text(["error.", member]))*{id_e <- id_e*, member <- member*}
      2. (Let val_e = `ErrV%`_val(member))*{member <- member*, val_e <- val_e*}
      3. (Let styp_e = `%%%%`_styp(`ErrT`_primtyp() as typ, `NO`_dir(), `LCTK`_ctk(), ?(val_e)))*{styp_e <- styp_e*, val_e <- val_e*}
      4. Let C' = $add_styps(`GLOBAL`_cursor(), C'''', id_e*{id_e <- id_e*}, styp_e*{styp_e <- styp_e*})
      5. Result in C', `ErrD%`_declIL(member*{member <- member*})
  1. Else If decl'' matches `MatchKindD%`, then
    1. Let `MatchKindD%`_decl(member*{member <- member*}) = decl''
    2. If $distinct_<member>(member*{member <- member*}), then
      1. (Let id_m = member)*{id_m <- id_m*, member <- member*}
      2. (Let val_m = `MatchKindV%`_val(member))*{member <- member*, val_m <- val_m*}
      3. (Let styp_m = `%%%%`_styp(`MatchKindT`_primtyp() as typ, `NO`_dir(), `LCTK`_ctk(), ?(val_m)))*{styp_m <- styp_m*, val_m <- val_m*}
      4. Let C' = $add_styps(`GLOBAL`_cursor(), C'''', id_m*{id_m <- id_m*}, styp_m*{styp_m <- styp_m*})
      5. Result in C', `MatchKindD%`_declIL(member*{member <- member*})
  1. Else If decl'' matches `StructD%%%`, then
    1. Let `StructD%%%`_decl(id, tparam*{tparam <- tparam*}, (member_f, type_f)*{member_f <- member_f*, type_f <- type_f*}) = decl''
    2. Let C' = $add_tparams(`BLOCK`_cursor(), C'''', tparam*{tparam <- tparam*})
    3. (Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), C', type_f, typ_f, tid_fresh_f*{tid_fresh_f <- tid_fresh_f*}))*{tid_fresh_f* <- tid_fresh_f**, typ_f <- typ_f*, type_f <- type_f*}
    4. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_f*{tid_fresh_f <- tid_fresh_f*}*{tid_fresh_f* <- tid_fresh_f**})
    5. Let typ_s = `StructT%%`_datatyp(id, (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*}) as typ
    6. Let td = `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ_s) as typdef
    7. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
    8. Let C'' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
    9. Result in C'', `StructD%%%%`_declIL(id, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*})
  1. Else If decl'' matches `HeaderD%%%`, then
    1. Let `HeaderD%%%`_decl(id, tparam*{tparam <- tparam*}, (member_f, type_f)*{member_f <- member_f*, type_f <- type_f*}) = decl''
    2. Let C' = $add_tparams(`BLOCK`_cursor(), C'''', tparam*{tparam <- tparam*})
    3. (Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), C', type_f, typ_f, tid_fresh_f*{tid_fresh_f <- tid_fresh_f*}))*{tid_fresh_f* <- tid_fresh_f**, typ_f <- typ_f*, type_f <- type_f*}
    4. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_f*{tid_fresh_f <- tid_fresh_f*}*{tid_fresh_f* <- tid_fresh_f**})
    5. Let typ_s = `HeaderT%%`_datatyp(id, (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*}) as typ
    6. Let td = `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ_s) as typdef
    7. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
    8. Let C'' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
    9. Result in C'', `HeaderD%%%%`_declIL(id, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*})
  1. Else If decl'' matches `UnionD%%%`, then
    1. Let `UnionD%%%`_decl(id, tparam*{tparam <- tparam*}, (member_f, type_f)*{member_f <- member_f*, type_f <- type_f*}) = decl''
    2. Let C' = $add_tparams(`BLOCK`_cursor(), C'''', tparam*{tparam <- tparam*})
    3. (Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), C', type_f, typ_f, tid_fresh_f*{tid_fresh_f <- tid_fresh_f*}))*{tid_fresh_f* <- tid_fresh_f**, typ_f <- typ_f*, type_f <- type_f*}
    4. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_f*{tid_fresh_f <- tid_fresh_f*}*{tid_fresh_f* <- tid_fresh_f**})
    5. Let typ_s = `UnionT%%`_datatyp(id, (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*}) as typ
    6. Let td = `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), typ_s) as typdef
    7. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
    8. Let C'' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
    9. Result in C'', `UnionD%%%%`_declIL(id, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*})
  1. Else If decl'' matches `EnumD%%`, then
    1. Let `EnumD%%`_decl(id, member*{member <- member*}) = decl''
    2. If $distinct_<member>(member*{member <- member*}), then
      1. (Let id_e = $concat_text([id, ".", member]))*{id_e <- id_e*, member <- member*}
      2. (Let val_e = `EnumFieldV%%`_val(id, member))*{member <- member*, val_e <- val_e*}
      3. Let typ_e = `EnumT%%`_datatyp(id, member*{member <- member*}) as typ
      4. (Let styp_e = `%%%%`_styp(typ_e, `NO`_dir(), `LCTK`_ctk(), ?(val_e)))*{styp_e <- styp_e*, val_e <- val_e*}
      5. Let C' = $add_styps(`GLOBAL`_cursor(), C'''', id_e*{id_e <- id_e*}, styp_e*{styp_e <- styp_e*})
      6. Let td = `MonoD%`_monotypdef(typ_e) as typdef
      7. Let tidset = $bound_tids(`GLOBAL`_cursor(), C'''')
      8. TypeDef_wf: `%|-%`(tidset, td)
      9. Let C'' = $add_typdef(`GLOBAL`_cursor(), C', id, td)
      10. Result in C'', `EnumD%%`_declIL(id, member*{member <- member*})
  1. Else If decl'' matches `SEnumD%%%`, then
    1. Let `SEnumD%%%`_decl(id, type, (member, expr)*{expr <- expr*, member <- member*}) = decl''
    2. If $distinct_<member>(member*{member <- member*}), then
      1. Type_ok: `%%|-%:%%`(`GLOBAL`_cursor(), C'''', type, typ, tid*)
      2. If tid* matches [], then
        1. Type_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), typ)
        2. SEnum_fields_ok: `%%%%|-%:%%`(C'''', id, typ, [], (member, expr)*{expr <- expr*, member <- member*}, C_1, (member', val_s)*{member' <- member'*, val_s <- val_s*})
        3. If ((member' = member))*{member <- member*, member' <- member'*}, then
          1. (Let id_s = $concat_text([id, ".", member]))*{id_s <- id_s*, member <- member*}
          2. Let typ_s = `SEnumT%%%`_datatyp(id, typ, (member, val_s)*{member <- member*, val_s <- val_s*}) as typ
          3. (Let styp_s = `%%%%`_styp(typ_s, `NO`_dir(), `LCTK`_ctk(), ?(val_s)))*{styp_s <- styp_s*, val_s <- val_s*}
          4. Let C_2 = $add_styps(`GLOBAL`_cursor(), C_1, id_s*{id_s <- id_s*}, styp_s*{styp_s <- styp_s*})
          5. Let td = `MonoD%`_monotypdef(typ_s) as typdef
          6. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
          7. Let C_3 = $add_typdef(`GLOBAL`_cursor(), C_2, id, td)
          8. Result in C_3, `SEnumD%%%`_declIL(id, typ, (member, val_s)*{member <- member*, val_s <- val_s*})
  1. Else If decl'' matches `NewTypeD%%`, then
    1. Let `NewTypeD%%`_decl(id, typedef) = decl''
    2. If typedef matches `TypeD%`, then
      1. Let `TypeD%`_typedef(type) = typedef
      2. Type_ok: `%%|-%:%%`(`GLOBAL`_cursor(), C'''', type, typ, tid*)
      3. If tid* matches [], then
        1. Type_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), typ)
        2. Let typ_n = `NewT%%`_datatyp(id, typ) as typ
        3. Let td = `MonoD%`_monotypdef(typ_n) as typdef
        4. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
        5. Let C' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
        6. Result in C', `NewTypeD%%`_declIL(id, `TypeD%`_typedefIL(typ))
    2. Else If typedef matches `DeclD%`, then
      1. Let `DeclD%`_typedef(decl'') = typedef
      2. Decl_ok: `%%|-%:%%`(`GLOBAL`_cursor(), C'''', decl'', C', declIL)
      3. Let `SET%`_set<tid>(tid*) = $diff_set<tid>($dom_map<tid, typdef>(C'.GLOBAL.TDENV), $dom_map<tid, typdef>(C''''.GLOBAL.TDENV))
      4. If tid* matches [ _/1 ], then
        1. Let [tid_n] = tid*
        2. Let typdef = $find_typdef(`GLOBAL`_cursor(), C', `CURRENT%`_name(tid_n))
        3. If typdef <: monotypdef, then
          1. Let `MonoD%`_monotypdef(typ_n) = typdef as monotypdef
          2. Let td = `MonoD%`_monotypdef(`NewT%%`_datatyp(id, typ_n) as typ) as typdef
          3. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
          4. Let C'' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
          5. Result in C'', `NewTypeD%%`_declIL(id, `DeclD%`_typedefIL(declIL))
        4. If typdef <: polytypdef, then
          1. Let ptd = typdef as polytypdef
          2. Let td = `MonoD%`_monotypdef(`NewT%%`_datatyp(id, `SpecT%%`_abstyp(ptd, []) as typ) as typ) as typdef
          3. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
          4. Let C'' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
          5. Result in C'', `NewTypeD%%`_declIL(id, `DeclD%`_typedefIL(declIL))
  1. Else If decl'' matches `TypeDefD%%`, then
    1. Let `TypeDefD%%`_decl(id, typedef) = decl''
    2. If typedef matches `TypeD%`, then
      1. Let `TypeD%`_typedef(type) = typedef
      2. Type_ok: `%%|-%:%%`(`GLOBAL`_cursor(), C'''', type, typ, tid*)
      3. If tid* matches [], then
        1. Type_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), typ)
        2. Let typ_d = `DefT%`_aliastyp(typ) as typ
        3. Let td = `MonoD%`_monotypdef(typ_d) as typdef
        4. Let tidset = $bound_tids(`GLOBAL`_cursor(), C'''')
        5. TypeDef_wf: `%|-%`(tidset, td)
        6. Let C' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
        7. Result in C', `TypeDefD%%`_declIL(id, `TypeD%`_typedefIL(typ))
    2. Else If typedef matches `DeclD%`, then
      1. Let `DeclD%`_typedef(decl'') = typedef
      2. Decl_ok: `%%|-%:%%`(`GLOBAL`_cursor(), C'''', decl'', C', declIL)
      3. Let `SET%`_set<tid>(tid*) = $diff_set<tid>($dom_map<tid, typdef>(C'.GLOBAL.TDENV), $dom_map<tid, typdef>(C''''.GLOBAL.TDENV))
      4. If tid* matches [ _/1 ], then
        1. Let [tid_d] = tid*
        2. Let typdef = $find_typdef(`GLOBAL`_cursor(), C', `CURRENT%`_name(tid_d))
        3. If typdef <: monotypdef, then
          1. Let `MonoD%`_monotypdef(typ_d) = typdef as monotypdef
          2. Let td = `MonoD%`_monotypdef(`DefT%`_aliastyp(typ_d) as typ) as typdef
          3. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
          4. Let C'' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
          5. Result in C'', `TypeDefD%%`_declIL(id, `DeclD%`_typedefIL(declIL))
        4. If typdef <: polytypdef, then
          1. Let ptd = typdef as polytypdef
          2. Let td = `MonoD%`_monotypdef(`DefT%`_aliastyp(`SpecT%%`_abstyp(ptd, []) as typ) as typ) as typdef
          3. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
          4. Let C'' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
          5. Result in C'', `TypeDefD%%`_declIL(id, `DeclD%`_typedefIL(declIL))
  1. Else If decl'' matches `FuncD%%%%%`, then
    1. Let `FuncD%%%%%`_decl(id, type_r, tparam*{tparam <- tparam*}, param*{param <- param*}, block) = decl''
    2. Let fid = $to_fid(id, param*{param <- param*})
    3. Let C_1 = $add_typdefs(`LOCAL`_cursor(), C'''', tparam*{tparam <- tparam*}, `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef*{tparam <- tparam*})
    4. Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_1, type_r, typ_r, tid*)
    5. If tid* matches [], then
      1. Let C_2 = $set_localkind(C_1, `FUNC%`_lkind(typ_r))
      2. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_2, param, paramIL, tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}))*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}
      3. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**})
      4. Let C_3 = $add_params(`LOCAL`_cursor(), C_2, paramIL*{paramIL <- paramIL*} as paramtyp*)
      5. Block_ok: `%%%%|-%:%%%`(`LOCAL`_cursor(), C_3, `CONT`_flow(), `INIT`_blkctxt(), block, C_4, f, blockIL)
      6. If ((f = `RET`_flow()) \/ ((f = `CONT`_flow()) /\ (typ_r = `VoidT`_primtyp() as typ))), then
        1. Let fd = `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `FuncT%%`_functyp(paramIL*{paramIL <- paramIL*} as paramtyp*, typ_r)) as funcdef
        2. FuncDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), fd)
        3. Let C_5 = $add_funcdef(`GLOBAL`_cursor(), C'''', fid, fd)
        4. Result in C_5, `FuncD%%%%%%`_declIL(id, typ_r, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, paramIL*{paramIL <- paramIL*}, blockIL)
  1. Else If decl'' matches `ExternFuncD%%%%`, then
    1. Let `ExternFuncD%%%%`_decl(id, type_r, tparam*{tparam <- tparam*}, param*{param <- param*}) = decl''
    2. Let fid = $to_fid(id, param*{param <- param*})
    3. Let C_1 = $add_typdefs(`LOCAL`_cursor(), C'''', tparam*{tparam <- tparam*}, `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef*{tparam <- tparam*})
    4. Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_1, type_r, typ_r, tid*)
    5. If tid* matches [], then
      1. Let C_2 = $set_localkind(C_1, `EXTERNFUNC`_lkind())
      2. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_2, param, paramIL, tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}))*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}
      3. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**})
      4. Let C_3 = $add_params(`LOCAL`_cursor(), C_2, paramIL*{paramIL <- paramIL*} as paramtyp*)
      5. Let fd = `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ExternFuncT%%`_functyp(paramIL*{paramIL <- paramIL*} as paramtyp*, typ_r)) as funcdef
      6. FuncDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), fd)
      7. Let C_4 = $add_funcdef(`GLOBAL`_cursor(), C'''', fid, fd)
      8. Result in C_4, `ExternFuncD%%%%%`_declIL(id, typ_r, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, paramIL*{paramIL <- paramIL*})
  1. Else If decl'' matches `ExternObjectD%%%`, then
    1. Let `ExternObjectD%%%`_decl(id, tparam*{tparam <- tparam*}, method*{method <- method*}) = decl''
    2. Let (method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*}) = $split_methods(method*{method <- method*})
    3. Let C_1 = $set_blockkind(C'''', `EXTERN`_bkind())
    4. Let C_2 = $add_typdefs(`BLOCK`_cursor(), C_1, tparam*{tparam <- tparam*}, `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef*{tparam <- tparam*})
    5. Methods_ok: `%%|-%:%%`(C_2, id, method_m*{method_m <- method_m*}, C_3, methodIL_m*{methodIL_m <- methodIL_m*})
    6. Let td = `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, []), `ExternT%%`_objtyp(id, C_3.BLOCK.FDENV) as typ) as typdef
    7. Let C_4 = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
    8. Let C_5 = $set_blockkind(C_4, `EXTERN`_bkind())
    9. Let C_6 = $add_typdefs(`BLOCK`_cursor(), C_5, tparam*{tparam <- tparam*}, `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef*{tparam <- tparam*})
    10. Methods_ok: `%%|-%:%%`(C_6, id, method_c*{method_c <- method_c*}, C_7, methodIL_c*{methodIL_c <- methodIL_c*})
    11. Let C_8 = C_4[GLOBAL.CDENV = C_7.GLOBAL.CDENV]
    12. Result in C_8, `ExternObjectD%%%`_declIL(id, tparam*{tparam <- tparam*}, methodIL_c*{methodIL_c <- methodIL_c*} ++ methodIL_m*{methodIL_m <- methodIL_m*})
  1. Else If decl'' matches `ParserTypeD%%%`, then
    1. Let `ParserTypeD%%%`_decl(id, tparam*{tparam <- tparam*}, param*{param <- param*}) = decl''
    2. Let C_1 = $set_blockkind(C'''', `PARSER`_bkind())
    3. Let C_2 = $add_typdefs(`BLOCK`_cursor(), C_1, tparam*{tparam <- tparam*}, `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef*{tparam <- tparam*})
    4. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_2, param, paramIL, tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}))*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}
    5. (Let `%%%%`_paramIL(id_p, dir_p, typ_p, val_p?{val_p <- val_p?}) = paramIL)*{dir_p <- dir_p*, id_p <- id_p*, paramIL <- paramIL*, typ_p <- typ_p*, val_p? <- val_p?*}
    6. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**})
    7. Let td = `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ParserT%`_objtyp(`%%%%`_paramtyp(id_p, dir_p, typ_p, val_p?{val_p <- val_p?})*{dir_p <- dir_p*, id_p <- id_p*, typ_p <- typ_p*, val_p? <- val_p?*}) as typ) as typdef
    8. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
    9. Let C_3 = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
    10. Result in C_3, `ParserTypeD%%%%`_declIL(id, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, paramIL*{paramIL <- paramIL*})
  1. Else If decl'' matches `ParserD%%%%%`, then
    1. Let `ParserD%%%%%`_decl(id, param*{param <- param*}, cparam*{cparam <- cparam*}, decl''*{decl'' <- decl''*}, parserstate*{parserstate <- parserstate*}) = decl''
    2. Let cid = $to_fid(id, cparam*{cparam <- cparam*})
    3. Let C_1 = $set_blockkind(C'''', `PARSER`_bkind())
    4. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_1, cparam, cparamIL, tid*))*{cparam <- cparam*, cparamIL <- cparamIL*, tid* <- tid**}
    5. If (tid* matches [])*{tid* <- tid**}, then
      1. Let C_2 = $add_params(`BLOCK`_cursor(), C_1, cparamIL*{cparamIL <- cparamIL*} as paramtyp*)
      2. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_2, param, paramIL, tid*'))*{param <- param*, paramIL <- paramIL*, tid*' <- tid*'*}
      3. If (tid*' matches [])*{tid*' <- tid*'*}, then
        1. Let funcdef_apply = `MonoFD%`_monofuncdef(`ParserApplyMethodT%`_functyp(paramIL*{paramIL <- paramIL*} as paramtyp*)) as funcdef
        2. FuncDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), funcdef_apply)
        3. Let C_3 = $add_params(`BLOCK`_cursor(), C_2, paramIL*{paramIL <- paramIL*} as paramtyp*)
        4. Decls_ok: `%%|-%:%%`(`BLOCK`_cursor(), C_3, decl''*{decl'' <- decl''*}, C_4, declIL*{declIL <- declIL*})
        5. (Let `%%`_parserstate(statelabel, block) = parserstate)*{block <- block*, parserstate <- parserstate*, statelabel <- statelabel*}
        6. If $distinct_<statelabel>(statelabel*{statelabel <- statelabel*}), then
          1. If $in_set<statelabel>("start", `SET%`_set<statelabel>(statelabel*{statelabel <- statelabel*})), then
            1. If ~ $in_set<statelabel>("accept", `SET%`_set<statelabel>(statelabel*{statelabel <- statelabel*})), then
              1. If ~ $in_set<statelabel>("reject", `SET%`_set<statelabel>(statelabel*{statelabel <- statelabel*})), then
                1. Let statelabel'*{statelabel' <- statelabel'*} = "accept" :: "reject" :: statelabel*{statelabel <- statelabel*}
                2. Let C_5 = $set_localkind(C_4, `PARSERSTATE`_lkind())
                3. Let styp*{styp <- styp*} = $repeat_<styp>(`%%%%`_styp(`StateT`_synthtyp() as typ, `NO`_dir(), `DYN`_ctk(), ?()), |statelabel'*{statelabel' <- statelabel'*}|)
                4. Let C_6 = $add_styps(`BLOCK`_cursor(), C_5, statelabel'*{statelabel' <- statelabel'*}, styp*{styp <- styp*})
                5. (ParserState_ok: `%|-%:%`(C_6, parserstate, parserstateIL))*{parserstate <- parserstate*, parserstateIL <- parserstateIL*}
                6. Let ptd = `PolyD%->%`_polytypdef(([], []), `ParserT%`_objtyp(paramIL*{paramIL <- paramIL*} as paramtyp*) as typ)
                7. Let typ = `SpecT%%`_abstyp(ptd, []) as typ
                8. Let cd = `ConsD%->%`_consdef(([], []), `ConsT%%`_constyp(cparamIL*{cparamIL <- cparamIL*} as paramtyp*, typ))
                9. ConsDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), cd)
                10. Let C_8 = $add_consdef(`GLOBAL`_cursor(), C'''', cid, cd)
                11. Result in C_8, `ParserD%%%%%`_declIL(id, paramIL*{paramIL <- paramIL*}, cparamIL*{cparamIL <- cparamIL*}, declIL*{declIL <- declIL*}, parserstateIL*{parserstateIL <- parserstateIL*})
  1. Else If decl'' matches `ControlTypeD%%%`, then
    1. Let `ControlTypeD%%%`_decl(id, tparam*{tparam <- tparam*}, param*{param <- param*}) = decl''
    2. Let C' = $add_typdefs(`BLOCK`_cursor(), C'''', tparam*{tparam <- tparam*}, `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef*{tparam <- tparam*})
    3. Let C'' = $set_blockkind(C'''', `CONTROL`_bkind())
    4. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C', param, paramIL, tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}))*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}
    5. (Let `%%%%`_paramIL(id_p, dir_p, typ_p, val_p?{val_p <- val_p?}) = paramIL)*{dir_p <- dir_p*, id_p <- id_p*, paramIL <- paramIL*, typ_p <- typ_p*, val_p? <- val_p?*}
    6. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**})
    7. Let td = `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ControlT%`_objtyp(`%%%%`_paramtyp(id_p, dir_p, typ_p, val_p?{val_p <- val_p?})*{dir_p <- dir_p*, id_p <- id_p*, typ_p <- typ_p*, val_p? <- val_p?*}) as typ) as typdef
    8. TypeDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), td)
    9. Let C''' = $add_typdef(`GLOBAL`_cursor(), C'''', id, td)
    10. Result in C''', `ControlTypeD%%%%`_declIL(id, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, paramIL*{paramIL <- paramIL*})
  1. Else If decl'' matches `ControlD%%%%%`, then
    1. Let `ControlD%%%%%`_decl(id, param*{param <- param*}, cparam*{cparam <- cparam*}, decl''*{decl'' <- decl''*}, block) = decl''
    2. Let cid = $to_fid(id, cparam*{cparam <- cparam*})
    3. Let C_1 = $set_blockkind(C'''', `CONTROL`_bkind())
    4. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_1, cparam, cparamIL, tid*))*{cparam <- cparam*, cparamIL <- cparamIL*, tid* <- tid**}
    5. If (tid* matches [])*{tid* <- tid**}, then
      1. Let C_2 = $add_params(`BLOCK`_cursor(), C_1, cparamIL*{cparamIL <- cparamIL*} as paramtyp*)
      2. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_2, param, paramIL, tid*'))*{param <- param*, paramIL <- paramIL*, tid*' <- tid*'*}
      3. If (tid*' matches [])*{tid*' <- tid*'*}, then
        1. Let funcdef_apply = `MonoFD%`_monofuncdef(`ControlApplyMethodT%`_functyp(paramIL*{paramIL <- paramIL*} as paramtyp*)) as funcdef
        2. FuncDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), funcdef_apply)
        3. Let C_3 = $add_params(`BLOCK`_cursor(), C_2, paramIL*{paramIL <- paramIL*} as paramtyp*)
        4. Decls_ok: `%%|-%:%%`(`BLOCK`_cursor(), C_3, decl''*{decl'' <- decl''*}, C_4, declIL*{declIL <- declIL*})
        5. Let C_5 = $set_localkind(C_4, `CONTROLAPPLYMETHOD`_lkind())
        6. Block_ok: `%%%%|-%:%%%`(`LOCAL`_cursor(), C_5, `CONT`_flow(), `INIT`_blkctxt(), block, C_6, f, blockIL)
        7. Let ptd = `PolyD%->%`_polytypdef(([], []), `ControlT%`_objtyp(paramIL*{paramIL <- paramIL*} as paramtyp*) as typ)
        8. Let typ = `SpecT%%`_abstyp(ptd, []) as typ
        9. Let cd = `ConsD%->%`_consdef(([], []), `ConsT%%`_constyp(cparamIL*{cparamIL <- cparamIL*} as paramtyp*, typ))
        10. ConsDef_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C''''), cd)
        11. Let C_7 = $add_consdef(`GLOBAL`_cursor(), C'''', cid, cd)
        12. Result in C_7, `ControlD%%%%%`_declIL(id, paramIL*{paramIL <- paramIL*}, cparamIL*{cparamIL <- cparamIL*}, declIL*{declIL <- declIL*}, blockIL)
  1. Else If decl'' matches `PackageTypeD%%%`, then
    1. Let `PackageTypeD%%%`_decl(id, tparam*{tparam <- tparam*}, cparam*{cparam <- cparam*}) = decl''
    2. Let cid = $to_fid(id, cparam*{cparam <- cparam*})
    3. Let C_1 = $add_typdefs(`BLOCK`_cursor(), C'''', tparam*{tparam <- tparam*}, `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef*{tparam <- tparam*})
    4. Let C_2 = $set_blockkind(C_1, `PACKAGE`_bkind())
    5. (CParam_ok: `%%|-%:%%`(`BLOCK`_cursor(), C_2, cparam, cparamIL, tid_fresh_c*{tid_fresh_c <- tid_fresh_c*}))*{cparam <- cparam*, cparamIL <- cparamIL*, tid_fresh_c* <- tid_fresh_c**}
    6. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_c*{tid_fresh_c <- tid_fresh_c*}*{tid_fresh_c* <- tid_fresh_c**})
    7. (Let `%%%%`_paramIL(_idIL, _dirIL, typ_c, _val?) = cparamIL)*{_dirIL <- _dirIL*, _idIL <- _idIL*, _val? <- _val?*, cparamIL <- cparamIL*, typ_c <- typ_c*}
    8. Let ptd = `PolyD%->%`_polytypdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `PackageT%`_objtyp(typ_c*{typ_c <- typ_c*}) as typ)
    9. TypeDef_wf: `%|-%`($bound_tids(`BLOCK`_cursor(), C_2), ptd as typdef)
    10. Let tparam'*{tparam' <- tparam'*} = tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}
    11. Let typ = `SpecT%%`_abstyp(ptd, `VarT%`_abstyp(tparam') as typ*{tparam' <- tparam'*}) as typ
    12. Let cd = `ConsD%->%`_consdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ConsT%%`_constyp(cparamIL*{cparamIL <- cparamIL*} as paramtyp*, typ))
    13. ConsDef_wf: `%|-%`($bound_tids(`BLOCK`_cursor(), C_2), cd)
    14. Let C_3 = $add_typdef(`GLOBAL`_cursor(), C'''', id, ptd as typdef)
    15. Let C_4 = $add_consdef(`GLOBAL`_cursor(), C_3, cid, cd)
    16. Result in C_4, `PackageTypeD%%%%`_declIL(id, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, cparamIL*{cparamIL <- cparamIL*})
2. Else If p' matches `BLOCK`, then
  1. If decl'' matches `TableD%%`, then
    1. Let `TableD%%`_decl(id, tbl) = decl''
    2. If (C''''.BLOCK.KIND = `CONTROL`_bkind()), then
      1. If (|$keys_of_table(tbl)| <= 1), then
        1. If (|$actions_of_table(tbl)| = 1), then
          1. Let C_1 = $set_localkind(C'''', `TABLEAPPLYMETHOD`_lkind())
          2. Table_props_ok: `%%%|-%:%%`(`LOCAL`_cursor(), C_1, $empty_tblctx, tbl, tblctx', tblIL)
          3. Table_type_decl_ok: `%%%|-%:%%`(`BLOCK`_cursor(), C_1, tblctx', id, C_2, typ_tbl)
          4. Let typ = `TableT%%`_objtyp(id, typ_tbl) as typ
          5. Type_wf: `%|-%`($bound_tids(`BLOCK`_cursor(), C_2), typ)
          6. Let C_3 = $add_styp(`BLOCK`_cursor(), C_2, id, `%%%%`_styp(typ, `NO`_dir(), `DYN`_ctk(), ?()))
          7. Result in C_3, `TableD%%%`_declIL(id, typ, tblIL)

;; ../../../../spec/4b-typing-relation.watsup:113.1-115.23
relation Decls_ok: p, C, decl*
1. If decl* matches [], then
  1. Result in C, []
1. Else
  1. Let decl_h :: decl_t*{decl_t <- decl_t*} = decl*
  2. Decl_ok: `%%|-%:%%`(p, C, decl_h, C', declIL_h)
  3. Decls_ok: `%%|-%:%%`(p, C', decl_t*{decl_t <- decl_t*}, C'', declIL_t*{declIL_t <- declIL_t*})
  4. Result in C'', declIL_h :: declIL_t*{declIL_t <- declIL_t*}

;; ../../../../spec/4b-typing-relation.watsup:119.1-121.17
relation Prog_ok: decl*{decl <- decl*}
1. Let C = $empty_context
2. Decls_ok: `%%|-%:%%`(`GLOBAL`_cursor(), C, decl*{decl <- decl*}, C', declIL*{declIL <- declIL*})
3. Result in C', declIL*{declIL <- declIL*}

;; ../../../../spec/4b-typing-relation.watsup:125.18-125.29
syntax actctxt = 
   | `ACT`()
   | `NOACT`()

;; ../../../../spec/4b-typing-relation.watsup:126.1-128.29
relation Call_convention_ok: p, C, actctxt, `%%%%`_paramtyp(id, dir, typ_p', val?{val <- val?}), (exprIL, typ_a')
1. If dir matches `IN`, then
  1. Let exprIL' = $coerce_assign(exprIL, typ_p')
  2. Result in exprIL'
2. If ((dir = `OUT`_dir()) \/ (dir = `INOUT`_dir())), then
  1. Type_alpha: `%~~%`(typ_a', typ_p')
  2. Lval_ok: `%%|-%`(p, C, exprIL)
  3. Result in exprIL
3. If actctxt matches `ACT`, then
  1. If dir matches `NO`, then
    1. Let exprIL' = $coerce_assign(exprIL, typ_p')
    2. Result in exprIL'
3. Else If actctxt matches `NOACT`, then
  1. If dir matches `NO`, then
    1. Let `(%;%)`_annotIL(_typ, ctk) = $annot(exprIL)
    2. If ((ctk = `LCTK`_ctk()) \/ (ctk = `CTK`_ctk())), then
      1. Type_alpha: `%~~%`(typ_a', typ_p')
      2. Result in exprIL

;; ../../../../spec/4b-typing-relation.watsup:129.1-131.29
relation Call_convention_arg_ok: p, C, actctxt, pt', (argIL, typ')
1. If argIL matches `ExprA%`, then
  1. Let `ExprA%`_argIL(exprIL) = argIL
  2. Call_convention_ok: `%%%|-%~~%:%`(p, C, actctxt, pt', (exprIL, typ'), exprIL')
  3. Result in `ExprA%`_argIL(exprIL')
1. Else If argIL matches `NameA%%`, then
  1. Let `NameA%%`_argIL(id, exprIL?) = argIL
  2. If exprIL? matches (_), then
    1. Let ?(exprIL) = exprIL?
    2. Call_convention_ok: `%%%|-%~~%:%`(p, C, actctxt, pt', (exprIL, typ'), exprIL')
    3. Result in `NameA%%`_argIL(id, ?(exprIL'))
2. Let `%%%%`_paramtyp(_id, dir, _typ, _val?) = pt'
3. If dir matches `OUT`, then
  1. If argIL matches `NameA%%`, then
    1. Let `NameA%%`_argIL(id, exprIL?) = argIL
    2. If exprIL? matches (), then
      1. Result in `NameA%%`_argIL(id, ?())
  1. Else If argIL matches `AnyA`, then
    1. Result in `AnyA`_argIL()

;; ../../../../spec/4b-typing-relation.watsup:137.1-139.23
relation Call_site_ok: cursor, C, functyp
1. If cursor matches `BLOCK`, then
  1. If functyp matches `ExternFuncT%%`, then
    1. Let `ExternFuncT%%`_functyp(_paramtyp*, _typ) = functyp
    2. If ((C.BLOCK.KIND = `PARSER`_bkind()) \/ (C.BLOCK.KIND = `CONTROL`_bkind())), then
      1. Result in 
  1. Else If functyp matches `BuiltinMethodT%%`, then
    1. Let `BuiltinMethodT%%`_functyp(_paramtyp*, _typ) = functyp
    2. If ((C.BLOCK.KIND = `PARSER`_bkind()) \/ (C.BLOCK.KIND = `CONTROL`_bkind())), then
      1. Result in 
  1. Else If functyp matches `ExternMethodT%%`, then
    1. Let `ExternMethodT%%`_functyp(_paramtyp*, _typ) = functyp
    2. If ((C.BLOCK.KIND = `PARSER`_bkind()) \/ (C.BLOCK.KIND = `CONTROL`_bkind())), then
      1. Result in 
  1. Else If functyp matches `ExternAbstractMethodT%%`, then
    1. Let `ExternAbstractMethodT%%`_functyp(_paramtyp*, _typ) = functyp
    2. If ((C.BLOCK.KIND = `PARSER`_bkind()) \/ (C.BLOCK.KIND = `CONTROL`_bkind())), then
      1. Result in 
1. Else If cursor matches `LOCAL`, then
  1. If functyp matches `ActionT%`, then
    1. Let `ActionT%`_functyp(_paramtyp*) = functyp
    2. If (((C.LOCAL.KIND = `ACTION`_lkind()) \/ (C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind())) \/ (C.LOCAL.KIND = `TABLEAPPLYMETHOD`_lkind())), then
      1. Result in 
  1. Else If functyp matches `FuncT%%`, then
    1. Let `FuncT%%`_functyp(_paramtyp*, _typ) = functyp
    2. Let lkind = C.LOCAL.KIND
    3. If lkind matches `FUNC%`, then
      1. Let `FUNC%`_lkind(typ) = lkind
      2. Result in 
    4. If ((((C.LOCAL.KIND = `ACTION`_lkind()) \/ (C.LOCAL.KIND = `PARSERSTATE`_lkind())) \/ (C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind())) \/ (C.LOCAL.KIND = `TABLEAPPLYMETHOD`_lkind())), then
      1. Result in 
  1. Else If functyp matches `ExternFuncT%%`, then
    1. Let `ExternFuncT%%`_functyp(_paramtyp*, _typ) = functyp
    2. Let lkind = C.LOCAL.KIND
    3. If lkind matches `EXTERNABSTRACTMETHOD%`, then
      1. Let `EXTERNABSTRACTMETHOD%`_lkind(typ) = lkind
      2. Result in 
    4. If ((((C.LOCAL.KIND = `ACTION`_lkind()) \/ (C.LOCAL.KIND = `PARSERSTATE`_lkind())) \/ (C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind())) \/ (C.LOCAL.KIND = `TABLEAPPLYMETHOD`_lkind())), then
      1. Result in 
  1. Else If functyp matches `BuiltinMethodT%%`, then
    1. Let `BuiltinMethodT%%`_functyp(_paramtyp*, _typ) = functyp
    2. Let lkind = C.LOCAL.KIND
    3. If lkind matches `FUNC%`, then
      1. Let `FUNC%`_lkind(typ) = lkind
      2. Result in 
    3. Else If lkind matches `EXTERNABSTRACTMETHOD%`, then
      1. Let `EXTERNABSTRACTMETHOD%`_lkind(typ) = lkind
      2. Result in 
    4. If ((((C.LOCAL.KIND = `ACTION`_lkind()) \/ (C.LOCAL.KIND = `PARSERSTATE`_lkind())) \/ (C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind())) \/ (C.LOCAL.KIND = `TABLEAPPLYMETHOD`_lkind())), then
      1. Result in 
  1. Else If functyp matches `ExternMethodT%%`, then
    1. Let `ExternMethodT%%`_functyp(_paramtyp*, _typ) = functyp
    2. Let lkind = C.LOCAL.KIND
    3. If lkind matches `EXTERNABSTRACTMETHOD%`, then
      1. Let `EXTERNABSTRACTMETHOD%`_lkind(typ) = lkind
      2. Result in 
    4. If ((((C.LOCAL.KIND = `ACTION`_lkind()) \/ (C.LOCAL.KIND = `PARSERSTATE`_lkind())) \/ (C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind())) \/ (C.LOCAL.KIND = `TABLEAPPLYMETHOD`_lkind())), then
      1. Result in 
  1. Else If functyp matches `ExternAbstractMethodT%%`, then
    1. Let `ExternAbstractMethodT%%`_functyp(_paramtyp*, _typ) = functyp
    2. Let lkind = C.LOCAL.KIND
    3. If lkind matches `EXTERNABSTRACTMETHOD%`, then
      1. Let `EXTERNABSTRACTMETHOD%`_lkind(typ) = lkind
      2. Result in 
    4. If ((((C.LOCAL.KIND = `ACTION`_lkind()) \/ (C.LOCAL.KIND = `PARSERSTATE`_lkind())) \/ (C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind())) \/ (C.LOCAL.KIND = `TABLEAPPLYMETHOD`_lkind())), then
      1. Result in 
  1. Else If functyp matches `ParserApplyMethodT%`, then
    1. Let `ParserApplyMethodT%`_functyp(_paramtyp*) = functyp
    2. If (C.LOCAL.KIND = `PARSERSTATE`_lkind()), then
      1. Result in 
  1. Else If functyp matches `ControlApplyMethodT%`, then
    1. Let `ControlApplyMethodT%`_functyp(_paramtyp*) = functyp
    2. If (C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind()), then
      1. Result in 
  1. Else If functyp matches `TableApplyMethodT%`, then
    1. Let `TableApplyMethodT%`_functyp(_typ) = functyp
    2. If ((C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind()) \/ (C.LOCAL.KIND = `TABLEAPPLYMETHOD`_lkind())), then
      1. Result in 

;; ../../../../spec/4b-typing-relation.watsup:140.1-142.35
relation Call_ok: p, C, tid*', functyp, targIL*', arg*', id*'
1. Let targIL*{targIL <- targIL*} = targIL*'
2. Let arg*{arg <- arg*} = arg*'
3. Let id_deft*{id_deft <- id_deft*} = id*'
4. If tid*' matches [], then
  1. If functyp matches `ActionT%`, then
    1. Let `ActionT%`_functyp(pt*{pt <- pt*}) = functyp
    2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
    3. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
    4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
      1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
      2. FuncType_wf: `%|-%`($bound_tids(p, C), `ActionT%`_functyp(pt*{pt <- pt*}))
      3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `ActionT%`_functyp(pt*{pt <- pt*}))
      4. If (~ $is_table_apply_in_action_arg(argIL))*{argIL <- argIL*}, then
        1. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `ACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
        2. Result in `VoidT`_primtyp() as typ, [], argIL*{argIL <- argIL*}
  1. Else If functyp matches `ExternFuncT%%`, then
    1. Let `ExternFuncT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
    2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
    3. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
    4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
      1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
      2. FuncType_wf: `%|-%`($bound_tids(p, C), `ExternFuncT%%`_functyp(pt*{pt <- pt*}, typ_r))
      3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `ExternFuncT%%`_functyp(pt*{pt <- pt*}, typ_r))
      4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
      5. Result in typ_r, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}
5. Let tid_fresh*{tid_fresh <- tid_fresh*} = tid*'
6. If functyp matches `ExternFuncT%%`, then
  1. Let `ExternFuncT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
  3. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
  4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
    1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
    2. Let theta = $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*})
    3. (Let targIL' = $find_map<tid, typ>(theta, tid_fresh))*{targIL' <- targIL'*, tid_fresh <- tid_fresh*}
    4. Let targIL''*{targIL'' <- targIL''*} = targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*}
    5. Let functyp' = $subst_functyp(theta, `ExternFuncT%%`_functyp(pt''*{pt'' <- pt''*}, typ_r))
    6. If functyp' matches `ExternFuncT%%`, then
      1. Let `ExternFuncT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r') = functyp'
      2. FuncType_wf: `%|-%`($bound_tids(p, C), `ExternFuncT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r'))
      3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `ExternFuncT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r'))
      4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt''', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}
      5. Result in typ_r', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}
6. Else If functyp matches `FuncT%%`, then
  1. Let `FuncT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
  3. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
  4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
    1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
    2. Let theta = $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*})
    3. (Let targIL' = $find_map<tid, typ>(theta, tid_fresh))*{targIL' <- targIL'*, tid_fresh <- tid_fresh*}
    4. Let targIL''*{targIL'' <- targIL''*} = targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*}
    5. Let functyp' = $subst_functyp(theta, `FuncT%%`_functyp(pt''*{pt'' <- pt''*}, typ_r))
    6. If functyp' matches `FuncT%%`, then
      1. Let `FuncT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r') = functyp'
      2. FuncType_wf: `%|-%`($bound_tids(p, C), `FuncT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r'))
      3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `FuncT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r'))
      4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt''', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}
      5. Result in typ_r', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}
6. Else If functyp matches `ExternMethodT%%`, then
  1. Let `ExternMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
  3. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
  4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
    1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
    2. Let theta = $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*})
    3. (Let targIL' = $find_map<tid, typ>(theta, tid_fresh))*{targIL' <- targIL'*, tid_fresh <- tid_fresh*}
    4. Let targIL''*{targIL'' <- targIL''*} = targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*}
    5. Let functyp' = $subst_functyp(theta, `ExternMethodT%%`_functyp(pt''*{pt'' <- pt''*}, typ_r))
    6. If functyp' matches `ExternMethodT%%`, then
      1. Let `ExternMethodT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r') = functyp'
      2. FuncType_wf: `%|-%`($bound_tids(p, C), `ExternMethodT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r'))
      3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `ExternMethodT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r'))
      4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt''', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}
      5. Result in typ_r', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}
6. Else If functyp matches `ExternAbstractMethodT%%`, then
  1. Let `ExternAbstractMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
  2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
  3. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
  4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
    1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
    2. Let theta = $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*})
    3. (Let targIL' = $find_map<tid, typ>(theta, tid_fresh))*{targIL' <- targIL'*, tid_fresh <- tid_fresh*}
    4. Let targIL''*{targIL'' <- targIL''*} = targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*}
    5. Let functyp' = $subst_functyp(theta, `ExternAbstractMethodT%%`_functyp(pt''*{pt'' <- pt''*}, typ_r))
    6. If functyp' matches `ExternAbstractMethodT%%`, then
      1. Let `ExternAbstractMethodT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r') = functyp'
      2. FuncType_wf: `%|-%`($bound_tids(p, C), `ExternAbstractMethodT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r'))
      3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `ExternAbstractMethodT%%`_functyp(pt'''*{pt''' <- pt'''*}, typ_r'))
      4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt''', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}
      5. Result in typ_r', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}
7. If tid*' matches [], then
  1. If functyp matches `FuncT%%`, then
    1. Let `FuncT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
    2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
    3. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
    4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
      1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
      2. FuncType_wf: `%|-%`($bound_tids(p, C), `FuncT%%`_functyp(pt*{pt <- pt*}, typ_r))
      3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `FuncT%%`_functyp(pt*{pt <- pt*}, typ_r))
      4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
      5. Result in typ_r, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}
  1. Else If functyp matches `BuiltinMethodT%%`, then
    1. Let `BuiltinMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
    2. If targIL*' matches [], then
      1. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
      2. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
      3. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
        1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
        2. FuncType_wf: `%|-%`($bound_tids(p, C), `BuiltinMethodT%%`_functyp(pt*{pt <- pt*}, typ_r))
        3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `BuiltinMethodT%%`_functyp(pt*{pt <- pt*}, typ_r))
        4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
        5. Result in typ_r, [], argIL''*{argIL'' <- argIL''*}
  1. Else If functyp matches `ExternMethodT%%`, then
    1. Let `ExternMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
    2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
    3. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
    4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
      1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
      2. FuncType_wf: `%|-%`($bound_tids(p, C), `ExternMethodT%%`_functyp(pt*{pt <- pt*}, typ_r))
      3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `ExternMethodT%%`_functyp(pt*{pt <- pt*}, typ_r))
      4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
      5. Result in typ_r, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}
  1. Else If functyp matches `ExternAbstractMethodT%%`, then
    1. Let `ExternAbstractMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
    2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
    3. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
    4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
      1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
      2. FuncType_wf: `%|-%`($bound_tids(p, C), `ExternAbstractMethodT%%`_functyp(pt*{pt <- pt*}, typ_r))
      3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `ExternAbstractMethodT%%`_functyp(pt*{pt <- pt*}, typ_r))
      4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
      5. Result in typ_r, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}
  1. Else If functyp matches `ParserApplyMethodT%`, then
    1. Let `ParserApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
    2. If targIL*' matches [], then
      1. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
      2. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
      3. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
        1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
        2. FuncType_wf: `%|-%`($bound_tids(p, C), `ParserApplyMethodT%`_functyp(pt*{pt <- pt*}))
        3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `ParserApplyMethodT%`_functyp(pt*{pt <- pt*}))
        4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
        5. Result in `VoidT`_primtyp() as typ, [], argIL''*{argIL'' <- argIL''*}
  1. Else If functyp matches `ControlApplyMethodT%`, then
    1. Let `ControlApplyMethodT%`_functyp(pt*{pt <- pt*}) = functyp
    2. If targIL*' matches [], then
      1. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
      2. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
      3. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
        1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
        2. FuncType_wf: `%|-%`($bound_tids(p, C), `ControlApplyMethodT%`_functyp(pt*{pt <- pt*}))
        3. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `ControlApplyMethodT%`_functyp(pt*{pt <- pt*}))
        4. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `NOACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
        5. Result in `VoidT`_primtyp() as typ, [], argIL''*{argIL'' <- argIL''*}
  1. Else If functyp matches `TableApplyMethodT%`, then
    1. Let `TableApplyMethodT%`_functyp(typ_r) = functyp
    2. If targIL*' matches [], then
      1. If arg*' matches [], then
        1. If id*' matches [], then
          1. FuncType_wf: `%|-%`($bound_tids(p, C), `TableApplyMethodT%`_functyp(typ_r))
          2. Call_site_ok: `%%|-%:CALLSITE_OK`(p, C, `TableApplyMethodT%`_functyp(typ_r))
          3. Result in typ_r, [], []

;; ../../../../spec/4b-typing-relation.watsup:147.1-149.29
relation FuncType_ok: p, C, name, targIL*{targIL <- targIL*}, arg*{arg <- arg*}
1. Let (fid, fd, id_deft*{id_deft <- id_deft*}) = $find_funcdef(p, C, name, arg*{arg <- arg*})
2. Let (ft, tid_fresh*{tid_fresh <- tid_fresh*}) = $specialize_funcdef(fd, targIL*{targIL <- targIL*})
3. Result in ft, tid_fresh*{tid_fresh <- tid_fresh*}, id_deft*{id_deft <- id_deft*}

;; ../../../../spec/4b-typing-relation.watsup:150.1-152.32
relation MethodType_ok: p, C, expr_b, member', targIL*', arg*'
1. If targIL*' matches [], then
  1. If arg*' matches [], then
    1. Expr_ok: `%%|-%:%`(p, C, expr_b, exprIL_b)
    2. If $in_set<member>(member', `SET%`_set<member>(["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])), then
      1. Result in `BuiltinMethodT%%`_functyp([], `IntT`_numtyp() as typ), exprIL_b, [], []
2. Let arg*{arg <- arg*} = arg*'
3. If targIL*' matches [], then
  1. If ((member' = "push_front") \/ (member' = "pop_front")), then
    1. Expr_ok: `%%|-%:%`(p, C, expr_b, exprIL_b)
    2. Let `(%;%)`_annotIL(typ_b, _ctk) = $annot(exprIL_b)
    3. Let typ = $canon_typ(typ_b)
    4. If typ <: datatyp, then
      1. Let datatyp = typ as datatyp
      2. If datatyp matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_b_in, int_b) = datatyp
        2. Let pt = `%%%%`_paramtyp("count", `NO`_dir(), `IntT`_numtyp() as typ, ?())
        3. Result in `BuiltinMethodT%%`_functyp([pt], `IntT`_numtyp() as typ), exprIL_b, [], []
  2. If ((member' = "setValid") \/ (member' = "setInvalid")), then
    1. Expr_ok: `%%|-%:%`(p, C, expr_b, exprIL_b)
    2. Let `(%;%)`_annotIL(typ_b, _ctk) = $annot(exprIL_b)
    3. Let typ = $canon_typ(typ_b)
    4. If typ <: datatyp, then
      1. Let datatyp = typ as datatyp
      2. If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(id_b, (member_b, typ_b_in)*{member_b <- member_b*, typ_b_in <- typ_b_in*}) = datatyp
        2. Result in `BuiltinMethodT%%`_functyp([], `VoidT`_primtyp() as typ), exprIL_b, [], []
4. If (member' = "isValid"), then
  1. If targIL*' matches [], then
    1. Expr_ok: `%%|-%:%`(p, C, expr_b, exprIL_b)
    2. Let `(%;%)`_annotIL(typ_b, _ctk) = $annot(exprIL_b)
    3. Let typ = $canon_typ(typ_b)
    4. If typ <: datatyp, then
      1. Let datatyp = typ as datatyp
      2. If datatyp matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(id_b, (member', typ_b_in)*{member' <- member'*, typ_b_in <- typ_b_in*}) = datatyp
        2. Result in `BuiltinMethodT%%`_functyp([], `BoolT`_primtyp() as typ), exprIL_b, [], []
      2. Else If datatyp matches `UnionT%%`, then
        1. Let `UnionT%%`_datatyp(id_b, (member', typ_b_in)*{member' <- member'*, typ_b_in <- typ_b_in*}) = datatyp
        2. Result in `BuiltinMethodT%%`_functyp([], `BoolT`_primtyp() as typ), exprIL_b, [], []
5. Let targIL*{targIL <- targIL*} = targIL*'
6. Expr_ok: `%%|-%:%`(p, C, expr_b, exprIL_b)
7. Let `(%;%)`_annotIL(typ_b, _ctk) = $annot(exprIL_b)
8. Let typ = $canon_typ(typ_b)
9. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(id_b, fmap_b) = objtyp
    2. Let (fid, fd, id_deft*{id_deft <- id_deft*}) = $find_func<funcdef>(member', $to_fkey(arg*{arg <- arg*}), fmap_b)
    3. Let (ft, tid_fresh*{tid_fresh <- tid_fresh*}) = $specialize_funcdef(fd, targIL*{targIL <- targIL*})
    4. Result in ft, exprIL_b, tid_fresh*{tid_fresh <- tid_fresh*}, id_deft*{id_deft <- id_deft*}
10. If (member' = "apply"), then
  1. If targIL*' matches [], then
    1. If typ <: objtyp, then
      1. Let objtyp = typ as objtyp
      2. If objtyp matches `ParserT%`, then
        1. Let `ParserT%`_objtyp(pt*{pt <- pt*}) = objtyp
        2. Let ft = `ParserApplyMethodT%`_functyp(pt*{pt <- pt*})
        3. Let fd = `MonoFD%`_monofuncdef(ft) as funcdef
        4. (Let `%%%%`_paramtyp(id_p, _dir, _typ, val_deft?{val_deft <- val_deft?}) = pt)*{_dir <- _dir*, _typ <- _typ*, id_p <- id_p*, pt <- pt*, val_deft? <- val_deft?*}
        5. (Let b_deft = (val_deft?{val_deft <- val_deft?} =/= ?()))*{b_deft <- b_deft*, val_deft? <- val_deft?*}
        6. Let fid = `%%`_fid("apply", (id_p, b_deft)*{b_deft <- b_deft*, id_p <- id_p*})
        7. Let (fid', funcdef, id_deft*{id_deft <- id_deft*}) = $find_func<funcdef>("apply", $to_fkey(arg*{arg <- arg*}), `MAP%`_map<fid, funcdef>([`PAIR%%`_pair<fid, funcdef>(fid, fd)]))
        8. If (fid' = fid), then
          1. If (funcdef = `MonoFD%`_monofuncdef(ft) as funcdef), then
            1. Result in ft, exprIL_b, [], id_deft*{id_deft <- id_deft*}
      2. Else If objtyp matches `ControlT%`, then
        1. Let `ControlT%`_objtyp(pt*{pt <- pt*}) = objtyp
        2. Let ft = `ControlApplyMethodT%`_functyp(pt*{pt <- pt*})
        3. Let fd = `MonoFD%`_monofuncdef(ft) as funcdef
        4. (Let `%%%%`_paramtyp(id_p, _dir, _typ, val_deft?{val_deft <- val_deft?}) = pt)*{_dir <- _dir*, _typ <- _typ*, id_p <- id_p*, pt <- pt*, val_deft? <- val_deft?*}
        5. (Let b_deft = (val_deft?{val_deft <- val_deft?} =/= ?()))*{b_deft <- b_deft*, val_deft? <- val_deft?*}
        6. Let fid = `%%`_fid("apply", (id_p, b_deft)*{b_deft <- b_deft*, id_p <- id_p*})
        7. Let (fid', funcdef, id_deft*{id_deft <- id_deft*}) = $find_func<funcdef>("apply", $to_fkey(arg*{arg <- arg*}), `MAP%`_map<fid, funcdef>([`PAIR%%`_pair<fid, funcdef>(fid, fd)]))
        8. If (fid' = fid), then
          1. If (funcdef = `MonoFD%`_monofuncdef(ft) as funcdef), then
            1. Result in ft, exprIL_b, [], id_deft*{id_deft <- id_deft*}
    2. If arg*' matches [], then
      1. If typ <: objtyp, then
        1. Let objtyp = typ as objtyp
        2. If objtyp matches `TableT%%`, then
          1. Let `TableT%%`_objtyp(id, typ_t) = objtyp
          2. Let functyp = `TableApplyMethodT%`_functyp(typ_t)
          3. Result in functyp, exprIL_b, [], []

;; ../../../../spec/4b-typing-relation.watsup:157.1-159.29
relation ConsType_ok: p, C, name, targIL*{targIL <- targIL*}, arg*{arg <- arg*}
1. Let (cid, cd, id_deft*{id_deft <- id_deft*}) = $find_consdef(`GLOBAL`_cursor(), C, name, arg*{arg <- arg*})
2. Let (ct, tid_fresh*{tid_fresh <- tid_fresh*}) = $specialize_consdef(cd, targIL*{targIL <- targIL*})
3. Result in ct, tid_fresh*{tid_fresh <- tid_fresh*}, id_deft*{id_deft <- id_deft*}

;; ../../../../spec/4b-typing-relation.watsup:165.1-167.23
relation Inst_site_ok: cursor, C, `ConsT%%`_constyp(pt*{pt <- pt*}, typ_i)
1. If cursor matches `GLOBAL`, then
  1. Let typ_i' = $canon_typ(typ_i)
  2. If ($is_externt(typ_i') \/ $is_packaget(typ_i')), then
    1. Result in 
1. Else If cursor matches `BLOCK`, then
  1. Let typ_i' = $canon_typ(typ_i)
  2. If (C.BLOCK.KIND = `PACKAGE`_bkind()), then
    1. If ((($is_externt(typ_i') \/ $is_parsert(typ_i')) \/ $is_controlt(typ_i')) \/ $is_packaget(typ_i')), then
      1. Result in 
  3. If (C.BLOCK.KIND = `PARSER`_bkind()), then
    1. If ($is_externt(typ_i') \/ $is_parsert(typ_i')), then
      1. Result in 
  4. If (C.BLOCK.KIND = `CONTROL`_bkind()), then
    1. If (($is_externt(typ_i') \/ $is_controlt(typ_i')) \/ $is_tablet(typ_i')), then
      1. Result in 
1. Else If cursor matches `LOCAL`, then
  1. Let typ_i' = $canon_typ(typ_i)
  2. If (C.LOCAL.KIND = `PARSERSTATE`_lkind()), then
    1. If ($is_externt(typ_i') \/ $is_parsert(typ_i')), then
      1. Result in 
  3. If (C.LOCAL.KIND = `CONTROLAPPLYMETHOD`_lkind()), then
    1. If ($is_externt(typ_i') \/ $is_controlt(typ_i')), then
      1. Result in 

;; ../../../../spec/4b-typing-relation.watsup:168.1-170.35
relation Inst_ok: cursor', C_0', tid*', ct, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft*{id_deft <- id_deft*}
1. If cursor' matches `GLOBAL`, then
  1. If tid*' matches [], then
    1. Let `ConsT%%`_constyp(pt*{pt <- pt*}, typ_i) = ct
    2. If $is_packaget($canon_typ(typ_i)), then
      1. Let C_1 = $set_blockkind(C_0', `PACKAGE`_bkind())
      2. (Arg_ok: `%%|-%:%%`(`BLOCK`_cursor(), C_1, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
      3. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
      4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
        1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
        2. ConsType_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C_0'), `ConsT%%`_constyp(pt*{pt <- pt*}, typ_i))
        3. Inst_site_ok: `%%|-%:INSTSITE_OK`(`GLOBAL`_cursor(), C_0', `ConsT%%`_constyp(pt*{pt <- pt*}, typ_i))
        4. (Call_convention_arg_ok: `%%%|-%~~%:%`(`BLOCK`_cursor(), C_1, `NOACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
        5. Result in typ_i, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}
2. Let tid_fresh*{tid_fresh <- tid_fresh*} = tid*'
3. If cursor' matches `GLOBAL`, then
  1. Let `ConsT%%`_constyp(pt*{pt <- pt*}, typ_i) = ct
  2. If $is_packaget($canon_typ(typ_i)), then
    1. If (|tid_fresh*{tid_fresh <- tid_fresh*}| > 0), then
      1. Let C_1 = $set_blockkind(C_0', `PACKAGE`_bkind())
      2. (Arg_ok: `%%|-%:%%`(`BLOCK`_cursor(), C_1, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
      3. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
      4. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
        1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
        2. Let theta = $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*})
        3. (Let targIL' = $find_map<tid, typ>(theta, tid_fresh))*{targIL' <- targIL'*, tid_fresh <- tid_fresh*}
        4. Let targIL''*{targIL'' <- targIL''*} = targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*}
        5. Let `ConsT%%`_constyp(pt'''*{pt''' <- pt'''*}, typ_i') = $subst_constyp(theta, `ConsT%%`_constyp(pt''*{pt'' <- pt''*}, typ_i))
        6. ConsType_wf: `%|-%`($bound_tids(`GLOBAL`_cursor(), C_0'), `ConsT%%`_constyp(pt'''*{pt''' <- pt'''*}, typ_i'))
        7. Inst_site_ok: `%%|-%:INSTSITE_OK`(`GLOBAL`_cursor(), C_0', `ConsT%%`_constyp(pt'''*{pt''' <- pt'''*}, typ_i'))
        8. (Call_convention_arg_ok: `%%%|-%~~%:%`(`BLOCK`_cursor(), C_1, `NOACT`_actctxt(), pt''', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}
        9. Result in typ_i', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}
4. If tid*' matches [], then
  1. Let `ConsT%%`_constyp(pt*{pt <- pt*}, typ_i) = ct
  2. If ~ ((cursor' = `GLOBAL`_cursor()) /\ $is_packaget($canon_typ(typ_i))), then
    1. (Arg_ok: `%%|-%:%%`(cursor', C_0', arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
    2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
    3. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
      1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
      2. ConsType_wf: `%|-%`($bound_tids(cursor', C_0'), `ConsT%%`_constyp(pt*{pt <- pt*}, typ_i))
      3. Inst_site_ok: `%%|-%:INSTSITE_OK`(cursor', C_0', `ConsT%%`_constyp(pt*{pt <- pt*}, typ_i))
      4. (Call_convention_arg_ok: `%%%|-%~~%:%`(cursor', C_0', `NOACT`_actctxt(), pt'', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}
      5. Result in typ_i, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}
5. Let `ConsT%%`_constyp(pt*{pt <- pt*}, typ_i) = ct
6. If ~ ((cursor' = `GLOBAL`_cursor()) /\ $is_packaget($canon_typ(typ_i))), then
  1. (Arg_ok: `%%|-%:%%`(cursor', C_0', arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
  2. Let pt'*{pt' <- pt'*} = $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*})
  3. If (|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|), then
    1. Let pt''*{pt'' <- pt''*} = $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*})
    2. Let theta = $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*})
    3. (Let targIL' = $find_map<tid, typ>(theta, tid_fresh))*{targIL' <- targIL'*, tid_fresh <- tid_fresh*}
    4. Let targIL''*{targIL'' <- targIL''*} = targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*}
    5. Let `ConsT%%`_constyp(pt'''*{pt''' <- pt'''*}, typ_i') = $subst_constyp(theta, `ConsT%%`_constyp(pt''*{pt'' <- pt''*}, typ_i))
    6. ConsType_wf: `%|-%`($bound_tids(cursor', C_0'), `ConsT%%`_constyp(pt'''*{pt''' <- pt'''*}, typ_i'))
    7. Inst_site_ok: `%%|-%:INSTSITE_OK`(cursor', C_0', `ConsT%%`_constyp(pt'''*{pt''' <- pt'''*}, typ_i'))
    8. (Call_convention_arg_ok: `%%%|-%~~%:%`(cursor', C_0', `NOACT`_actctxt(), pt''', (argIL, typ_a), argIL''))*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}
    9. Result in typ_i', targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}

;; ../../../../spec/4d2-typing-subtyping.watsup:298.1-299.34
def $reduce_senum_unary(exprIL, $check_unary)
1. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
2. If $check_unary(typ), then
  1. Return exprIL
3. Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL)
4. If ~ $check_unary(typ), then
  1. Let typ'' = typ
  2. If typ'' <: datatyp, then
    1. Let datatyp = typ'' as datatyp
    2. If datatyp matches `SEnumT%%%`, then
      1. Let `SEnumT%%%`_datatyp(_id, typ', _(member, val)*) = datatyp
      2. Let exprIL' = `CastE%%%`_exprIL(typ', exprIL, `(%;%)`_annotIL(typ', ctk))
      3. Let exprIL'' = $reduce_senum_unary(exprIL', $check_unary)
      4. Return exprIL''

;; ../../../../spec/4d2-typing-subtyping.watsup:313.1-314.41
def $reduce_senums_binary(exprIL_a, exprIL_b, $check_binary)
1. Let `(%;%)`_annotIL(typ_a, _ctk) = $annot(exprIL_a)
2. Let `(%;%)`_annotIL(typ_b, _ctk') = $annot(exprIL_b)
3. If $check_binary(typ_a, typ_b), then
  1. Return (exprIL_a, exprIL_b)
4. Let `(%;%)`_annotIL(typ_a, ctk_a) = $annot(exprIL_a)
5. Let `(%;%)`_annotIL(typ_b, _ctk) = $annot(exprIL_b)
6. If ~ $check_binary(typ_a, typ_b), then
  1. Let typ = typ_a
  2. If typ <: datatyp, then
    1. Let datatyp = typ as datatyp
    2. If datatyp matches `SEnumT%%%`, then
      1. Let `SEnumT%%%`_datatyp(_id, typ_a', _(member, val)*) = datatyp
      2. Let exprIL_a' = `CastE%%%`_exprIL(typ_a', exprIL_a, `(%;%)`_annotIL(typ_a', ctk_a))
      3. Let (exprIL_a'', exprIL_b'') = $reduce_senums_binary(exprIL_a', exprIL_b, $check_binary)
      4. Return (exprIL_a'', exprIL_b'')
7. Let `(%;%)`_annotIL(typ_b, ctk_b) = $annot(exprIL_b)
8. If ~ $check_binary(typ_a, typ_b), then
  1. Let typ = typ_b
  2. If typ <: datatyp, then
    1. Let datatyp = typ as datatyp
    2. If datatyp matches `SEnumT%%%`, then
      1. Let `SEnumT%%%`_datatyp(_id, typ_b', _(member, val)*) = datatyp
      2. Let exprIL_b' = `CastE%%%`_exprIL(typ_b', exprIL_b, `(%;%)`_annotIL(typ_b', ctk_b))
      3. Let (exprIL_a'', exprIL_b'') = $reduce_senums_binary(exprIL_a, exprIL_b', $check_binary)
      4. Return (exprIL_a'', exprIL_b'')

;; ../../../../spec/4d2-typing-subtyping.watsup:339.1-340.32
def $coerce_binary(exprIL_a, exprIL_b)
1. Let `(%;%)`_annotIL(typ_a, _ctk) = $annot(exprIL_a)
2. Let `(%;%)`_annotIL(typ_b, _ctk') = $annot(exprIL_b)
3. Type_alpha: `%~~%`(typ_a, typ_b)
4. Return (exprIL_a, exprIL_b)
5. Let `(%;%)`_annotIL(typ_a, ctk_a) = $annot(exprIL_a)
6. Let `(%;%)`_annotIL(typ_b, _ctk) = $annot(exprIL_b)
7. If ~ Type_alpha: `%~~%`(typ_a, typ_b) holds, then
  1. Sub_impl: `%<<%`(typ_a, typ_b)
  2. Let exprIL_a' = `CastE%%%`_exprIL(typ_b, exprIL_a, `(%;%)`_annotIL(typ_b, ctk_a))
  3. Return (exprIL_a', exprIL_b)
8. Let `(%;%)`_annotIL(typ_b, ctk_b) = $annot(exprIL_b)
9. If ~ Type_alpha: `%~~%`(typ_a, typ_b) holds, then
  1. If ~ Sub_impl: `%<<%`(typ_a, typ_b) holds, then
    1. Sub_impl: `%<<%`(typ_b, typ_a)
    2. Let exprIL_b' = `CastE%%%`_exprIL(typ_a, exprIL_b, `(%;%)`_annotIL(typ_a, ctk_b))
    3. Return (exprIL_a, exprIL_b')

;; ../../../../spec/4d2-typing-subtyping.watsup:363.1-364.31
def $coerce_assign(exprIL, typ_t)
1. Let `(%;%)`_annotIL(typ_f, _ctk) = $annot(exprIL)
2. Type_alpha: `%~~%`(typ_f, typ_t)
3. Return exprIL
4. Let `(%;%)`_annotIL(typ_f, ctk_f) = $annot(exprIL)
5. If ~ Type_alpha: `%~~%`(typ_f, typ_t) holds, then
  1. Sub_impl: `%<<%`(typ_f, typ_t)
  2. Return `CastE%%%`_exprIL(typ_t, exprIL, `(%;%)`_annotIL(typ_t, ctk_f))

;; ../../../../spec/4e-typing-expr.watsup:88.1-88.33
def $compatible_bnot(typ)
1. Return $compatible'_bnot($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:89.1-89.34
def $compatible'_bnot(typ)
1. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:103.1-103.33
def $compatible_lnot(typ)
1. Return $compatible'_lnot($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:104.1-104.34
def $compatible'_lnot(typ)
1. If (typ = `BoolT`_primtyp() as typ), then
  1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:117.1-117.34
def $compatible_uplus(typ)
1. Return $compatible'_uplus($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:118.1-118.35
def $compatible'_uplus(typ)
1. If (typ = `IntT`_numtyp() as typ), then
  1. Return true
2. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:133.1-133.35
def $compatible_uminus(typ)
1. Return $compatible'_uminus($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:134.1-134.36
def $compatible'_uminus(typ)
1. If (typ = `IntT`_numtyp() as typ), then
  1. Return true
2. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:153.1-153.47
def $compatible_plusminusmult(typ_l, typ_r)
1. Return $compatible'_plusminusmult($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:154.1-154.48
def $compatible'_plusminusmult(typ'', typ''')
1. If (typ'' = `IntT`_numtyp() as typ), then
  1. If (typ''' = `IntT`_numtyp() as typ), then
    1. Return true
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:179.1-179.46
def $compatible_satplusminus(typ_l, typ_r)
1. Return $compatible'_satplusminus($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:180.1-180.47
def $compatible'_satplusminus(typ'', typ''')
1. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:204.1-204.40
def $compatible_divmod(typ_l, typ_r)
1. Return $compatible'_divmod($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:205.1-205.41
def $compatible'_divmod(typ'', typ''')
1. If (typ'' = `IntT`_numtyp() as typ), then
  1. If (typ''' = `IntT`_numtyp() as typ), then
    1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:249.1-249.39
def $compatible_shift(typ_l, typ_r)
1. Return $compatible'_shift($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:250.1-250.40
def $compatible'_shift(typ'', typ''')
1. If (typ'' = `IntT`_numtyp() as typ), then
  1. If (typ''' = `IntT`_numtyp() as typ), then
    1. Return true
  2. If typ''' <: numtyp, then
    1. Let numtyp = typ''' as numtyp
    2. If numtyp matches `FIntT%`, then
      1. Let `FIntT%`_numtyp(_width) = numtyp
      2. Return true
    2. Else If numtyp matches `FBitT%`, then
      1. Let `FBitT%`_numtyp(_width) = numtyp
      2. Return true
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. If (typ''' = `IntT`_numtyp() as typ), then
      1. Return true
    3. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(_width') = numtyp'
        2. Return true
      2. Else If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(_width') = numtyp'
        2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. If (typ''' = `IntT`_numtyp() as typ), then
      1. Return true
    3. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(_width') = numtyp'
        2. Return true
      2. Else If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(_width') = numtyp'
        2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:296.1-296.41
def $compatible_compare(typ_l, typ_r)
1. Return $compatible'_compare($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:297.1-297.42
def $compatible'_compare(typ'', typ''')
1. If (typ'' = `IntT`_numtyp() as typ), then
  1. If (typ''' = `IntT`_numtyp() as typ), then
    1. Return true
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:322.1-322.41
def $compatible_bitwise(typ_l, typ_r)
1. Return $compatible'_bitwise($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:323.1-323.42
def $compatible'_bitwise(typ'', typ''')
1. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:347.1-347.40
def $compatible_concat(typ_l, typ_r)
1. Return $compatible'_concat($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:348.1-348.41
def $compatible'_concat(typ'', typ''')
1. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(_width') = numtyp'
        2. Return true
      2. Else If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(_width') = numtyp'
        2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(_width') = numtyp'
        2. Return true
      2. Else If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(_width') = numtyp'
        2. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:391.1-391.41
def $compatible_logical(typ_l, typ_r)
1. Return $compatible'_logical($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:392.1-392.42
def $compatible'_logical(typ'', typ''')
1. If (typ'' = `BoolT`_primtyp() as typ), then
  1. If (typ''' = `BoolT`_primtyp() as typ), then
    1. Return true
2. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:453.1-453.38
def $compatible_mask(typ_l, typ_r)
1. Return $compatible'_mask($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:454.1-454.39
def $compatible'_mask(typ'', typ''')
1. If (typ'' = `IntT`_numtyp() as typ), then
  1. If (typ''' = `IntT`_numtyp() as typ), then
    1. Return true
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:481.1-481.39
def $compatible_range(typ_l, typ_r)
1. Return $compatible'_range($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:482.1-482.40
def $compatible'_range(typ'', typ''')
1. If (typ'' = `IntT`_numtyp() as typ), then
  1. If (typ''' = `IntT`_numtyp() as typ), then
    1. Return true
2. If typ'' <: numtyp, then
  1. Let numtyp = typ'' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FIntT%`, then
        1. Let `FIntT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. If typ''' <: numtyp, then
      1. Let numtyp' = typ''' as numtyp
      2. If numtyp' matches `FBitT%`, then
        1. Let `FBitT%`_numtyp(nat) = numtyp'
        2. If (w = nat), then
          1. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:508.1-510.26
relation Select_case_keyset_ok: cursor, C, typ_k, keyset
1. If cursor matches `LOCAL`, then
  1. If keyset matches `ExprK%`, then
    1. Let `ExprK%`_keyset(expr) = keyset
    2. Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), C, expr, exprIL)
    3. Let `(%;%)`_annotIL(typ', _ctk) = $annot(exprIL)
    4. If typ' <: synthtyp, then
      1. Let synthtyp = typ' as synthtyp
      2. If synthtyp matches `SetT%`, then
        1. Let `SetT%`_synthtyp(typ) = synthtyp
        2. Type_alpha: `%~~%`(typ, typ_k)
        3. Result in `ExprK%`_keysetIL(exprIL)
        4. If ~ Type_alpha: `%~~%`(typ, typ_k) holds, then
          1. Sub_impl: `%<<%`(typ, typ_k)
          2. Let exprIL' = `CastE%%%`_exprIL(`SetT%`_synthtyp(typ_k) as typeIL, exprIL, `(%;%)`_annotIL(`SetT%`_synthtyp(typ_k) as typ, `DYN`_ctk()))
          3. Result in `ExprK%`_keysetIL(exprIL')
    5. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
    6. Sub_impl: `%<<%`(typ, typ_k)
    7. Let exprIL' = `CastE%%%`_exprIL(`SetT%`_synthtyp(typ_k) as typeIL, exprIL, `(%;%)`_annotIL(`SetT%`_synthtyp(typ_k) as typ, `DYN`_ctk()))
    8. Result in `ExprK%`_keysetIL(exprIL')
  1. Else If keyset matches `DefaultK`, then
    1. Result in `DefaultK`_keysetIL()
  1. Else If keyset matches `AnyK`, then
    1. Result in `AnyK`_keysetIL()

;; ../../../../spec/4e-typing-expr.watsup:543.1-545.26
relation Select_case_keysets_ok: p, C, typ*', keyset*'
1. If typ*' matches [ _/1 ], then
  1. Let [typ_k] = typ*'
  2. If keyset*' matches [ _/1 ], then
    1. Let [keyset] = keyset*'
    2. Select_case_keyset_ok: `%%%|-%:%`(p, C, typ_k, keyset, keysetIL)
    3. Result in [keysetIL]
2. Let typ_k*{typ_k <- typ_k*} = typ*'
3. If keyset*' matches [ _/1 ], then
  1. Let [keyset] = keyset*'
  2. Select_case_keyset_ok: `%%%|-%:%`(p, C, `SeqT%`_synthtyp(typ_k*{typ_k <- typ_k*}) as typ, keyset, keysetIL)
  3. Result in [keysetIL]
4. Let keyset*{keyset <- keyset*} = keyset*'
5. If (|typ_k*{typ_k <- typ_k*}| = |keyset*{keyset <- keyset*}|), then
  1. (Select_case_keyset_ok: `%%%|-%:%`(p, C, typ_k, keyset, keysetIL))*{keyset <- keyset*, keysetIL <- keysetIL*, typ_k <- typ_k*}
  2. Result in keysetIL*{keysetIL <- keysetIL*}

;; ../../../../spec/4e-typing-expr.watsup:561.1-563.26
relation Select_case_ok: cursor, C, typ_k*{typ_k <- typ_k*}, `%%`_selectcase(keyset*{keyset <- keyset*}, statelabel)
1. If cursor matches `LOCAL`, then
  1. Select_case_keysets_ok: `%%|-%%:%`(`LOCAL`_cursor(), C, typ_k*{typ_k <- typ_k*}, keyset*{keyset <- keyset*}, keysetIL*{keysetIL <- keysetIL*})
  2. Let `%%%%`_styp(typ, dir'', ctk'', val?) = $find_styp(`LOCAL`_cursor(), C, `CURRENT%`_name(statelabel))
  3. If (typ = `StateT`_synthtyp() as typ), then
    1. If val? matches (), then
      1. Result in `%%`_selectcaseIL(keysetIL*{keysetIL <- keysetIL*}, statelabel)

;; ../../../../spec/4e-typing-expr.watsup:585.1-585.39
def $compatible_arrayindex(typ)
1. Return $compatible'_arrayindex($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:586.1-586.40
def $compatible'_arrayindex(typ)
1. If (typ = `IntT`_numtyp() as typ), then
  1. Return true
2. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:642.1-642.42
def $compatible_bitstringbase(typ)
1. Return $compatible'_bitstringbase($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:643.1-643.43
def $compatible'_bitstringbase(typ)
1. If (typ = `IntT`_numtyp() as typ), then
  1. Return true
2. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. Return (w > 0)
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:652.1-652.43
def $compatible_bitstringindex(typ)
1. Return $compatible'_bitstringindex($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:653.1-653.44
def $compatible'_bitstringindex(typ)
1. If (typ = `IntT`_numtyp() as typ), then
  1. Return true
2. If typ <: numtyp, then
  1. Let numtyp = typ as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(_width) = numtyp
    2. Return true
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(_width) = numtyp
    2. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:662.1-662.52
def $is_valid_bitstring_slice(typ, n_l, n_h)
1. Return ((n_l <= n_h) /\ $is_valid_bitstring_slice'($canon_typ(typ), n_l, n_h))

;; ../../../../spec/4e-typing-expr.watsup:663.1-663.53
def $is_valid_bitstring_slice'(typ', _nat'', _nat''')
1. If (typ' = `IntT`_numtyp() as typ), then
  1. Return true
2. If typ' <: numtyp, then
  1. Let numtyp = typ' as numtyp
  2. If numtyp matches `FIntT%`, then
    1. Let `FIntT%`_numtyp(w) = numtyp
    2. Let w_slice = ((_nat''' - _nat'') + 1)
    3. Return ((_nat''' <= w) /\ (w_slice <= w))
  2. Else If numtyp matches `FBitT%`, then
    1. Let `FBitT%`_numtyp(w) = numtyp
    2. Let w_slice = ((_nat''' - _nat'') + 1)
    3. Return ((_nat''' <= w) /\ (w_slice <= w))
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:855.1-855.44
def $not_abstract_extern_object(typ)
1. Return $not_abstract_extern_object'($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:856.1-856.45
def $not_abstract_extern_object'(typ)
1. If ~ $is_externt(typ), then
  1. Return true
2. If typ <: objtyp, then
  1. Let objtyp = typ as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(_id, fmap) = objtyp
    2. Let `SET%`_set<fid>(fid*{fid <- fid*}) = $dom_map<fid, funcdef>(fmap)
    3. (Let fd = $find_map<fid, funcdef>(fmap, fid))*{fd <- fd*, fid <- fid*}
    4. If ($not_abstract_extern_object''(fd))*{fd <- fd*}, then
      1. Return true
3. Otherwise
  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:857.1-857.50
def $not_abstract_extern_object''(funcdef')
1. If funcdef' <: polyfuncdef, then
  1. Let `PolyFD%->%`_polyfuncdef((_tparam*, _tparam*'), functyp) = funcdef' as polyfuncdef
  2. If functyp matches `ExternAbstractMethodT%%`, then
    1. Let `ExternAbstractMethodT%%`_functyp(_paramtyp*, _typ) = functyp
    2. Return false
2. Otherwise
  1. Return true

;; ../../../../spec/4f-typing-stmt.watsup:45.1-47.29
relation Switch_tbl_label_ok: p, C, id_t, b_last', switchlabel
1. If switchlabel matches `ExprL%`, then
  1. Let `ExprL%`_switchlabel(expr) = switchlabel
  2. If expr matches `NameE%`, then
    1. Let `NameE%`_expr(name) = expr
    2. If name matches `CURRENT%`, then
      1. Let `CURRENT%`_name(id_a) = name
      2. Let id_e = $concat_text(["action_list(", id_t, ")"])
      3. Let id = $concat_text([id_e, ".", id_a])
      4. If (`TableEnumFieldV%%`_val(id_e, id_a) = $find_val(p, C, `CURRENT%`_name(id))), then
        1. Let `%%%%`_styp(typ_e, _dir, ctk_e, _val?) = $find_styp(p, C, `CURRENT%`_name(id))
        2. Result in `ExprL%`_switchlabelIL(`NameE%%`_exprIL(`CURRENT%`_name(id_a), `(%;%)`_annotIL(typ_e, ctk_e)))
2. If (b_last' = true), then
  1. If switchlabel matches `DefaultL`, then
    1. Result in `DefaultL`_switchlabelIL()

;; ../../../../spec/4f-typing-stmt.watsup:60.1-62.32
relation Switch_tbl_case_ok: p, C, f, id_t, b_last, switchcase
1. If switchcase matches `MatchC%%`, then
  1. Let `MatchC%%`_switchcase(switchlabel, block) = switchcase
  2. Switch_tbl_label_ok: `%%%%|-%:%`(p, C, id_t, b_last, switchlabel, switchlabelIL)
  3. Block_ok: `%%%%|-%:%%%`(p, C, f, `NOINIT`_blkctxt(), block, C', f', blockIL)
  4. Result in f', `MatchC%%`_switchcaseIL(switchlabelIL, blockIL), switchlabel
1. Else If switchcase matches `FallC%`, then
  1. Let `FallC%`_switchcase(switchlabel) = switchcase
  2. Switch_tbl_label_ok: `%%%%|-%:%`(p, C, id_t, b_last, switchlabel, switchlabelIL)
  3. Result in f, `FallC%`_switchcaseIL(switchlabelIL), switchlabel

;; ../../../../spec/4f-typing-stmt.watsup:74.1-76.29
relation Switch_tbl_cases_ok: p, C, f, id_t, switchcase*
1. If switchcase* matches [], then
  1. Result in f, [], []
1. Else
  1. Let switchcase_h :: switchcase_t*{switchcase_t <- switchcase_t*} = switchcase*
  2. Let b_last = (switchcase_t*{switchcase_t <- switchcase_t*} = [])
  3. Switch_tbl_case_ok: `%%%%%|-%:%%%`(p, C, f, id_t, b_last, switchcase_h, f', switchcaseIL_h, switchlabel_h)
  4. Switch_tbl_cases_ok: `%%%%|-%:%%%`(p, C, f', id_t, switchcase_t*{switchcase_t <- switchcase_t*}, f'', switchcaseIL_t*{switchcaseIL_t <- switchcaseIL_t*}, switchlabel_t*{switchlabel_t <- switchlabel_t*})
  5. Result in f'', switchcaseIL_h :: switchcaseIL_t*{switchcaseIL_t <- switchcaseIL_t*}, switchlabel_h :: switchlabel_t*{switchlabel_t <- switchlabel_t*}

;; ../../../../spec/4f-typing-stmt.watsup:98.1-100.29
relation Switch_gen_label_ok: p, C, typ_s, b_last', switchlabel
1. If switchlabel matches `ExprL%`, then
  1. Let `ExprL%`_switchlabel(expr) = switchlabel
  2. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  3. Let `(%;%)`_annotIL(_typ, ctk) = $annot(exprIL)
  4. If ctk matches `LCTK`, then
    1. Let exprIL' = $coerce_assign(exprIL, typ_s)
    2. Result in `ExprL%`_switchlabelIL(exprIL')
2. If (b_last' = true), then
  1. If switchlabel matches `DefaultL`, then
    1. Result in `DefaultL`_switchlabelIL()

;; ../../../../spec/4f-typing-stmt.watsup:112.1-114.32
relation Switch_gen_case_ok: p, C, f, typ_s, b_last, switchcase
1. If switchcase matches `MatchC%%`, then
  1. Let `MatchC%%`_switchcase(switchlabel, block) = switchcase
  2. Switch_gen_label_ok: `%%%%|-%:%`(p, C, typ_s, b_last, switchlabel, switchlabelIL)
  3. Block_ok: `%%%%|-%:%%%`(p, C, f, `NOINIT`_blkctxt(), block, C', f', blockIL)
  4. Result in f', `MatchC%%`_switchcaseIL(switchlabelIL, blockIL), switchlabel
1. Else If switchcase matches `FallC%`, then
  1. Let `FallC%`_switchcase(switchlabel) = switchcase
  2. Switch_gen_label_ok: `%%%%|-%:%`(p, C, typ_s, b_last, switchlabel, switchlabelIL)
  3. Result in f, `FallC%`_switchcaseIL(switchlabelIL), switchlabel

;; ../../../../spec/4f-typing-stmt.watsup:126.1-128.29
relation Switch_gen_cases_ok: p, C, f, typ_s, switchcase*
1. If switchcase* matches [], then
  1. Result in f, [], []
1. Else
  1. Let switchcase_h :: switchcase_t*{switchcase_t <- switchcase_t*} = switchcase*
  2. Let b_last = (switchcase_t*{switchcase_t <- switchcase_t*} = [])
  3. Switch_gen_case_ok: `%%%%%|-%:%%%`(p, C, f, typ_s, b_last, switchcase_h, f', switchcaseIL_h, switchlabel_h)
  4. Switch_gen_cases_ok: `%%%%|-%:%%%`(p, C, f', typ_s, switchcase_t*{switchcase_t <- switchcase_t*}, f'', switchcaseIL_t*{switchcaseIL_t <- switchcaseIL_t*}, switchlabel_t*{switchlabel_t <- switchlabel_t*})
  5. Result in f'', switchcaseIL_h :: switchcaseIL_t*{switchcaseIL_t <- switchcaseIL_t*}, switchlabel_h :: switchlabel_t*{switchlabel_t <- switchlabel_t*}

;; ../../../../spec/4g-typing-decl.watsup:88.1-90.29
relation Inst_init_decl_ok: p, C'', frame, fdenv, decl''
1. If decl'' matches `InstD%%%%%`, then
  1. Let `InstD%%%%%`_decl(id', name, targ*{targ <- targ*}, arg*{arg <- arg*}, decl*{decl <- decl*}) = decl''
  2. Decl_ok: `%%|-%:%%`(p, C'', `InstD%%%%%`_decl(id', name, targ*{targ <- targ*}, arg*{arg <- arg*}, decl*{decl <- decl*}), C', declIL)
  3. Let styp' = $find_styp(p, C', `CURRENT%`_name(id'))
  4. Let frame' = $update_map<id, styp>(frame, id', styp')
  5. Result in frame', fdenv, declIL
1. Else If decl'' matches `FuncD%%%%%`, then
  1. Let `FuncD%%%%%`_decl(id, type_r, tparam*{tparam <- tparam*}, param*{param <- param*}, block) = decl''
  2. Let fid = $to_fid(id, param*{param <- param*})
  3. Let C_1 = $set_blockkind(C'', `EXTERN`_bkind())
  4. Let C_2 = C_1[BLOCK.FRAME = frame]
  5. Let C_3 = $add_tparams(`LOCAL`_cursor(), C_2, tparam*{tparam <- tparam*})
  6. Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_3, type_r, typ_r, tid*)
  7. If tid* matches [], then
    1. Let C_4 = $set_localkind(C_3, `EXTERNABSTRACTMETHOD%`_lkind(typ_r))
    2. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_4, param, paramIL, tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}))*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}
    3. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**})
    4. Let C_5 = $add_params(`LOCAL`_cursor(), C_4, paramIL*{paramIL <- paramIL*} as paramtyp*)
    5. Let C_6 = $add_tparams(`LOCAL`_cursor(), C_5, tparam_hidden*{tparam_hidden <- tparam_hidden*})
    6. Block_ok: `%%%%|-%:%%%`(`LOCAL`_cursor(), C_6, `CONT`_flow(), `INIT`_blkctxt(), block, C_7, f, blockIL)
    7. If ((f = `RET`_flow()) \/ (typ_r = `VoidT`_primtyp() as typ)), then
      1. Let fd = `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ExternMethodT%%`_functyp(paramIL*{paramIL <- paramIL*} as paramtyp*, typ_r)) as funcdef
      2. FuncDef_wf: `%|-%`($bound_tids(p, C''), fd)
      3. Let fdenv' = $update_map<fid, funcdef>(fdenv, fid, fd)
      4. Result in frame, fdenv', `FuncD%%%%%%`_declIL(id, typ_r, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, paramIL*{paramIL <- paramIL*}, blockIL)

;; ../../../../spec/4g-typing-decl.watsup:128.1-130.26
relation Inst_init_decls_ok: C, frame, fdenv, decl*
1. If decl* matches [], then
  1. Result in frame, fdenv, []
1. Else
  1. Let decl_h :: decl_t*{decl_t <- decl_t*} = decl*
  2. Inst_init_decl_ok: `%%%%|-%:%%%`(`GLOBAL`_cursor(), C, frame, fdenv, decl_h, frame', fdenv', declIL_h)
  3. Inst_init_decls_ok: `%%%|-%:%%%`(C, frame', fdenv', decl_t*{decl_t <- decl_t*}, frame'', fdenv'', declIL_t*{declIL_t <- declIL_t*})
  4. Result in frame'', fdenv'', declIL_h :: declIL_t*{declIL_t <- declIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:141.1-142.109
def $update_fdenv_extern(fdenv_ext, theta, fid*, funcdef*)
1. If fid* matches [], then
  1. If funcdef* matches [], then
    1. Return fdenv_ext
1. Else
  1. Let fid_h :: fid_t*{fid_t <- fid_t*} = fid*
  2. If funcdef* matches _ :: _, then
    1. Let fd_h :: fd_t*{fd_t <- fd_t*} = funcdef*
    2. Let funcdef = $find_map<fid, funcdef>(fdenv_ext, fid_h)
    3. If funcdef <: polyfuncdef, then
      1. Let `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), functyp) = funcdef as polyfuncdef
      2. If functyp matches `ExternAbstractMethodT%%`, then
        1. Let `ExternAbstractMethodT%%`_functyp(pt*{pt <- pt*}, typ_r) = functyp
        2. Let fd_ext = `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ExternMethodT%%`_functyp(pt*{pt <- pt*}, typ_r)) as funcdef
        3. Let fd_ext' = $subst_funcdef(theta, fd_ext)
        4. FuncDef_alpha: `%~~%`(fd_ext', fd_h)
        5. Let fdenv_ext' = $update_map<fid, funcdef>(fdenv_ext, fid_h, fd_ext')
        6. Return $update_fdenv_extern(fdenv_ext', theta, fid_t*{fid_t <- fid_t*}, fd_t*{fd_t <- fd_t*})

;; ../../../../spec/4g-typing-decl.watsup:291.1-293.32
relation SEnum_field_ok: C, id_s, typ_s, (member_s, val_s)*{member_s <- member_s*, val_s <- val_s*}, member, expr
1. Expr_ok: `%%|-%:%`(`BLOCK`_cursor(), C, expr, exprIL)
2. Let `(%;%)`_annotIL(_typ, ctk) = $annot(exprIL)
3. If ctk matches `LCTK`, then
  1. Let exprIL' = $coerce_assign(exprIL, typ_s)
  2. Eval_static: `%%|-%~>%`(`BLOCK`_cursor(), C, exprIL', val_e)
  3. Let val = `SEnumFieldV%%%`_val(id_s, member, val_e)
  4. Let member_s'*{member_s' <- member_s'*} = member_s*{member_s <- member_s*} ++ [member]
  5. Let val_s'*{val_s' <- val_s'*} = val_s*{val_s <- val_s*} ++ [val]
  6. Let typ_f = `SEnumT%%%`_datatyp(id_s, typ_s, (member_s', val_s')*{member_s' <- member_s'*, val_s' <- val_s'*}) as typ
  7. Let C' = $add_styp(`BLOCK`_cursor(), C, member, `%%%%`_styp(typ_f, `NO`_dir(), `LCTK`_ctk(), ?(val)))
  8. Result in C', (member_s', val_s')*{member_s' <- member_s'*, val_s' <- val_s'*}

;; ../../../../spec/4g-typing-decl.watsup:311.1-313.29
relation SEnum_fields_ok: C, id, typ, (member, val)*{member <- member*, val <- val*}, (member, expr)*
1. If (member, expr)* matches [], then
  1. Result in C, (member, val)*{member <- member*, val <- val*}
1. Else
  1. Let (member_h, expr_h) :: (member_t, expr_t)*{expr_t <- expr_t*, member_t <- member_t*} = (member, expr)*
  2. SEnum_field_ok: `%%%%|-%%:%%`(C, id, typ, (member, val)*{member <- member*, val <- val*}, member_h, expr_h, C', (member', val')*{member' <- member'*, val' <- val'*})
  3. SEnum_fields_ok: `%%%%|-%:%%`(C', id, typ, (member', val')*{member' <- member'*, val' <- val'*}, (member_t, expr_t)*{expr_t <- expr_t*, member_t <- member_t*}, C'', (member'', val'')*{member'' <- member''*, val'' <- val''*})
  4. Result in C'', (member'', val'')*{member'' <- member''*, val'' <- val''*}

;; ../../../../spec/4g-typing-decl.watsup:500.1-500.49
def $split_methods(method*)
1. If method* matches [], then
  1. Return ([], [])
1. Else
  1. Let method_h :: method_t*{method_t <- method_t*} = method*
  2. Let method = method_h
  3. If method matches `ExternConsM%%`, then
    1. Let `ExternConsM%%`_method(_id, _cparam*) = method
    2. Let (method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*}) = $split_methods(method_t*{method_t <- method_t*})
    3. Return (method_h :: method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*})
  3. Else If method matches `ExternM%%%%`, then
    1. Let `ExternM%%%%`_method(_id, _type, _tparam*, _param*) = method
    2. Let (method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*}) = $split_methods(method_t*{method_t <- method_t*})
    3. Return (method_c*{method_c <- method_c*}, method_h :: method_m*{method_m <- method_m*})
  3. Else If method matches `ExternAbstractM%%%%`, then
    1. Let `ExternAbstractM%%%%`_method(_id, _type, _tparam*, _param*) = method
    2. Let (method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*}) = $split_methods(method_t*{method_t <- method_t*})
    3. Return (method_c*{method_c <- method_c*}, method_h :: method_m*{method_m <- method_m*})

;; ../../../../spec/4g-typing-decl.watsup:514.1-516.23
relation Method_ok: C'', id_e, method
1. If method matches `ExternConsM%%`, then
  1. Let `ExternConsM%%`_method(id, cparam*{cparam <- cparam*}) = method
  2. If (id_e = id), then
    1. Let cid = $to_fid(id_e, cparam*{cparam <- cparam*})
    2. (CParam_ok: `%%|-%:%%`(`BLOCK`_cursor(), C'', cparam, cparamIL, tid_fresh_c*{tid_fresh_c <- tid_fresh_c*}))*{cparam <- cparam*, cparamIL <- cparamIL*, tid_fresh_c* <- tid_fresh_c**}
    3. (Let `%%%%`_paramIL(id_c, dir_c, typ_c, val_c?{val_c <- val_c?}) = cparamIL)*{cparamIL <- cparamIL*, dir_c <- dir_c*, id_c <- id_c*, typ_c <- typ_c*, val_c? <- val_c?*}
    4. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_c*{tid_fresh_c <- tid_fresh_c*}*{tid_fresh_c* <- tid_fresh_c**})
    5. Let typdef = $find_typdef(`GLOBAL`_cursor(), C'', `CURRENT%`_name(id_e))
    6. If typdef <: polytypdef, then
      1. Let `PolyD%->%`_polytypdef((tparam_e*{tparam_e <- tparam_e*}, tparam*), typ_e) = typdef as polytypdef
      2. If tparam* matches [], then
        1. Let typ = `SpecT%%`_abstyp(`PolyD%->%`_polytypdef((tparam_e*{tparam_e <- tparam_e*}, []), typ_e), `VarT%`_abstyp(tparam_e) as typ*{tparam_e <- tparam_e*}) as typ
        2. Let cd = `ConsD%->%`_consdef((tparam_e*{tparam_e <- tparam_e*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ConsT%%`_constyp(`%%%%`_paramtyp(id_c, dir_c, typ_c, val_c?{val_c <- val_c?})*{dir_c <- dir_c*, id_c <- id_c*, typ_c <- typ_c*, val_c? <- val_c?*}, typ))
        3. ConsDef_wf: `%|-%`($bound_tids(`BLOCK`_cursor(), C''), cd)
        4. Let C' = $add_consdef(`GLOBAL`_cursor(), C'', cid, cd)
        5. Result in C', `ExternConsM%%%`_methodIL(id_e, tparam_hidden*{tparam_hidden <- tparam_hidden*}, cparamIL*{cparamIL <- cparamIL*})
1. Else If method matches `ExternAbstractM%%%%`, then
  1. Let `ExternAbstractM%%%%`_method(id, type_r, tparam*{tparam <- tparam*}, param*{param <- param*}) = method
  2. If (id_e =/= id), then
    1. Let fid = $to_fid(id, param*{param <- param*})
    2. Let C_1 = $add_typdefs(`LOCAL`_cursor(), C'', tparam*{tparam <- tparam*}, `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef*{tparam <- tparam*})
    3. Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_1, type_r, typ_r, tid*)
    4. If tid* matches [], then
      1. Let C_2 = $set_localkind(C_1, `EXTERNABSTRACTMETHOD%`_lkind(typ_r))
      2. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_2, param, paramIL, tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}))*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}
      3. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**})
      4. Let C_3 = $add_params(`LOCAL`_cursor(), C_2, paramIL*{paramIL <- paramIL*} as paramtyp*)
      5. Let fd = `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ExternAbstractMethodT%%`_functyp(paramIL*{paramIL <- paramIL*} as paramtyp*, typ_r)) as funcdef
      6. FuncDef_wf: `%|-%`($bound_tids(`BLOCK`_cursor(), C''), fd)
      7. Let C_4 = $add_funcdef(`BLOCK`_cursor(), C'', fid, fd)
      8. Result in C_4, `ExternAbstractM%%%%%`_methodIL(id, typ_r, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, paramIL*{paramIL <- paramIL*})
1. Else If method matches `ExternM%%%%`, then
  1. Let `ExternM%%%%`_method(id, type_r, tparam*{tparam <- tparam*}, param*{param <- param*}) = method
  2. If (id_e =/= id), then
    1. Let fid = $to_fid(id, param*{param <- param*})
    2. Let C_1 = $add_typdefs(`LOCAL`_cursor(), C'', tparam*{tparam <- tparam*}, `MonoD%`_monotypdef(`VarT%`_abstyp(tparam) as typ) as typdef*{tparam <- tparam*})
    3. Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_1, type_r, typ_r, tid*)
    4. If tid* matches [], then
      1. Let C_2 = $set_localkind(C_1, `EXTERNMETHOD`_lkind())
      2. (Param_ok: `%%|-%:%%`(`LOCAL`_cursor(), C_2, param, paramIL, tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}))*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}
      3. (Let `%%%%`_paramIL(id_p, dir_p, typ_p, val_p?{val_p <- val_p?}) = paramIL)*{dir_p <- dir_p*, id_p <- id_p*, paramIL <- paramIL*, typ_p <- typ_p*, val_p? <- val_p?*}
      4. Let tparam_hidden*{tparam_hidden <- tparam_hidden*} = $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**})
      5. Let C_3 = $add_params(`LOCAL`_cursor(), C_2, paramIL*{paramIL <- paramIL*} as paramtyp*)
      6. Let fd = `PolyFD%->%`_polyfuncdef((tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}), `ExternMethodT%%`_functyp(paramIL*{paramIL <- paramIL*} as paramtyp*, typ_r)) as funcdef
      7. FuncDef_wf: `%|-%`($bound_tids(`BLOCK`_cursor(), C''), fd)
      8. Let C_4 = $add_funcdef(`BLOCK`_cursor(), C'', fid, fd)
      9. Result in C_4, `ExternM%%%%%`_methodIL(id, typ_r, tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}, paramIL*{paramIL <- paramIL*})

;; ../../../../spec/4g-typing-decl.watsup:580.1-582.23
relation Methods_ok: C, id_e, method*
1. If method* matches [], then
  1. Result in C, []
1. Else
  1. Let method_h :: method_t*{method_t <- method_t*} = method*
  2. Method_ok: `%%|-%:%%`(C, id_e, method_h, C', methodIL_h)
  3. Methods_ok: `%%|-%:%%`(C', id_e, method_t*{method_t <- method_t*}, C'', methodIL_t*{methodIL_t <- methodIL_t*})
  4. Result in C'', methodIL_h :: methodIL_t*{methodIL_t <- methodIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:652.1-654.20
relation ParserState_ok: C, `%%`_parserstate(statelabel, block)
1. Block_ok: `%%%%|-%:%%%`(`LOCAL`_cursor(), C, `CONT`_flow(), `INIT`_blkctxt(), block, C', flow, blockIL)
2. If flow matches `CONT`, then
  1. Result in `%%`_parserstateIL(statelabel, blockIL)

;; ../../../../spec/4g-typing-decl.watsup:713.1-715.26
relation Table_key_ok: p, C, tblctx, `%%`_tblkey(expr, matchkind)
1. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
2. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
3. Type_wf: `%|-%`($bound_tids(p, C), `SetT%`_synthtyp(typ) as typ)
4. If (`MatchKindV%`_val(matchkind) = $find_val(p, C, `CURRENT%`_name(matchkind))), then
  1. If $check_table_key(matchkind, typ), then
    1. Let tblctx' = $update_mode(matchkind, typ, tblctx)
    2. Let tblctx'' = $add_key((typ, matchkind), tblctx')
    3. Result in tblctx'', `%%`_tblkeyIL(exprIL, matchkind)

;; ../../../../spec/4g-typing-decl.watsup:717.1-717.44
def $check_table_key(matchkind, typ)
1. If ((matchkind = "exact") \/ (matchkind = "optional")), then
  1. Let typ' = $canon_typ(typ)
  2. If (((((($is_errt(typ') \/ $is_boolt(typ')) \/ $is_intt(typ')) \/ $is_fintt(typ')) \/ $is_fbitt(typ')) \/ $is_vbitt(typ')) \/ $is_enumt(typ')), then
    1. Return true
  3. Let typ'' = $canon_typ(typ)
  4. If typ'' <: datatyp, then
    1. Let datatyp = typ'' as datatyp
    2. If datatyp matches `SEnumT%%%`, then
      1. Let `SEnumT%%%`_datatyp(_id, typ', _(member, val)*) = datatyp
      2. Return $check_table_key(matchkind, typ')
    2. Else If datatyp matches `NewT%%`, then
      1. Let `NewT%%`_datatyp(_id, typ') = datatyp
      2. Return $check_table_key(matchkind, typ')
2. If (((matchkind = "lpm") \/ (matchkind = "ternary")) \/ (matchkind = "range")), then
  1. Let typ' = $canon_typ(typ)
  2. If (($is_intt(typ') \/ $is_fintt(typ')) \/ $is_fbitt(typ')), then
    1. Return true
  3. Let typ'' = $canon_typ(typ)
  4. If typ'' <: datatyp, then
    1. Let datatyp = typ'' as datatyp
    2. If datatyp matches `SEnumT%%%`, then
      1. Let `SEnumT%%%`_datatyp(_id, typ', _(member, val)*) = datatyp
      2. Return $check_table_key(matchkind, typ')
    2. Else If datatyp matches `NewT%%`, then
      1. Let `NewT%%`_datatyp(_id, typ') = datatyp
      2. Return $check_table_key(matchkind, typ')
3. Otherwise
  1. Return false

;; ../../../../spec/4g-typing-decl.watsup:767.1-769.26
relation Table_keys_ok: p, C, tblctx, tblkey*
1. If tblkey* matches [], then
  1. Result in tblctx, []
1. Else
  1. Let tblkey_h :: tblkey_t*{tblkey_t <- tblkey_t*} = tblkey*
  2. Table_key_ok: `%%%|-%:%%`(p, C, tblctx, tblkey_h, tblctx', tblkeyIL_h)
  3. Table_keys_ok: `%%%|-%:%%`(p, C, tblctx', tblkey_t*{tblkey_t <- tblkey_t*}, tblctx'', tblkeyIL_t*{tblkeyIL_t <- tblkeyIL_t*})
  4. Result in tblctx'', tblkeyIL_h :: tblkeyIL_t*{tblkeyIL_t <- tblkeyIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:783.1-785.26
relation Call_action_partial_ok: p, C, pt*{pt <- pt*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}
1. Let (paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}) = $split_directionless_params(pt*{pt <- pt*} as paramIL*)
2. If (|paramIL_d*{paramIL_d <- paramIL_d*}| = |argIL*{argIL <- argIL*}|), then
  1. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `ACT`_actctxt(), paramIL_d as paramtyp, (argIL, typ_a), argIL'))*{argIL <- argIL*, argIL' <- argIL'*, paramIL_d <- paramIL_d*, typ_a <- typ_a*}
  2. Result in paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}, argIL'*{argIL' <- argIL'*}

;; ../../../../spec/4g-typing-decl.watsup:787.1-788.46
def $split_directionless_params(paramIL*)
1. If paramIL* matches [], then
  1. Return ([], [])
1. Else
  1. Let paramIL_h :: paramIL_t*{paramIL_t <- paramIL_t*} = paramIL*
  2. Let `%%%%`_paramIL(_idIL, dir, _typeIL, _val?) = paramIL_h
  3. If dir matches `NO`, then
    1. Let (paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}) = $split_directionless_params(paramIL_t*{paramIL_t <- paramIL_t*})
    2. Return (paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_h :: paramIL_c*{paramIL_c <- paramIL_c*})
  4. If (dir =/= `NO`_dir()), then
    1. Let (paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}) = $split_directionless_params(paramIL_t*{paramIL_t <- paramIL_t*})
    2. Return (paramIL_h :: paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*})

;; ../../../../spec/4g-typing-decl.watsup:807.1-809.26
relation Table_action_ok: p, C, tblctx, `%%`_tblaction(name, arg*{arg <- arg*})
1. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
2. Let funcdef = $find_funcdef_by_name(p, C, name)
3. If funcdef <: monofuncdef, then
  1. Let `MonoFD%`_monofuncdef(functyp) = funcdef as monofuncdef
  2. If functyp matches `ActionT%`, then
    1. Let `ActionT%`_functyp(pt*{pt <- pt*}) = functyp
    2. Call_action_partial_ok: `%%|-%%:%%%`(p, C, pt*{pt <- pt*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}, paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}, argIL'*{argIL' <- argIL'*})
    3. Let tblctx' = $add_action((name, pt*{pt <- pt*}, argIL*{argIL <- argIL*}), tblctx)
    4. Result in tblctx', `%%%%`_tblactionIL(name, argIL'*{argIL' <- argIL'*}, paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*})

;; ../../../../spec/4g-typing-decl.watsup:821.1-823.26
relation Table_actions_ok: p, C, tblctx, tblaction*
1. If tblaction* matches [], then
  1. Result in tblctx, []
1. Else
  1. Let tblaction_h :: tblaction_t*{tblaction_t <- tblaction_t*} = tblaction*
  2. Table_action_ok: `%%%|-%:%%`(p, C, tblctx, tblaction_h, tblctx', tblactionIL_h)
  3. Table_actions_ok: `%%%|-%:%%`(p, C, tblctx', tblaction_t*{tblaction_t <- tblaction_t*}, tblctx'', tblactionIL_t*{tblactionIL_t <- tblactionIL_t*})
  4. Let tblactionIL*{tblactionIL <- tblactionIL*} = tblactionIL_h :: tblactionIL_t*{tblactionIL_t <- tblactionIL_t*}
  5. (Let `%%%%`_tblactionIL(name, argIL*{argIL <- argIL*}, paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}) = tblactionIL)*{argIL* <- argIL**, name <- name*, paramIL_c* <- paramIL_c**, paramIL_d* <- paramIL_d**, tblactionIL <- tblactionIL*}
  6. If $distinct_<name>(name*{name <- name*}), then
    1. Result in tblctx'', tblactionIL_h :: tblactionIL_t*{tblactionIL_t <- tblactionIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:841.1-843.29
relation Table_entry_keyset_ok: p, C, tblctx, (typ_k, text'), keyset
1. If (text' = "lpm"), then
  1. If keyset matches `ExprK%`, then
    1. Let `ExprK%`_keyset(expr) = keyset
    2. If expr matches `MaskE%%`, then
      1. Let `MaskE%%`_expr(expr_b, expr_m) = expr
      2. Expr_ok: `%%|-%:%`(p, C, `MaskE%%`_expr(expr_b, expr_m), exprIL)
      3. Let `(%;%)`_annotIL(typ', _ctk) = $annot(exprIL)
      4. If typ' <: synthtyp, then
        1. Let synthtyp = typ' as synthtyp
        2. If synthtyp matches `SetT%`, then
          1. Let `SetT%`_synthtyp(typ) = synthtyp
          2. Let exprIL' = exprIL
          3. If exprIL' matches `MaskE%%%`, then
            1. Let `MaskE%%%`_exprIL(exprIL_b, exprIL_m, _annotIL) = exprIL'
            2. Let mode = tblctx.MODE
            3. If mode matches `NOPRILPM%`, then
              1. Let `NOPRILPM%`_mode(n_w) = mode
              2. Eval_static: `%%|-%~>%`(p, C, exprIL_m, val_m)
              3. Let i_m = $get_num(val_m)
              4. Let tblstate_e = $get_lpm_prefix(`FBitV%%`_val(n_w, $to_bitstr(n_w as int, i_m)))
              5. Sub_impl: `%<<%`(typ, typ_k)
              6. Result in tblstate_e, `ExprK%`_keysetIL(exprIL)
    3. If ~ ($is_maske(expr) \/ $is_rangee(expr)), then
      1. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
      2. Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL)
      3. Let mode = tblctx.MODE
      4. If mode matches `NOPRILPM%`, then
        1. Let `NOPRILPM%`_mode(n_w) = mode
        2. Sub_impl: `%<<%`(typ, typ_k)
        3. Let exprIL' = `CastE%%%`_exprIL(`SetT%`_synthtyp(typ_k) as typeIL, exprIL, `(%;%)`_annotIL(`SetT%`_synthtyp(typ_k) as typ, ctk))
        4. Result in `LPM%`_tblstate(n_w), `ExprK%`_keysetIL(exprIL')
  1. Else If keyset matches `DefaultK`, then
    1. Let mode = tblctx.MODE
    2. If mode matches `NOPRILPM%`, then
      1. Let `NOPRILPM%`_mode(n_w) = mode
      2. Result in `LPM%`_tblstate(n_w), `DefaultK`_keysetIL()
  1. Else If keyset matches `AnyK`, then
    1. Let mode = tblctx.MODE
    2. If mode matches `NOPRILPM%`, then
      1. Let `NOPRILPM%`_mode(_nat) = mode
      2. Result in `LPM%`_tblstate(0), `AnyK`_keysetIL()
1. Else If (text' = "ternary"), then
  1. If keyset matches `ExprK%`, then
    1. Let `ExprK%`_keyset(expr) = keyset
    2. If expr matches `MaskE%%`, then
      1. Let `MaskE%%`_expr(expr_b, expr_m) = expr
      2. Expr_ok: `%%|-%:%`(p, C, `MaskE%%`_expr(expr_b, expr_m), exprIL)
      3. Let `(%;%)`_annotIL(typ', _ctk) = $annot(exprIL)
      4. If typ' <: synthtyp, then
        1. Let synthtyp = typ' as synthtyp
        2. If synthtyp matches `SetT%`, then
          1. Let `SetT%`_synthtyp(typ) = synthtyp
          2. Sub_impl: `%<<%`(typ, typ_k)
          3. Result in `NOLPM`_tblstate(), `ExprK%`_keysetIL(exprIL)
    3. If ~ ($is_maske(expr) \/ $is_rangee(expr)), then
      1. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
      2. Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL)
      3. Sub_impl: `%<<%`(typ, typ_k)
      4. Let exprIL' = `CastE%%%`_exprIL(`SetT%`_synthtyp(typ_k) as typeIL, exprIL, `(%;%)`_annotIL(`SetT%`_synthtyp(typ_k) as typ, ctk))
      5. Result in `NOLPM`_tblstate(), `ExprK%`_keysetIL(exprIL')
1. Else If (text' = "range"), then
  1. If keyset matches `ExprK%`, then
    1. Let `ExprK%`_keyset(expr) = keyset
    2. If expr matches `RangeE%%`, then
      1. Let `RangeE%%`_expr(expr_l, expr_r) = expr
      2. Expr_ok: `%%|-%:%`(p, C, `RangeE%%`_expr(expr_l, expr_r), exprIL)
      3. Let `(%;%)`_annotIL(typ', _ctk) = $annot(exprIL)
      4. If typ' <: synthtyp, then
        1. Let synthtyp = typ' as synthtyp
        2. If synthtyp matches `SetT%`, then
          1. Let `SetT%`_synthtyp(typ) = synthtyp
          2. Sub_impl: `%<<%`(typ, typ_k)
          3. Result in `NOLPM`_tblstate(), `ExprK%`_keysetIL(exprIL)
    3. If ~ ($is_maske(expr) \/ $is_rangee(expr)), then
      1. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
      2. Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL)
      3. Sub_impl: `%<<%`(typ, typ_k)
      4. Let exprIL' = `CastE%%%`_exprIL(`SetT%`_synthtyp(typ_k) as typeIL, exprIL, `(%;%)`_annotIL(`SetT%`_synthtyp(typ_k) as typ, ctk))
      5. Result in `NOLPM`_tblstate(), `ExprK%`_keysetIL(exprIL')
2. If keyset matches `ExprK%`, then
  1. Let `ExprK%`_keyset(expr) = keyset
  2. If (((text' =/= "lpm") /\ (text' =/= "ternary")) /\ (text' =/= "range")), then
    1. If ~ ($is_maske(expr) \/ $is_rangee(expr)), then
      1. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
      2. Let `(%;%)`_annotIL(typ, ctk) = $annot(exprIL)
      3. Sub_impl: `%<<%`(typ, typ_k)
      4. Let exprIL' = `CastE%%%`_exprIL(`SetT%`_synthtyp(typ_k) as typeIL, exprIL, `(%;%)`_annotIL(`SetT%`_synthtyp(typ_k) as typ, ctk))
      5. Result in `NOLPM`_tblstate(), `ExprK%`_keysetIL(exprIL')
2. Else If keyset matches `DefaultK`, then
  1. If (text' =/= "exact"), then
    1. Result in `NOLPM`_tblstate(), `DefaultK`_keysetIL()
2. Else If keyset matches `AnyK`, then
  1. If (text' =/= "exact"), then
    1. Result in `NOLPM`_tblstate(), `AnyK`_keysetIL()

;; ../../../../spec/4g-typing-decl.watsup:935.1-937.32
relation Table_entry_keysets_state_ok: p, C, tblctx, tblstate', key*, keyset*
1. If key* matches [], then
  1. If keyset* matches [], then
    1. Result in tblstate', []
1. Else
  1. Let key_h :: key_t*{key_t <- key_t*} = key*
  2. If keyset* matches _ :: _, then
    1. Let keyset_h :: keyset_t*{keyset_t <- keyset_t*} = keyset*
    2. Table_entry_keyset_ok: `%%%|-%%:%%`(p, C, tblctx, key_h, keyset_h, tblstate_1, keysetIL_h)
    3. Let tblstate_2 = $update_state(tblstate', tblstate_1)
    4. Table_entry_keysets_state_ok: `%%%%|-%%:%%`(p, C, tblctx, tblstate_2, key_t*{key_t <- key_t*}, keyset_t*{keyset_t <- keyset_t*}, tblstate_3, keysetIL_t*{keysetIL_t <- keysetIL_t*})
    5. Result in tblstate_3, keysetIL_h :: keysetIL_t*{keysetIL_t <- keysetIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:949.1-951.26
relation Table_entry_keysets_ok: p, C, tblctx, keyset*'
1. If (keyset*' = [`DefaultK`_keyset()]), then
  1. Let mode = tblctx.MODE
  2. If mode matches `NOPRILPM%`, then
    1. Let `NOPRILPM%`_mode(nat) = mode
    2. Result in `LPM%`_tblstate(nat), [`DefaultK`_keysetIL()]
  3. If (((tblctx.MODE = `NOPRI`_mode()) \/ (tblctx.MODE = `PRI`_mode())) \/ (tblctx.MODE = `PRILPM`_mode())), then
    1. Result in `NOLPM`_tblstate(), [`DefaultK`_keysetIL()]
2. If (keyset*' = [`AnyK`_keyset()]), then
  1. Let mode = tblctx.MODE
  2. If mode matches `NOPRILPM%`, then
    1. Let `NOPRILPM%`_mode(nat) = mode
    2. Result in `LPM%`_tblstate(0), [`AnyK`_keysetIL()]
  3. If (((tblctx.MODE = `NOPRI`_mode()) \/ (tblctx.MODE = `PRI`_mode())) \/ (tblctx.MODE = `PRILPM`_mode())), then
    1. Result in `NOLPM`_tblstate(), [`AnyK`_keysetIL()]
3. Let keyset*{keyset <- keyset*} = keyset*'
4. If (|tblctx.KEYS| = |keyset*{keyset <- keyset*}|), then
  1. Table_entry_keysets_state_ok: `%%%%|-%%:%%`(p, C, tblctx, `NOLPM`_tblstate(), tblctx.KEYS, keyset*{keyset <- keyset*}, tblstate, keysetIL*{keysetIL <- keysetIL*})
  2. Result in tblstate, keysetIL*{keysetIL <- keysetIL*}

;; ../../../../spec/4g-typing-decl.watsup:975.1-977.29
relation Call_default_action_ok: p, C, pt*{pt <- pt*}, (argIL, typ)*{argIL <- argIL*, typ <- typ*}, argIL_a*{argIL_a <- argIL_a*}
1. If (|pt*{pt <- pt*}| = |argIL*{argIL <- argIL*}|), then
  1. Let argIL_d*{argIL_d <- argIL_d*} = $filter_directionless_args(pt*{pt <- pt*}, argIL*{argIL <- argIL*})
  2. If ((argIL_a = argIL_d))*{argIL_a <- argIL_a*, argIL_d <- argIL_d*}, then
    1. (Call_convention_arg_ok: `%%%|-%~~%:%`(p, C, `ACT`_actctxt(), pt, (argIL, typ), argIL'))*{argIL <- argIL*, argIL' <- argIL'*, pt <- pt*, typ <- typ*}
    2. Result in argIL'*{argIL' <- argIL'*}

;; ../../../../spec/4g-typing-decl.watsup:979.1-979.59
def $filter_directionless_args(paramtyp*, argIL*)
1. If paramtyp* matches [], then
  1. If argIL* matches [], then
    1. Return []
1. Else
  1. Let pt_h :: pt_t*{pt_t <- pt_t*} = paramtyp*
  2. If argIL* matches _ :: _, then
    1. Let argIL_h :: argIL_t*{argIL_t <- argIL_t*} = argIL*
    2. Let `%%%%`_paramtyp(id, dir, typ, val?{val <- val?}) = pt_h
    3. If dir matches `NO`, then
      1. Return $filter_directionless_args(pt_t*{pt_t <- pt_t*}, argIL_t*{argIL_t <- argIL_t*})
    4. Otherwise
      1. Return argIL_h :: $filter_directionless_args(pt_t*{pt_t <- pt_t*}, argIL_t*{argIL_t <- argIL_t*})

;; ../../../../spec/4g-typing-decl.watsup:997.1-999.26
relation Table_entry_action_ok: p, C, tblctx, `%%`_tblaction(name, arg*{arg <- arg*})
1. Let (paramtyp*, argIL*)? = $find_action(tblctx, name)
2. If (paramtyp*, argIL*)? matches (_), then
  1. Let ?((pt*{pt <- pt*}, argIL_a*{argIL_a <- argIL_a*})) = (paramtyp*, argIL*)?
  2. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_arg))*{arg <- arg*, argIL <- argIL*, typ_arg <- typ_arg*}
  3. Call_default_action_ok: `%%|-%%%:%`(p, C, pt*{pt <- pt*}, (argIL, typ_arg)*{argIL <- argIL*, typ_arg <- typ_arg*}, argIL_a*{argIL_a <- argIL_a*}, argIL'*{argIL' <- argIL'*})
  4. Let tblactionIL = `%%%%`_tblactionIL(name, argIL'*{argIL' <- argIL'*}, pt*{pt <- pt*} as paramIL*, [])
  5. Result in tblactionIL

;; ../../../../spec/4g-typing-decl.watsup:1012.1-1014.29
relation Table_entry_priority_ok: cursor, C, tblctx, tblstate, expr?
1. If cursor matches `LOCAL`, then
  1. If expr? matches (), then
    1. If (tblctx.MODE = `NOPRI`_mode()), then
      1. Result in tblctx, ?()
    2. If ((tblctx.MODE = `PRI`_mode()) \/ (tblctx.MODE = `PRILPM`_mode())), then
      1. If (tblctx.PRIORITIES.VALUES = []), then
        1. If tblctx.PRIORITIES.LARGEST_WINS, then
          1. Let i_size = tblctx.ENTRIES.SIZE
          2. Let i_delta = tblctx.PRIORITIES.DELTA
          3. Let i = (((i_size - 1 as int) * i_delta) + 1 as int)
          4. If (i >= 0 as int), then
            1. Let tblctx' = $add_priority(i, tblctx)
            2. Result in tblctx', ?(`IntV%`_val(i))
        1. Else
          1. Let tblctx' = $add_priority(1 as int, tblctx)
          2. Result in tblctx', ?(`IntV%`_val(1 as int))
      1. Else
        1. Let i_delta = tblctx.PRIORITIES.DELTA
        2. Let i = $find_last_priority(tblctx)
        3. If tblctx.PRIORITIES.LARGEST_WINS, then
          1. Let i' = (i - i_delta)
          2. If (i' >= 0 as int), then
            1. Let tblctx' = $add_priority(i', tblctx)
            2. Result in tblctx', ?(`IntV%`_val(i'))
        3. Else
          1. Let i' = (i + i_delta)
          2. If (i' >= 0 as int), then
            1. Let tblctx' = $add_priority(i', tblctx)
            2. Result in tblctx', ?(`IntV%`_val(i'))
  1. Else
    1. Let ?(expr) = expr?
    2. If ((tblctx.MODE = `PRI`_mode()) \/ (tblctx.MODE = `PRILPM`_mode())), then
      1. If ~ tblctx.ENTRIES.CONST, then
        1. If (tblctx.PRIORITIES.VALUES = []), then
          1. Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), C, expr, exprIL)
          2. Eval_static: `%%|-%~>%`(`LOCAL`_cursor(), C, exprIL, val)
          3. Let i = $get_num(val)
          4. If (i >= 0 as int), then
            1. Let tblctx' = tblctx[PRIORITIES.INIT = true]
            2. Let tblctx'' = $add_priority(i, tblctx')
            3. Result in tblctx'', ?(`IntV%`_val(i))
        1. Else If tblctx.PRIORITIES.INIT, then
          1. Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), C, expr, exprIL)
          2. Eval_static: `%%|-%~>%`(`LOCAL`_cursor(), C, exprIL, val)
          3. Let i = $get_num(val)
          4. If (i >= 0 as int), then
            1. Let tblctx' = $add_priority(i, tblctx)
            2. Result in tblctx', ?(`IntV%`_val(i))
  2. If tblstate matches `LPM%`, then
    1. Let `LPM%`_tblstate(nat_prefix) = tblstate
    2. If expr? matches (), then
      1. Let mode = tblctx.MODE
      2. If mode matches `NOPRILPM%`, then
        1. Let `NOPRILPM%`_mode(nat) = mode
        2. Result in tblctx, ?()

;; ../../../../spec/4g-typing-decl.watsup:1105.1-1107.26
relation Table_entry_ok: p, C, tblctx, `%%%%`_tblentry(bool, keyset*{keyset <- keyset*}, tblaction, expr?{expr <- expr?})
1. Table_entry_keysets_ok: `%%%|-%:%%`(p, C, tblctx, keyset*{keyset <- keyset*}, tblstate, keysetIL*{keysetIL <- keysetIL*})
2. Table_entry_action_ok: `%%%|-%:%`(p, C, tblctx, tblaction, tblactionIL)
3. Table_entry_priority_ok: `%%%%|-%:%%`(p, C, tblctx, tblstate, expr?{expr <- expr?}, tblctx', val?{val <- val?})
4. Result in tblctx', `%%%%`_tblentryIL(bool, keysetIL*{keysetIL <- keysetIL*}, tblactionIL, val?{val <- val?})

;; ../../../../spec/4g-typing-decl.watsup:1118.1-1120.26
relation Table_entries_fold_ok: p, C, tblctx, tblentry*
1. If tblentry* matches [], then
  1. Result in tblctx, []
1. Else
  1. Let tblentry_h :: tblentry_t*{tblentry_t <- tblentry_t*} = tblentry*
  2. Table_entry_ok: `%%%|-%:%%`(p, C, tblctx, tblentry_h, tblctx', tblentryIL_h)
  3. Table_entries_fold_ok: `%%%|-%:%%`(p, C, tblctx', tblentry_t*{tblentry_t <- tblentry_t*}, tblctx'', tblentryIL_t*{tblentryIL_t <- tblentryIL_t*})
  4. Result in tblctx'', tblentryIL_h :: tblentryIL_t*{tblentryIL_t <- tblentryIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:1131.1-1133.26
relation Table_entries_ok: p, C, tblctx_0, `%%`_tblentryprop(b, tblentry*{tblentry <- tblentry*})
1. If ((|tblctx_0.KEYS| = 0) => (|tblentry*{tblentry <- tblentry*}| = 0)), then
  1. Let tblctx_1 = tblctx_0[ENTRIES.SIZE = |tblentry*{tblentry <- tblentry*}| as int]
  2. Let tblctx_2 = tblctx_1[ENTRIES.CONST = b]
  3. Table_entries_fold_ok: `%%%|-%:%%`(p, C, tblctx_2, tblentry*{tblentry <- tblentry*}, tblctx_3, tblentryIL*{tblentryIL <- tblentryIL*})
  4. Result in tblctx_3, `%%`_tblentrypropIL(b, tblentryIL*{tblentryIL <- tblentryIL*})

;; ../../../../spec/4g-typing-decl.watsup:1148.1-1150.26
relation Table_default_ok: p, C, tblctx, `%%`_tbldefaultprop(bool, `%%`_tblaction(name, arg*{arg <- arg*}))
1. Let (paramtyp*, argIL*)? = $find_action(tblctx, name)
2. If (paramtyp*, argIL*)? matches (_), then
  1. Let ?((pt*{pt <- pt*}, argIL_a*{argIL_a <- argIL_a*})) = (paramtyp*, argIL*)?
  2. (Arg_ok: `%%|-%:%%`(p, C, arg, argIL, typ_a))*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}
  3. Call_default_action_ok: `%%|-%%%:%`(p, C, pt*{pt <- pt*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}, argIL_a*{argIL_a <- argIL_a*}, argIL'*{argIL' <- argIL'*})
  4. Let tblactionIL = `%%%%`_tblactionIL(name, argIL'*{argIL' <- argIL'*}, pt*{pt <- pt*} as paramIL*, [])
  5. Result in `%%`_tbldefaultpropIL(bool, tblactionIL)

;; ../../../../spec/4g-typing-decl.watsup:1166.1-1168.26
relation Table_custom_ok: p, C, tblctx, `%%%`_tblcustomprop(b, text', expr)
1. If (text' = "size"), then
  1. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  2. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
  3. If (($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ)), then
    1. Result in tblctx, `%%%`_tblcustompropIL(b, "size", exprIL)
1. Else If (text' = "largest_priority_wins"), then
  1. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  2. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
  3. If (typ = `BoolT`_primtyp() as typ), then
    1. Eval_static: `%%|-%~>%`(p, C, exprIL, val)
    2. If val matches `BoolV%`, then
      1. Let `BoolV%`_val(b_lw) = val
      2. Let tblctx' = tblctx[PRIORITIES.LARGEST_WINS = b_lw]
      3. Result in tblctx', `%%%`_tblcustompropIL(b, "largest_priority_wins", exprIL)
1. Else If (text' = "priority_delta"), then
  1. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  2. Let `(%;%)`_annotIL(typ, _ctk) = $annot(exprIL)
  3. If (($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ)), then
    1. Eval_static: `%%|-%~>%`(p, C, exprIL, val)
    2. Let i_delta = $get_num(val)
    3. If (i_delta > 0 as int), then
      1. Let tblctx' = tblctx[PRIORITIES.DELTA = i_delta]
      2. Result in tblctx', `%%%`_tblcustompropIL(b, "priority_delta", exprIL)
2. If (((text' =/= "size") /\ (text' =/= "largest_priority_wins")) /\ (text' =/= "priority_delta")), then
  1. Expr_ok: `%%|-%:%`(p, C, expr, exprIL)
  2. Result in tblctx, `%%%`_tblcustompropIL(b, text', exprIL)

;; ../../../../spec/4g-typing-decl.watsup:1203.1-1205.26
relation Table_prop_ok: p, C, tblctx, tblprop
1. If tblprop matches `KeyP%`, then
  1. Let `KeyP%`_tblprop(tblkeyprop) = tblprop
  2. Table_keys_ok: `%%%|-%:%%`(p, C, tblctx, tblkeyprop, tblctx', tblkeypropIL)
  3. Result in tblctx', `KeyP%`_tblpropIL(tblkeypropIL)
1. Else If tblprop matches `ActionP%`, then
  1. Let `ActionP%`_tblprop(tblactionprop) = tblprop
  2. Table_actions_ok: `%%%|-%:%%`(p, C, tblctx, tblactionprop, tblctx', tblactionpropIL)
  3. Result in tblctx', `ActionP%`_tblpropIL(tblactionpropIL)
1. Else If tblprop matches `EntryP%`, then
  1. Let `EntryP%`_tblprop(tblentryprop) = tblprop
  2. Table_entries_ok: `%%%|-%:%%`(p, C, tblctx, tblentryprop, tblctx', tblentrypropIL)
  3. Result in tblctx', `EntryP%`_tblpropIL(tblentrypropIL)
1. Else If tblprop matches `DefaultP%`, then
  1. Let `DefaultP%`_tblprop(tbldefaultprop) = tblprop
  2. Table_default_ok: `%%%|-%:%`(p, C, tblctx, tbldefaultprop, tbldefaultpropIL)
  3. Result in tblctx, `DefaultP%`_tblpropIL(tbldefaultpropIL)
1. Else If tblprop matches `CustomP%`, then
  1. Let `CustomP%`_tblprop(tblcustomprop) = tblprop
  2. Table_custom_ok: `%%%|-%:%%`(p, C, tblctx, tblcustomprop, tblctx', tblcustompropIL)
  3. Result in tblctx', `CustomP%`_tblpropIL(tblcustompropIL)

;; ../../../../spec/4g-typing-decl.watsup:1228.1-1230.26
relation Table_props_ok: p, C, tblctx, tblprop*
1. If tblprop* matches [], then
  1. Result in tblctx, []
1. Else
  1. Let tblprop_h :: tblprop_t*{tblprop_t <- tblprop_t*} = tblprop*
  2. Table_prop_ok: `%%%|-%:%%`(p, C, tblctx, tblprop_h, tblctx', tblpropIL_h)
  3. Table_props_ok: `%%%|-%:%%`(p, C, tblctx', tblprop_t*{tblprop_t <- tblprop_t*}, tblctx'', tblpropIL_t*{tblpropIL_t <- tblpropIL_t*})
  4. Result in tblctx'', tblpropIL_h :: tblpropIL_t*{tblpropIL_t <- tblpropIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:1244.1-1246.26
relation Table_type_decl_ok: cursor, C, tblctx, id
1. If cursor matches `BLOCK`, then
  1. Let id_e = $concat_text(["action_list(", id, ")"])
  2. Let (name, pt*{pt <- pt*}, argIL*{argIL <- argIL*})*{argIL* <- argIL**, name <- name*, pt* <- pt**} = tblctx.ACTIONS
  3. (Let member = $string_of_name(name))*{member <- member*, name <- name*}
  4. Let typ_e = `TableEnumT%%`_synthtyp(id_e, member*{member <- member*}) as typ
  5. (Let val_e = `TableEnumFieldV%%`_val(id_e, member))*{member <- member*, val_e <- val_e*}
  6. (Let id_f = $concat_text([id_e, ".", member]))*{id_f <- id_f*, member <- member*}
  7. Let C' = $add_styps(`BLOCK`_cursor(), C, id_f*{id_f <- id_f*}, `%%%%`_styp(typ_e, `NO`_dir(), `LCTK`_ctk(), ?(val_e))*{val_e <- val_e*})
  8. Let id_s = $concat_text(["apply_result(", id, ")"])
  9. Let typ_s = `TableStructT%%`_synthtyp(id_s, [("hit", `BoolT`_primtyp() as typ), ("miss", `BoolT`_primtyp() as typ), ("action_run", typ_e)]) as typ
  10. Result in C', typ_s

;; ../../../../spec/4h-typing-call.watsup:149.1-150.77
def $filter_default_args(paramtyp*, id_deft*{id_deft <- id_deft*})
1. If paramtyp* matches [], then
  1. Return []
1. Else
  1. Let pt_h :: pt_t*{pt_t <- pt_t*} = paramtyp*
  2. Let `%%%%`_paramtyp(id_p, _dir, _typ, _val?) = pt_h
  3. If id_p <- id_deft*{id_deft <- id_deft*}, then
    1. Return $filter_default_args(pt_t*{pt_t <- pt_t*}, id_deft*{id_deft <- id_deft*})
  4. Otherwise
    1. Return pt_h :: $filter_default_args(pt_t*{pt_t <- pt_t*}, id_deft*{id_deft <- id_deft*})

;; ../../../../spec/4h-typing-call.watsup:161.15-161.32
syntax pmap = map<id, paramtyp>

;; ../../../../spec/4h-typing-call.watsup:163.1-164.80
def $align_params_with_args(pt*{pt <- pt*}, (argIL, typ)*{argIL <- argIL*, typ <- typ*})
1. (Let `%%%%`_paramtyp(id, _dir, _typ, _val?) = pt)*{_dir <- _dir*, _typ <- _typ*, _val? <- _val?*, id <- id*, pt <- pt*}
2. Let pmap = `MAP%`_map<id, paramtyp>(`PAIR%%`_pair<id, paramtyp>(id, pt)*{id <- id*, pt <- pt*})
3. (Let pt' = $align_params_with_args'(pmap, pt, (argIL, typ)))*{argIL <- argIL*, pt <- pt*, pt' <- pt'*, typ <- typ*}
4. Return pt'*{pt' <- pt'*}

;; ../../../../spec/4h-typing-call.watsup:165.1-166.97
def $align_params_with_args'(pmap, pt, (argIL, _typ))
1. If argIL matches `ExprA%`, then
  1. Let `ExprA%`_argIL(_exprIL) = argIL
  2. Return pt
1. Else If argIL matches `NameA%%`, then
  1. Let `NameA%%`_argIL(id, _exprIL?) = argIL
  2. Let pt' = $find_map<id, paramtyp>(pmap, id)
  3. Return pt'
1. Else If argIL matches `AnyA`, then
  1. Return pt

;; ../../../../spec/4h-typing-call.watsup:184.1-184.39
def $empty_cstr(tid*{tid <- tid*})
1. Return `MAP%`_map<tid, typ?>(`PAIR%%`_pair<tid, typ?>(tid, ?())*{tid <- tid*})

;; ../../../../spec/4h-typing-call.watsup:190.1-190.57
def $gen_cstr(cstr, typ'', typ_a''')
1. If typ'' <: abstyp, then
  1. Let abstyp = typ'' as abstyp
  2. If abstyp matches `VarT%`, then
    1. Let `VarT%`_abstyp(tid) = abstyp
    2. If $in_set<tid>(tid, $dom_map<tid, typ?>(cstr)), then
      1. Return $update_map<tid, typ?>(cstr, tid, ?(typ_a'''))
  2. Else If abstyp matches `SpecT%%`, then
    1. Let `SpecT%%`_abstyp(ptd_p, typ_p'*{typ_p' <- typ_p'*}) = abstyp
    2. If typ_a''' <: abstyp, then
      1. Let abstyp' = typ_a''' as abstyp
      2. If abstyp' matches `SpecT%%`, then
        1. Let `SpecT%%`_abstyp(ptd_a, typ_a'*{typ_a' <- typ_a'*}) = abstyp'
        2. Let typ_p'' = $specialize_typdef(ptd_p as typdef, typ_p'*{typ_p' <- typ_p'*})
        3. Let typ_a'' = $specialize_typdef(ptd_a as typdef, typ_a'*{typ_a' <- typ_a'*})
        4. If ($is_nominal(typ_p'') /\ $is_nominal(typ_a'')), then
          1. Let cstr' = $gen_cstr(cstr, typ_p'', typ_a'')
          2. Return $gen_cstrs(cstr', typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})
        4. Else
          1. Let cstr' = $gen_cstr(cstr, typ_p'', typ_a'')
          2. Return cstr'
2. If typ'' <: aliastyp, then
  1. Let `DefT%`_aliastyp(typ_p') = typ'' as aliastyp
  2. Return $gen_cstr(cstr, typ_p', typ_a''')
3. If typ_a''' <: aliastyp, then
  1. Let `DefT%`_aliastyp(typ_a') = typ_a''' as aliastyp
  2. Return $gen_cstr(cstr, typ'', typ_a')
4. If typ'' <: datatyp, then
  1. Let datatyp = typ'' as datatyp
  2. If datatyp matches `NewT%%`, then
    1. Let `NewT%%`_datatyp(id, typ_p') = datatyp
    2. If typ_a''' <: datatyp, then
      1. Let datatyp' = typ_a''' as datatyp
      2. If datatyp' matches `NewT%%`, then
        1. Let `NewT%%`_datatyp(id', typ_a') = datatyp'
        2. If (id = id'), then
          1. Return $gen_cstr(cstr, typ_p', typ_a')
  2. Else If datatyp matches `ListT%`, then
    1. Let `ListT%`_datatyp(typ'') = datatyp
    2. If typ_a''' <: datatyp, then
      1. Let datatyp' = typ_a''' as datatyp
      2. If datatyp' matches `ListT%`, then
        1. Let `ListT%`_datatyp(typ_a''') = datatyp'
        2. Return $gen_cstr(cstr, typ'', typ_a''')
  2. Else If datatyp matches `TupleT%`, then
    1. Let `TupleT%`_datatyp(typ''*{typ'' <- typ''*}) = datatyp
    2. If typ_a''' <: datatyp, then
      1. Let datatyp' = typ_a''' as datatyp
      2. If datatyp' matches `TupleT%`, then
        1. Let `TupleT%`_datatyp(typ_a'''*{typ_a''' <- typ_a'''*}) = datatyp'
        2. Return $gen_cstrs(cstr, typ''*{typ'' <- typ''*}, typ_a'''*{typ_a''' <- typ_a'''*})
  2. Else If datatyp matches `StackT%%`, then
    1. Let `StackT%%`_datatyp(typ_p', i_p) = datatyp
    2. If typ_a''' <: datatyp, then
      1. Let datatyp' = typ_a''' as datatyp
      2. If datatyp' matches `StackT%%`, then
        1. Let `StackT%%`_datatyp(typ_a', i_a) = datatyp'
        2. Return $gen_cstr(cstr, typ_p', typ_a')
  2. Else If datatyp matches `StructT%%`, then
    1. Let `StructT%%`_datatyp(id, (member_p, typ_p')*{member_p <- member_p*, typ_p' <- typ_p'*}) = datatyp
    2. If typ_a''' <: datatyp, then
      1. Let datatyp' = typ_a''' as datatyp
      2. If datatyp' matches `StructT%%`, then
        1. Let `StructT%%`_datatyp(id', (member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) = datatyp'
        2. If (id = id'), then
          1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})
  2. Else If datatyp matches `HeaderT%%`, then
    1. Let `HeaderT%%`_datatyp(id, (member_p, typ_p')*{member_p <- member_p*, typ_p' <- typ_p'*}) = datatyp
    2. If typ_a''' <: datatyp, then
      1. Let datatyp' = typ_a''' as datatyp
      2. If datatyp' matches `HeaderT%%`, then
        1. Let `HeaderT%%`_datatyp(id', (member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) = datatyp'
        2. If (id = id'), then
          1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})
  2. Else If datatyp matches `UnionT%%`, then
    1. Let `UnionT%%`_datatyp(id, (member_p, typ_p')*{member_p <- member_p*, typ_p' <- typ_p'*}) = datatyp
    2. If typ_a''' <: datatyp, then
      1. Let datatyp' = typ_a''' as datatyp
      2. If datatyp' matches `UnionT%%`, then
        1. Let `UnionT%%`_datatyp(id', (member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) = datatyp'
        2. If (id = id'), then
          1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})
5. If typ'' <: objtyp, then
  1. Let objtyp = typ'' as objtyp
  2. If objtyp matches `ExternT%%`, then
    1. Let `ExternT%%`_objtyp(id, fdenv_p) = objtyp
    2. If typ_a''' <: objtyp, then
      1. Let objtyp' = typ_a''' as objtyp
      2. If objtyp' matches `ExternT%%`, then
        1. Let `ExternT%%`_objtyp(id', fdenv_a) = objtyp'
        2. If (id = id'), then
          1. Let `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid_p, fd_p)*{fd_p <- fd_p*, fid_p <- fid_p*}) = fdenv_p
          2. Let `MAP%`_map<fid, funcdef>(`PAIR%%`_pair<fid, funcdef>(fid_a, fd_a)*{fd_a <- fd_a*, fid_a <- fid_a*}) = fdenv_a
          3. If $eq_set<fid>(`SET%`_set<fid>(fid_p*{fid_p <- fid_p*}), `SET%`_set<fid>(fid_a*{fid_a <- fid_a*})), then
            1. Return $gen_cstr_fd'(cstr, fid_p*{fid_p <- fid_p*}, fdenv_p, fdenv_a)
  2. Else If objtyp matches `ParserT%`, then
    1. Let `ParserT%`_objtyp(pt_p*{pt_p <- pt_p*}) = objtyp
    2. If typ_a''' <: objtyp, then
      1. Let objtyp' = typ_a''' as objtyp
      2. If objtyp' matches `ParserT%`, then
        1. Let `ParserT%`_objtyp(pt_a*{pt_a <- pt_a*}) = objtyp'
        2. (Let `%%%%`_paramtyp(_id, dir, typ_p', _val?) = pt_p)*{_id <- _id*, _val? <- _val?*, dir <- dir*, pt_p <- pt_p*, typ_p' <- typ_p'*}
        3. (Let `%%%%`_paramtyp(_id', dir', typ_a', _val?') = pt_a)*{_id' <- _id'*, _val?' <- _val?'*, dir' <- dir'*, pt_a <- pt_a*, typ_a' <- typ_a'*}
        4. If ((dir' = dir))*{dir <- dir*, dir' <- dir'*}, then
          1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})
  2. Else If objtyp matches `ControlT%`, then
    1. Let `ControlT%`_objtyp(pt_p*{pt_p <- pt_p*}) = objtyp
    2. If typ_a''' <: objtyp, then
      1. Let objtyp' = typ_a''' as objtyp
      2. If objtyp' matches `ControlT%`, then
        1. Let `ControlT%`_objtyp(pt_a*{pt_a <- pt_a*}) = objtyp'
        2. (Let `%%%%`_paramtyp(_id, dir, typ_p', _val?) = pt_p)*{_id <- _id*, _val? <- _val?*, dir <- dir*, pt_p <- pt_p*, typ_p' <- typ_p'*}
        3. (Let `%%%%`_paramtyp(_id', dir', typ_a', _val?') = pt_a)*{_id' <- _id'*, _val?' <- _val?'*, dir' <- dir'*, pt_a <- pt_a*, typ_a' <- typ_a'*}
        4. If ((dir' = dir))*{dir <- dir*, dir' <- dir'*}, then
          1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})
  2. Else If objtyp matches `PackageT%`, then
    1. Let `PackageT%`_objtyp(typ''*{typ'' <- typ''*}) = objtyp
    2. If typ_a''' <: objtyp, then
      1. Let objtyp' = typ_a''' as objtyp
      2. If objtyp' matches `PackageT%`, then
        1. Let `PackageT%`_objtyp(typ_a'''*{typ_a''' <- typ_a'''*}) = objtyp'
        2. Return $gen_cstrs(cstr, typ''*{typ'' <- typ''*}, typ_a'''*{typ_a''' <- typ_a'''*})
6. Otherwise
  1. Return cstr

;; ../../../../spec/4h-typing-call.watsup:192.1-192.60
def $gen_cstrs(cstr, typ_p*{typ_p <- typ_p*}, typ_a*{typ_a <- typ_a*})
1. If (|typ_p*{typ_p <- typ_p*}| = |typ_a*{typ_a <- typ_a*}|), then
  1. (Let cstr' = $gen_cstr(cstr, typ_p, typ_a))*{cstr' <- cstr'*, typ_a <- typ_a*, typ_p <- typ_p*}
  2. Return $merge_cstrs(cstr, cstr'*{cstr' <- cstr'*})

;; ../../../../spec/4h-typing-call.watsup:194.1-194.68
def $gen_cstr_fd(cstr, fd_p, fd_a)
1. Let `%%%%`_paramtyp(id_p, dir_p, typ_p, val_p?{val_p <- val_p?})*{dir_p <- dir_p*, id_p <- id_p*, typ_p <- typ_p*, val_p? <- val_p?*} = $get_params_funcdef(fd_p)
2. Let `%%%%`_paramtyp(id_a, dir_a, typ_a, val_a?{val_a <- val_a?})*{dir_a <- dir_a*, id_a <- id_a*, typ_a <- typ_a*, val_a? <- val_a?*} = $get_params_funcdef(fd_a)
3. Let cstr' = $gen_cstrs(cstr, typ_p*{typ_p <- typ_p*}, typ_a*{typ_a <- typ_a*})
4. Let cstr'' = $gen_cstr(cstr', $get_typ_ret_funcdef(fd_p), $get_typ_ret_funcdef(fd_a))
5. Return cstr''

;; ../../../../spec/4h-typing-call.watsup:196.1-196.71
def $gen_cstr_fd'(cstr, fid*, fdenv_p, fdenv_a)
1. If fid* matches [], then
  1. Return cstr
1. Else
  1. Let fid_h :: fid_t*{fid_t <- fid_t*} = fid*
  2. Let fd_p = $find_map<fid, funcdef>(fdenv_p, fid_h)
  3. Let fd_a = $find_map<fid, funcdef>(fdenv_a, fid_h)
  4. Let cstr' = $gen_cstr_fd(cstr, fd_p, fd_a)
  5. Return $gen_cstr_fd'(cstr', fid_t*{fid_t <- fid_t*}, fdenv_p, fdenv_a)

;; ../../../../spec/4h-typing-call.watsup:198.1-198.65
def $merge_cstr(cstr_o, cstr_n)
1. Let `SET%`_set<tid>(tid_o*{tid_o <- tid_o*}) = $dom_map<tid, typ?>(cstr_o)
2. If $eq_set<tid>($dom_map<tid, typ?>(cstr_o), $dom_map<tid, typ?>(cstr_n)), then
  1. Return $merge_cstr'(cstr_o, cstr_n, tid_o*{tid_o <- tid_o*}, `MAP%`_map<tid, typ?>([]))

;; ../../../../spec/4h-typing-call.watsup:200.1-200.88
def $merge_cstr'(cstr_o, cstr_n, tid*, cstr)
1. If tid* matches [], then
  1. Return cstr
1. Else
  1. Let tid_h :: tid_t*{tid_t <- tid_t*} = tid*
  2. If ($find_map<tid, typ?>(cstr_o, tid_h) = ?()), then
    1. If ($find_map<tid, typ?>(cstr_n, tid_h) = ?()), then
      1. Let cstr' = $update_map<tid, typ?>(cstr, tid_h, ?())
      2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')
    2. Let typ? = $find_map<tid, typ?>(cstr_n, tid_h)
    3. If typ? matches (_), then
      1. Let ?(typ_n) = typ?
      2. Let cstr' = $update_map<tid, typ?>(cstr, tid_h, ?(typ_n))
      3. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')
  3. Let typ? = $find_map<tid, typ?>(cstr_o, tid_h)
  4. If typ? matches (_), then
    1. Let ?(typ_o) = typ?
    2. If ($find_map<tid, typ?>(cstr_n, tid_h) = ?()), then
      1. Let cstr' = $update_map<tid, typ?>(cstr, tid_h, ?(typ_o))
      2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')
    3. Let typ?' = $find_map<tid, typ?>(cstr_n, tid_h)
    4. If typ?' matches (_), then
      1. Let ?(typ_n) = typ?'
      2. Sub_impl: `%<<%`(typ_o, typ_n)
      3. Let cstr' = $update_map<tid, typ?>(cstr, tid_h, ?(typ_n))
      4. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')
      5. If ~ Sub_impl: `%<<%`(typ_o, typ_n) holds, then
        1. Sub_impl: `%<<%`(typ_n, typ_o)
        2. Let cstr' = $update_map<tid, typ?>(cstr, tid_h, ?(typ_o))
        3. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')

;; ../../../../spec/4h-typing-call.watsup:202.1-202.67
def $merge_cstrs(cstr, map<tid, typ?>*)
1. If map<tid, typ?>* matches [], then
  1. Return cstr
1. Else
  1. Let cstr_h :: cstr_t*{cstr_t <- cstr_t*} = map<tid, typ?>*
  2. Let cstr' = $merge_cstr(cstr, cstr_h)
  3. Let cstr'' = $merge_cstrs(cstr', cstr_t*{cstr_t <- cstr_t*})
  4. Return cstr''

;; ../../../../spec/4h-typing-call.watsup:204.1-204.51
def $resolve_cstrs(map<tid, typ?>')
1. If (map<tid, typ?>' = `MAP%`_map<tid, typ?>([])), then
  1. Return `MAP%`_map<tid, typ>([])
2. Let `MAP%`_map<tid, typ?>(pair<tid, typ?>*) = map<tid, typ?>'
3. If pair<tid, typ?>* matches _ :: _, then
  1. Let `PAIR%%`_pair<tid, typ?>(tid_h, typ?) :: `PAIR%%`_pair<tid, typ?>(tid_t, typ_t?{typ_t <- typ_t?})*{tid_t <- tid_t*, typ_t? <- typ_t?*} = pair<tid, typ?>*
  2. If typ? matches (_), then
    1. Let ?(typ_h) = typ?
    2. If (typ_h =/= `AnyT`_synthtyp() as typ), then
      1. Let `MAP%`_map<tid, typ>(`PAIR%%`_pair<tid, typ>(tid_t', typ_t')*{tid_t' <- tid_t'*, typ_t' <- typ_t'*}) = $resolve_cstrs(`MAP%`_map<tid, typ?>(`PAIR%%`_pair<tid, typ?>(tid_t, typ_t?{typ_t <- typ_t?})*{tid_t <- tid_t*, typ_t? <- typ_t?*}))
      2. Return $add_map<tid, typ>(`MAP%`_map<tid, typ>(`PAIR%%`_pair<tid, typ>(tid_t', typ_t')*{tid_t' <- tid_t'*, typ_t' <- typ_t'*}), tid_h, typ_h)

;; ../../../../spec/4h-typing-call.watsup:328.1-328.56
def $infer_targs(tid*{tid <- tid*}, `%%%%`_paramtyp(id, dir, typ_p, val?{val <- val?})*{dir <- dir*, id <- id*, typ_p <- typ_p*, val? <- val?*}, typ_a*{typ_a <- typ_a*})
1. Let cstr = $empty_cstr(tid*{tid <- tid*})
2. Let cstr' = $gen_cstrs(cstr, typ_p*{typ_p <- typ_p*}, typ_a*{typ_a <- typ_a*})
3. Return $resolve_cstrs(cstr')

;; ../../../../spec/4h-typing-call.watsup:434.1-435.43
def $is_table_apply_in_action_arg(argIL)
1. Return false
