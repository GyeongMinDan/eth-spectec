rule Type_ok/voidt:
  p C |- VoidT : VoidT

rule Type_ok/errt:
  p C |- ErrT : ErrT

rule Type_ok/matchkindt:
  p C |- MatchKindT : MatchKindT

rule Type_ok/strt:
  p C |- StrT : StrT

rule Type_ok/intt:
  p C |- IntT : IntT

rule Type_ok/fintt:
  p C |- FIntT expr : FIntT w
  -- Eval_static: p C |- expr ~> val
  -- if w = $reduce_num(val)

rule Type_ok/fbitt:
  p C |- FBitT expr : FBitT w
  -- Eval_static: p C |- expr ~> val
  -- if w = $reduce_num(val)

rule Type_ok/vbitt:
  p C |- VBitT expr : VBitT w
  -- Eval_static: p C |- expr ~> val
  -- if w = $reduce_num(val)

rule Type_ok/stackt:
  p C |- StackT type expr : SpecT typdef typ
  ----
  -- Type_ok: p C |- type : typ
  -- Eval_static: p C |- expr ~> val
  -- if s = $reduce_num(val)
  ----
  -- if tid = $fresh_tid()
  -- if typdef = PolyD tid (StackT (VarT tid) s)

rule Type_ok/listt:
  p C |- ListT type : SpecT typdef typ
  -- Type_ok: p C |- type : typ
  -- if tid = $fresh_tid()
  -- if typdef = PolyD tid (ListT (VarT tid))

rule Type_ok/tuplet:
  p C |- TupleT type* : SpecT typdef typ*
  -- (Type_ok: p C |- type : typ)*
  -- if (tid = $fresh_tid())*
  -- if typdef = PolyD tid* (TupleT (VarT tid)*)

;; TODO handle the case where it is a type parameter
rule Type_ok/namet:
  p C |- NameT name : SpecT typdef eps
  -- if typdef = $find_typdef(p, C, name)

rule Type_ok/spect:
  p C |- SpecT name type* : SpecT typdef typ*
  -- if typdef = $find_typdef(p, C, name) 
  -- (Type_ok: p C |- type : typ)*
