;;
;; Empty statement
;;

rule Stmt_ok/emptys:
  p C f |- EmptyS : C f

;;
;; Assignment statement
;;

def $assignable(typ) : bool     hint(show % IS ASSIGNABLE)
def $assignable'(typ) : bool

def $assignable(typ) = $assignable'($canon_typ(typ))

def $assignable'(VoidT) = false
def $assignable'(ParserT paramtyp*) = false
def $assignable'(ControlT paramtyp*) = false
def $assignable'(PackageT typ*) = false
def $assignable'(TableT id typ) = false
def $assignable'(synthtyp) = false
def $assignable'(typ) = true
  -- otherwise


rule Lval_ok/namee:
  p C |- NameE name
  -- if typ dir ctk val? = $find_styp(p, C, name)
  -- if dir = OUT \/ dir = INOUT
  -- if $assignable(typ)

rule Lval_ok/arracce:
  p C |- ArrAccE expr_b expr_i
  -- Lval_ok: p C |- expr_b

rule Lval_ok/bitacce:
  p C |- BitAccE expr_b expr_l expr_h
  -- Lval_ok: p C |- expr_b

rule Lval_ok/expracce:
  p C |- ExprAccE expr_b member
  -- Lval_ok: p C |- expr_b


rule Stmt_ok/assigns:
  p C f |- AssignS expr_l expr_r : C f
  -- Expr_ok: p C |- expr_l : typ_l DYN
  -- Lval_ok: p C |- expr_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  -- Sub_impl: typ_r << typ_l

;;
;; Switch statement
;; (TODO-Jaehyun) check for duplicate label and non-last default label
;;

relation Switch_tbl_label_ok:
  cursor context id |- switchlabel

rule Switch_tbl_label_ok/exprl:
  p C id_t |- ExprL (NameE (CURRENT id_a))
  -- if id_e = $concat_texts("action\\_list(" id_t ")")
  -- if id = $concat_texts(id_e "." id_a)
  -- if TableEnumFieldV id_e id_a = $find_val(p, C, CURRENT id)

rule Switch_tbl_label_ok/defaultl:
  p C id_t |- DefaultL


relation Switch_tbl_case_ok:
  cursor context flow id |- switchcase : flow

rule Switch_tbl_case_ok/matchc:
  p C f id_t |- MatchC label block : f'
  -- Switch_tbl_label_ok: p C id_t |- label
  -- Stmt_ok: p C f |- BlockS block : C' f'

rule Switch_tbl_case_ok/fallc:
  p C f id_t |- FallC label : f
  -- Switch_tbl_label_ok: p C id_t |- label


relation Switch_tbl_cases_ok:
  cursor context flow id |- switchcase* : flow

rule Switch_tbl_cases_ok/empty:
  p C f id_t |- eps : f

rule Switch_tbl_cases_ok/seq:
  p C f id_t |- case_h case_t* : f''
  -- Switch_tbl_case_ok: p C f id_t |- case_h : f'
  -- Switch_tbl_cases_ok: p C f' id_t |- case_t* : f''


rule Stmt_ok/switchs-tbl:
  p C f |- SwitchS expr case* : C f'
  -- Expr_ok: p C |- expr : (TableEnumT id member) ctk_e
  -- if id = $concat_texts("action\\_list(" id_t ")")
  -- Switch_tbl_cases_ok: p C f id_t |- case* : f'


relation Switch_gen_label_ok:
  cursor context typ |- switchlabel

rule Switch_gen_label_ok/exprl:
  p C typ_s |- ExprL expr
  -- Expr_ok: p C |- expr : typ ctk
  -- Sub_impl: typ << typ_s

rule Switch_gen_label_ok/defaultl:
  p C typ_s |- DefaultL

relation Switch_gen_case_ok:
  cursor context flow typ |- switchcase : flow

rule Switch_gen_case_ok/matchc:
  p C f typ_s |- MatchC label block : f'
  -- Switch_gen_label_ok: p C typ_s |- label
  -- Stmt_ok: p C f |- BlockS block : C' f'

rule Switch_gen_case_ok/fallc:
  p C f typ_s |- FallC label : f
  -- Switch_gen_label_ok: p C typ_s |- label


relation Switch_gen_cases_ok:
  cursor context flow typ |- switchcase* : flow

rule Switch_gen_cases_ok/empty:
  p C f typ_s |- eps : f

rule Switch_gen_cases_ok/seq:
  p C f typ_s |- case_h case_t* : f''
  -- Switch_gen_case_ok: p C f typ_s |- case_h : f'
  -- Switch_gen_cases_ok: p C f' typ_s |- case_t* : f''


rule Stmt_ok/switchs-gen:
  p C f |- SwitchS expr case* : C f'
  -- Expr_ok: p C |- expr : typ ctk
  -- if typ' = $canon_typ(typ)
  ----
  -- (if typ' = ErrT \/ typ' = FIntT w \/ typ' = FBitT w \/ typ' = EnumT id member* \/ typ' = SEnumT id typ' (member, val)*)
  ----
  -- Switch_gen_cases_ok: p C f typ |- case* : f'

;;
;; If statement
;;

rule Stmt_ok/ifs:
  p C f |- IfS expr_c stmt_t stmt_f : C f'
  -- Expr_ok: p C |- expr_c : BoolT ctk_c
  -- Stmt_ok: p C f |- stmt_t : C_t f_t
  -- Stmt_ok: p C f |- stmt_f : C_f f_f
  -- if f' = $join_flow(f_t, f_f)

;;
;; Block statement
;;

rule Stmt_ok/blocks:
  p C f |- BlockS block : C''' f'
  -- if BlockB stmt* = block
  -- if C' = $enter(C)
  -- Stmts_ok: p C' f |- stmt* : C'' f'
  -- if C''' = $exit(C'')

;;
;; Exit statement
;;

rule Stmt_ok/exits:
  p C f |- ExitS : C f

;;
;; Return statement
;;

rule Stmt_ok/rets-none:
  LOCAL C f |- RetS eps : C RET
  -- if typ = VoidT
  -- if typ_r = $find_returntyp(C.LOCAL.KIND)
  -- Sub_impl: typ << typ_r

rule Stmt_ok/rets-some:
  LOCAL C f |- RetS expr? : C RET
  -- Expr_ok: p C |- expr : typ ctk
  -- if typ_r = $find_returntyp(C.LOCAL.KIND)
  -- Sub_impl: typ << typ_r

;;
;; Function call statement
;;

rule Stmt_ok/callfuncs:
  p C f |- CallFuncS name targ* arg* : C f
  ----
  -- FuncType_ok: p C |- name targ* arg* : functyp
  ----
  -- Call_ok: p C |- functyp arg* : typ

;;
;; Method call statement
;;

rule Stmt_ok/callmethods:
  p C f |- CallMethodS expr_b member targ* arg* : C f
  ----
  -- MethodType_ok: p C |- expr_b member targ* arg* : functyp
  ----
  -- Call_ok: p C |- functyp arg* : typ

;;
;; Instantiation statement
;;

rule Stmt_ok/callinsts:
  p C f |- CallInstS name targ* arg* : C f
  -- if consdef = $find_consdef(p, C, name)
  -- if constyp = $specialize_consdef(consdef, eps)
  -- Inst_ok: p C |- constyp eps : typ
  ----
  -- if ($canon_typ(typ) = ParserT paramtyp*) \/ ($canon_typ(typ) = ControlT paramtyp*)
  ----
  -- if (TOP id = name) \/ (CURRENT id = name)
  -- if C' = $add_typ(p, C, id, (typ, NO, CTK))
  ----
  -- Stmt_ok: p C' f |- CallMethodS (NameE (CURRENT id)) "apply" targ* arg* : C' f'

;;
;; Transition statement
;;

rule Stmt_ok/transs:
  p C f |- TransS expr : C f
  -- Expr_ok: p C |- expr : StateT ctk

;;
;; Declaration statement
;;

rule Stmt_ok/decls:
  p C f |- DeclS decl : C' f
  -- Decl_ok: p C |- decl : C'

;;
;; Statement sequence
;;

rule Stmts_ok/nil:
  p C f |- eps : C f

rule Stmts_ok/cons:
  p C f |- stmt_h stmt_t* : C'' f''
  -- Stmt_ok: p C f |- stmt_h : C' f'
  -- Stmts_ok: p C' f' |- stmt_t* : C'' f''
