;; ================================
;; 06-helpers-validator.spectec
;; validator predicates & helpers
;; ================================


;; ------------------------------------------------------------
;; compute_activation_exit_epoch : epoch -> epoch
;; ------------------------------------------------------------
dec $compute_activation_exit_epoch(epoch) : epoch
def $compute_activation_exit_epoch(epoch) = $(epoch + 1 + $MAX_SEED_LOOKAHEAD)

;; ------------------------------------------------------------
;; is_active_validator : (validator, epoch) -> bool
;; ------------------------------------------------------------
dec $is_active_validator(validator, epoch) : boolean

def $is_active_validator(validator, epoch) = true
  -- if $(validator.ACTIVATION_EPOCH <= epoch)
  -- if $(epoch < validator.EXIT_EPOCH)

def $is_active_validator(validator, epoch) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_eligible_for_activation_queue : validator -> bool
;; ------------------------------------------------------------
dec $is_eligible_for_activation_queue(validator) : boolean

def $is_eligible_for_activation_queue(validator) = true
  -- if $(validator.ACTIVATION_ELIGIBILITY_EPOCH = $FAR_FUTURE_EPOCH)
  -- if $(validator.EFFECTIVE_BALANCE = $MAX_EFFECTIVE_BALANCE)

def $is_eligible_for_activation_queue(validator) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_eligible_for_activation : (state, validator) -> bool
;; ------------------------------------------------------------
dec $is_eligible_for_activation(beaconState, validator) : boolean

def $is_eligible_for_activation(state, validator) = true
  -- if $(validator.ACTIVATION_ELIGIBILITY_EPOCH <= state.FINALIZED_CHECKPOINT.EPOCH)
  -- if $(validator.ACTIVATION_EPOCH = $FAR_FUTURE_EPOCH)

def $is_eligible_for_activation(state, validator) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_slashable_validator : (validator, epoch) -> bool
;; ------------------------------------------------------------
dec $is_slashable_validator(validator, epoch) : boolean

def $is_slashable_validator(validator, epoch) = true
  -- if $(validator.SLASHED = false)
  -- if $(validator.ACTIVATION_EPOCH <= epoch)
  -- if $(epoch < validator.WITHDRAWABLE_EPOCH)

def $is_slashable_validator(validator, epoch) = false
  -- otherwise

;; ------------------------------------------------------------
;; has_eth1_withdrawal_credential : validator -> bool
;; ------------------------------------------------------------
dec $has_eth1_withdrawal_credential(validator) : boolean

def $has_eth1_withdrawal_credential(validator) = true
  -- if $get_first_byte(validator.WITHDRAWAL_CREDENTIALS) = $ETH1_ADDRESS_WITHDRAWAL_PREFIX

def $has_eth1_withdrawal_credential(validator) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_fully_withdrawable_validator : (validator, balance:gwei, epoch) -> bool
;; ------------------------------------------------------------
dec $is_fully_withdrawable_validator(validator, gwei, epoch) : boolean

def $is_fully_withdrawable_validator(validator, balance, epoch) = true
  -- if $has_eth1_withdrawal_credential(validator) = true
  -- if $(validator.WITHDRAWABLE_EPOCH <= epoch)
  -- if $(balance > 0)

def $is_fully_withdrawable_validator(validator, balance, epoch) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_partially_withdrawable_validator : (validator, balance:gwei) -> bool
;; ------------------------------------------------------------
dec $is_partially_withdrawable_validator(validator, gwei) : boolean

def $is_partially_withdrawable_validator(validator, balance) = true
  -- if $has_eth1_withdrawal_credential(validator) = true
  -- if $(validator.EFFECTIVE_BALANCE = $MAX_EFFECTIVE_BALANCE)
  -- if $(balance > $MAX_EFFECTIVE_BALANCE)

def $is_partially_withdrawable_validator(validator, balance) = false
  -- otherwise

;; ------------------------------------------------------------
;; get_index_for_new_validator
;; ------------------------------------------------------------
dec $get_index_for_new_validator(beaconState) : validatorIndex
def $get_index_for_new_validator(state) =
  $( |state.VALIDATORS| )

;; ------------------------------------------------------------
;; get_validator_from_deposit(pubkey, withdrawal_credentials, amount) : validator
;; ------------------------------------------------------------
dec $get_validator_from_deposit(blsPubkey, bytes32, uint64) : validator

def $get_validator_from_deposit(blsPubkey_pk, bytes32_wc, uint64_amount) = validator_new
  -- if $( uint64_amount \ $EFFECTIVE_BALANCE_INCREMENT ) = gwei_mod
  -- if $( uint64_amount - gwei_mod ) = gwei_floor_inc
  -- if $min_uint64(gwei_floor_inc, $MAX_EFFECTIVE_BALANCE) = gwei_effective
  -- if validator_new =
       { PUBKEY                       blsPubkey_pk,
         WITHDRAWAL_CREDENTIALS       bytes32_wc,
         EFFECTIVE_BALANCE            gwei_effective,
         SLASHED                      false,
         ACTIVATION_ELIGIBILITY_EPOCH $FAR_FUTURE_EPOCH,
         ACTIVATION_EPOCH             $FAR_FUTURE_EPOCH,
         EXIT_EPOCH                   $FAR_FUTURE_EPOCH,
         WITHDRAWABLE_EPOCH           $FAR_FUTURE_EPOCH }

;; ------------------------------------------------------------
;; add_validator_to_registry(state, pubkey, withdrawal_credentials, amount) : beaconState
;; ------------------------------------------------------------

dec $add_validator_to_registry(beaconState, blsPubkey, bytes32, uint64) : beaconState

def $add_validator_to_registry(state_in, blsPubkey_pk, bytes32_wc, uint64_amount) = state_out
  -- if $get_index_for_new_validator(state_in) = validatorIndex_idx
  -- if $get_validator_from_deposit(blsPubkey_pk, bytes32_wc, uint64_amount) = validator_new
  ;; 여기서부터 state의 내용이 업데이트
  ;; validator 추가
  -- if $set_or_append_list_<validator>(state_in.VALIDATORS, validatorIndex_idx, validator_new) = validator_list_updated*
  -- if state_1 = state_in[.VALIDATORS = validator_list_updated*]
  ;; balance 추가
  -- if $set_or_append_list_<gwei>(state_1.BALANCES, validatorIndex_idx, uint64_amount) = balance_updated*
  -- if state_2 = state_1[.BALANCES = balance_updated*]
  ;; participationFlags 추가(previous)
  -- if $set_or_append_list_<participationFlags>(state_2.PREVIOUS_EPOCH_PARTICIPATION, validatorIndex_idx, 0) = participationFlags_prev_updated*
  -- if state_3 = state_2[.PREVIOUS_EPOCH_PARTICIPATION = participationFlags_prev_updated*]
  ;; participationFlags 추가(previous)
  -- if $set_or_append_list_<participationFlags>(state_3.CURRENT_EPOCH_PARTICIPATION, validatorIndex_idx, 0) = participationFlags_cur_updated*
  -- if state_4 = state_3[.CURRENT_EPOCH_PARTICIPATION = participationFlags_cur_updated*]
  ;; inactivity_scores 추가
  -- if $set_or_append_list_<uint64>(state_4.INACTIVITY_SCORES, validatorIndex_idx, 0) = uint64_inactivity_updated*
  -- if state_out = state_4[.INACTIVITY_SCORES = uint64_inactivity_updated*]

