;;
;; Collection of relations (for they are mutually recursive)
;;

relation Interp_extern: sto ctx |- str : sig ctx

relation Interp_call: sto ctx |- expr type* arg* : sig ctx
relation Interp_fcall: sto ctx |- name type* arg* : sig ctx
relation Interp_mcall: sto ctx |- expr str type* arg* : sig ctx
relation Interp_inter_call: sto ctx ctx |- func type* arg* : sig ctx
relation Interp_intra_call: sto ctx ctx |- func type* arg* : sig ctx

relation Interp_type : ctx |- type : rtype

relation Interp_arg : sto ctx |- arg : ctx val
relation Interp_args : sto ctx |- arg* : ctx val*

relation Interp_expr : sto ctx |- expr : ctx val
relation Interp_exprs : sto ctx |- expr* : ctx val*

relation Interp_stmt: sto sig ctx |- stmt : sig ctx
relation Interp_stmts: sto sig ctx |- block : sig ctx

relation Interp_write : sto ctx |- expr <- val -| ctx

rule Interp_write/e_var:
  S C |- (E_VAR (BARE id)) <- val -| C'
  -- if rtype = $find_var_type(C, id)
  -- if val' = $cast(val, rtype)
  -- if C' = $update_var(C, id, rtype, val')

rule Interp_write/e_expracc-struct:
  S C |- (E_EXPRACC expr_base field) <- val -| C''
  -- Interp_expr: S C |- expr_base : C' (V_STRUCT (field, val')*)
  -- if (field', val'')* = $write_field((field, val')*, field, val)
  -- Interp_write: S C' |- expr_base <- (V_STRUCT (field', val'')*) -| C''

rule Interp_write/e_expracc-header:
  S C |- (E_EXPRACC expr_base field) <- val -| C''
  -- Interp_expr: S C |- expr_base : C' (V_HEADER valid (field, val')*)
  -- if (field', val'')* = $write_field((field, val')*, field, val)
  -- Interp_write: S C' |- expr_base <- (V_HEADER valid (field', val'')*) -| C''
