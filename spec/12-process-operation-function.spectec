;;
;; process_proposer_slashing
;; 
relation ProcessProposerSlashing:
  beaconState proposerSlashing ~> beaconState
  hint(input %0 %1)

rule ProcessProposerSlashing/main:
  state_beaconState proposerSlashing_ps ~> state_slashed
  -- if beaconBlockHeader_1 = proposerSlashing_ps.SIGNED_HEADER_1.MESSAGE
  -- if beaconBlockHeader_2 = proposerSlashing_ps.SIGNED_HEADER_2.MESSAGE
  -- if $(beaconBlockHeader_1.SLOT = beaconBlockHeader_2.SLOT)
  -- if $(beaconBlockHeader_1.PROPOSER_INDEX = beaconBlockHeader_2.PROPOSER_INDEX)
  -- if ~(beaconBlockHeader_1 = beaconBlockHeader_2)
  -- if validatorIndex_prop = beaconBlockHeader_1.PROPOSER_INDEX
  -- if $(validatorIndex_prop < |state_beaconState.VALIDATORS|)
  -- if state_beaconState.VALIDATORS[validatorIndex_prop] = validator_prop
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $is_slashable_validator(validator_prop, epoch_cur) = true
  -- if signedBeaconBlockHeader_header_1 = proposerSlashing_ps.SIGNED_HEADER_1
  -- if $compute_epoch_at_slot(signedBeaconBlockHeader_header_1.MESSAGE.SLOT) = epoch_h1
  -- if $get_domain(state_beaconState, $DOMAIN_BEACON_PROPOSER, epoch_h1) = domain_h1
  -- if $compute_signing_root_beaconBlockHeader(signedBeaconBlockHeader_header_1.MESSAGE, domain_h1) = root_sign_h1
  -- if $bls_verify(validator_prop.PUBKEY, root_sign_h1, signedBeaconBlockHeader_header_1.SIGNATURE) = true
  -- if signedBeaconBlockHeader_header_2 = proposerSlashing_ps.SIGNED_HEADER_2
  -- if $compute_epoch_at_slot(signedBeaconBlockHeader_header_2.MESSAGE.SLOT) = epoch_h2
  -- if $get_domain(state_beaconState, $DOMAIN_BEACON_PROPOSER, epoch_h2) = domain_h2
  -- if $compute_signing_root_beaconBlockHeader(signedBeaconBlockHeader_header_2.MESSAGE, domain_h2) = root_sign_h2
  -- if $bls_verify(validator_prop.PUBKEY, root_sign_h2, signedBeaconBlockHeader_header_2.SIGNATURE) = true
  -- if state_slashed = $slash_validator(state_beaconState, validatorIndex_prop, eps)

;;
;; process_attester_slashing
;;
relation ProcessAttesterSlashing:
  beaconState attesterSlashing ~> beaconState
  hint(input %0 %1)

rule ProcessAttesterSlashing/main:
  state_beaconState attesterSlashing_as ~> state_after_slash
  -- if indexedAttestation_1 = attesterSlashing_as.ATTESTATION_1
  -- if indexedAttestation_2 = attesterSlashing_as.ATTESTATION_2
  ;; assert is_slashable_attestation_data
  -- if $is_slashable_attestation_data(indexedAttestation_1.DATA, indexedAttestation_2.DATA) = true
  ;; assert is_valid_indexed_attestation
  -- if $is_valid_indexed_attestation(state_beaconState, indexedAttestation_1) = true
  -- if $is_valid_indexed_attestation(state_beaconState, indexedAttestation_2) = true
  ;; set
  -- if validatorIndex_list_1* = indexedAttestation_1.ATTESTING_INDICES
  -- if validatorIndex_list_2* = indexedAttestation_2.ATTESTING_INDICES
  -- if $to_set_<validatorIndex>(validatorIndex_list_1*) = validatorIndex_set_1*
  -- if $to_set_<validatorIndex>(validatorIndex_list_2*) = validatorIndex_set_2*
  -- if $set_intersection_<validatorIndex>(validatorIndex_set_1*, validatorIndex_set_2*) = validatorIndex_intersection*
  -- if $sort_<validatorIndex>(validatorIndex_intersection*) = validatorIndex_sorted*
  ;; assert slashed_any -> 1보다 큰 is_slashable 의 결과로 생각..
  -- if $filter_list_2_<validatorIndex, beaconState>(validatorIndex_sorted*, state_beaconState, def $is_slashable_now) = validatorIndex_slashable_now*
  -- if $( |validatorIndex_slashable_now*| > 0 )
  ;; use fold_list_2
  -- if state_after_slash =
       $fold_list_2_<validatorIndex, beaconState>(
         validatorIndex_sorted*,
         state_beaconState,
         def $slash_if_eligible
       )

;;
;; process_attestation
;;

;; TODO


;; 
;; process_deposit
;;
relation ProcessDeposit:
  beaconState deposit ~> beaconState
  hint(input %0 %1)

rule ProcessDeposit/main:
  state deposit ~> state_applied
  -- if $hash_tree_root_depositData(deposit.DATA) = root_leaf
  -- if $( $DEPOSIT_CONTRACT_TREE_DEPTH + 1 ) = uint64_depth_plus_1
  -- if $is_valid_merkle_branch(
         root_leaf,
         deposit.PROOF,
         uint64_depth_plus_1,
         state.ETH1_DEPOSIT_INDEX,
         state.ETH1_DATA.DEPOSIT_ROOT
       ) = true
  -- if $(state.ETH1_DEPOSIT_INDEX + 1) = uint64_deposit_index_next
  -- if state_inc = state[.ETH1_DEPOSIT_INDEX = uint64_deposit_index_next]
  -- if state_applied =
       $apply_deposit(
         state_inc,
         deposit.DATA.PUBKEY,
         deposit.DATA.WITHDRAWAL_CREDENTIALS,
         deposit.DATA.AMOUNT,
         deposit.DATA.SIGNATURE
       )

;; 
;; process_voluntary_exit
;; 

relation ProcessVoluntaryExit:
  beaconState signedVoluntaryExit ~> beaconState
  hint(input %0 %1)

rule ProcessVoluntaryExit/main:
  state signedVoluntaryExit ~> state_after_exit
  -- if voluntaryExit = signedVoluntaryExit.MESSAGE
  -- if validatorIndex_exit = voluntaryExit.VALIDATOR_INDEX
  -- if $(validatorIndex_exit < |state.VALIDATORS|)
  -- if state.VALIDATORS[validatorIndex_exit] = validator
  -- if $get_current_epoch(state) = epoch_cur
  -- if $is_active_validator(validator, epoch_cur) = true
  -- if $(validator.EXIT_EPOCH = $FAR_FUTURE_EPOCH)
  -- if $(epoch_cur >= voluntaryExit.EPOCH)
  -- if $(epoch_cur >= validator.ACTIVATION_EPOCH + $SHARD_COMMITTEE_PERIOD)
  -- if $get_domain(state, $DOMAIN_VOLUNTARY_EXIT, voluntaryExit.EPOCH) = domain_exit
  -- if $compute_signing_root_voluntary_exit(voluntaryExit, domain_exit) = root_vol_exit_signing_root
  -- if $bls_verify(validator.PUBKEY, root_vol_exit_signing_root, signedVoluntaryExit.SIGNATURE) = true
  -- if state_after_exit = $initiate_validator_exit(state, validatorIndex_exit)

;; 
;; process_bls_to_execution_change
;; 
relation ProcessBLSToExecutionChange:
  beaconState signedBlsToExecutionChange ~> beaconState
  hint(input %0 %1)

rule ProcessBLSToExecutionChange/main:
  state signedBlsToExecutionChange ~> state_updated
  -- if blsToExecutionChange = signedBlsToExecutionChange.MESSAGE
  -- if validatorIndex_change = blsToExecutionChange.VALIDATOR_INDEX
  -- if $(validatorIndex_change < |state.VALIDATORS|)
  -- if state.VALIDATORS[validatorIndex_change] = validator
  -- if $get_first_byte(validator.WITHDRAWAL_CREDENTIALS) = $BLS_WITHDRAWAL_PREFIX
  -- if $hash_<blsPubkey>(blsToExecutionChange.FROM_BLS_PUBKEY) = bytes32_pk_hash
  -- if $strip_first_byte(validator.WITHDRAWAL_CREDENTIALS) = bytes32_wc_tail
  -- if $strip_first_byte(bytes32_pk_hash) = bytes32_pk_tail
  -- if $(bytes32_wc_tail = bytes32_pk_tail)
  -- if $compute_domain($DOMAIN_BLS_TO_EXECUTION_CHANGE, eps, state.GENESIS_VALIDATORS_ROOT) = domain_btec
  -- if $compute_signing_root_bls_to_execution_change(blsToExecutionChange, domain_btec) = root_sign
  -- if $bls_verify(blsToExecutionChange.FROM_BLS_PUBKEY, root_sign, signedBlsToExecutionChange.SIGNATURE) = true
  -- if $make_withdrawal_credentials_eth1(blsToExecutionChange.TO_EXECUTION_ADDRESS) = bytes32_new_wc
  -- if validator_updated = validator[.WITHDRAWAL_CREDENTIALS = bytes32_new_wc]
  -- if state.VALIDATORS[[validatorIndex_change] = validator_updated] = validator_update*
  -- if state_updated = state[.VALIDATORS = validator_update*]