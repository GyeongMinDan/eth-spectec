;;
;; process_justification_and_finalization
;;
relation Process_justification_and_finalization:
  beaconState ~> beaconState
  hint(input %0)

rule Process_justification_and_finalization/skip:
  state_beaconState ~> state_beaconState
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $(epoch_cur <= ($GENESIS_EPOCH + 1))

rule Process_justification_and_finalization/main:
  state_beaconState ~> state_weighed
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $get_previous_epoch(state_beaconState) = epoch_prev
  -- if $get_unslashed_participating_indices(state_beaconState, $TIMELY_TARGET_FLAG_INDEX, epoch_prev) = validatorIndex_prev_indices*
  -- if $get_unslashed_participating_indices(state_beaconState, $TIMELY_TARGET_FLAG_INDEX, epoch_cur)  = validatorIndex_curr_indices*
  -- if $get_total_active_balance(state_beaconState) = gwei_total_active
  -- if $get_total_balance(state_beaconState, validatorIndex_prev_indices*) = gwei_prev_target_bal
  -- if $get_total_balance(state_beaconState, validatorIndex_curr_indices*) = gwei_curr_target_bal
  -- if $weigh_justification_and_finalization(state_beaconState, gwei_total_active, gwei_prev_target_bal, gwei_curr_target_bal) = state_weighed


;;
;; process_inactivity_updates
;;
relation Process_inactivity_updates:
  beaconState ~> beaconState
  hint(input %0)


;;
;; process_rewards_and_penalties
;;
relation Process_rewards_and_penalties:
  beaconState ~> beaconState
  hint(input %0)

rule Process_rewards_and_penalties/skip_genesis:
  state ~> state
  -- if $get_current_epoch(state) = $GENESIS_EPOCH

rule Process_rewards_and_penalties/main:
  state ~> state_out
  ;; 1 flag deltas 수집: 0..|PARTICIPATION_FLAG_WEIGHTS|-1
  -- if $range(|$PARTICIPATION_FLAG_WEIGHTS|) = nat_flag_idx*
  -- if ( $get_flag_index_deltas(state, nat_flag_idx) = (gwei_rf*, gwei_pf*) )*
  ;;    ↑ 반복으로 gwei_rf** / gwei_pf** 생성
  ;; 2 inactivity deltas 추가 → 총 4세트
  -- if $get_inactivity_penalty_deltas(state) = (gwei_ri*, gwei_pi*)
  -- if gwei_rf** ++ [gwei_ri*] = gwei_reward_2d**
  -- if gwei_pf** ++ [gwei_pi*] = gwei_penalty_2d**
  ;; 3 검증자 인덱스 목록 준비 
  -- if $range(|state.VALIDATORS|) = nat_idx*
  -- if validatorIndex_idx* = nat_idx*          
  ;; 4 바깥 세트(reward*, penalty*)들에 대해 차례대로 적용 (fold 1회)
  -- if $fold_<beaconState, (validatorIndex*, (gwei*, gwei*))>(
         def $apply_one_round_captured,
         state,
         (validatorIndex_idx*, (gwei_reward_2d*, gwei_penalty_2d*))*
       ) = state_out

;;
;; process_registry_updates
;;
relation Process_registry_updates:
  beaconState ~> beaconState
  hint(input %0)

;;
;; process_slashings
;;
relation Process_slashings:
  beaconState ~> beaconState
  hint(input %0)


;;
;; process_eth1_data_reset
;;
relation Process_eth1_data_reset:
  beaconState ~> beaconState
  hint(input %0)

rule Process_eth1_data_reset/skip:
  state_beaconState ~> state_beaconState
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_ETH1_VOTING_PERIOD) = uint64_r
  -- if ~(uint64_r = 0)

rule Process_eth1_data_reset/main:
  state_beaconState ~> state_updated
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_ETH1_VOTING_PERIOD) = 0
  -- if state_updated = state_beaconState[.ETH1_DATA_VOTES = eps]


;;
;; process_effective_balance_updates
;;
relation Process_effective_balance_updates:
  beaconState ~> beaconState
  hint(input %0)

rule Process_effective_balance_updates/main:
  state_beaconState ~> state_updated
  -- if state_beaconState.VALIDATORS = validator_list*
  -- if $enumerate_<validator>(validator_list*) = (n, validator_item)*
  -- if $map_list_2_<(nat, validator), beaconState, validator>(
         (n, validator_item)*,
         state_beaconState,
         def $rebalance_validator_enumerated
       ) = validator_updated_list*
  -- if state_updated = state_beaconState[.VALIDATORS = validator_updated_list*]

;;
;; process_slashings_reset
;;
relation Process_slashings_reset:
  beaconState ~> beaconState
  hint(input %0)

rule Process_slashings_reset/skip:
  state_beaconState ~> state_beaconState
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SLASHINGS_VECTOR) = uint64_n
  -- if $(uint64_n >= |state_beaconState.SLASHINGS|)

rule Process_slashings_reset/main:
  state_beaconState ~> state_updated
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SLASHINGS_VECTOR) = uint64_n
  -- if $(uint64_n < |state_beaconState.SLASHINGS|)
  -- if state_beaconState.SLASHINGS[[uint64_n] = 0] = gwei_update*
  -- if state_updated = state_beaconState[.SLASHINGS = gwei_update*]


;;
;; process_randao_mixes_reset
;;
relation Process_randao_mixes_reset:
  beaconState ~> beaconState
  hint(input %0)

rule Process_randao_mixes_reset/skip:
  state_beaconState ~> state_beaconState
  -- if $get_current_epoch(state_beaconState) = epoch_current
  -- if $(epoch_current + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_HISTORICAL_VECTOR) = uint64_n
  -- if $(uint64_n >= |state_beaconState.RANDAO_MIXES|)

rule Process_randao_mixes_reset/main:
  state_beaconState ~> state_updated
  -- if $get_current_epoch(state_beaconState) = epoch_current
  -- if $(epoch_current + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_HISTORICAL_VECTOR) = uint64_n
  -- if $get_randao_mix(state_beaconState, epoch_current) = bytes32_mix
  -- if $(uint64_n < |state_beaconState.RANDAO_MIXES|)
  -- if state_beaconState.RANDAO_MIXES[[uint64_n] = bytes32_mix] = bytes32_randao_mixes_update*
  -- if state_updated = state_beaconState[.RANDAO_MIXES = bytes32_randao_mixes_update*]



;;
;; process_historical_summaries_update
;;
relation Process_historical_summaries_update:
  beaconState ~> beaconState
  hint(input %0)

rule Process_historical_summaries_update/skip:
  state_beaconState ~> state_beaconState
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $(epoch_cur + 1) = epoch_next
  -- if $(epoch_next \ ($SLOTS_PER_HISTORICAL_ROOT / $SLOTS_PER_EPOCH)) = uint64_r
  -- if ~(uint64_r = 0)

rule Process_historical_summaries_update/main:
  state_beaconState ~> state_updated
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $(epoch_cur + 1) = epoch_next
  -- if $( epoch_next \ ($SLOTS_PER_HISTORICAL_ROOT / $SLOTS_PER_EPOCH) ) = 0
  -- if $hash_tree_root_roots(state_beaconState.BLOCK_ROOTS) = root_block_summary
  -- if $hash_tree_root_roots(state_beaconState.STATE_ROOTS) = root_state_summary
  -- if { BLOCK_SUMMARY_ROOT root_block_summary, STATE_SUMMARY_ROOT root_state_summary } = historicalSummary_new
  -- if state_beaconState.HISTORICAL_SUMMARIES ++ [ historicalSummary_new ] = historicalSummary_update*
  -- if state_updated = state_beaconState[.HISTORICAL_SUMMARIES = historicalSummary_update*]


;;
;; process_participation_flag_updates
;;
relation Process_participation_flag_updates:
  beaconState ~> beaconState
  hint(input %0)

rule Process_participation_flag_updates/main:
  state_beaconState ~> state_updated
  -- if participationFlags_prev* = state_beaconState.CURRENT_EPOCH_PARTICIPATION
  -- if $( |state_beaconState.VALIDATORS| ) = uint64_len_validators
  -- if $repeat_<participationFlags>(0, uint64_len_validators) = participationFlags_zero*
  -- if state_mid = state_beaconState[.PREVIOUS_EPOCH_PARTICIPATION = participationFlags_prev*]
  -- if state_updated = state_mid[.CURRENT_EPOCH_PARTICIPATION = participationFlags_zero*]


;;
;; process_sync_committee_updates
;;
relation Process_sync_committee_updates:
  beaconState ~> beaconState
  hint(input %0)

rule Process_sync_committee_updates/skip:
  state_beaconState ~> state_beaconState
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SYNC_COMMITTEE_PERIOD) = uint64_r
  -- if ~(uint64_r = 0)

rule Process_sync_committee_updates/main:
  state_beaconState ~> state_updated
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SYNC_COMMITTEE_PERIOD) = 0
  -- if syncCommittee_next = $get_next_sync_committee(state_beaconState)
  -- if state_updated =
       state_beaconState[.CURRENT_SYNC_COMMITTEE = state_beaconState.NEXT_SYNC_COMMITTEE]
                        [.NEXT_SYNC_COMMITTEE    = syncCommittee_next]
