;;
;; process_block_header
;;
relation Process_block_header:
  beaconState beaconBlock ~> beaconState
  hint(input %0 %1)

rule Process_block_header/main:
  state_beaconState block_beaconBlock ~> state_updated
  -- if $(block_beaconBlock.SLOT = state_beaconState.SLOT)
  -- if $(state_beaconState.LATEST_BLOCK_HEADER.SLOT < block_beaconBlock.SLOT)
  -- if $get_beacon_proposer_index(state_beaconState) = validatorIndex_prop_vi
  -- if $(block_beaconBlock.PROPOSER_INDEX = validatorIndex_prop_vi)
  -- if root_parent_expected_root = $hash_tree_root_beaconBlockHeader(state_beaconState.LATEST_BLOCK_HEADER)
  -- if $(block_beaconBlock.PARENT_ROOT = root_parent_expected_root)
  -- if root_body_root_new = $hash_tree_root_beaconBlockBody(block_beaconBlock.BODY)
  -- if beaconBlockHeader_new =
       { SLOT block_beaconBlock.SLOT,
         PROPOSER_INDEX block_beaconBlock.PROPOSER_INDEX,
         PARENT_ROOT block_beaconBlock.PARENT_ROOT,
         STATE_ROOT $ZERO_ROOT,
         BODY_ROOT root_body_root_new }
  -- if $(validatorIndex_prop_vi < |state_beaconState.VALIDATORS|)
  -- if state_beaconState.VALIDATORS[validatorIndex_prop_vi] = validator_proposer
  -- if $(validator_proposer.SLASHED = false)
  -- if state_updated = state_beaconState[.LATEST_BLOCK_HEADER = beaconBlockHeader_new]


;;
;; process_withdrawals
;;   
;;
relation Process_withdrawals:
  beaconState executionPayload ~> beaconState
  hint(input %0 %1)



;;
;; process_execution_payload
;;
relation Process_execution_payload:
  beaconState beaconBlockBody ~> beaconState
  hint(input %0 %1)

rule Process_execution_payload/main:
  state_beaconState body_beaconBlockBody ~> state_updated
  -- if executionPayload_block = body_beaconBlockBody.EXECUTION_PAYLOAD
  -- if $(executionPayload_block.PARENT_HASH = state_beaconState.LATEST_EXECUTION_PAYLOAD_HEADER.BLOCK_HASH)
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $get_randao_mix(state_beaconState, epoch_cur) = bytes32_randao_expected
  -- if $(executionPayload_block.PREV_RANDAO = bytes32_randao_expected)
  -- if $compute_time_at_slot(state_beaconState, state_beaconState.SLOT) = uint64_ts_expected
  -- if $(executionPayload_block.TIMESTAMP = uint64_ts_expected)
  -- if $ee_verify_and_notify_new_payload(executionPayload_block) = true
  -- if $hash_tree_root_tx(executionPayload_block.TRANSACTIONS) = root_tx
  -- if $hash_tree_root_withdrawals(executionPayload_block.WITHDRAWALS) = root_withdrawal
  -- if executionPayloadHeader_new =
       { PARENT_HASH        executionPayload_block.PARENT_HASH,
         FEE_RECIPIENT      executionPayload_block.FEE_RECIPIENT,
         STATE_ROOT         executionPayload_block.STATE_ROOT,
         RECEIPTS_ROOT      executionPayload_block.RECEIPTS_ROOT,
         LOGS_BLOOM         executionPayload_block.LOGS_BLOOM,
         PREV_RANDAO        executionPayload_block.PREV_RANDAO,
         BLOCK_NUMBER       executionPayload_block.BLOCK_NUMBER,
         GAS_LIMIT          executionPayload_block.GAS_LIMIT,
         GAS_USED           executionPayload_block.GAS_USED,
         TIMESTAMP          executionPayload_block.TIMESTAMP,
         EXTRA_DATA         executionPayload_block.EXTRA_DATA,
         BASE_FEE_PER_GAS   executionPayload_block.BASE_FEE_PER_GAS,
         BLOCK_HASH         executionPayload_block.BLOCK_HASH,
         TRANSACTIONS_ROOT  root_tx,
         WITHDRAWALS_ROOT   root_withdrawal }
  -- if state_updated = state_beaconState[.LATEST_EXECUTION_PAYLOAD_HEADER = executionPayloadHeader_new]



;;
;; process_randao
;;
relation Process_randao:
  beaconState beaconBlockBody ~> beaconState
  hint(input %0 %1)

rule Process_randao/main:
  state_beaconState body_beaconBlockBody ~> state_updated
  -- if $get_current_epoch(state_beaconState) = epoch
  -- if $get_beacon_proposer_index(state_beaconState) = validatorIndex_prop_vi
  -- if $(validatorIndex_prop_vi < |state_beaconState.VALIDATORS|)
  -- if state_beaconState.VALIDATORS[validatorIndex_prop_vi] = validator_proposer
  -- if $get_domain(state_beaconState, $DOMAIN_RANDAO, eps) = domain_randao
  -- if $compute_signing_root(epoch, domain_randao) = root_signing
  -- if $bls_verify(validator_proposer.PUBKEY, root_signing, body_beaconBlockBody.RANDAO_REVEAL) = true
  -- if $get_randao_mix(state_beaconState, epoch) = bytes32_mix_old
  -- if $hash_<blsSignature>(body_beaconBlockBody.RANDAO_REVEAL) = bytes32_hash_reveal
  -- if $xor(bytes32_mix_old, bytes32_hash_reveal) = bytes32_mix_new
  -- if $(epoch \ $EPOCHS_PER_HISTORICAL_VECTOR) = uint64_n
  -- if state_beaconState.RANDAO_MIXES[[uint64_n] = bytes32_mix_new] = bytes32_randao_mixes_update*
  -- if state_updated = state_beaconState[.RANDAO_MIXES = bytes32_randao_mixes_update*]



;;
;; process_eth1_data
;;
relation Process_eth1_data:
  beaconState beaconBlockBody ~> beaconState
  hint(input %0 %1)

rule Process_eth1_data/majority:
  state_beaconState body_beaconBlockBody ~> state_updated
  -- if state_beaconState.ETH1_DATA_VOTES ++ [ body_beaconBlockBody.ETH1_DATA ] = eth1Data_update*
  -- if $count_occurrences_<eth1Data>(eth1Data_update*, body_beaconBlockBody.ETH1_DATA) = nat_occ
  -- if $(nat_occ * 2 > $EPOCHS_PER_ETH1_VOTING_PERIOD * $SLOTS_PER_EPOCH)
  -- if state_updated = state_beaconState[.ETH1_DATA_VOTES = eth1Data_update*][.ETH1_DATA = body_beaconBlockBody.ETH1_DATA]

rule Process_eth1_data/accumulate:
  state_beaconState body_beaconBlockBody ~> state_updated
  -- if state_beaconState.ETH1_DATA_VOTES ++ [ body_beaconBlockBody.ETH1_DATA ] = eth1Data_update*
  -- if $count_occurrences_<eth1Data>(eth1Data_update*, body_beaconBlockBody.ETH1_DATA) = nat_occ
  -- if $(nat_occ * 2 <= $EPOCHS_PER_ETH1_VOTING_PERIOD * $SLOTS_PER_EPOCH)
  -- if state_updated = state_beaconState[.ETH1_DATA_VOTES = eth1Data_update*]

;;
;; process_operations
;;   
relation Process_operations:
  beaconState beaconBlockBody ~> beaconState
  hint(input %0 %1)


;;
;; process_sync_aggregate
;; 
;;
relation Process_sync_aggregate:
  beaconState syncAggregate ~> beaconState
  hint(input %0 %1)
