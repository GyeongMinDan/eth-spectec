;;
;; Calling convention
;;

rule Call_convention_ok/in:
  p C actctxt |- (id IN typ_p val?) ~~ (expr, typ_a)
  -- Expr_ok: p C |- expr : typ_e ctk
  -- Sub_impl: typ_e << typ_p

rule Call_convention_ok/out-inout:
  p C actctxt |- (id dir typ_p val?) ~~ (expr, typ_a)
  -- if dir = OUT \/ dir = INOUT
  -- Type_alpha: typ_a ~~ typ_p
  -- Lval_ok: p C |- expr

rule Call_convention_ok/no-action:
  p C ACT |- (id NO typ_p val?) ~~ (expr, typ_a)
  -- Expr_ok: p C |- expr : typ_e ctk
  -- Sub_impl: typ'' << typ

rule Call_convention_ok/no-not-action:
  p C NOACT |- (id NO typ val?) ~~ (expr, typ')
  -- Type_alpha: typ' ~~ typ
  -- Expr_ok: p C |- expr : typ'' ctk
  -- if ctk = CTK \/ ctk = LCTK


rule Call_convention_arg_ok/expra:
  p C actctxt |- pt ~~ (ExprA expr, typ)
  -- Call_convention_ok: p C actctxt |- pt ~~ (expr, typ)

rule Call_convention_arg_ok/some-namea:
  p C actctxt |- pt ~~ (NameA id expr, typ)
  -- Call_convention_ok: p C actctxt |- pt ~~ (expr, typ)

rule Call_convention_arg_ok/none-namea-anya:
  p C actctxt |- (id OUT typ val?) ~~ (arg, typ)
  -- if arg = (NameA id' eps) \/ arg = AnyA


def $is_table_apply_in_action_arg(arg) : bool   hint(show % CONTAINS TABLE.APPLY CALL)

syntax pmap = map(id, paramtyp)

def $align_params_with_args'(pmap, paramtyp, typ, arg): (paramtyp, typ, arg) hint(show ALIGN_PARAMS_WITH_ARGS'%latex("(")#%1#%latex(", ")#%2#%latex(", ")#%3#%latex(")"))

def $align_params_with_args'(pmap, paramtyp, typ, ExprA expr) = (paramtyp, typ, ExprA expr)
def $align_params_with_args'(pmap, paramtyp, typ, NameA id expr?) = (paramtyp', typ, (NameA id expr?))
  -- if paramtyp' = $find_map(id, paramtyp, pmap, id)
def $align_params_with_args'(pmap, paramtyp, typ, AnyA) = (paramtyp, typ, AnyA)

def $align_params_with_args(paramtyp*, typ*, arg*): (paramtyp*, typ*, arg*) hint(show ALIGN_PARAMS_WITH_ARGS%latex("(")#%1#%latex(", ")#%2#%latex(", ")#%3#%latex(")"))

def $align_params_with_args(paramtyp*, typ*, arg*) = (paramtyp'*, typ'*, arg'*)
  -- if (id dir typ val?)* = paramtyp*
  -- if pmap = MAP id* paramtyp*
  -- (if (paramtyp', typ', arg') = $align_params_with_args'(pmap, paramtyp, typ, arg))*

rule Call_ok/actiont:
  p C |- (ActionT pt*) arg* : VoidT
  -- (Arg_ok: p C |- arg : typ_a)*
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C)
  -- FuncType_wf: tidset |- ActionT pt'*
  ----
  -- Call_site_ok: p C |- ActionT pt'* : CALLSITE_OK
  -- if (~$is_table_apply_in_action_arg(arg'))*
  -- (Call_convention_arg_ok: p C ACT |- pt' ~~ (arg', typ_a'))*

rule Call_ok/extern-funct:
  p C |- (ExternFuncT pt* typ_r) arg* : typ
  -- (Arg_ok: p C |- arg : typ_a)*
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C)
  -- FuncType_wf: tidset |- ExternFuncT pt'* typ_r
  ----
  -- Call_site_ok: p C |- ExternFuncT pt'* typ_r : CALLSITE_OK
  -- (Call_convention_arg_ok: p C NOACT |- pt' ~~ (arg', typ_a'))*

rule Call_ok/funct:
  p C |- (FuncT pt* typ_r) arg* : typ
  -- (Arg_ok: p C |- arg : typ_a)*
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C)
  -- FuncType_wf: tidset |- (FuncT pt'* typ_r)
  ----
  -- Call_site_ok: p C |- FuncT pt'* typ_r : CALLSITE_OK
  -- (Call_convention_arg_ok: p C NOACT |- pt' ~~ (arg', typ_a'))*

rule Call_ok/extern-methodt:
  p C |- (ExternMethodT pt* typ_r) arg* : typ
  -- (Arg_ok: p C |- arg : typ_a)*
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C)
  -- FuncType_wf: tidset |- ExternMethodT pt'* typ_r
  ----
  -- Call_site_ok: p C |- ExternMethodT pt'* typ_r : CALLSITE_OK
  -- (Call_convention_arg_ok: p C NOACT |- pt' ~~ (arg', typ_a'))*

rule Call_ok/extern-abstract-methodt:
  p C |- (ExternAbstractMethodT pt* typ_r) arg* : typ
  -- (Arg_ok: p C |- arg : typ_a)*
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C)
  -- FuncType_wf: tidset |- ExternAbstractMethodT pt'* typ_r
  ----
  -- Call_site_ok: p C |- ExternAbstractMethodT pt'* typ_r : CALLSITE_OK
  -- (Call_convention_arg_ok: p C NOACT |- pt' ~~ (arg', typ_a'))*

rule Call_ok/parser-apply-methodt:
  p C |- (ParserApplyMethodT pt*) arg* : VoidT
  -- (Arg_ok: p C |- arg : typ_a)*
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C)
  -- FuncType_wf: tidset |- (ParserApplyMethodT pt'*)
  ----
  -- Call_site_ok: p C |- ParserApplyMethodT pt'* : CALLSITE_OK
  -- (Call_convention_arg_ok: p C NOACT |- pt' ~~ (arg', typ_a'))*

rule Call_ok/control-apply-methodt:
  p C |- (ControlApplyMethodT pt*) arg* : VoidT
  -- (Arg_ok: p C |- arg : typ_a)*
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C)
  -- FuncType_wf: tidset |- ControlApplyMethodT pt'*
  ----
  -- Call_site_ok: p C |- ControlApplyMethodT pt'* : CALLSITE_OK
  -- (Call_convention_arg_ok: p C NOACT |- pt' ~~ (arg', typ_a'))*

rule Call_ok/builtin-methodt:
  p C |- (BuiltinMethodT pt* typ_r) arg* : typ_r
  -- (Arg_ok: p C |- arg : typ_a)*
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C)
  -- FuncType_wf: tidset |- BuiltinMethodT pt'* typ_r
  ----
  -- Call_site_ok: p C |- BuiltinMethodT pt'* typ_r : CALLSITE_OK
  -- (Call_convention_arg_ok: p C NOACT |- pt' ~~ (arg', typ_a'))*

rule Call_ok/table-apply-methodt:
  p C |- (TableApplyMethodT typ_r) eps : typ_r
  -- if tidset = $bound_tid(C)
  -- FuncType_wf: tidset |- TableApplyMethodT typ_r
  ----
  -- Call_site_ok: p C |- TableApplyMethodT typ_r : CALLSITE_OK

;;
;; Constructor invocation
;;

rule Inst_site_ok/global:
  GLOBAL C |- (ConsT pt* typ_i) : INSTSITE_OK
  -- if typ_i' = $canon_typ(typ_i)
  -- if $is_externt(typ_i') \/ $is_packaget(typ_i')

rule Inst_site_ok/block-package:
  BLOCK C |- (ConsT pt* typ_i) : INSTSITE_OK
  -- if typ_i' = $canon_typ(typ_i)
  -- if C.BLOCK.KIND = PACKAGE
  ----
  -- if $is_externt(typ_i') \/ $is_parsert(typ_i')
      \/ $is_controlt(typ_i') \/ $is_packaget(typ_i')

rule Inst_site_ok/block-parser:
  BLOCK C |- (ConsT pt* typ_i) : INSTSITE_OK
  -- if typ_i' = $canon_typ(typ_i)
  -- if C.BLOCK.KIND = PARSER
  ----
  -- if $is_externt(typ_i') \/ $is_parsert(typ_i')

rule Inst_site_ok/block-control:
  BLOCK C |- (ConsT pt* typ_i) : INSTSITE_OK
  -- if typ_i' = $canon_typ(typ_i)
  -- if C.BLOCK.KIND = CONTROL
  ----
  -- if $is_externt(typ_i') \/ $is_controlt(typ_i') \/ $is_tablet(typ_i')

rule Inst_site_ok/local-parserstate:
  LOCAL C |- (ConsT pt* typ_i) : INSTSITE_OK
  -- if typ_i' = $canon_typ(typ_i)
  -- if C.LOCAL.KIND = PARSERSTATE
  ----
  -- if $is_externt(typ_i') \/ $is_parsert(typ_i')

rule Inst_site_ok/local-controlapplymethod:
  LOCAL C |- (ConsT pt* typ_i) : INSTSITE_OK
  -- if typ_i' = $canon_typ(typ_i)
  -- if C.LOCAL.KIND = CONTROLAPPLYMETHOD
  ----
  -- if $is_externt(typ_i') \/ $is_controlt(typ_i')


rule Inst_ok/global-packaget:
  GLOBAL C_0 |- (ConsT pt* typ_i) arg* : typ_i
  -- if PackageT typ_i'* = $canon_typ(typ_i)
  -- if C_1 = $set_blockkind(C_0, PACKAGE)
  ----
  -- (Arg_ok: BLOCK C_1 |- arg : typ_a)*
  ----
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C_1)
  -- ConsType_wf: tidset |- (ConsT pt* typ_i)
  ----
  -- Inst_site_ok: BLOCK C_1 |- (ConsT pt* typ_i) : INSTSITE_OK
  -- (Call_convention_arg_ok: BLOCK C_1 NOACT |- pt' ~~ (arg', typ_a'))*

rule Inst_ok/else:
  p C |- (ConsT pt* typ_i) arg* : typ_i
  -- (Arg_ok: p C |- arg : typ_a)*
  ----
  -- if |pt*| = |arg*|
  -- if (pt'*, typ_a'*, arg'*) = $align_params_with_args(pt*, typ_a*, arg*)
  ----
  -- if tidset = $bound_tid(C)
  -- ConsType_wf: tidset |- (ConsT pt* typ_i)
  ----
  -- Inst_site_ok: p C |- (ConsT pt* typ_i) : INSTSITE_OK
  -- (Call_convention_arg_ok: p C NOACT |- pt' ~~ (arg', typ_a'))*

;;
;; Function typing
;;

;; (TODO-Jaehyun) should consider overload resolution and default parameters

rule FuncType_ok:
   p C |- name targ* arg* : functyp
   ----
   -- (Type_ok: p C |- targ: typ_a)*
   -- if funcdef = $find_funcdef(GLOBAL, C, name)
   ----
   -- if functyp = $specialize_funcdef(funcdef, typ_a*)

;;
;; Method typing
;;

;; (TODO-Jaehyun) check that builtin is defined on typ_b
rule MethodType_ok/builtin:
  p C |- expr_b member eps eps : BuiltinMethodT eps IntT
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  ----
  -- (Type_ok: p C |- targ : typ_a)*
  ----
  -- if $in_set(member, member, SET "minSizeInBits" "minSizeInBytes" "maxSizeInBits" "maxSizeInBytes")

rule MethodType_ok/stackt:
  p C |- expr_b member eps arg* : BuiltinMethodT paramtyp IntT
  ----
  -- Expr_ok: p C |- expr_b: typ_b ctk_b
  -- if StackT typ_b_in size_b = $canon_typ(typ_b)
  ----
  -- if $in_set(member, member, SET "push\\_front" "pop\\_back")
  ----
  -- if paramtyp = "count" NO IntT eps

rule MethodType_ok/headert-isvalid:
  p C |- expr_b "isValid" eps arg* : BuiltinMethodT eps BoolT
  ----
  -- Expr_ok: p C |- expr_b: typ_b ctk_b
  -- if HeaderT id_b (member, typ_b_in)* = $canon_typ(typ_b)

rule MethodType_ok/headert-setvalid-setinvalid:
  p C |- expr_b member eps arg* : BuiltinMethodT eps VoidT
  ----
  -- Expr_ok: p C |- expr_b: typ_b ctk_b
  -- if HeaderT id_b (member, typ_b_in)* = $canon_typ(typ_b)
  ----
  -- if $in_set(member, member, SET "setValid" "setInvalid")

rule MethodType_ok/uniont:
  p C |- expr_b "isValid" eps arg* : BuiltinMethodT eps BoolT
  ----
  -- Expr_ok: p C |- expr_b: typ_b ctk_b
  -- if UnionT id_b (member, typ_b_in)* = $canon_typ(typ_b)

rule MethodType_ok/externt:
  p C |- expr_b member targ* arg* : functyp
  ----
  -- Expr_ok: p C |- expr_b: typ_b ctk_b
  -- if ExternT id_b fmap_b = $canon_typ(typ_b)
  ----
  -- (Type_ok: p C |- targ: typ_a)*
  ----
  -- if funcdef = $find_env(fid, funcdef, fmap_b, member)
  -- if functyp = $specialize_funcdef(funcdef, typ_a*)

;;
;; Type inference
;;

def $empty_cstr(tid*) : map(tid, typ?)                                                      hint(show EMPTY_CSTR(%1))
def $gen_cstr(map(tid, typ?), typ, typ) : map(tid, typ?)                                    hint(show GEN_CSTR(%1, %2, %3))
def $gen_cstrs(map(tid, typ?), typ*, typ*) : map(tid, typ?)                                 hint(show GEN_CSTRS(%1, %2, %3))
def $gen_cstr_fd(map(tid, typ?), funcdef, funcdef) : map(tid, typ?)                         hint(show GEN_CSTR_FD(%1, %2, %3))
def $gen_cstr_fd'(map(tid, typ?), fid*, fdenv, fdenv) : map(tid, typ?)                      hint(show GEN_CSTR_FD'(%1, %2, %3, %4))
def $merge_cstr(map(tid, typ?), map(tid, typ?)) : map(tid, typ?)                            hint(show MERGE_CSTR(%1, %2))
def $merge_cstr'(map(tid, typ?), map(tid, typ?), tid*, map(tid, typ?)) : map(tid, typ?)     hint(show MERGE_CSTR'(%1, %2, %3, %4))
def $merge_cstrs(map(tid, typ?), map(tid, typ?)*) : map(tid, typ?)                          hint(show MERGE_CSTRS(%1, %2))
def $resolve_cstrs(map(tid, typ?)) : map(tid, typ)                                          hint(show RESOLVE_CSTRS(%1))
def $infer_targs(tid*, paramtyp*, typ*) : map(tid, typ)                                     hint(show INFER_TARGS(%1, %2, %3))

def $empty_cstr(eps) = MAP eps eps
def $empty_cstr(tid_h tid_t*) = cstr'
  -- if cstr = $empty_cstr(tid_t*)
  -- if cstr' = $update_map(tid, typ?, cstr, tid_h, eps)


def $gen_cstr_fd(cstr, fd_p, fd_a) = cstr''
  -- if (id_p dir_p typ_p val_p?)* = $get_params_funcdef(fd_p)
  -- if (id_a dir_a typ_a val_a?)* = $get_params_funcdef(fd_a)
  -- if cstr' = $gen_cstrs(cstr, typ_p*, typ_a*)
  -- if cstr'' = $gen_cstr(cstr', $get_typ_ret_funcdef(fd_p), $get_typ_ret_funcdef(fd_a))

def $gen_cstr_fd'(cstr, eps, fdenv_p, fdenv_a) = cstr
def $gen_cstr_fd'(cstr, fid_h fid_t*, fdenv_p, fdenv_a) = $gen_cstr_fd'(cstr', fid_t*, fdenv_p, fdenv_a)
  -- if fd_p = $find_env(fid, funcdef, fdenv_p, fid_h)
  -- if fd_a = $find_env(fid, funcdef, fdenv_a, fid_h)
  -- if cstr' = $gen_cstr_fd(cstr, fd_p, fd_a)


def $gen_cstr(cstr, VarT tid, typ_a) = $update_map(tid, typ?, cstr, tid, typ_a)
  -- if $in_dom_map(tid, typ?, tid, cstr)
def $gen_cstr(cstr, SpecT ptd_p typ_p'*, SpecT ptd_a typ_a'*) = $gen_cstrs(cstr', typ_p'*, typ_a'*)
  -- if typ_p'' = $specialize_typdef(ptd_p, typ_p'*)
  -- if typ_a'' = $specialize_typdef(ptd_a, typ_a'*)
  -- if cstr' = $gen_cstr(cstr, typ_p'', typ_a'')
  -- if $nominal(typ_p'') /\ $nominal(typ_a'')
def $gen_cstr(cstr, SpecT ptd_p typ_p'*, SpecT ptd_a typ_a'*) = cstr'
  -- if typ_p'' = $specialize_typdef(ptd_p, typ_p'*)
  -- if typ_a'' = $specialize_typdef(ptd_a, typ_a'*)
  -- if cstr' = $gen_cstr(cstr, typ_p'', typ_a'')
  -- if ~($nominal(typ_p'') /\ $nominal(typ_a''))
def $gen_cstr(cstr, DefT typ_p', typ_a) = $gen_cstr(cstr, typ_p', typ_a)
def $gen_cstr(cstr, typ_p, DefT typ_a') = $gen_cstr(cstr, typ_p, typ_a')
def $gen_cstr(cstr, NewT id_p typ_p', NewT id_a typ_a') = $gen_cstr(cstr, typ_p', typ_a')
  -- if id_p = id_a
def $gen_cstr(cstr, ListT typ_p, ListT typ_a) = $gen_cstr(cstr, typ_p, typ_a)
def $gen_cstr(cstr, TupleT typ_p*, TupleT typ_a*) = $gen_cstrs(cstr, typ_p*, typ_a*)
def $gen_cstr(cstr, StackT typ_p' size_p, StackT typ_a' size_a) = $gen_cstr(cstr, typ_p', typ_a')
  -- if size_p = size_a
def $gen_cstr(cstr, StructT id_p (member_p, typ_p')*, StructT id_a (member_a, typ_a')*) = $gen_cstrs(cstr, typ_p'*, typ_a'*)
  -- if id_p = id_a
def $gen_cstr(cstr, HeaderT id_p (member_p, typ_p')*, HeaderT id_a (member_a, typ_a')*) = $gen_cstrs(cstr, typ_p'*, typ_a'*)
  -- if id_p = id_a
def $gen_cstr(cstr, UnionT id_p (member_p, typ_p')*, UnionT id_a (member_a, typ_a')*) = $gen_cstrs(cstr, typ_p'*, typ_a'*)
  -- if id_p = id_a
def $gen_cstr(cstr, ExternT id_p fdenv_p, ExternT id_a fdenv_a) = $gen_cstr_fd'(cstr, fid_p*, fdenv_p, fdenv_a)
  -- if MAP fid_p* fd_p* = fdenv_p
  -- if MAP fid_a* fd_a* = fdenv_a
  -- if id_p = id_a
  -- if $eq_set(fid, SET fid_p*, SET fid_a*)
def $gen_cstr(cstr, ParserT pt_p*, ParserT pt_a*) = $gen_cstrs(cstr, typ_p'*, typ_a'*)
  -- if (id dir typ_p' val? = pt_p)*
  -- if (id dir typ_a' val? = pt_a)*
def $gen_cstr(cstr, ControlT pt_p*, ControlT pt_a*) = $gen_cstrs(cstr, typ_p'*, typ_a'*)
  -- if (id dir typ_p' val? = pt_p)*
  -- if (id dir typ_a' val? = pt_a)*
def $gen_cstr(cstr, PackageT typ_p*, PackageT typ_a*) = $gen_cstrs(cstr, typ_p*, typ_a*)
def $gen_cstr(cstr, typ_p, typ_a) = cstr
  -- otherwise


def $merge_cstr'(cstr_o, cstr_n, eps, cstr) = cstr
def $merge_cstr'(cstr_o, cstr_n, tid_h tid_t*, cstr) = $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')
  -- if $find_env(tid, typ?, cstr_o, tid_h) = eps
  -- if $find_env(tid, typ?, cstr_n, tid_h) = typ_n
  -- if cstr' = $update_map(tid, typ?, cstr, tid_h, typ_n)
def $merge_cstr'(cstr_o, cstr_n, tid_h tid_t*, cstr) = $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')
  -- if $find_env(tid, typ?, cstr_o, tid_h) = typ_o
  -- if $find_env(tid, typ?, cstr_n, tid_h) = eps
  -- if cstr' = $update_map(tid, typ?, cstr, tid_h, typ_o)
def $merge_cstr'(cstr_o, cstr_n, tid_h tid_t*, cstr) = $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')
  -- if $find_env(tid, typ?, cstr_o, tid_h) = typ_o
  -- if $find_env(tid, typ?, cstr_n, tid_h) = typ_n
  -- Sub_impl: typ_o << typ_n
  -- if cstr' = $update_map(tid, typ?, cstr, tid_h, typ_n)
def $merge_cstr'(cstr_o, cstr_n, tid_h tid_t*, cstr) = $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')
  -- if $find_env(tid, typ?, cstr_o, tid_h) = typ_o
  -- if $find_env(tid, typ?, cstr_n, tid_h) = typ_n
  -- Sub_impl: typ_n << typ_o
  -- if cstr' = $update_map(tid, typ?, cstr, tid_h, typ_o)


def $merge_cstr(cstr_o, cstr_n) = $merge_cstr'(cstr_o, cstr_n, tid_o*, MAP eps eps)
  -- if MAP tid_o* typ_o?* = cstr_o
  -- if MAP tid_n* typ_n?* = cstr_n
  -- if $eq_set(tid, SET tid_o*, SET tid_n*)


def $merge_cstrs(MAP tid* typ?*, eps) = MAP tid* typ?*
def $merge_cstrs(cstr, cstr_h' cstr_t'*) = cstr'''
  -- if cstr'' = $merge_cstr(cstr, cstr_h')
  -- if cstr''' = $merge_cstrs(cstr'', cstr_t'*)


def $gen_cstrs(cstr, typ_p*, typ_a*) = $merge_cstrs(cstr, cstr'*)
  -- if |typ_p*| = |typ_a*|
  -- if (cstr' = $gen_cstr(cstr, typ_p, typ_a))*


def $resolve_cstrs(MAP eps eps) = MAP eps eps
def $resolve_cstrs(MAP tid* typ?*) = MAP (tid_h tid_t'*) (typ_h typ_t'*)
  -- if tid_h tid_t* = tid*
  -- if typ_h typ_t?* = typ?*
  -- if typ_h =/= AnyT
  -- if MAP tid_t'* typ_t'* = $resolve_cstrs(MAP tid_t* typ_t?*)


def $infer_targs(tid*, (id dir typ_p val?)*, typ_a*) = $resolve_cstrs(cstr')
  -- if cstr = $empty_cstr(tid*)
  -- if cstr' = $gen_cstrs(cstr, typ_p*, typ_a*)