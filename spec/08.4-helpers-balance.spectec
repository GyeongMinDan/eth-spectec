;; --------------------------------------------
;; get_total_balance(state, indices) : gwei
;; --------------------------------------------

dec $get_total_balance(beaconState, validatorIndex*) : gwei

def $get_total_balance(state, validatorIndex*) = gwei_total
  -- if (state.VALIDATORS[validatorIndex].EFFECTIVE_BALANCE = balance)*
  -- if $sum_<gwei>(balance*) = gwei_sum
  -- if $max_uint64($EFFECTIVE_BALANCE_INCREMENT, gwei_sum) = gwei_total

dec $get_total_active_balance(beaconState) : gwei

def $get_total_active_balance(state) = gwei_total
  -- if $get_current_epoch(state) = epoch_cur
  -- if $get_active_validator_indices(state, epoch_cur) = validatorIndex_active*
  -- if $to_set_<validatorIndex>(validatorIndex_active*) = validatorIndex_set*
  -- if $get_total_balance(state, validatorIndex_set*) = gwei_total

;; --------------------------------------------
;; get_base_reward_per_increment(state) : gwei
;;
;; --------------------------------------------
dec $get_base_reward_per_increment(beaconState) : gwei

def $get_base_reward_per_increment(state) = gwei_base
  -- if $get_total_active_balance(state) = gwei_total_active
  -- if $integer_squareroot(gwei_total_active) = uint64_sqrt_total
  -- if $( $EFFECTIVE_BALANCE_INCREMENT * $BASE_REWARD_FACTOR ) = uint64_num
  -- if $( uint64_num / uint64_sqrt_total ) = gwei_base

;; --------------------------------------------
;; get_base_reward(state, index) : gwei
;; --------------------------------------------
dec $get_base_reward(beaconState, validatorIndex) : gwei

def $get_base_reward(state, validatorIndex_vi) = gwei_reward
  -- if $(validatorIndex_vi < |state.VALIDATORS|)
  -- if state.VALIDATORS[validatorIndex_vi] = validator_i
  -- if $( validator_i.EFFECTIVE_BALANCE / $EFFECTIVE_BALANCE_INCREMENT ) = uint64_increments
  -- if $get_base_reward_per_increment(state) = gwei_per_inc
  -- if $( uint64_increments * gwei_per_inc ) = gwei_reward


;; for process_effective_balance_updates
;; ------------------------------------------------------------
;; map over a list with one extra captured argument
;; X*  ×  Y  ×  (X,Y)->Z   ==>   Z*
;; X* 의 원소 X 에 대해 Y 인자를 넘겨 f(X,Y) 를 적용하고 그 결과를 Z* 를 만든다.
;; 라고 이해했는데.... 
;; ------------------------------------------------------------
dec $map_list_2_<X, Y, Z>(X*, Y, def $f(X, Y) : Z) : Z*


;; predicate: apply update iff
;;   balance + DOWNWARD_THRESHOLD < effective_balance
;;   OR
;;   effective_balance + UPWARD_THRESHOLD < balance
dec $cond_hysteresis(gwei, gwei, uint64, uint64) : boolean

def $cond_hysteresis(gwei_balance, gwei_eff, uint64_down_th, uint64_up_th) = true
  -- if $( gwei_balance + uint64_down_th < gwei_eff )
   \/
       $( gwei_eff + uint64_up_th   < gwei_balance )

def $cond_hysteresis(gwei_balance, gwei_eff, uint64_down_th, uint64_up_th) = false
  -- otherwise

;; ------------------------------------------------------------
;; rebalance rule for a single (index, validator) pair
;; (computes hysteresis thresholds and updates EFFECTIVE_BALANCE if needed)
;; ------------------------------------------------------------
dec $rebalance_validator_enumerated((nat, validator), beaconState) : validator

def $rebalance_validator_enumerated((n, validator_v), state) = validator_updated
  -- if $(n < |state.BALANCES|)
  -- if state.BALANCES[n] = gwei_balance
  -- if $( $EFFECTIVE_BALANCE_INCREMENT / $HYSTERESIS_QUOTIENT ) = uint64_hyst_inc
  -- if $( uint64_hyst_inc * $HYSTERESIS_DOWNWARD_MULTIPLIER ) = uint64_down_th
  -- if $( uint64_hyst_inc * $HYSTERESIS_UPWARD_MULTIPLIER )  = uint64_up_th
  -- if $cond_hysteresis(
         gwei_balance,
         validator_v.EFFECTIVE_BALANCE,
         uint64_down_th,
         uint64_up_th
       ) = true
  -- if $( gwei_balance \ $EFFECTIVE_BALANCE_INCREMENT ) = gwei_mod
  -- if $( gwei_balance - gwei_mod ) = gwei_floor_inc
  -- if $min_uint64(gwei_floor_inc, $MAX_EFFECTIVE_BALANCE) = gwei_new_eff
  -- if validator_updated = validator_v[.EFFECTIVE_BALANCE = gwei_new_eff]

def $rebalance_validator_enumerated((n, validator_v), state) = validator_v
  -- otherwise

