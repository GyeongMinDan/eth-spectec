;;
;; Boolean expression
;;

rule Expr_ok/boole:
  p C |- BoolE b : BoolT LCTK

;;
;; String expression
;;

rule Expr_ok/stre:
  p C |- StrE t : StrT LCTK

;;
;; Number expression
;;

rule Expr_ok/nume-intt:
  p C |- NumE (INT i) : IntT LCTK

rule Expr_ok/nume-fintt:
  p C |- NumE (FINT w i) : (FIntT w) LCTK

rule Expr_ok/nume-fbitt:
  p C |- NumE (FBIT w i) : (FBitT w) LCTK

;;
;; Variable expression
;;

rule Expr_ok/namee:
  p C |- NameE name : typ ctk
  -- if typ dir ctk = $find_typ(p, C, name)

;;
;; Sequence expression
;;

rule Expr_ok/seqe:
  p C |- SeqE expr* : (SeqT typ_e*) ctk
  -- (Expr_ok: p C |- expr : typ_e ctk_e)*
  -- if ctk = $joins_ctk(ctk_e*)

rule Expr_ok/seqdefaulte:
  p C |- SeqDefaultE expr* : (SeqDefaultT typ_e*) ctk
  -- (Expr_ok: p C |- expr : typ_e ctk_e)*
  -- if ctk = $joins_ctk(ctk_e*)

;;
;; Record expression
;;

rule Expr_ok/recorde:
  p C |- RecordE (member, expr)* : (RecordT (member, typ_e)*) ctk
  -- (Expr_ok: p C |- expr : typ_e ctk_e)*
  -- if ctk = $joins_ctk(ctk_e*)

rule Expr_ok/recorddefaulte:
  p C |- RecordDefaultE (member, expr)* : (RecordDefaultT (member, typ_e)*) ctk
  -- (Expr_ok: p C |- expr : typ_e ctk_e)*
  -- if ctk = $joins_ctk(ctk_e*)

;;
;; Default expression
;;

rule Expr_ok/defaulte:
  p C |- DefaultE : DefaultT LCTK

;;
;; Invalid expression
;;

rule Expr_ok/invalide:
  p C |- InvalidE : InvalidT LCTK

;;
;; Unary expression
;;

rule Expr_ok/une-bnot:
  p C |- UnE BNOT expr : typ ctk_e
  -- Expr_ok: p C |- expr : typ_e ctk_e
  -- Sub_impl: typ_e << typ
  -- if $is_fintt(typ) \/ $is_fbitt(typ)

rule Expr_ok/une-lnot:
  p C |- UnE LNOT expr : BoolT ctk_e
  -- Expr_ok: p C |- expr : typ_e ctk_e
  -- Sub_impl: typ_e << BoolT

rule Expr_ok/une-uminus-intt:
  p C |- UnE UMINUS expr : IntT ctk_e
  -- Expr_ok: p C |- expr : typ_e ctk_e
  -- Sub_impl: typ_e << IntT

rule Expr_ok/une-uminus:
  p C |- UnE UMINUS expr : typ ctk_e
  -- Expr_ok: p C |- expr : typ_e ctk_e
  -- Sub_impl: typ_e << typ
  -- if $is_intt(typ) \/ $is_fintt(typ) \/ $is_fbitt(typ)

rule Expr_ok/une-uplus:
  p C |- UnE UPLUS expr : typ ctk_e
  -- Expr_ok: p C |- expr : typ_e ctk_e
  -- Sub_impl: typ_e << typ
  -- if $is_intt(typ) \/ $is_fintt(typ) \/ $is_fbitt(typ)

;;
;; Binary expression
;;

rule Expr_ok/bine-plus-minus-mult:
  p C |- BinE binop expr_l expr_r : typ ctk
  ----
  -- if $in_set(binop, binop, SET PLUS MINUS MUL)
  ----
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  ----
  -- Sub_impl: typ_l << typ
  -- Sub_impl: typ_r << typ
  -- if $is_intt(typ) \/ $is_fintt(typ) \/ $is_fbitt(typ)
  ----
  -- if ctk = $join_ctk(ctk_l, ctk_r)

rule Expr_ok/bine-sat-plus-minus:
  p C |- BinE binop expr_l expr_r : typ ctk
  ----
  -- if $in_set(binop, binop, SET SPLUS SMINUS)
  ----
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  ----
  -- Sub_impl: typ_l << typ
  -- Sub_impl: typ_r << typ
  -- if $is_fintt(typ) \/ $is_fbitt(typ)
  ----
  -- if ctk = $join_ctk(ctk_l, ctk_r)

rule Expr_ok/bine-div-mod:
  p C |- BinE binop expr_l expr_r : typ ctk
  ----
  -- if $in_set(binop, binop, SET DIV MOD)
  ----
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  ----
  -- Sub_impl: typ_l << IntT
  -- Sub_impl: typ_r << IntT
  ----
  -- if ctk = $join_ctk(ctk_l, ctk_r)

rule Expr_ok/bine-shift:
  p C |- BinE binop expr_l expr_r : typ ctk
  ----
  -- if $in_set(binop, binop, SET SHL SHR)
  ----
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  ----
  -- Sub_impl: typ_l << typ_l'
  -- Sub_impl: typ_r << typ_r'
  -- if ($is_fintt(typ_l') /\ $is_fintt(typ_r'))
        \/ ($is_fintt(typ_l') /\ $is_fbitt(typ_r'))
        \/ ($is_fintt(typ_l') /\ $is_intt(typ_r'))
        \/ ($is_fbitt(typ_l') /\ $is_fintt(typ_r'))
        \/ ($is_fbitt(typ_l') /\ $is_fbitt(typ_r'))
        \/ ($is_fbitt(typ_l') /\ $is_intt(typ_r'))
        \/ ($is_intt(typ_l') /\ $is_fintt(typ_r'))
        \/ ($is_intt(typ_l') /\ $is_fbitt(typ_r'))
        \/ ($is_intt(typ_l') /\ $is_intt(typ_r'))
  ----
  -- if $implies($is_fintt(typ_r') \/ $is_intt(typ_r'), ctk_r = LCTK)
  ----
  -- if ctk = $join_ctk(ctk_l, ctk_r)


def $equalable(typ) : bool    hint(show % IS EQUALABLE)
def $equalable'(typ) : bool

def $equalable(typ) = $equalable'($canon_typ(typ))

def $equalable'(VoidT) = false
def $equalable'(VarT id) = false
def $equalable'(ExternT id fmap) = false
def $equalable'(ParserT paramtyp*) = false
def $equalable'(ControlT paramtyp*) = false
def $equalable'(PackageT typ*) = false
def $equalable'(TableT id typ) = false
def $equalable'(synthtyp) = $is_seqt(synthtyp) \/ $is_recordt(synthtyp)
def $equalable'(typ) = true


rule Expr_ok/bine-compare-eq:
  p C |- BinE binop expr_l expr_r : typ ctk
  ----
  -- if $in_set(binop,binop, SET EQ NE)
  ----
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  ----
  -- Sub_impl: typ_l << typ
  -- Sub_impl: typ_r << typ
  ----
  -- if $equalable(typ_l)
  ----
  -- if ctk = $join_ctk(ctk_l, ctk_r)

rule Expr_ok/bine-compare:
  p C |- BinE binop expr_l expr_r : typ ctk
  ----
  -- if $in_set(binop, binop, SET LE GE LT GT)
  ----
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  ----
  -- Sub_impl: typ_l << typ
  -- Sub_impl: typ_r << typ
  -- if $is_intt(typ) \/ $is_fintt(typ) \/ $is_fbitt(typ)
  ----
  -- if ctk = $join_ctk(ctk_l, ctk_r)

rule Expr_ok/bine-bitwise:
  p C |- BinE binop expr_l expr_r : typ ctk
  ----
  -- if $in_set(binop, binop, SET BAND BXOR BOR)
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  ----
  -- Sub_impl: typ_l << typ
  -- Sub_impl: typ_r << typ
  -- if $is_fintt(typ) \/ $is_fbitt(typ)
  ----
  -- if ctk = $join_ctk(ctk_l, ctk_r)

rule Expr_ok/bine-concat:
  p C |- BinE CONCAT expr_l expr_r : typ ctk
  ----
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  ----
  -- Sub_impl: typ_l << typ_l'
  -- Sub_impl: typ_r << typ_r'
  -- if ((typ_l' = FIntT w_l' /\ typ_r' = FIntT w_r')
          \/ (typ_l' = FIntT w_l' /\ typ_r' = FBitT w_r')
          \/ (typ_l' = FBitT w_l' /\ typ_r' = FIntT w_r')
          \/ (typ_l' = FBitT w_l' /\ typ_r' = FBitT w_r'))
  ----
  -- if $implies($is_fintt(typ_l'), typ = FIntT $(w_l' + w_r'))
        \/ $implies($is_fbitt(typ_l'), typ = FIntT $(w_l' + w_r'))
  ----
  -- if ctk = $join_ctk(ctk_l, ctk_r)

rule Expr_ok/bine-logical:
  p C |- BinE binop expr_l expr_r : BoolT ctk
  ----
  -- if $in_set(binop, binop, SET LAND LOR)
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_r : typ_r ctk_r
  ----
  -- Sub_impl: typ_l << BoolT
  -- Sub_impl: typ_r << BoolT
  ----
  -- if ctk = $join_ctk(ctk_l, ctk_r)

;;
;; Ternary expression
;;

rule Expr_ok/terne-nointt:
  p C |- TernE expr_c expr_t expr_f : typ ctk
  ----
  -- Expr_ok: p C |- expr_c : typ_c ctk_c
  -- Sub_impl: typ_c << BoolT
  ----
  -- Expr_ok: p C |- expr_t : typ_t ctk_t
  -- Expr_ok: p C |- expr_f : typ_f ctk_f
  ----
  -- Sub_impl: typ_t << typ
  -- Sub_impl: typ_f << typ
  ----
  -- if typ =/= IntT
  ----
  -- if ctk = $joins_ctk(ctk_c ctk_t ctk_f)

rule Expr_ok/terne-intt:
  p C |- TernE expr_c expr_t expr_f : typ ctk
  ----
  -- Expr_ok: p C |- expr_c : typ_c ctk_c
  -- Sub_impl: typ_c << BoolT
  ----
  -- Expr_ok: p C |- expr_t : typ_t ctk_t
  -- Expr_ok: p C |- expr_f : typ_f ctk_f
  ----
  -- Sub_impl: typ_t << IntT
  -- Sub_impl: typ_f << IntT
  ----
  -- if ctk_t = LCTK /\ ctk_f = LCTK
  ----
  -- if ctk = $joins_ctk(ctk_c ctk_t ctk_f)

;;
;; Cast expression
;;

rule Expr_ok/caste:
  p C |- CastE type expr : typ_t ctk_e
  -- Type_ok: p C |- type : typ_t
  -- Expr_ok: p C |- expr : typ_e ctk_e
  -- Sub_expl: typ_e <: typ_t

;;
;; Mask expression
;;

rule Expr_ok/maske:
  p C |- MaskE expr_b expr_m : (SetT typ) DYN
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- Expr_ok: p C |- expr_m : typ_m ctk_m
  ----
  -- Sub_impl: typ_b << typ
  -- Sub_impl: typ_m << typ
  -- if typ = IntT \/ typ = FIntT w \/ typ = FBitT w

;;
;; Range expression
;;

rule Expr_ok/rangee:
  p C |- RangeE expr_l expr_u : (SetT typ) DYN
  ----
  -- Expr_ok: p C |- expr_l : typ_l ctk_l
  -- Expr_ok: p C |- expr_u : typ_u ctk_u
  ----
  -- Sub_impl: typ_l << typ
  -- Sub_impl: typ_u << typ
  -- if typ = IntT \/ typ = FIntT w \/ typ = FBitT w

;;
;; Select expression
;;

relation Select_case_keyset_ok: cursor context typ |- keyset : typ ctk

rule Select_case_keyset_ok/exprk-maske:
  LOCAL C typ_k |- (ExprK (MaskE expr_b expr_m)) : (SetT typ_k) ctk'
  -- Expr_ok: LOCAL C |- (MaskE expr_b expr_m) : (SetT typ') ctk'
  -- Sub_impl: typ' << typ_k

rule Select_case_keyset_ok/exprk-range:
  LOCAL C typ_k |- (ExprK (RangeE expr_l expr_r)) : (SetT typ_k) ctk'
  -- Expr_ok: LOCAL C |- (RangeE expr_l expr_r) : (SetT typ') ctk'
  -- Sub_impl: typ' << typ_k

rule Select_case_keyset_ok/exprk-namee:
  LOCAL C typ_k |- (ExprK (NameE name)) : (SetT typ_k) ctk'
  -- Expr_ok: LOCAL C |- (NameE name) : (SetT typ') ctk'
  -- Sub_impl: typ' << typ_k

rule Select_case_keyset_ok/exprk-else:
  LOCAL C typ_k |- (ExprK expr) : (SetT typ_k) ctk'
  -- Expr_ok: LOCAL C |- expr : (SetT typ') ctk'
  ----
  -- if ~($is_maske(expr) \/ $is_rangee(expr) \/ $is_namee(expr))
  ----
  -- Sub_impl: typ' << typ_k

rule Select_case_keyset_ok/defaultk:
  LOCAL C typ_k |- DefaultK : typ' ctk'

rule Select_case_keyset_ok/anyk:
  LOCAL C typ_k |- AnyK : typ' ctk'

relation Select_case_keysets_ok: cursor context |- typ* keyset* : typ* ctk*

rule Select_case_keysets_ok/one-to-one:
  p C |- typ_k keyset : typ'* ctk'*
  -- Select_case_keyset_ok: p C typ_k |- keyset : typ' ctk'

rule Select_case_keysets_ok/many-to-one:
  p C |- typ_k* keyset : typ'* ctk'*
  -- Select_case_keyset_ok: p C (SeqT typ_k*) |- keyset : typ' ctk'

rule Select_case_keysets_ok/many-to-many:
  p C |- typ_k* keyset* : typ'* ctk'*
  -- if |typ_k*| = |keyset*|
  -- (Select_case_keyset_ok: p C typ_k |- keyset : typ' ctk')*

relation Select_case_ok: cursor context typ* |- selectcase : typ ctk

rule Select_case_ok/singleton:
  LOCAL C typ_k* |- keyset* statelabel : StateT ctk''
  -- Select_case_keysets_ok: LOCAL C |- typ_k* keyset* : typ'* ctk'*
  -- if StateT dir'' ctk'' = $find_typ(LOCAL, C, CURRENT statelabel)

rule Expr_ok/selecte:
  LOCAL C |- SelectE expr_k* selectcase* : StateT DYN
  -- if C.LOCAL.KIND = PARSERSTATE
  -- (Expr_ok: LOCAL C |- expr_k : typ_k ctk_k)*
  ----
  -- (Select_case_ok: LOCAL C typ_k* |- selectcase : StateT DYN)*

;;
;; Array access expression
;;

rule Expr_ok/arracce-tuplet:
  p C |- ArrAccE expr_b expr_i : typ DYN
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- Expr_ok: p C |- expr_i : typ_i ctk_i
  -- Sub_impl: typ_i << typ_i'
  ----
  -- if typ_i' = IntT \/ typ_i' = FIntT w \/ typ_i' = FBitT w
  ----
  -- if TupleT typs_b'* = $canon_typ(typ_b)
  -- Eval_static: p C |- expr_i ~> val_i
  -- if i = $num(val_i)
  -- if typ = typs_b'*[i]

rule Expr_ok/arracce-stackt:
  p C |- ArrAccE expr_b expr_i : typ_b' DYN
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- Expr_ok: p C |- expr_i : typ_i LCTK
  -- Sub_impl: typ_i << typ_i'
  ----
  -- if typ_i' = IntT \/ typ_i' = FIntT w_i' \/ typ_i' = FBitT w_i'
  ----
  -- if StackT typ_b' size = $canon_typ(typ_b)

;;
;; Bitstring access expression
;;

;; (TODO-Jaehyun) check bitstring slice range
rule Expr_ok/bitacce:
  p C |- BitAccE expr_b expr_l expr_h : typ ctk_b
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- Sub_impl: typ_b << typ_b'
  ----
  -- if typ_b' = IntT \/ (typ_b' = FIntT w_b' /\ w_b' >= 1) \/ (typ_b' = FBitT w_b' /\ w_b' >= 0)
  ----
  -- Expr_ok: p C |- expr_l : typ_l LCTK
  -- Sub_impl: typ_l << typ_l'
  -- if typ_l' = IntT \/ typ_l' = FIntT w_l' \/ typ_l' = FBitT w_l'
  ----
  -- Eval_static: p C |- expr_l ~> val_l
  -- if i_l = $num(val_l)
  ----
  -- Expr_ok: p C |- expr_h : typ_h LCTK
  -- Sub_impl: typ_h << typ_h'
  -- if typ_h' = IntT \/ typ_h' = FIntT w_h' \/ typ_h' = FBitT w_h'
  ----
  -- Eval_static: p C |- expr_h ~> val_h
  -- if i_h = $num(val_h)
  ----
  -- if typ = FBitT $(i_h - i_l + 1)

;;
;; Error access expression
;;

rule Expr_ok/erracce:
  p C |- ErrAccE member : ErrT LCTK
  -- if id = $concat_texts("error." member)
  -- if ErrV member = $find_val(p, C, TOP id)

;;
;; Type access expression
;;

rule Expr_ok/typeacce-enumt:
  p C |- TypeAccE name member : typ LCTK
  -- if MonoD typ = $find_typdef(p, C, name)
  -- if EnumT id_t member_t* = $canon_typ(typ)
  -- if member <- member_t*

rule Expr_ok/typeacce-senumt:
  p C |- TypeAccE name member : typ LCTK
  -- if MonoD typ = $find_typdef(p, C, name)
  -- if SEnumT id_t typ_t (member_t, val_t)* = $canon_typ(typ)
  -- if member <- member_t*

;;
;; Expression access expression
;;

rule Expr_ok/expracce-stackt-size:
  p C |- ExprAccE expr_b member : (FBitT 32) LCTK
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- if StackT typ_b' size = $canon_typ(typ_b)
  ----
  -- if $in_set(member, member, SET "size")

rule Expr_ok/expracce-stackt-lastindex:
  p C |- ExprAccE expr_b member : (FBitT 32) DYN
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- if StackT typ_b' size = $canon_typ(typ_b)
  ----
  -- if $in_set(member, member, SET "lastIndex")

rule Expr_ok/expracce-stackt-next-last:
  p C |- ExprAccE expr_b member : typ_b' DYN
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- if StackT typ_b' size = $canon_typ(typ_b)
  ----
  -- if $in_set(member, member, SET "next" "last")

rule Expr_ok/expracce-structt:
  p C |- ExprAccE expr_b member : typ DYN
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- if StructT id_b (member_b, typ_b')* = $canon_typ(typ_b)
  ----
  -- if (member, typ) <- (member_b, typ_b')*

rule Expr_ok/expracce-headert:
  p C |- ExprAccE expr_b member : typ DYN
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- if HeaderT id_b (member_b, typ_b')* = $canon_typ(typ_b)
  ----
  -- if (member, typ) <- (member_b, typ_b')*

rule Expr_ok/expracce-uniont:
  p C |- ExprAccE expr_b member : typ DYN
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- if UnionT id_b (member_b, typ_b')* = $canon_typ(typ_b)
  ----
  -- if (member, typ) <- (member_b, typ_b')*

rule Expr_ok/expracce-tablestructt:
  p C |- ExprAccE expr_b member : typ DYN
  ----
  -- Expr_ok: p C |- expr_b : typ_b ctk_b
  -- if TableStructT id_b (member_b, typ_b')* = $canon_typ(typ_b)
  ----
  -- if (member, typ) <- (member_b, typ_b')*

;;
;; Function call expression
;;

rule Expr_ok/callfunce:
  p C |- CallFuncE name targ* arg* : typ DYN
  ----
  -- FuncType_ok: p C |- name targ* arg* : functyp
  ----
  -- Call_ok: p C |- functyp arg* : typ
  -- if typ =/= VoidT

;;
;; Method call expression
;;

rule Expr_ok/callmethode:
  p C |- CallMethodE expr_b member targ* arg* : typ DYN
  ----
  -- MethodType_ok: p C |- expr_b member targ* arg* : functyp
  ----
  -- Call_ok: p C |- functyp arg* : typ
  -- if typ =/= VoidT

;;
;; Type call expression
;;

rule Expr_ok/calltypee:
  p C |- CallTypeE name member eps arg* : typ DYN
  ----
  -- if typdef = $find_typdef(p, C, name)
  ----
  -- if $in_set(member, member, SET "minSizeInBits" "minSizeInBytes" "maxSizeInBits" "maxSizeInBytes")
  ----
  -- if functyp = BuiltinMethodT eps IntT
  ----
  -- Call_ok: p C |- functyp arg* : typ
  -- if typ =/= VoidT

;;
;; Nameless instantiation expression
;;

rule Expr_ok/inste:
  p C |- InstE name targ* arg* : typ CTK
  -- (Type_ok: p C |- targ : typ_a)*
  -- if consdef = $find_consdef(p, C, name)
  -- if constyp = $specialize_consdef(consdef, typ_a*)
  -- Inst_ok: p C |- constyp arg* : typ

;;
;; L-value expression
;;

def $assignable(typ) : bool     hint(show % IS ASSIGNABLE)
def $assignable'(typ) : bool

def $assignable(typ) = $assignable'($canon_typ(typ))

def $assignable'(VoidT) = false
def $assignable'(ParserT paramtyp*) = false
def $assignable'(ControlT paramtyp*) = false
def $assignable'(PackageT typ*) = false
def $assignable'(TableT id typ) = false
def $assignable'(styp) = false
def $assignable'(typ) = true
  -- otherwise


rule Lval_ok/namee:
  p C |- NameE name
  -- if typ dir ctk = $find_typ(p, C, name)
  -- if dir = OUT \/ dir = INOUT
  -- if $assignable(typ)

rule Lval_ok/arracce:
  p C |- ArrAccE expr_b expr_i
  -- Lval_ok: p C |- expr_b

rule Lval_ok/bitacce:
  p C |- BitAccE expr_b expr_l expr_h
  -- Lval_ok: p C |- expr_b

rule Lval_ok/expracce:
  p C |- ExprAccE expr_b member
  -- Lval_ok: p C |- expr_b
