;;
;; Big-step semantics for expressions
;;

;; Folding sequence of expressions

rule Interp_exprs/base:
  S C |- eps : C eps

rule Interp_exprs/rec:
  S C |- expr expr* : C'' (val val*)
  ----
  -- Interp_expr: S C |- expr : C' val
  ----
  -- Interp_exprs : S C' |- expr* : C'' val*


;; Rules for each expression

rule Interp_expr/e_bool:
  S C |- E_BOOL boolean : C (V_BOOL boolean)

rule Interp_expr/e_str:
  S C |- E_STR str : C (V_STR str)

;; TODO
;; rule Interp_expr/e_num:

rule Interp_expr/e_var-top:
  S C |- E_VAR (TOP id) : C val
  -- if val = $find_var_glob(C, id)

rule Interp_expr/e_var-bare:
  S C |- E_VAR (BARE id) : C val
  -- if val = $find_var(C, id)

rule Interp_expr/e_list:
  S C |- E_LIST expr* : C' (V_TUPLE val*)
  -- Interp_exprs: S C |- expr* : C' val*

rule Interp_expr/e_record:
  S C |- E_RECORD (str, expr)* : C' (V_STRUCT (str, val)*)
  -- Interp_exprs: S C |- expr* : C' val*

rule Interp_expr/e_un:
  S C |- E_UN unop expr : C' val'
  ----
  -- Interp_expr: S C |- expr : C' val
  ----
  -- if val' = $unop(unop, val)

rule Interp_expr/e_bin:
  S C |- E_BIN binop expr_l expr_r : C'' val
  ----
  -- Interp_expr: S C |- expr_l : C' val_l
  ----
  -- Interp_expr: S C' |- expr_r : C'' val_r
  ----
  -- if val = $binop(binop, val_l, val_r)

rule Interp_expr/e_tern-tru:
  S C |- E_TERN expr_c expr_t expr_f : C'' val
  ----
  -- Interp_expr: S C |- expr_c : C' val_c
  ----
  -- if V_BOOL true = $cast(val_c, RT_BOOL)
  ----
  -- Interp_expr: S C |- expr_t : C'' val

rule Interp_expr/e_tern-fls:
  S C |- E_TERN expr_c expr_t expr_f : C'' val
  ----
  -- Interp_expr: S C |- expr_c : C' val_c
  ----
  -- if V_BOOL false = $cast(val_c, RT_BOOL)
  ----
  -- Interp_expr: S C |- expr_f : C'' val

rule Interp_expr/e_cast:
  S C |- E_CAST type expr : C' val'
  ----
  -- Interp_type: C |- type : rtype
  ----
  -- Interp_expr: S C |- expr : C' val
  ----
  -- if val' = $cast(val, rtype)

;; TODO
;; rule Interp_expr/e_mask:
;; TODO
;; rule Interp_expr/e_range:

rule Interp_expr/e_arracc:
  S C |- E_ARRACC expr_b expr_i : C'' val
  ----
  -- Interp_expr: S C |- expr_b : C' (V_STACK val* num_i num_s)
  ----
  -- Interp_expr: S C' |- expr_i : C'' val_i
  ----
  -- if i = $unpack(val_i)
  -- if val = val*[i]

rule Interp_expr/e_bitacc:
  S C |- E_BITACC expr_b expr_h expr_l : C''' val
  ----
  -- Interp_expr: S C |- expr_b : C' val_b
  ----
  -- Interp_expr: S C' |- expr_h : C'' val_h
  ----
  -- Interp_expr: S C'' |- expr_l : C''' val_l
  ----
  -- if val = $bitslice(val_b, val_h, val_l)

rule Interp_expr/e_typeacc-top:
  S C |- E_TYPEACC (TOP id) mem : C (V_ENUMFIELD mem)
  -- if RT_ENUM mems = $find_td_glob(C, id)
  ;; TODO check that mem \in mems

rule Interp_expr/e_typeacc-bare:
  S C |- E_TYPEACC (BARE id) mem : C (V_ENUMFIELD mem)
  -- if RT_ENUM mems = $find_td(C, id)
  ;; TODO check that mem \in mems

rule Interp_expr/e_erracc:
  S C |- E_ERRACC mem : C (V_ERR mem)
  -- if RT_ERR mems = $find_td_glob(C, "error")
  ;; TODO check that mem \in mems

rule Interp_expr/e_expracc-header:
  S C |- E_EXPRACC expr_b mem : C' val
  -- Interp_expr: S C |- expr_b : C' (V_HEADER valid (str, val)*)
  -- if val = $find_field((str, val)*, mem)

rule Interp_expr/e_expracc-struct:
  S C |- E_EXPRACC expr_b mem : C' val
  -- Interp_expr: S C |- expr_b : C' (V_STRUCT (str, val)*)
  -- if val = $find_field((str, val)*, mem)

;; TODO
;; rule Interp_expr/e_expracc-stack:

rule Interp_expr/e_expracc-ref:
  S C |- E_EXPRACC expr_b mem : C' (V_REF (path mem))
  -- Interp_expr: S C |- expr_b : C' (V_REF path)

rule Interp_expr/e_call:
  S C |- E_CALL expr_f type* arg* : C' val
  -- Interp_call: S C |- expr_f type* arg* : (RET val?) C'


