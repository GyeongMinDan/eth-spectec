;; Statements

rule Stmts_ok/empty:
  p C f |- eps : C f

rule Stmts_ok/seq:
  p C f |- stmt_h stmt_t* : C'' f''
  -- Stmt_ok: p C f |- stmt_h : C' f'
  -- Stmts_ok: p C' f' |- stmt_t* : C'' f''


;; Empty statement

rule Stmt_ok/emptys:
  p C f |- EmptyS : C f


;; Assignment statement

rule Stmt_ok/assigns:
  p C f |- AssignS expr_l expr_r : C f
  -- Expr_ok: p C |- expr_l : typ_l
  -- Lval_ok: p C |- expr_l : OK
  -- Expr_ok: p C |- expr_r : typ_r
  -- Sub_impl: typ_r <: typ_l


;; Switch statement
;; TODO check for duplicate label and non-last default label

relation Switch_tbl_label_ok:
  cursor context id |- switchlabel : OK

rule Switch_tbl_label_ok/exprl:
  p C id_t |- ExprL (NameE (CURRENT id_a)) : OK
  -- if id_e = $concat_texts("action\\_list(" id_t ")")
  -- if id = $concat_texts(id_e "." id_a)
  -- if TableEnumFieldV id_e id_a = $find_val(p, C, CURRENT id)

rule Switch_tbl_label_ok/defaultl:
  p C id_t |- DefaultL : OK


relation Switch_tbl_case_ok:
  cursor context flow id |- switchcase : flow

rule Switch_tbl_case_ok/matchc:
  p C f id_t |- MatchC label block : f'
  -- Switch_tbl_label_ok: p C id_t |- label : OK
  -- Stmt_ok: p C f |- BlockS block : C' f'

rule Switch_tbl_case_ok/fallc:
  p C f id_t |- FallC label : f
  -- Switch_tbl_label_ok: p C id_t |- label : OK


relation Switch_tbl_cases_ok:
  cursor context flow id |- switchcase* : flow

rule Switch_tbl_cases_ok/empty:
  p C f id_t |- eps : f

rule Switch_tbl_cases_ok/seq:
  p C f id_t |- case_h case_t* : f''
  -- Switch_tbl_case_ok: p C f id_t |- case_h : f'
  -- Switch_tbl_cases_ok: p C f' id_t |- case_t* : f''


rule Stmt_ok/switchs-tbl:
  p C f |- SwitchS expr case* : C f'
  -- Expr_ok: p C |- expr : TableEnumT id member
  -- if id = $concat_texts("action\\_list(" id_t ")")
  -- Switch_tbl_cases_ok: p C f id_t |- case* : f'


relation Switch_gen_label_ok:
  cursor context typ |- switchlabel : OK

rule Switch_gen_label_ok/exprl:
  p C typ_s |- ExprL expr : OK
  -- Expr_ok: p C |- expr : typ
  -- Sub_impl: typ <: typ_s

rule Switch_gen_label_ok/defaultl:
  p C typ_s |- DefaultL : OK

relation Switch_gen_case_ok:
  cursor context flow typ |- switchcase : flow

rule Switch_gen_case_ok/matchc:
  p C f typ_s |- MatchC label block : f'
  -- Switch_gen_label_ok: p C typ_s |- label : OK
  -- Stmt_ok: p C f |- BlockS block : C' f'

rule Switch_gen_case_ok/fallc:
  p C f typ_s |- FallC label : f
  -- Switch_gen_label_ok: p C typ_s |- label : OK


relation Switch_gen_cases_ok:
  cursor context flow typ |- switchcase* : flow

rule Switch_gen_cases_ok/empty:
  p C f typ_s |- eps : f

rule Switch_gen_cases_ok/seq:
  p C f typ_s |- case_h case_t* : f''
  -- Switch_gen_case_ok: p C f typ_s |- case_h : f'
  -- Switch_gen_cases_ok: p C f' typ_s |- case_t* : f''


rule Stmt_ok/switchs-gen:
  p C f |- SwitchS expr case* : C f'
  -- Expr_ok: p C |- expr : typ
  ----
  -- (if $saturate_typ(typ) = ErrT \/ $saturate_typ(typ) = FIntT w \/ $saturate_typ(typ) = FBitT w \/ $saturate_typ(typ) = EnumT id member* \/ $saturate_typ(typ) = SEnumT id typ' (member, val)*)
  ----
  -- Switch_gen_cases_ok: p C f typ |- case* : f'

;; If statement

rule Stmt_ok/ifs:
  p C f |- IfS expr_c stmt_t stmt_f : C f'
  -- Expr_ok: p C |- expr_c : BoolT
  -- Stmt_ok: p C f |- stmt_t : C_t f_t
  -- Stmt_ok: p C f |- stmt_f : C_f f_f
  -- if f' = $join_flow(f_t f_f)


;; Block statement

rule Stmt_ok/blocks:
  p C f |- BlockS block : C''' f'
  -- if BlockB stmt* = block
  -- if C' = $enter(C)
  -- Stmts_ok: p C' f |- stmt* : C'' f'
  -- if C''' = $exit(C'')


;; Exit statement

rule Stmt_ok/exits:
  p C f |- ExitS : C f


;; Return statement

rule Stmt_ok/rets-none:
  LOCAL C f |- RetS eps : C RET
  -- if typ = VoidT
  -- if typ_r = $find_returntyp(C.LOCAL.KIND)
  -- Sub_impl: typ <: typ_r

rule Stmt_ok/rets-none:
  LOCAL C f |- RetS expr? : C RET
  -- Expr_ok: p C |- expr : typ
  -- if typ_r = $find_returntyp(C.LOCAL.KIND)
  -- Sub_impl: typ <: typ_r


;; Function call statement

rule Stmt_ok/callfuncs:
  p C f |- CallFuncS name targ* arg* : C f
  ----
  -- Func_ok: p C |- name targ* arg* : functyp
  ----
  -- Call_ok: p C |- functyp arg* : typ


;; Method call statement

rule Stmt_ok/callmethods:
  p C f |- CallMethodS expr_b member targ* arg* : C f
  ----
  -- Method_ok: p C |- expr_b member targ* arg* : functyp
  ----
  -- Call_ok: p C |- functyp arg* : typ


;; Instantiation statement

rule Stmt_ok/callinsts:
  p C f |- CallInstS name targ* arg* : C f
  -- if consdef = $find_consdef(p, C, name)
  -- if constyp = $specialize_consdef(consdef, eps)
  -- Inst_ok: p C |- constyp eps : typ
  ----
  -- if ($saturate_typ(typ) = ParserT paramtyp*) \/ ($saturate_typ(typ) = ControlT paramtyp*)
  ----
  -- if (TOP id = name) \/ (CURRENT id = name)
  -- if C' = $add_typ(p, C, id, typ)
  ----
  -- Stmt_ok: p C' f |- CallMethodS (NameE (CURRENT id)) "apply" targ* arg* : C' f'


;; Transition statement

rule Stmt_ok/transs:
  p C f |- TransS expr : C f
  -- Expr_ok: p C |- expr : StateT


;; Declaration statement

rule Stmt_ok/decls:
  p C f |- DeclS decl : C' f
  -- Decl_ok: p C |- decl : C'
