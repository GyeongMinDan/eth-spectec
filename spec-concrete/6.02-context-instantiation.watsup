;;
;; Layered context
;;

;; Global layer

syntax glayerInst =
  { CENV cenv,
    TDENV tdenv,
    RENV renv,
    VENV venv }

;; Block Layer

syntax blayerInst =
  { THETA theta,
    RENV renv,
    SENV senv,
    VENV venv }

;; Local layer

syntax llayerInst =
  { THETA theta,
    VENVS venv* }

;;
;; Instantiation context
;;

syntax contextInst =
  { PATH oid,
    GLOBAL glayerInst,
    BLOCK blayerInst,
    LOCAL llayerInst }

var Ci : contextInst

;;
;; Constructors
;;

dec $empty_block() : blayerInst

def $empty_block() =
  { THETA $empty_theta,
    RENV $empty_renv,
    SENV $empty_senv,
    VENV $empty_venv }

dec $empty_local() : llayerInst

def $empty_local() =
  { THETA $empty_theta,
    VENVS ([]) }

dec $empty_context_inst() : contextInst

def $empty_context_inst() = Ci
  -- if glayerInst =
      { CENV $empty_cenv,
        TDENV $empty_tdenv,
        RENV $empty_renv,
        VENV $empty_venv }
  -- if blayerInst = $empty_block()
  -- if llayerInst = $empty_local()
  -- if Ci = { PATH ([]), GLOBAL glayerInst, BLOCK blayerInst, LOCAL llayerInst }


;;
;; Frame entry
;;

dec $enter_inst(contextInst) : contextInst

def $enter_inst(Ci) = Ci[ .LOCAL.VENVS = $empty_venv :: Ci.LOCAL.VENVS ]

dec $exit_inst(contextInst) : contextInst

def $exit_inst(Ci) = Ci[ .LOCAL.VENVS = venv_t* ]
  -- if venv_h :: venv_t* = Ci.LOCAL.VENVS

;;
;; Path entry
;;

dec $enter_path(contextInst, id) : contextInst

def $enter_path(Ci, id) = Ci[ .PATH = Ci.PATH ++ id ]

;;
;; Context inheritance
;;

dec $copy_context_inst(cursor, contextInst) : contextInst

def $copy_context_inst(GLOBAL, Ci) = Ci[ .BLOCK = $empty_block ][ .LOCAL = $empty_local ]
def $copy_context_inst(BLOCK, Ci) = Ci[ .LOCAL = $empty_local ]
def $copy_context_inst(LOCAL, Ci) = Ci

;;
;; Adders
;;

;;; Adder for values

dec $add_value_inst(cursor, contextInst, id, value): contextInst
dec $add_values_inst(cursor, contextInst, id*, value*): contextInst

def $add_value_inst(GLOBAL, Ci, id, value) = Ci[ .GLOBAL.VENV = venv ]
  -- if $add_map<id, value>(Ci.GLOBAL.VENV, id, value) = venv ;; TODO: add_nodup?
def $add_value_inst(BLOCK, Ci, id, value) = Ci[ .BLOCK.VENV = venv ]
  -- if $add_map<id, value>(Ci.BLOCK.VENV, id, value) = venv ;; TODO: add_nodup?
def $add_value_inst(LOCAL, Ci, id, value) = Ci[ .LOCAL.VENVS = venv_h :: venv_t* ]
  -- if Ci.LOCAL.VENVS = venv_h :: venv_t*
  -- if $add_map<id, value>(venv_h, id, value) = venv_h' ;; TODO: add_nodup?

def $add_values_inst(p, Ci, eps, eps) = Ci
def $add_values_inst(p, Ci, id_h :: id_t*, value_h :: value_t*) = Ci''
  -- if $add_value_inst(p, Ci, id_h, value_h) = Ci'
  -- if $add_values_inst(p, Ci', id_t*, value_t*) = Ci''

;;; Adder for routines

dec $add_routine_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst

dec $add_routine_non_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst

def $add_routine_non_overload_inst(GLOBAL, Ci, rid, routineDyn) = Ci[ .GLOBAL.RENV = renv ]
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.GLOBAL.RENV))
  -- if renv = $add_map<rid, routineDyn>(Ci.GLOBAL.RENV, rid, routineDyn)

def $add_routine_non_overload_inst(BLOCK, Ci, rid, routineDyn) = Ci[ .BLOCK.RENV = renv ]
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.BLOCK.RENV))
  -- if renv = $add_map<rid, routineDyn>(Ci.BLOCK.RENV, rid, routineDyn)

dec $add_tparams_inst(cursor, contextInst, typeParameterIR*, typeIR*) : contextInst
dec $add_tparam_inst(cursor, contextInst, typeParameterIR, typeIR) : contextInst

;;; Adder for type parameters
def $add_tparams_inst(p, Ci, eps, eps) = Ci
def $add_tparams_inst(p, Ci, typeParameterIR_h :: typeParameterIR_t*, typeIR_h :: typeIR_t*) =
    $add_tparams_inst(p, Ci', typeParameterIR_t*, typeIR_t*)
  -- if $add_tparam_inst(p, Ci, typeParameterIR_h, typeIR_h) = Ci'

def $add_tparam_inst(BLOCK, Ci, typeParameterIR, typeIR) = Ci[ .BLOCK.THETA = theta ]
  -- if $add_map<tid, typeIR>(Ci.BLOCK.THETA, typeParameterIR, typeIR) = theta
def $add_tparam_inst(LOCAL, Ci, typeParameterIR, typeIR) = Ci[ .LOCAL.THETA = theta ]
  -- if $add_map<tid, typeIR>(Ci.LOCAL.THETA, typeParameterIR, typeIR) = theta

;;; Adder for constructors
dec $add_constructor_inst(cursor, contextInst, cid, consDyn) : contextInst

def $add_constructor_inst(GLOBAL, Ci, cid, consDyn) = Ci[ .GLOBAL.CENV = cenv ]
  -- if cenv = $add_map<cid, consDyn>(Ci.GLOBAL.CENV, cid, consDyn)

;;; Adder for types
dec $add_typedef_inst(cursor, contextInst, tid, typeDefIR) : contextInst

def $add_typedef_inst(GLOBAL, Ci, tid, typeDefIR) = Ci[ .GLOBAL.TDENV = tdenv ]
  -- if tdenv = $add_map<tid, typeDefIR>(Ci.GLOBAL.TDENV, tid, typeDefIR)

;;
;; Finders
;;

;;; Finder for values

dec $find_value_inst(cursor, contextInst, nameIR) : value?

;;; Finder for types
dec $find_type_inst(cursor, contextInst, prefixedNameIR) : typeIR

;;; Finder for typedefs

dec $find_typedef_inst(cursor, contextInst, nameIR) : typeDefIR?

;;; Finder for routines

dec $ids_arguments_IR(argumentIR*) : (id?)*
dec $id_argument_IR(argumentIR) : id?

def $ids_arguments_IR(argumentIR*) = ($id_argument_IR(argumentIR))*
def $id_argument_IR(typedExpressionIR) = eps
def $id_argument_IR(nameIR `= _) = nameIR
def $id_argument_IR(nameIR `= `_) = nameIR
def $id_argument_IR(`_) = eps

dec $find_constructor_overloaded_inst(contextInst, prefixedNameIR, argumentIR*) : (rid, consDyn, id*)?
def $find_constructor_overloaded_inst(Ci, `` id, argumentIR*)
  = $find_overloaded<consDyn>(Ci.GLOBAL.CENV, id, (id_arg?)*)
  -- if $ids_arguments_IR(argumentIR*) = (id_arg?)*

def $find_constructor_overloaded_inst(Ci, `. id, argumentIR*)
  = $find_overloaded<consDyn>(Ci.GLOBAL.CENV, id, (id_arg?)*)
  -- if $ids_arguments_IR(argumentIR*) = (id_arg?)*


