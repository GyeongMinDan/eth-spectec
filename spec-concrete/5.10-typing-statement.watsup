;;
;; Statement typing
;;
;; syntax statement
;;

;;; emptyStatement
;;; syntax emptyStatement = `;

rule Stmt_ok/emptyStatement:
  p C f |- `; : C f `;

;;; assignmentStatement
;;; syntax assignmentStatement = lvalue assignop expression `;
;;;; syntax assignop

;;;;; `=

rule Stmt_ok/assignmentStatement-eq:
  p C f |- lvalue `= expression `;
         : C f (typedLvalueIR `= typedExpressionIR `;)
  ---- ;; check lvalue
  -- Lvalue_ok: p C |- lvalue : typedLvalueIR
  ---- ;; check expression
  -- Expr_ok: p C |- expression : typedExpressionIR
  ---- ;; fetch annotations
  -- if _ `# `( typeIR_l ) = typedLvalueIR
  -- if _ `# `( typeIR_r _ ) = typedExpressionIR
  ---- ;; check type compatibility
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_cast = $coerce_unary(typedExpressionIR, typeIR_l)

;;;;; `+= | `-= | `|+|= | `|-|= | `*=
;;;;; | `/= | `%= | `<<= | `>>= | `&= | `^= | `|=

;;; callStatement
;;; syntax callStatement

;;;; lvalue `( argumentList ) `;

rule Stmt_ok/callStatement-no-typeArgumentList:
  p C f |- lvalue_routine `( argumentList ) `;
         : C f callStatementIR
  ---- ;; check base lvalue
  -- RoutineTarget_lvalue_ok: p C |- lvalue_routine : routineTargetIR
  ---- ;; check lvalue as routine
  -- if argument* = $flatten_argumentList(argumentList)
  -- RoutineType_ok:
      p C |- routineTargetIR `< eps > `( argument* )
           : routineTypeIR `< `# tid_impl* > `( `# id_default* )
  ---- ;; check arguments
  -- (Argument_ok: p C |- argument : argumentIR)*
  ---- ;; check calling convention
  -- Call_ok: p C |- routineTypeIR `< eps `# tid_impl* > `( argumentIR* `# id_default* )
                   : typeIR_ret `< typeArgumentIR_inferred* > `( argumentIR_cast* )
  ---- ;; create IR
  -- if callStatementIR
      = routineTargetIR `< typeArgumentIR_inferred* > `( argumentIR_cast* ) `;

;;;; lvalue `< typeArgumentList > `( argumentList ) `;

rule Stmt_ok/callStatement-typeArgumentList:
  p C f |- lvalue_routine `< typeArgumentList > `( argumentList ) `;
         : C f callStatementIR
  ---- ;; check base lvalue
  -- RoutineTarget_lvalue_ok: p C |- lvalue_routine : routineTargetIR
  ---- ;; check type arguments
  -- if typeArgument* = $flatten_typeArgumentList(typeArgumentList)
  -- TypeArguments_ok: p C |- typeArgument* : typeArgumentIR* `# tid_impl*
  ---- ;; check lvalue as routine
  -- if argument* = $flatten_argumentList(argumentList)
  -- RoutineType_ok:
      p C |- routineTargetIR `< typeArgumentIR* > `( argument* )
           : routineTypeIR `< `# tid_inserted* > `( `# id_default* )
  ---- ;; check arguments
  -- (Argument_ok: p C |- argument : argumentIR)*
  ---- ;; check calling convention
  -- if tid_infer* = tid_impl* ++ tid_inserted*
  -- Call_ok: p C |- routineTypeIR `< eps `# tid_infer* > `( argumentIR* `# id_default* )
                   : typeIR_ret `< typeArgumentIR_inferred* > `( argumentIR_cast* )
  ---- ;; create IR
  -- if callStatementIR
      = routineTargetIR `< typeArgumentIR_inferred* > `( argumentIR_cast* ) `;

;;; directApplicationStatement
;;; syntax directApplicationStatement = namedType `. APPLY `( argumentList ) `;

dec $compat_direct_application(typeIR) : bool
dec $compat'_direct_application(typeIR) : bool

def $compat_direct_application(typeIR)
  = $compat'_direct_application($canon(typeIR))
def $compat'_direct_application(PARSER `( _ )) = true
def $compat'_direct_application(CONTROL `( _ )) = true
def $compat'_direct_application(typeIR) = false
  -- otherwise

rule Stmt_ok/directApplicationStatement-prefixedTypeName:
  p C_0 f |- namedType `. APPLY `( argumentList ) `;
           : C_0 f directApplicationStatementIR
  ---- ;; check instantiation
  -- Expr_ok: p C_0 |- namedType `( `EMPTY )
                     : ((typeIR_object `< eps >) `( eps )) 
                       `# `( _ _ )
  ---- ;; only parser and controls can be direclty invoked
  -- if $compat_direct_application(typeIR_object)
  ---- ;; insert temporary variable for the constructed type
  -- if nameIR_object = "__direct_application"
  -- if C_1 = $add_var(p, C_0, nameIR_object, `EMPTY typeIR_object CTK eps)
  ---- ;; check apply method
  -- if lvalue = (`ID nameIR_object) `. (`ID "apply")
  -- Stmt_ok: p C_1 f |- lvalue `( argumentList ) `; : _ _ callStatementIR
  -- if (((`` nameIR_object) `# `( typeIR_object )) `. "apply")
          `< eps > `( argumentIR_cast* ) `;
      = callStatementIR
  ---- ;; create IR
  -- if directApplicationStatementIR
      = typeIR_object `. APPLY `( argumentIR_cast* ) `;

;;; returnStatement
;;; syntax returnStatement

;;;; RETURN `;

rule Stmt_ok/returnStatement-empty:
  LOCAL C f |- RETURN `;
             : C RET (RETURN `;)
  ---- ;; check that the return type in the context is VOID
  -- if VOID = $get_return_type(C)

;;;; RETURN expression `;

rule Stmt_ok/returnStatement-expression:
  LOCAL C f |- RETURN expression `;
             : C RET (RETURN typedExpressionIR_cast `;)
  ---- ;; check expression
  -- Expr_ok: LOCAL C |- expression : typedExpressionIR
  ---- ;; fetch annotation
  -- if _ `# `( typeIR _ ) = typedExpressionIR
  ---- ;; check the return type in the context
  -- if typeIR_ret = $get_return_type(C)
  ---- ;; check type compatibility
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_cast = $coerce_unary(typedExpressionIR, typeIR_ret)

;;; exitStatement
;;; syntax exitStatement = EXIT `;

rule Stmt_ok/exitStatement:
  p C f |- EXIT `; : C f (EXIT `;)

;;; blockStatement

rule Stmt_ok/blockStatement:
  LOCAL C_0 f_0 |- blockStatement : C_1 f_1 blockStatementIR
  -- Block_ok: C_0 f_0 |- blockStatement
                        : C_1 f_1 blockStatementIR

;;; conditionalStatement
;;; syntax conditionalStatement =

;;;; IF `( expression ) statement

rule Stmt_ok/conditionalStatement-non-else:
  p C f |- IF `( expression_cond ) statement_then
         : C f (IF `( typedExpressionIR_cond ) statementIR_then)
  ---- ;; check condition expression
  -- Expr_ok: p C |- expression_cond : typedExpressionIR_cond
  ---- ;; fetch annotation
  ---- ;; the condition must be a boolean type
  -- if _ `# `( BOOL _ ) = typedExpressionIR_cond
  ---- ;; check then statement
  -- Stmt_ok: p C f |- statement_then : C_then f_then statementIR_then

;;;; IF `( expression ) statement ELSE statement

rule Stmt_ok/conditionalStatement-else:
  p C f |- IF `( expression_cond ) statement_then ELSE statement_else
         : C f_post (IF `( typedExpressionIR_cond ) statementIR_then
                     ELSE statementIR_else)
  ---- ;; check condition expression
  -- Expr_ok: p C |- expression_cond : typedExpressionIR_cond
  ---- ;; fetch annotation
  ---- ;; the condition must be a boolean type
  -- if _ `# `( BOOL _ ) = typedExpressionIR_cond
  ---- ;; check then and else statements
  -- Stmt_ok: p C f |- statement_then : C_then f_then statementIR_then
  -- Stmt_ok: p C f |- statement_else : C_else f_else statementIR_else
  -- if f_post = $join_flow(f_then, f_else)

;;; forStatement

;;; breakStatement

;;; continueStatement

;;; switchStatement

;;
;; syntax blockElementStatement
;;

;;; constantDeclaration

rule BlockElementStmt_ok/constantDeclaration:
  C_0 f |- constantDeclaration : C_1 f constantDeclarationIR
  -- Decl_ok: LOCAL C_0 |- constantDeclaration : C_1 constantDeclarationIR

;;; variableDeclaration
;;; syntax variableDeclaration =
;;;   annotationList type name initializerOpt `;

rule BlockElementStmt_ok/variableDeclaration-empty:
  C_0 f |- annotationList type name `EMPTY `;
         : C_1 f variableDeclarationIR
  ---- ;; check type
  -- Type_ok: LOCAL C_0 |- type : typeIR `# eps
  -- Type_wf: $bound(LOCAL, C_0) |- typeIR
  ---- ;; update the context
  -- if nameIR = $name(name)
  -- if C_1 = $add_var(LOCAL, C_0, nameIR, INOUT typeIR DYN eps)
  ---- ;; create IR
  -- if variableDeclarationIR
      = annotationList typeIR nameIR eps `;

rule BlockElementStmt_ok/variableDeclaration-initializer:
  C_0 f |- annotationList type name (`= expression_init) `;
         : C_1 f variableDeclarationIR
  ---- ;; check type
  -- Type_ok: LOCAL C_0 |- type : typeIR `# eps
  -- Type_wf: $bound(LOCAL, C_0) |- typeIR
  ---- ;; check expression
  -- Expr_ok: LOCAL C_0 |- expression_init : typedExpressionIR_init
  ---- ;; check that the expression matches the type
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_init_cast
      = $coerce_unary(typedExpressionIR_init, typeIR)
  ---- ;; update the context
  -- if nameIR = $name(name)
  -- if C_1 = $add_var(LOCAL, C_0, nameIR, INOUT typeIR DYN eps)
  ---- ;; create IR
  -- if variableDeclarationIR
      = annotationList typeIR nameIR (`= typedExpressionIR_init_cast) `;

;;; statement

rule BlockElementStmt_ok/statement:
  C_0 f |- statement : C_1 f_post statementIR
  -- Stmt_ok: LOCAL C_0 f |- statement : C_1 f_post statementIR

;;
;; syntax blockElementStatementList
;;

rule BlockElementStmts_ok/nil:
  C f |- eps : C f eps

rule BlockElementStmts_ok/cons:
  C_0 f_0 |- blockElementStatement_h :: blockElementStatement_t*
           : C_2 f_2 (blockElementStatementIR_h :: blockElementStatementIR_t*)
  -- BlockElementStmt_ok: C_0 f_0 |- blockElementStatement_h
                                   : C_1 f_1 blockElementStatementIR_h
  -- BlockElementStmts_ok: C_1 f_1 |- blockElementStatement_t*
                                    : C_2 f_2 blockElementStatementIR_t*

;;
;; syntax blockStatement
;;

;;; syntax blockStatement = annotationList `{ blockElementStatementList }

rule Block_ok:
  C_0 f |- annotationList `{ blockElementStatementList }
           : C_3 f_post blockStatementIR
  ---- ;; check block element statements in nested context
  -- if blockElementStatement*
      = $flatten_blockElementStatementList(blockElementStatementList)
  -- if C_1 = $enter(C_0)
  -- BlockElementStmts_ok: C_1 f |- blockElementStatement*
                                  : C_2 f_post blockElementStatementIR*
  -- if C_3 = $exit(C_2)
  ---- ;; create IR
  -- if blockStatementIR = annotationList `{ blockElementStatementIR* }
