;;
;;;; syntax declaration
;;

;;; constantDeclaration
;;; syntax constantDeclaration =
;;;   annotationList CONST type name initializer `;

rule Decl_ok/constantDeclaration:
  p C_0 |- annotationList CONST type name (`= expression_value) `;
         : C_1 constantDeclarationIR
  ---- ;; check type
  -- Type_ok: p C_0 |- type : typeIR `# eps
  -- Type_wf: $bound(p, C_0) |- typeIR
  ---- ;; check expression
  -- Expr_ok: p C_0 |- expression_value : typedExpressionIR_value
  -- if _ `# `( _ LCTK ) = typedExpressionIR_value
  ---- ;; check that the expression matches the type
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_value_cast
      = $coerce_unary(typedExpressionIR_value, typeIR)
  ---- ;; evaluate the expression
  -- Eval_static: p C_0 |- typedExpressionIR_value_cast ~> value
  ---- ;; update the context
  -- if nameIR = $name(name) 
  -- if C_1 = $add_var(p, C_0, nameIR, `EMPTY typeIR LCTK value)
  ---- ;; create IR
  -- if constantDeclarationIR
      = annotationList CONST typeIR nameIR (`= value) `;

;;; instantiation
;;; syntax instantiation

;;;; annotationList type `( argumentList ) name `;

rule Decl_ok/instantiation-prefixedTypeName-non-objectInitializer:
  p C_0 |- annotationList prefixedTypeName `( argumentList ) name `;
         : C_1 instantiationIR
  ---- ;; check constructor type
  -- if prefixedNameIR = $prefixedTypeName(prefixedTypeName)
  -- if argument* = $flatten_argumentList(argumentList)
  -- ConstructorType_ok: p C_0 |- prefixedNameIR `< eps > `( argument* )
                                : constructorTypeIR `< `# tid_impl* > `( `# id_default* )
  ---- ;; check arguments
  -- (Argument_ok: p C_0 |- argument : argumentIR)*
  ---- ;; check instantiation convention
  -- Inst_ok: p C_0 |- constructorTypeIR `< eps `# tid_impl* > `( argumentIR* `# id_default* )
                     : typeIR_object `< typeArgumentIR_inferred* > `( argumentIR_cast* )
  ---- ;; update the context with the instantiated object
  -- if nameIR = $name(name)
  -- if C_1 = $add_var(p, C_0, nameIR, `EMPTY typeIR_object CTK eps)
  ---- ;; create IR
  -- if instantiationIR
      = annotationList prefixedNameIR
          `< typeArgumentIR_inferred* > `( argumentIR* ) nameIR eps `;

rule Decl_ok/instantiation-specializedType-non-objectInitializer:
  p C_0 |- annotationList
            (prefixedTypeName `< typeArgumentList >) `( argumentList ) name `;
         : C_1 instantiationIR
  ---- ;; check type arguments
  -- if typeArgument* = $flatten_typeArgumentList(typeArgumentList)
  -- TypeArguments_ok: p C_0 |- typeArgument* : typeArgumentIR* `# tid_impl*
  ---- ;; check constructor type
  -- if prefixedNameIR = $prefixedTypeName(prefixedTypeName)
  -- if argument* = $flatten_argumentList(argumentList)
  -- ConstructorType_ok:
      p C_0 |- prefixedNameIR `< typeArgumentIR* > `( argument* )
             : constructorTypeIR `< `# tid_inserted* > `( `# id_default* )
  ---- ;; check arguments
  -- (Argument_ok: p C_0 |- argument : argumentIR)*
  ---- ;; check instantiation convention
  -- if tid_infer* = tid_impl* ++ tid_inserted*
  -- Inst_ok:
      p C_0 |- constructorTypeIR `< typeArgumentIR* `# tid_infer* > `( argumentIR* `# id_default* )
             : typeIR_object `< typeArgumentIR_inferred* > `( argumentIR_cast* )
  ---- ;; update the context with the instantiated object
  -- if nameIR = $name(name)
  -- if C_1 = $add_var(p, C_0, nameIR, `EMPTY typeIR_object CTK eps)
  ---- ;; create IR
  -- if instantiationIR
      = annotationList prefixedNameIR
          `< typeArgumentIR_inferred* > `( argumentIR* ) nameIR eps `;

;;;; annotationList type `( argumentList ) name objectInitializer `;

relation Decl_object_ok:
  cursor context frame rdenv |- objectDeclaration : frame rdenv objectDeclarationIR
  hint(input %0 %1 %2 %3 %4)

;;;;; syntax objectDeclaration

;;;;;; functionDeclaration
;;;;;; syntax functionDeclaration =
;;;;;;   annotationList functionPrototype blockStatement
;;;;;;; syntax functionPrototype =
;;;;;;;   typeOrVoid name typeParameterListOpt `( parameterList )

rule Decl_object_ok/functionDeclaration:
  p C_0 frame rdenv |- annotationList
                        (typeOrVoid name typeParameterListOpt `( parameterList ))
                        blockStatement
                     : frame rdenv_init functionDeclarationIR
  ---- ;; set dummy context
  -- if C_1 = C_0[ .BLOCK.FRAME = frame ]
  ---- ;; check type parameters
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_2 = $add_types(LOCAL, C_1, tid_expl*, (TID tid_expl)*)
  ---- ;; check return type
  -- Type_ok: LOCAL C_2 |- typeOrVoid : typeIR_ret `# eps
  ---- ;; check parameters
  -- if parameter* = $flatten_parameterList(parameterList)
  -- Parameters_ok: LOCAL C_2 |- parameter* : parameterIR* `# tid_impl*
  -- if (parameterTypeIR = $parameterIR(parameterIR))*
  -- if C_3 = $add_parameters(LOCAL, C_2, parameterTypeIR*)
  ---- ;; check body
  -- if C_4 = $set_return_type(C_3, typeIR_ret)
  -- Block_ok: C_4 CONT |- blockStatement : _ _ blockStatementIR
  ---- ;; add function
  -- if rid = $rid(name, parameterList)
  -- if methodTypeIR = EXTERN_METHOD `( parameterTypeIR* ) `-> typeIR_ret
  -- if routineTypeDefIR = methodTypeIR `< tid_expl* `, tid_impl* >
  -- RoutineTypeDef_wf: $bound(p, C_0) |- routineTypeDefIR
  -- if rdenv_init = $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
  ---- ;; create IR
  -- if nameIR = $name(name)
  -- if functionDeclarationIR
      = annotationList
          (typeIR_ret nameIR `< tid_expl* `, tid_impl* > `( parameterIR* ))
          blockStatementIR

;;;;;; instantiation

rule Decl_object_ok/instantiation:
  p C_0 frame rdenv |- instantiation
                     : frame_init rdenv instantiationIR
  ---- ;; check instantiation
  -- Decl_ok: p C_0 |- instantiation : C_1 instantiationIR
  ---- ;; add instance
  -- if _ _ `< _ > `( _ ) nameIR _ `; = instantiationIR
  -- if varTypeIR = $find_var(p, C_1, `` nameIR)
  -- if frame_init
      = $update_map<id, varTypeIR>(frame, nameIR, varTypeIR)

relation Decls_object_ok:
  cursor context frame rdenv |- objectDeclaration* : frame rdenv objectDeclarationListIR
  hint(input %0 %1 %2 %3 %4)

rule Decls_object_ok/nil:
  p C frame rdenv |- eps : frame rdenv eps

rule Decls_object_ok/cons:
  p C frame_0 rdenv_0 |- objectDeclaration_h :: objectDeclaration_t*
                       : frame_2 rdenv_2 (objectDeclarationIR_h :: objectDeclarationIR_t*)
  -- Decl_object_ok:
      p C frame_0 rdenv_0 |- objectDeclaration_h
                           : frame_1 rdenv_1 objectDeclarationIR_h
  -- Decls_object_ok:
      p C frame_1 rdenv_1 |- objectDeclaration_t*
                           : frame_2 rdenv_2 objectDeclarationIR_t*

dec $subst_rdenv(theta, rdenv, rdenv) : rdenv

def $subst_rdenv(theta, rdenv_extern, `{ eps }) = rdenv_extern
def $subst_rdenv(
    theta, rdenv_extern,
    `{ (rid_init_h `: routineTypeDefIR_init_h) :: (rid_init_t `: routineTypeDefIR_init_t)* }
  )
  = $subst_rdenv(theta, rdenv_extern_subst, `{ (rid_init_t `: routineTypeDefIR_init_t)* })
  ---- ;; find abstract extern method
  -- if (EXTERN_METHOD ABSTRACT `( parameterTypeIR* ) `-> typeIR_ret) `< tid_expl* `, tid_impl* >
      = $find_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h)
  ---- ;; make abstract extern method concrete
  -- if routineTypeDefIR
      = (EXTERN_METHOD `( parameterTypeIR* ) `-> typeIR_ret) `< tid_expl* `, tid_impl* >
  -- if routineTypeDefIR_subst = $subst_routineTypeDef(theta, routineTypeDefIR)
  ---- ;; concretized extern method should be the same as the one initialized
  -- RoutineTypeDef_alpha: routineTypeDefIR_subst ~~ routineTypeDefIR_init_h
  ---- ;; update the map
  -- if rdenv_extern_subst
      = $update_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h, routineTypeDefIR_subst)

rule Decl_ok/instantiation-prefixedTypeName-objectInitializer:
  p C_0 |- annotationList
            prefixedTypeName `( argumentList ) name (`= `{ objectDeclarationList }) `;
         : C_2 instantiationIR
  ---- ;; check constructor type
  -- if prefixedNameIR = $prefixedTypeName(prefixedTypeName)
  -- if argument* = $flatten_argumentList(argumentList)
  -- ConstructorType_ok: p C_0 |- prefixedNameIR `< eps > `( argument* )
                                : constructorTypeIR `< `# tid_impl* > `( `# id_default* )
  ---- ;; check arguments
  -- (Argument_ok: p C_0 |- argument : argumentIR)*
  ---- ;; check instantiation convention
  -- Inst_ok: p C_0 |- constructorTypeIR `< eps `# tid_impl* > `( argumentIR* `# id_default* )
                     : typeIR_object `< typeArgumentIR_inferred* > `( argumentIR_cast* )
  ---- ;; object initializer can be specified for an extern object
  -- if $is_extern_object_typeIR($canon(typeIR_object))
  -- if typeIR_object
      = ((EXTERN tid_extern rdenv_extern) `< tid_expl* `, tid_impl* >)
        `< typeIR_arg* >
  ---- ;; temporarily add "this" to the context
  -- if C_1 = $add_var(LOCAL, C_0, "this", `EMPTY typeIR_object CTK eps)
  ---- ;; check object initializer
  -- if objectDeclaration* = $flatten_objectDeclarationList(objectDeclarationList)
  -- Decls_object_ok:
      p C_1 (`{ eps }) (`{ eps }) |- objectDeclaration*
                                   : frame_init rdenv_init objectDeclarationIR*
  ---- ;; create updated extern type
  -- if tid* = tid_expl* ++ tid_impl*
  -- if theta = `{ (tid `: typeIR_arg)* }
  -- if rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
  -- if typeIR_object_init
      = ((EXTERN tid_extern rdenv_init_subst) `< tid_expl* `, tid_impl* >)
        `< typeIR_arg* >
  ---- ;; constructed object may not contain an abstract method
  -- if $is_concrete_extern_object(typeIR_object_init)
  ---- ;; update the context with the instantiated object
  -- if nameIR = $name(name)
  -- if C_2 = $add_var(p, C_0, nameIR, `EMPTY typeIR_object_init CTK eps)
  ---- ;; create IR
  -- if instantiationIR
      = annotationList prefixedNameIR
          `< typeArgumentIR_inferred* > `( argumentIR* ) nameIR (`= `{ objectDeclarationIR* }) `;

rule Decl_ok/instantiation-specializedType-objectInitializer:
  p C_0 |- annotationList
            (prefixedTypeName `< typeArgumentList >) `( argumentList )
            name (`= `{ objectDeclarationList }) `;
         : C_2 instantiationIR
  ---- ;; check type arguments
  -- if typeArgument* = $flatten_typeArgumentList(typeArgumentList)
  -- TypeArguments_ok: p C_0 |- typeArgument* : typeArgumentIR* `# tid_impl*
  ---- ;; check constructor type
  -- if prefixedNameIR = $prefixedTypeName(prefixedTypeName)
  -- if argument* = $flatten_argumentList(argumentList)
  -- ConstructorType_ok: p C_0 |- prefixedNameIR `< typeArgumentIR* > `( argument* )
                                : constructorTypeIR `< `# tid_inserted* > `( `# id_default* )
  ---- ;; check arguments
  -- (Argument_ok: p C_0 |- argument : argumentIR)*
  ---- ;; check instantiation convention
  -- if tid_infer* = tid_impl* ++ tid_inserted*
  -- Inst_ok:
      p C_0 |- constructorTypeIR `< typeArgumentIR* `# tid_infer* > `( argumentIR* `# id_default* )
             : typeIR_object `< typeArgumentIR_inferred* > `( argumentIR_cast* )
  ---- ;; object initializer can be specified for an extern object
  -- if $is_extern_object_typeIR($canon(typeIR_object))
  -- if typeIR_object
      = ((EXTERN tid_extern rdenv_extern) `< tid_expl* `, tid_impl* >)
        `< typeIR_arg* >
  ---- ;; temporarily add "this" to the context
  -- if C_1 = $add_var(LOCAL, C_0, "this", `EMPTY typeIR_object CTK eps)
  ---- ;; check object initializer
  -- if objectDeclaration* = $flatten_objectDeclarationList(objectDeclarationList)
  -- Decls_object_ok:
      p C_1 (`{ eps }) (`{ eps }) |- objectDeclaration*
                                   : frame_init rdenv_init objectDeclarationIR*
  ---- ;; create updated extern type
  -- if tid* = tid_expl* ++ tid_impl*
  -- if theta = `{ (tid `: typeIR_arg)* }
  -- if rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
  -- if typeIR_object_init
      = ((EXTERN tid_extern rdenv_init_subst) `< tid_expl* `, tid_impl* >)
        `< typeIR_arg* >
  ---- ;; constructed object may not contain an abstract method
  -- if $is_concrete_extern_object(typeIR_object_init)
  ---- ;; update the context with the instantiated object
  -- if nameIR = $name(name)
  -- if C_2 = $add_var(p, C_0, nameIR, `EMPTY typeIR_object_init CTK eps)
  ---- ;; create IR
  -- if instantiationIR
      = annotationList prefixedNameIR
          `< typeArgumentIR_inferred* > `( argumentIR* ) nameIR (`= `{ objectDeclarationIR* }) `;

;;; functionDeclaration
;;; syntax functionDeclaration =
;;;   annotationList functionPrototype blockStatement
;;;; syntax functionPrototype =
;;;;   typeOrVoid name typeParameterListOpt `( parameterList )

rule Decl_ok/functionDeclaration:
  p C_0 |- annotationList
            (typeOrVoid name typeParameterListOpt `( parameterList )) blockStatement
         : C_4 functionDeclarationIR
  ---- ;; check type parameters
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_1 = $add_types(LOCAL, C_0, tid_expl*, (TID tid_expl)*)
  ---- ;; check return type
  -- Type_ok: LOCAL C_1 |- typeOrVoid : typeIR_ret `# eps
  ---- ;; check parameters
  -- if parameter* = $flatten_parameterList(parameterList)
  -- Parameters_ok: LOCAL C_1 |- parameter* : parameterIR* `# tid_impl*
  -- if (parameterTypeIR = $parameterIR(parameterIR))*
  -- if C_2 = $add_parameters(LOCAL, C_1, parameterTypeIR*)
  ---- ;; check body
  -- if C_3 = $set_return_type(C_2, typeIR_ret)
  -- Block_ok: C_3 CONT |- blockStatement : _ _ blockStatementIR
  ---- ;; add function to the context
  -- if rid = $rid(name, parameterList)
  -- if functionTypeIR = FUNCTION `( parameterTypeIR* ) `-> typeIR_ret
  -- if routineTypeDefIR = functionTypeIR `< tid_expl* `, tid_impl* >
  -- RoutineTypeDef_wf: $bound(p, C_0) |- routineTypeDefIR
  -- if C_4 = $add_routine_overload(p, C_0, rid, routineTypeDefIR)
  ---- ;; create IR
  -- if nameIR = $name(name)
  -- if functionDeclarationIR
      = annotationList
          (typeIR_ret nameIR `< tid_expl* `, tid_impl* > `( parameterIR* ))
          blockStatementIR

;;; actionDeclaration
;;; syntax actionDeclaration =
;;;   annotationList ACTION name `( parameterList ) blockStatement

rule Decl_ok/actionDeclaration:
  p C_0 |- annotationList ACTION name `( parameterList ) blockStatement
         : C_3 actionDeclarationIR
  ---- ;; check parameters
  -- if parameter* = $flatten_parameterList(parameterList)
  -- Parameters_ok: p C_0 |- parameter* : parameterIR* `# eps
  -- if (parameterTypeIR = $parameterIR(parameterIR))*
  ---- ;; add parameters to the context
  -- if C_1 = $add_parameters(LOCAL, C_0, parameterTypeIR*)
  ---- ;; check body
  -- if C_2 = $set_return_type(C_1, VOID)
  -- Block_ok: C_2 CONT |- blockStatement : _ _ blockStatementIR
  ---- ;; add action to the context
  -- if rid = $rid(name, parameterList)
  -- if functionTypeIR = ACTION `( parameterTypeIR* )
  -- RoutineTypeDef_wf: $bound(p, C_0) |- functionTypeIR
  -- if C_3 = $add_routine_non_overload(p, C_0, rid, functionTypeIR)
  ---- ;; create IR
  -- if nameIR = $name(name)
  -- if actionDeclarationIR
      = annotationList ACTION nameIR `( parameterIR* ) blockStatementIR

;;; errorDeclaration
;;; syntax errorDeclaration = ERROR `{ nameList }

rule Decl_ok/errorDeclaration:
  GLOBAL C_0 |- ERROR `{ nameList }
              : C_1 (ERROR `{ nameIR* })
  ---- ;; check that error names are distinct
  -- if name* = $flatten_nameList(nameList)
  -- if (nameIR = $name(name))*
  -- if $distinct_<nameIR>(nameIR*)
  ---- ;; update the context
  -- if (nameIR_error = "error." ++ nameIR)*
  -- if (value_error = ERROR `. nameIR)*
  -- if C_1 = $add_vars(GLOBAL, C_0, nameIR_error*, (`EMPTY ERROR LCTK value_error)*)

;;; matchKindDeclaration
;;; syntax matchKindDeclaration = MATCH_KIND `{ nameList trailingCommaOpt }

rule Decl_ok/matchKindDeclaration:
  GLOBAL C_0 |- MATCH_KIND `{ nameList _ }
              : C_1 (MATCH_KIND `{ nameIR* })
  ---- ;; check that match kind names are distinct
  -- if name* = $flatten_nameList(nameList)
  -- if (nameIR = $name(name))*
  -- if $distinct_<nameIR>(nameIR*)
  ---- ;; update the context
  -- if (value_match_kind = MATCH_KIND `. nameIR)*
  -- if C_1 = $add_vars(GLOBAL, C_0, nameIR*, (`EMPTY MATCH_KIND LCTK value_match_kind)*)

;;; externDeclaration
;;; syntax externDeclaration

;;;; externFunctionDeclaration
;;;; syntax externFunctionDeclaration =
;;;;   annotationList EXTERN functionPrototype `;

rule Decl_ok/externDeclaration-externFunctionDeclaration:
  GLOBAL C_0 |- annotationList EXTERN
                  (typeOrVoid name typeParameterListOpt `( parameterList )) `;
              : C_3 externFunctionDeclarationIR
  ---- ;; check type parameters
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_1 = $add_types(LOCAL, C_0, tid_expl*, (TID tid_expl)*)
  ---- ;; check return type
  -- Type_ok: LOCAL C_1 |- typeOrVoid : typeIR_ret `# eps
  ---- ;; check parameters
  -- if parameter* = $flatten_parameterList(parameterList)
  -- Parameters_ok: LOCAL C_1 |- parameter* : parameterIR* `# tid_impl*
  -- if (parameterTypeIR = $parameterIR(parameterIR))*
  -- if C_2 = $add_parameters(LOCAL, C_1, parameterTypeIR*)
  ---- ;; check extern function type and add to context
  -- if rid = $rid(name, parameterList)
  -- if functionTypeIR = EXTERN_FUNCTION `( parameterTypeIR* ) `-> typeIR_ret
  -- if routineTypeDefIR = functionTypeIR `< tid_expl* `, tid_impl* >
  -- RoutineTypeDef_wf: $bound(GLOBAL, C_0) |- routineTypeDefIR
  -- if C_3 = $add_routine_overload(GLOBAL, C_0, rid, routineTypeDefIR)
  ---- ;; create IR
  -- if nameIR = $name(name)
  -- if externFunctionDeclarationIR
      = annotationList EXTERN
          (typeIR_ret nameIR `< tid_expl* `, tid_impl* > `( parameterIR* )) `;

;;;; externObjectDeclaration
;;;; syntax externObjectDeclaration =
;;;;   annotationList EXTERN nonTypeName typeParameterListOpt `{ methodPrototypeList }

dec $split_constructors(methodPrototype*) : (methodPrototype*, methodPrototype*)

def $split_constructors(eps) = (eps, eps)
def $split_constructors(methodPrototype_h :: methodPrototype_t*)
  = (methodPrototype_h :: methodPrototype_t_constructor*,
     methodPrototype_t_method*)
  -- if _ _ `( _ ) `; = methodPrototype_h
  -- if (methodPrototype_t_constructor*, methodPrototype_t_method*)
      = $split_constructors(methodPrototype_t*)
def $split_constructors(methodPrototype_h :: methodPrototype_t*)
  = (methodPrototype_t_constructor*,
     methodPrototype_h :: methodPrototype_t_method*)
  -- if _ _ `; = methodPrototype_h
  -- if (methodPrototype_t_constructor*, methodPrototype_t_method*)
      = $split_constructors(methodPrototype_t*)
def $split_constructors(methodPrototype_h :: methodPrototype_t*)
  = (methodPrototype_t_constructor*,
     methodPrototype_h :: methodPrototype_t_method*)
  -- if _ ABSTRACT _ `; = methodPrototype_h
  -- if (methodPrototype_t_constructor*, methodPrototype_t_method*)
      = $split_constructors(methodPrototype_t*)

rule Decl_ok/externDeclaration-externObjectDeclaration:
  GLOBAL C_0 |- annotationList EXTERN nonTypeName
                  typeParameterListOpt `{ methodPrototypeList }
              : C_6 externObjectDeclarationIR
  ---- ;; split methods and constructors
  -- if methodPrototype* = $flatten_methodPrototypeList(methodPrototypeList)
  -- if (methodPrototype_constructor*, methodPrototype_method*)
      = $split_constructors(methodPrototype*)
  ---- ;; check type parameters
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_1 = $add_types(BLOCK, C_0, tid_expl*, (TID tid_expl)*)
  ---- ;; check methods
  -- if nameIR = $name(nonTypeName)
  -- ExternMethods_ok: C_1 nameIR |- methodPrototype_method*
                                   : C_2 methodPrototypeIR_method*
  ---- ;; create extern object type and add to context
  -- if typeIR_extern = EXTERN nameIR C_2.BLOCK.RDENV
  -- if typeDefIR_extern = typeIR_extern `< tid_expl* `, eps >
  -- if C_3 = $add_type(GLOBAL, C_0, nameIR, typeDefIR_extern)
  ---- ;; check constructors and add to context
  -- if C_4 = $add_types(BLOCK, C_3, tid_expl*, (TID tid_expl)*)
  -- ExternConstructors_ok: C_4 nameIR |- methodPrototype_constructor*
                                        : C_5 methodPrototypeIR_constructor*
  -- if C_6 = C_3[ .GLOBAL.CDENV = C_5.GLOBAL.CDENV ]
  ---- ;; create IR
  -- if externObjectDeclarationIR
      = annotationList EXTERN nameIR `< tid_expl* `, eps >
        `{ methodPrototypeIR_constructor* ++ methodPrototypeIR_method* }

;;; parserDeclaration
;;; syntax parserDeclaration =
;;;   annotationList PARSER name typeParameterListOpt
;;;     `( parameterList ) constructorParameterListOpt
;;;     `{ parserLocalDeclarationList parserStateList }

rule Decl_ok/parserDeclaration:
  GLOBAL C_0 |- annotationList PARSER name `EMPTY
                 `( parameterList ) constructorParameterListOpt
                 `{ parserLocalDeclarationList parserStateList }
              : C_4 parserDeclarationIR
  ---- ;; check constructor parameters
  -- if constructorParameter*
      = $flatten_constructorParameterListOpt(constructorParameterListOpt)
  -- ConstructorParameters_ok: BLOCK C_0 |- constructorParameter*
                                          : constructorParameterIR* `# eps
  -- if (constructorParameterTypeIR
      = $constructorParameterIR(constructorParameterIR))*
  -- if C_1 = $add_parameters(BLOCK, C_0, constructorParameterTypeIR*)
  ---- ;; check parameters to apply method
  -- if parameter* = $flatten_parameterList(parameterList)
  -- Parameters_ok: BLOCK C_0 |- parameter* : parameterIR* `# eps
  -- if (parameterTypeIR = $parameterIR(parameterIR))*
  -- if C_2 = $add_parameters(BLOCK, C_1, parameterTypeIR*)
  ---- ;; check parser local declarations
  -- if parserLocalDeclaration*
      = $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
  -- ParserLocalDecls_ok: C_2 |- parserLocalDeclaration*
                               : C_3 parserLocalDeclarationIR*
  ---- ;; check parser states
  -- if parserState* = $flatten_parserStateList(parserStateList)
  -- ParserStates_ok: C_3 |- parserState* : parserStateIR*
  ---- ;; check apply method
  -- if methodTypeIR = PARSER_APPLY `( parameterTypeIR* )
  -- RoutineTypeDef_wf: $bound(GLOBAL, C_0) |- methodTypeIR
  ---- ;; create parser object constructor and add to context
  -- if cid = $cid(name, constructorParameterListOpt)
  -- if typeIR_parser = PARSER `( parameterTypeIR* )
  -- if typeIR_parser_spec = (typeIR_parser `< eps `, eps >) `< eps >
  -- if constructorTypeIR
      = CONSTRUCTOR `( constructorParameterTypeIR* ) `-> typeIR_parser_spec
  -- if constructorTypeDefIR = constructorTypeIR `< eps `, eps >
  -- ConstructorTypeDef_wf: $bound(GLOBAL, C_0) |- constructorTypeDefIR
  -- if C_4 = $add_constructor(C_0, cid, constructorTypeDefIR)
  ---- ;; create IR
  -- if nameIR = $name(name)
  -- if parserDeclarationIR
      = annotationList PARSER nameIR `< eps >
          `( parameterIR* ) `( constructorParameterIR* )
          `{ parserLocalDeclarationIR* parserStateIR* }

;;; controlDeclaration 
;;; syntax controlDeclaration =
;;;   annotationList CONTROL name typeParameterListOpt
;;;     `( parameterList ) constructorParameterListOpt
;;;     `{ controlLocalDeclarationList APPLY controlBody }

rule Decl_ok/controlDeclaration:
  GLOBAL C_0 |- annotationList CONTROL name `EMPTY
                 `( parameterList ) constructorParameterListOpt
                 `{ controlLocalDeclarationList APPLY controlBody }
              : C_5 controlDeclarationIR
  ---- ;; check constructor parameters
  -- if constructorParameter*
      = $flatten_constructorParameterListOpt(constructorParameterListOpt)
  -- ConstructorParameters_ok: BLOCK C_0 |- constructorParameter*
                                          : constructorParameterIR* `# eps
  -- if (constructorParameterTypeIR
      = $constructorParameterIR(constructorParameterIR))*
  -- if C_1 = $add_parameters(BLOCK, C_0, constructorParameterTypeIR*)
  ---- ;; check parameters to apply method
  -- if parameter* = $flatten_parameterList(parameterList)
  -- Parameters_ok: BLOCK C_0 |- parameter* : parameterIR* `# eps
  -- if (parameterTypeIR = $parameterIR(parameterIR))*
  -- if C_2 = $add_parameters(BLOCK, C_1, parameterTypeIR*)
  ---- ;; check control local declarations
  -- if controlLocalDeclaration*
      = $flatten_controlLocalDeclarationList(controlLocalDeclarationList)
  -- ControlLocalDecls_ok: C_2 |- controlLocalDeclaration*
                                : C_3 controlLocalDeclarationIR*
  ---- ;; check control body
  -- if C_4 = $set_return_type(C_3, VOID)
  -- Block_ok: C_4 CONT |- controlBody : _ _ controlBodyIR
  ---- ;; check apply method
  -- if methodTypeIR = CONTROL_APPLY `( parameterTypeIR* )
  -- RoutineTypeDef_wf: $bound(GLOBAL, C_0) |- methodTypeIR
  ---- ;; create control object constructor and add to context
  -- if cid = $cid(name, constructorParameterListOpt)
  -- if typeIR_control = CONTROL `( parameterTypeIR* )
  -- if typeIR_control_spec = (typeIR_control `< eps `, eps >) `< eps >
  -- if constructorTypeIR
      = CONSTRUCTOR `( constructorParameterTypeIR* ) `-> typeIR_control_spec
  -- if constructorTypeDefIR = constructorTypeIR `< eps `, eps >
  -- ConstructorTypeDef_wf: $bound(GLOBAL, C_0) |- constructorTypeDefIR
  -- if C_5 = $add_constructor(C_0, cid, constructorTypeDefIR)
  ---- ;; create IR
  -- if nameIR = $name(name)
  -- if controlDeclarationIR
      = annotationList CONTROL nameIR `< eps >
        `( parameterIR* ) `( constructorParameterIR* )
        `{ controlLocalDeclarationIR* APPLY controlBodyIR }

;;; typeDeclaration
;;; syntax typeDeclaration

;;;; derivedTypeDeclaration
;;;; syntax derivedTypeDeclaration

;;;;; enumTypeDeclaration
;;;;; syntax enumTypeDeclaration =

;;;;;; annotationList ENUM name `{ nameList trailingCommaOpt }

rule Decl_ok/typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration:
  GLOBAL C_0 |- annotationList ENUM name `{ nameList_field _ }
              : C_2 enumTypeDeclarationIR
  ---- ;; create enum type and add to context
  -- if nameIR = $name(name)
  -- if name_field* = $flatten_nameList(nameList_field)
  -- if (nameIR_field = $name(name_field))*
  -- if typeIR_enum = ENUM nameIR `{ nameIR_field* }
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeIR_enum
  -- if C_1 = $add_type(GLOBAL, C_0, nameIR, typeIR_enum)
  ---- ;; add enum field values to the context
  -- if (id_field = nameIR ++ "." ++ nameIR_field)*
  -- if (value_field = nameIR `. nameIR_field)*
  -- if C_2
      = $add_vars(GLOBAL, C_1, id_field*, (`EMPTY typeIR_enum LCTK value_field)*)
  ---- ;; create IR
  -- if enumTypeDeclarationIR
      = annotationList ENUM nameIR `{ nameIR_field* }

;;;;;; annotationList ENUM type name `{ namedExpressionList trailingCommaOpt }

relation Enum_serializable_field_ok:
  context nameIR typeIR |- namedExpression
                         : context namedExpressionIR `# value
  hint(input %0 %1 %2 %3)

rule Enum_serializable_field_ok:
  C_0 nameIR_enum typeIR |- name `= expression
                          : C_1 (nameIR `= typedExpressionIR_cast) `# value
  ---- ;; check expression
  -- Expr_ok: BLOCK C_0 |- expression : typedExpressionIR
  ---- ;; coerce expression to type
  -- if typedExpressionIR_cast = $coerce_unary(typedExpressionIR, typeIR)
  ---- ;; perform compile-time evaluation
  -- if _ `# `( _ LCTK ) = typedExpressionIR_cast
  -- Eval_static: BLOCK C_0 |- typedExpressionIR_cast ~> value
  ---- ;; temporarily add value to block context
  -- if nameIR = $name(name)
  -- if typeIR_enum = ENUM nameIR_enum `# typeIR `{ eps }
  -- if value_enum = nameIR_enum `. nameIR `# value
  -- if C_1
      = $add_var(BLOCK, C_0, nameIR, `EMPTY typeIR_enum LCTK value_enum)

relation Enum_serializable_fields_ok:
  context nameIR typeIR |- namedExpression*
                         : context namedExpressionIR* `# value*
  hint(input %0 %1 %2 %3)

rule Enum_serializable_fields_ok/nil:
  C nameIR_enum typeIR |- eps : C eps `# eps

rule Enum_serializable_fields_ok/cons:
  C_0 nameIR_enum typeIR |- namedExpression_h :: namedExpression_t*
                          : C_2 namedExpressionIR* `# value_field*
  -- Enum_serializable_field_ok:
      C_0 nameIR_enum typeIR |- namedExpression_h
                              : C_1 namedExpressionIR_h `# value_field_h
  -- Enum_serializable_fields_ok:
      C_1 nameIR_enum typeIR |- namedExpression_t*
                              : C_2 namedExpressionIR_t* `# value_field_t*
  -- if namedExpressionIR* = namedExpressionIR_h :: namedExpressionIR_t*
  -- if value_field* = value_field_h :: value_field_t*

rule Decl_ok/typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable:
  GLOBAL C_0 |- annotationList ENUM type name `{ namedExpressionList_field _ }
              : C_3 enumTypeDeclarationIR
  ---- ;; check underlying type
  -- Type_ok: GLOBAL C_0 |- type : typeIR `# eps
  -- Type_wf: $bound(GLOBAL, C_0) |- typeIR
  ---- ;; evaluate expressions
  -- if nameIR = $name(name)
  -- if namedExpression_field* = $flatten_namedExpressionList(namedExpressionList_field)
  -- Enum_serializable_fields_ok:
      C_0 nameIR typeIR |- namedExpression_field*
                         : C_1 namedExpressionIR_field* `# value_field*
  ---- ;; add enum field values to the context
  -- if ((nameIR_field `= _) = namedExpressionIR_field)*
  -- if (id_field = nameIR ++ "." ++ nameIR_field)*
  -- if typeIR_enum = ENUM nameIR `# typeIR `{ (nameIR_field `= value_field `;)* }
  -- if C_2
      = $add_vars(GLOBAL, C_0, id_field*, (`EMPTY typeIR_enum LCTK value_field)*)
  ---- ;; add enum type to context
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeIR_enum
  -- if C_3 = $add_type(GLOBAL, C_2, nameIR, typeIR_enum)
  ---- ;; create IR (TODO)
  -- if enumTypeDeclarationIR
      = annotationList ENUM typeIR nameIR `{ namedExpressionIR_field* }

;;;;; structTypeDeclaration
;;;;; syntax structTypeDeclaration =
;;;;;   annotationList STRUCT name typeParameterListOpt `{ typeFieldList }

rule Decl_ok/typeDeclaration-derivedTypeDeclaration-structTypeDeclaration:
  GLOBAL C_0 |- annotationList STRUCT name typeParameterListOpt `{ typeFieldList }
              : C_2 structTypeDeclarationIR
  ---- ;; check type parameters
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_1 = $add_types(BLOCK, C_0, tid_expl*, (TID tid_expl)*)
  ---- ;; check type fields
  -- if (annotationList_field type_field name_field `;)*
      = $flatten_typeFieldList(typeFieldList)
  -- (Type_ok: BLOCK C_1 |- type_field : typeIR_field `# tid_impl_field*)*
  -- if tid_impl* = $concat_<tid>(tid_impl_field**)
  ---- ;; create struct type and add to context
  -- if nameIR = $name(name)
  -- if (nameIR_field = $name(name_field))*
  -- if typeIR_struct = STRUCT nameIR `{ (typeIR_field nameIR_field `;)* }
  -- if typeDefIR_struct = typeIR_struct `< tid_expl* `, tid_impl* >
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeDefIR_struct
  -- if C_2 = $add_type(GLOBAL, C_0, nameIR, typeDefIR_struct)
  ---- ;; create IR
  -- if structTypeDeclarationIR
      = annotationList STRUCT nameIR `< tid_expl* `, tid_impl* >
        `{ (annotationList_field typeIR_field nameIR_field `;)* }

;;;;; headerTypeDeclaration
;;;;; syntax headerTypeDeclaration =
;;;;;   annotationList HEADER name typeParameterListOpt `{ typeFieldList }

rule Decl_ok/typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration:
  GLOBAL C_0 |- annotationList HEADER name typeParameterListOpt `{ typeFieldList }
              : C_2 headerTypeDeclarationIR
  ---- ;; check type parameters
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_1 = $add_types(BLOCK, C_0, tid_expl*, (TID tid_expl)*)
  ---- ;; check type fields
  -- if (annotationList_f type_f name_f `;)*
      = $flatten_typeFieldList(typeFieldList)
  -- (Type_ok: BLOCK C_1 |- type_f : typeIR_f `# tid_impl_f*)*
  -- if tid_impl* = $concat_<tid>(tid_impl_f**)
  ---- ;; create struct type and add to context
  -- if nameIR = $name(name)
  -- if (nameIR_f = $name(name_f))*
  -- if typeIR_header = HEADER nameIR `{ (typeIR_f nameIR_f `;)* }
  -- if typeDefIR_header = typeIR_header `< tid_expl* `, tid_impl* >
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeDefIR_header
  -- if C_2 = $add_type(GLOBAL, C_0, nameIR, typeDefIR_header)
  ---- ;; create IR
  -- if headerTypeDeclarationIR
      = annotationList HEADER nameIR `< tid_expl* `, tid_impl* >
        `{ (annotationList_f typeIR_f nameIR_f `;)* }

;;;;; headerUnionDeclaration
;;;;; syntax headerUnionDeclaration =
;;;;;   annotationList HEADER_UNION name typeParameterListOpt `{ typeFieldList }

rule Decl_ok/typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration:
  GLOBAL C_0 |- annotationList HEADER_UNION name typeParameterListOpt `{ typeFieldList }
              : C_2 headerUnionTypeDeclarationIR
  ---- ;; check type parameters
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_1 = $add_types(BLOCK, C_0, tid_expl*, (TID tid_expl)*)
  ---- ;; check type fields
  -- if (annotationList_f type_f name_f `;)*
      = $flatten_typeFieldList(typeFieldList)
  -- (Type_ok: BLOCK C_1 |- type_f : typeIR_f `# tid_impl_f*)*
  -- if tid_impl* = $concat_<tid>(tid_impl_f**)
  ---- ;; create struct type and add to context
  -- if nameIR = $name(name)
  -- if (nameIR_f = $name(name_f))*
  -- if typeIR_union = HEADER_UNION nameIR `{ (typeIR_f nameIR_f `;)* }
  -- if typeDefIR_union = typeIR_union `< tid_expl* `, tid_impl* >
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeDefIR_union
  -- if C_2 = $add_type(GLOBAL, C_0, nameIR, typeDefIR_union)
  ---- ;; create IR
  -- if headerUnionTypeDeclarationIR
      = annotationList HEADER_UNION nameIR `< tid_expl* `, tid_impl* >
        `{ (annotationList_f typeIR_f nameIR_f `;)* }

;;;; typedefDeclaration
;;;; syntax typedefDeclaration

;;;;; annotationList TYPEDEF typedefType name `;
;;;;; syntax typedefType

;;;;;; type

rule Decl_ok/typeDeclaration-typedefDeclaration-typedef-type:
  GLOBAL C_0 |- annotationList TYPEDEF type name `;
              : C_1 typedefDeclarationIR
  ---- ;; check type
  -- Type_ok: GLOBAL C_0 |- type : typeIR `# eps
  -- Type_wf: $bound(GLOBAL, C_0) |- typeIR
  ---- ;; create typedef and add to context
  -- if nameIR = $name(name)
  -- if typeIR_typedef = TYPEDEF nameIR typeIR
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeIR_typedef
  -- if C_1 = $add_type(GLOBAL, C_0, nameIR, typeIR_typedef)
  ---- ;; create IR
  -- if typedefDeclarationIR
      = annotationList TYPEDEF typeIR nameIR `;

;;;;;; derivedTypeDeclaration

rule Decl_ok/typeDeclaration-typedefDeclaration-typedef-derivedTypeDeclaration-mono:
  GLOBAL C_0 |- annotationList TYPEDEF derivedTypeDeclaration name `;
              : C_1 typedefDeclarationIR
  ---- ;; check type
  -- Decl_ok: GLOBAL C_0 |- derivedTypeDeclaration
                          : C_1 derivedTypeDeclarationIR
  ---- ;; find the created type
  -- if `{ tid }
      = $diff_set<tid>($dom_map<tid, typeDefIR>(C_1.GLOBAL.TDENV),
                       $dom_map<tid, typeDefIR>(C_0.GLOBAL.TDENV))
  -- if typeIR = $find_type(GLOBAL, C_1, `` tid)
  ---- ;; create typedef and add to context
  -- if nameIR = $name(name)
  -- if typeIR_typedef = TYPEDEF nameIR typeIR
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeIR_typedef
  -- if C_2 = $add_type(GLOBAL, C_0, nameIR, typeIR_typedef)
  ---- ;; create IR
  -- if typedefDeclarationIR
      = annotationList TYPEDEF derivedTypeDeclarationIR nameIR `;

rule Decl_ok/typeDeclaration-typedefDeclaration-typedef-derivedTypeDeclaration-poly:
  GLOBAL C_0 |- annotationList TYPEDEF derivedTypeDeclaration name `;
              : C_1 typedefDeclarationIR
  ---- ;; check type
  -- Decl_ok: GLOBAL C_0 |- derivedTypeDeclaration
                          : C_1 derivedTypeDeclarationIR
  ---- ;; find the created type
  -- if `{ tid }
      = $diff_set<tid>($dom_map<tid, typeDefIR>(C_1.GLOBAL.TDENV),
                       $dom_map<tid, typeDefIR>(C_0.GLOBAL.TDENV))
  -- if typeIR `< eps `, eps > = $find_type(GLOBAL, C_1, `` tid)
  ---- ;; create typedef and add to context
  -- if nameIR = $name(name)
  -- if typeIR_typedef = TYPEDEF nameIR ((typeIR `< eps `, eps >) `< eps >)
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeIR_typedef
  -- if C_2 = $add_type(GLOBAL, C_0, nameIR, typeIR_typedef)
  ---- ;; create IR
  -- if typedefDeclarationIR
      = annotationList TYPEDEF derivedTypeDeclarationIR nameIR `;

;;;;; annotationList TYPE type name `;

rule Decl_ok/typeDeclaration-typedefDeclaration-newtype:
  GLOBAL C_0 |- annotationList TYPE type name `;
              : C_1 typedefDeclarationIR
  ---- ;; check type
  -- Type_ok: GLOBAL C_0 |- type : typeIR `# eps
  -- Type_wf: $bound(GLOBAL, C_0) |- typeIR
  ---- ;; create new type and add to context
  -- if nameIR = $name(name)
  -- if typeIR_newtype = TYPE nameIR typeIR
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeIR_newtype
  -- if C_1 = $add_type(GLOBAL, C_0, nameIR, typeIR_newtype)
  ---- ;; create IR
  -- if typedefDeclarationIR
      = annotationList TYPE typeIR nameIR `;

;;;; parserTypeDeclaration
;;;; syntax parserTypeDeclaration =
;;;;   annotationList PARSER name typeParameterListOpt `( parameterList ) `;

rule Decl_ok/typeDeclaration-parserTypeDeclaration:
  GLOBAL C_0 |- annotationList PARSER name typeParameterListOpt `( parameterList ) `;
              : C_2 parserTypeDeclarationIR
  ---- ;; add type parameters to the context
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_1 = $add_types(BLOCK, C_0, tid_expl*, (TID tid_expl)*)
  ---- ;; check parameters to apply method
  -- if parameter* = $flatten_parameterList(parameterList)
  -- Parameters_ok: BLOCK C_1 |- parameter* : parameterIR* `# tid_impl*
  -- if (parameterTypeIR = $parameterIR(parameterIR))*
  ---- ;; update the context with parser type
  -- if nameIR = $name(name)
  -- if typeIR_parser = PARSER `( parameterTypeIR* )
  -- if typeDefIR_parser = typeIR_parser `< tid_expl* `, tid_impl* >
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeDefIR_parser
  -- if C_2 = $add_type(GLOBAL, C_0, nameIR, typeDefIR_parser)
  ---- ;; create IR
  -- if parserTypeDeclarationIR
      = annotationList PARSER nameIR `< tid_expl* `, tid_impl* > `( parameterIR* ) `;

;;;; controlTypeDeclaration
;;;; syntax controlTypeDeclaration =
;;;;   annotationList CONTROL name typeParameterListOpt `( parameterList ) `;

rule Decl_ok/typeDeclaration-controlTypeDeclaration:
  GLOBAL C_0 |- annotationList CONTROL name typeParameterListOpt `( parameterList ) `;
              : C_2 controlTypeDeclarationIR
  ---- ;; add type parameters to the context
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_1 = $add_types(BLOCK, C_0, tid_expl*, (TID tid_expl)*)
  ---- ;; check parameters to apply method
  -- if parameter* = $flatten_parameterList(parameterList)
  -- Parameters_ok: BLOCK C_1 |- parameter* : parameterIR* `# tid_impl*
  -- if (parameterTypeIR = $parameterIR(parameterIR))*
  ---- ;; update the context with control type
  -- if nameIR = $name(name)
  -- if typeIR_control = CONTROL `( parameterTypeIR* )
  -- if typeDefIR_control = typeIR_control `< tid_expl* `, tid_impl* >
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeDefIR_control
  -- if C_2 = $add_type(GLOBAL, C_0, nameIR, typeDefIR_control)
  ---- ;; create IR
  -- if controlTypeDeclarationIR
      = annotationList CONTROL nameIR `< tid_expl* `, tid_impl* > `( parameterIR* ) `;

;;;; packageTypeDeclaration
;;;; syntax packageTypeDeclaration =
;;;;   annotationList PACKAGE name typeParameterListOpt `( parameterList ) `;

rule Decl_ok/typeDeclaration-packageTypeDeclaration:
  GLOBAL C_0 |- annotationList PACKAGE name typeParameterListOpt `( parameterList ) `;
              : C_3 packageTypeDeclarationIR
  ---- ;; add type parameters to the context
  -- if typeParameter* = $flatten_typeParameterListOpt(typeParameterListOpt)
  -- if (tid_expl = $name(typeParameter))*
  -- if C_1 = $add_types(BLOCK, C_0, tid_expl*, (TID tid_expl)*)
  ---- ;; check constructor parameters
  -- if constructorParameter* = $flatten_parameterList(parameterList)
  -- ConstructorParameters_ok: BLOCK C_1 |- constructorParameter*
                                          : constructorParameterIR* `# tid_impl*
  -- if (constructorParameterTypeIR
        = $constructorParameterIR(constructorParameterIR))*
  ---- ;; update the context with package type
  -- if nameIR = $name(name)
  -- if (_ typeIR_package_inner _ _ = constructorParameterTypeIR)*
  -- if typeIR_package = PACKAGE `< typeIR_package_inner* >
  -- if polyTypeDefIR_package = typeIR_package `< tid_expl* `, tid_impl* >
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- polyTypeDefIR_package
  -- if C_2 = $add_type(GLOBAL, C_0, nameIR, polyTypeDefIR_package)
  ---- ;; update the context with package constructor
  -- if cid = $cid(name, `( parameterList ))
  -- if typeIR_package_spec
      = polyTypeDefIR_package `< (TID tid_expl)* ++ (TID tid_impl)* >
  -- if constructorTypeIR
      = CONSTRUCTOR `( constructorParameterTypeIR* ) `-> typeIR_package_spec
  -- if constructorTypeDefIR = constructorTypeIR `< tid_expl* `, tid_impl* >
  -- ConstructorTypeDef_wf: $bound(GLOBAL, C_0) |- constructorTypeDefIR
  -- if C_3 = $add_constructor(C_2, cid, constructorTypeDefIR)
  ---- ;; create IR
  -- if packageTypeDeclarationIR
      = annotationList PACKAGE nameIR `< tid_expl* `, tid_impl* >
        `( constructorParameterIR* ) `;

;;
;;;; syntax declarationList (doesn't exist in the grammar)
;;

rule Decls_ok/nil:
  p C |- eps : C eps

rule Decls_ok/cons:
  p C_0 |- declaration_h :: declaration_t*
         : C_2 (declarationIR_h :: declarationIR_t*)
  -- Decl_ok: p C_0 |- declaration_h : C_1 declarationIR_h
  -- Decls_ok: p C_1 |- declaration_t* : C_2 declarationIR_t*

;;
;;;; syntax p4program
;;

rule Program_ok:
  |- p4program : C_1 (declarationIR* `;)
  -- if declaration* = $flatten_p4program(p4program)
  -- if C_0 = $empty_context()
  -- Decls_ok: GLOBAL C_0 |- declaration* : C_1 declarationIR*
