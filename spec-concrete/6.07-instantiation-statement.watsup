;;
;; Statement instantiation
;;
;; syntax statementIR
;;

;;; emptyStatementIR

rule Stmt_inst/emptyStatementIR:
  p Ci sto |- emptyStatementIR ==> Ci sto emptyStatementIR

;;; assignmentStatementIR

rule Stmt_inst/assignmentStatementIR:
  p Ci sto |- assignmentStatementIR ==> Ci sto assignmentStatementIR

;;; callStatementIR
;;; syntax callStatementIR =
;;;   routineLvalueIR `< typeArgumentListIR > `( argumentListIR ) `;

rule Stmt_inst/callStatementIR:
  p Ci sto |- callStatementIR ==> Ci sto callStatementIR

;;; directApplicationStatementIR
;;; syntax directApplicationStatementIR =
;;;   prefixedNameIR `. APPLY `( argumentListIR ) `;

rule Stmt_inst/directApplicationStatementIR:
  p Ci sto_0 |- prefixedNameIR `. APPLY `( argumentListIR ) `;
    ==> Ci sto_2 blockStatementIR
  -- if $find_constructor_overloaded_inst(Ci, prefixedNameIR, eps) = (_, consDyn, _)
  -- Constructor_inst: p Ci sto_0 |- consDyn `< eps > `( eps `# eps ) ==> sto_1 objDyn
  -- if $fresh_tid() = tid_fresh
  -- if $flatten_prefixedNameIR(prefixedNameIR) = tid
  -- if TID tid = typeIR
  -- if $concat_text([ tid, "_", tid_fresh]) = nameIR
  -- if oid = Ci.PATH ++ nameIR
  -- if $add_sto(sto_1, oid, objDyn) = sto_2
  -- if `EMPTY CONST typeIR nameIR (`= (`! oid)) `; = constantDeclarationIR
  -- if ((`` tid) `# `( typeIR CTK )) `. "apply" = routineTargetIR
  -- if routineTargetIR `< eps > `( argumentListIR ) `; = callStatementIR
  -- if `EMPTY `{ [ constantDeclarationIR, callStatementIR ] } = blockStatementIR

;;; returnStatementIR

rule Stmt_inst/returnStatementIR:
  p Ci sto |- returnStatementIR ==> Ci sto returnStatementIR

;;; exitStatementIR

rule Stmt_inst/exitStatementIR:
  p Ci sto |- exitStatementIR ==> Ci sto exitStatementIR

;;; blockStatementIR
;;; syntax blockStatementIR = annotationList `{ blockElementStatementListIR }

rule Stmt_inst/blockStatementIR:
  p Ci sto |- annotationList `{ blockElementStatementListIR }
    ==> Ci' sto' (annotationList `{ blockElementStatementListIR' })
  -- Block_inst: Ci sto false |- annotationList `{ blockElementStatementListIR } ==> Ci' sto' (_ `{ blockElementStatementListIR' })

;;; conditionalStatementIR
;;; syntax conditionalStatementIR =

;;;; IF `( typedExpressionIR ) statementIR

rule Stmt_inst/conditionalStatementIR-non-else:
  p Ci sto |- IF `( typedExpressionIR ) statementIR
       ==> Ci sto' (IF `( typedExpressionIR ) statementIR')
  -- Stmt_inst: p Ci sto |- statementIR ==> _ sto' statementIR'

;;;; IF `( typedExpressionIR ) statementIR ELSE statementIR

rule Stmt_inst/conditionalStatementIR-else:
  p Ci sto |- IF `( typedExpressionIR ) statementIR_then ELSE statementIR_else
       ==> Ci sto'' (IF `( typedExpressionIR ) statementIR_then' ELSE statementIR_else')
  ---- ;; instantiate then branch
  -- Stmt_inst: p Ci sto |- statementIR_then ==> _ sto' statementIR_then'
  ---- ;; instantiate else branch
  -- Stmt_inst: p Ci sto' |- statementIR_else ==> _ sto'' statementIR_else'

;;; forStatementIR : TODO

;;; breakStatementIR

rule Stmt_inst/breakStatementIR:
  p Ci sto |- breakStatementIR ==> Ci sto breakStatementIR

;;; continueStatementIR

rule Stmt_inst/continueStatementIR:
  p Ci sto |- continueStatementIR ==> Ci sto continueStatementIR

;;; switchStatementIR
;;; syntax switchStatementIR = SWITCH `( typedExpressionIR ) `{ switchCaseListIR }

rule Stmt_inst/switchStatementIR:
  p Ci sto |- SWITCH `( typedExpressionIR ) `{ switchCaseListIR } 
  ==> Ci' sto' (SWITCH `( typedExpressionIR ) `{ switchCaseListIR' })
  ---- ;; instantiate switch cases
  -- SwitchCases_inst: p Ci sto |- switchCaseListIR ==> Ci' sto' switchCaseListIR'

;;
;; Switch case instantiation
;;
;; syntax switchCaseIR
;;

;;; switchLabelIR `: blockStatementIR

rule SwitchCase_inst/match:
  p Ci sto |- switchLabelIR `: blockStatementIR ==> Ci' sto' (switchLabelIR `: blockStatementIR')
  -- Stmt_inst: p Ci sto |- blockStatementIR ==> Ci' sto' blockStatementIR'

;;; switchLabelIR `:

rule SwitchCase_inst/fallthrough:
  p Ci sto |- switchLabelIR `: ==> Ci sto (switchLabelIR `:)

rule SwitchCases_inst/nil:
  p Ci sto |- eps ==> Ci sto eps

rule SwitchCases_inst/cons:
  p Ci_0 sto_0 |- switchCaseIR_h :: switchCaseIR_t*
    ==> Ci_2 sto_2 (switchCaseIR_h' :: switchCaseIR_t'*)
  -- SwitchCase_inst: p Ci_0 sto_0 |- switchCaseIR_h ==> Ci_1 sto_1 switchCaseIR_h'
  -- SwitchCases_inst: p Ci_1 sto_1 |- switchCaseIR_t* ==> Ci_2 sto_2 switchCaseIR_t'*

;;
;; syntax blockElementStatementIR
;;

;;; constantDeclarationIR

rule BlockElementStmt_inst/constantDeclarationIR:
  Ci sto |- constantDeclarationIR ==> Ci' sto' constantDeclarationIR'
  -- Decl_inst: LOCAL Ci sto |- constantDeclarationIR ==> Ci' sto' constantDeclarationIR'

;;; variableDeclarationIR

rule BlockElementStmt_inst/variableDeclarationIR:
  Ci sto |- variableDeclarationIR ==> Ci sto variableDeclarationIR

;;; statementIR

rule BlockElementStmt_inst/statementIR:
  Ci sto |- statementIR ==> Ci' sto' statementIR_inst
  -- Stmt_inst: LOCAL Ci sto |- statementIR ==> Ci' sto' statementIR_inst

rule BlockElementStmts_inst/nil:
  Ci sto |- eps ==> Ci sto eps

rule BlockElementStmts_inst/cons:
  Ci_0 sto_0 |- blockElementStatementIR_h :: blockElementStatementIR_t*
    ==> Ci_2 sto_2 (blockElementStatementIR_h' :: blockElementStatementIR_t'*)
  -- BlockElementStmt_inst: Ci_0 sto_0 |- blockElementStatementIR_h ==> Ci_1 sto_1 blockElementStatementIR_h'
  -- BlockElementStmts_inst: Ci_1 sto_1 |- blockElementStatementIR_t* ==> Ci_2 sto_2 blockElementStatementIR_t'*

;;
;; syntax blockStatmentIR
;;

;;; syntax blockStatmentIR =
;;;   annotationList `{ blockElementStatementListIR }

rule Block_inst/start:
  Ci_0 sto_0 true |- annotationList `{ blockElementStatementListIR }
    ==> Ci_1 sto_1 (annotationList `{ blockElementStatementListIR_inst })
  -- BlockElementStmts_inst: Ci_0 sto_0 |- blockElementStatementListIR ==> Ci_1 sto_1 blockElementStatementListIR_inst

rule Block_inst/no-start:
  Ci_0 sto_0 false |- annotationList `{ blockElementStatementListIR }
    ==> Ci_2 sto_1 (annotationList `{ blockElementStatementListIR_inst })
  -- if $enter_inst(Ci_0) = Ci_1
  -- BlockElementStmts_inst: Ci_1 sto_0 |- blockElementStatementListIR ==> Ci_2 sto_1 blockElementStatementListIR_inst
  -- if $exit_inst(Ci_2) = Ci_3
