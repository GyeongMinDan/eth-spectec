;;
;; Parser local declaration typing
;;
;; syntax parserLocalDeclaration
;;

;;; constantDeclaration

rule ParserLocalDecl_ok/constantDeclaration:
  C_0 |- constantDeclaration
       : C_1 constantDeclarationIR
  -- Decl_ok: BLOCK C_0 |- constantDeclaration
                         : C_1 constantDeclarationIR

;;; instantiation

rule ParserLocalDecl_ok/instantiation:
  C_0 |- instantiation
       : C_1 instantiationIR
  -- Decl_ok: BLOCK C_0 |- instantiation
                         : C_1 instantiationIR

;;; variableDeclaration
;;; syntax variableDeclaration =
;;;   annotationList type name initializerOpt `;

rule ParserLocalDecl_ok/variableDeclaration-empty:
  C_0 |- annotationList type name `EMPTY `;
       : C_1 variableDeclarationIR
  ---- ;; check type
  -- Type_ok: BLOCK C_0 |- type : typeIR `# eps
  -- Type_wf: $bound(BLOCK, C_0) |- typeIR
  ---- ;; update the context
  -- if nameIR = $name(name)
  -- if C_1 = $add_var(BLOCK, C_0, nameIR, INOUT typeIR DYN eps)
  ---- ;; create IR
  -- if variableDeclarationIR
      = annotationList typeIR nameIR eps `;

rule ParserLocalDecl_ok/variableDeclaration-initializer:
  C_0 |- annotationList type name (`= expression_init) `;
       : C_1 variableDeclarationIR
  ---- ;; check type
  -- Type_ok: BLOCK C_0 |- type : typeIR `# eps
  -- Type_wf: $bound(BLOCK, C_0) |- typeIR
  ---- ;; check expression
  -- Expr_ok: BLOCK C_0 |- expression_init : typedExpressionIR_init
  ---- ;; check that the expression matches the type
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_init_cast
      = $coerce_unary(typedExpressionIR_init, typeIR)
  ---- ;; update the context
  -- if nameIR = $name(name)
  -- if C_1 = $add_var(BLOCK, C_0, nameIR, INOUT typeIR DYN eps)
  ---- ;; create IR
  -- if variableDeclarationIR
      = annotationList typeIR nameIR (`= typedExpressionIR_init_cast) `;

;;; valueSetDeclaration
;;; syntax valueSetDeclaration =
;;;   annotationList VALUE_SET `< valueSetType > `( expression ) name `;

rule ParserLocalDecl_ok/valueSetDeclaration:
  C_0 |- annotationList VALUE_SET `< valueSetType > `( expression ) name `;
       : C_1 valueSetDeclarationIR
  ---- ;; check type
  -- Type_ok: BLOCK C_0 |- valueSetType : typeIR `# eps
  ---- ;; check that the type can be embedded in a set
  -- Type_wf: $bound(BLOCK, C_0) |- SET `< typeIR >
  ---- ;; check expression
  -- Expr_ok: BLOCK C_0 |- expression : typedExpressionIR
  ---- ;; check that the expression is compile-time known
  -- if _ `# `( _ ctk ) = typedExpressionIR
  -- if ctk =/= DYN
  ---- ;; add the value set to the context
  -- if nameIR = $name(name)
  -- if C_1 = $add_var(BLOCK, C_0, nameIR, `EMPTY (SET `< typeIR >) CTK eps)
  ---- ;; create IR
  -- if valueSetDeclarationIR
      = annotationList VALUE_SET `< typeIR > `( typedExpressionIR ) nameIR `;

;;
;; Parser local declaration list typing
;;
;; syntax parserLocalDeclarationList
;;

rule ParserLocalDecls_ok/nil:
  C |- eps : C eps

rule ParserLocalDecls_ok/cons:
  C_0 |- parserLocalDeclaration_h :: parserLocalDeclaration_t*
       : C_2 (parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*)
  -- ParserLocalDecl_ok: C_0 |- parserLocalDeclaration_h
                              : C_1 parserLocalDeclarationIR_h
  -- ParserLocalDecls_ok: C_1 |- parserLocalDeclaration_t*
                               : C_2 parserLocalDeclarationIR_t*
