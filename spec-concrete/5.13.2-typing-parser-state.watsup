;;
;; Parser state typing
;;
;; syntax parserState =
;;   annotationList STATE name `{ parserStatementList transitionStatement }
;;

rule ParserState_ok:
  C_0 nameIR_state* |- annotationList STATE name
                        `{ parserStatementList transitionStatement }
                     : parserStateIR
  -- if nameIR = $name(name)
  ---- ;; enter block scope
  -- if C_1 = $enter(C_0)
  ---- ;; check parser statements
  -- if parserStatement*
      = $flatten_parserStatementList(parserStatementList)
  -- ParserStmts_ok: C_1 |- parserStatement* : C_2 parserStatementIR*
  ---- ;; check transition statement
  -- ParserTransition_ok: C_2 nameIR_state* |- transitionStatement
                                             : transitionStatementIR
  ---- ;; exit block scope
  -- if C_3 = $exit(C_2)
  ---- ;; create IR
  -- if parserStateIR
      = annotationList STATE nameIR `{ parserStatementIR* transitionStatementIR }

;;
;; Parser state list typing
;;
;; syntax parserStateList
;;

rule ParserStates_ok:
  C |- parserState* : parserStateIR*
  ---- ;; check that state names are distinct
  -- if (_ STATE name_state `{ _ _ } = parserState)*
  -- if (nameIR_state = $name(name_state))*
  -- if $distinct_<nameIR>(nameIR_state*)
  ---- ;; check that a "start" state exists
  ---- ;; and "accept"/"reject" are reserved
  -- if "start" <- nameIR_state*
  -- if ~("accept" <- nameIR_state*) /\ ~("reject" <- nameIR_state*)
  -- if nameIR_state_impl* = "accept" :: "reject" :: nameIR_state*
  ---- ;; check each parser state
  -- (ParserState_ok: C nameIR_state_impl* |- parserState : parserStateIR)*
