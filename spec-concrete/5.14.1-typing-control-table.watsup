;;
;; Table key property typing
;;
;; syntax tableKey = expression `: name annotationList `;
;;

dec $compat_table_exact_optional_key(typeIR) : bool
dec $compat'_table_exact_optional_key(typeIR) : bool

def $compat_table_exact_optional_key(typeIR)
  = $compat'_table_exact_optional_key($canon(typeIR))
def $compat'_table_exact_optional_key(BOOL) = true
def $compat'_table_exact_optional_key(ERROR) = true
def $compat'_table_exact_optional_key(numberTypeIR) = true
def $compat'_table_exact_optional_key(TYPE _ typeIR)
  = $compat_table_exact_optional_key(typeIR)
def $compat'_table_exact_optional_key(ENUM _ `{ _ }) = true
def $compat'_table_exact_optional_key(ENUM _ `# typeIR `{ _ })
  = $compat_table_exact_optional_key(typeIR)

dec $compat_table_lpm_ternary_range_key(typeIR) : bool
dec $compat'_table_lpm_ternary_range_key(typeIR) : bool

def $compat_table_lpm_ternary_range_key(typeIR)
  = $compat'_table_lpm_ternary_range_key($canon(typeIR))
def $compat'_table_lpm_ternary_range_key(INT) = true
def $compat'_table_lpm_ternary_range_key(INT `< _ >) = true
def $compat'_table_lpm_ternary_range_key(BIT `< _ >) = true
def $compat'_table_lpm_ternary_range_key(TYPE _ typeIR)
  = $compat_table_lpm_ternary_range_key(typeIR)
def $compat'_table_lpm_ternary_range_key(ENUM _ `# typeIR `{ _ })
  = $compat_table_lpm_ternary_range_key(typeIR)

dec $compat_table_key(nameIR, typeIR) : bool

def $compat_table_key(nameIR, typeIR) = true
  -- if nameIR = "exact" \/ nameIR = "optional"
  -- if $compat_table_exact_optional_key(typeIR)

def $compat_table_key(nameIR, typeIR) = true
  -- if nameIR = "lpm" \/ nameIR = "ternary" \/ nameIR = "range"
  -- if $compat_table_lpm_ternary_range_key(typeIR)

def $compat_table_key(nameIR, typeIR) = false
  -- otherwise

rule TableKey_ok:
  C TC_0 |- expression `: name annotationList `;
          : TC_2 tableKeyIR
  ---- ;; check expression
  -- Expr_ok: BLOCK C |- expression : typedExpressionIR
  -- if _ `# `( typeIR _ ) = typedExpressionIR
  ---- ;; check that the expression can be embedded in a set
  -- Type_wf: $bound(BLOCK, C) |- SET `< typeIR >
  ---- ;; check match kind
  -- if nameIR = $name(name)
  -- if MATCH_KIND `. nameIR = $find_value(BLOCK, C, `` nameIR)
  ---- ;; check compatibility with the match kind
  -- if $compat_table_key(nameIR, typeIR)
  ---- ;; update table context
  -- if TC_1 = $update_mode(TC_0, nameIR, typeIR)
  -- if TC_2 = $add_key(TC_1, nameIR, typeIR)
  ---- ;; create IR
  -- if tableKeyIR = typedExpressionIR `: nameIR annotationList `;

;;
;; Table key property list typing
;;
;; syntax tableKeyList
;;

rule TableKeys_ok/nil:
  C TC |- eps : TC eps

rule TableKeys_ok/cons:
  C TC_0 |- (tableKey_h :: tableKey_t*)
          : TC_2 (tableKeyIR_h :: tableKeyIR_t*)
  -- TableKey_ok: C TC_0 |- tableKey_h : TC_1 tableKeyIR_h
  -- TableKeys_ok: C TC_1 |- tableKey_t* : TC_2 tableKeyIR_t*

;;
;; Table action property typing
;;
;; syntax tableAction
;;

dec $split_dataplane_parameters(parameterTypeIR*)
  : (parameterTypeIR*, parameterTypeIR*)

def $split_dataplane_parameters(eps) = (eps, eps)
def $split_dataplane_parameters(parameterTypeIR_h :: parameterTypeIR_t*)
  = (parameterTypeIR_data*, parameterTypeIR_h :: parameterTypeIR_control*)
  -- if `EMPTY _ _ _ = parameterTypeIR_h
  -- if (parameterTypeIR_data*, parameterTypeIR_control*)
      = $split_dataplane_parameters(parameterTypeIR_t*)
def $split_dataplane_parameters(parameterTypeIR_h :: parameterTypeIR_t*)
  = (parameterTypeIR_h :: parameterTypeIR_data*, parameterTypeIR_control*)
  -- if direction _ _ _ = parameterTypeIR_h
  -- if direction =/= `EMPTY
  -- if (parameterTypeIR_data*, parameterTypeIR_control*)
      = $split_dataplane_parameters(parameterTypeIR_t*)

rule Call_action_partial_ok:
  C |- parameterTypeIR* `@ argumentIR*
     : parameterTypeIR_data* `, parameterTypeIR_control*
       `@ argumentIR_cast*
  ---- ;; split parameters into data- and control-planes
  -- if (parameterTypeIR_data*, parameterTypeIR_control*)
      = $split_dataplane_parameters(parameterTypeIR*)
  ---- ;; check arity 
  -- if $(|parameterTypeIR_data*| = |argumentIR*|)
  ---- ;; check calling convention on dataplane parameters
  -- Call_convention_ok:
      BLOCK C ACTION |- parameterTypeIR_data* `@ argumentIR*
                      : argumentIR_cast*

;;; syntax tableAction = annotationList tableActionReference `;
;;;; syntax tableActionReference

;;;; prefixedNonTypeName

rule TableAction_ok/prefixedNonTypeName:
  C TC_0 |- annotationList prefixedNonTypeName `;
          : TC_1 tableActionIR
  ---- ;; check that the action exists
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if ACTION `( parameterTypeIR* )
      = $find_routine_non_overloaded(BLOCK, C, prefixedNameIR)
  ---- ;; check that the action reference is a valid data-plane call
  -- Call_action_partial_ok: C |- parameterTypeIR* `@ eps
                                : parameterTypeIR_data* `, parameterTypeIR_control*
                                  `@ eps
  ---- ;; update the table context with the action
  -- if TC_1 = $add_action(TC_0, prefixedNameIR, parameterTypeIR*, eps)
  ---- ;; create IR
  -- if tableActionIR = annotationList (prefixedNameIR `( eps )) `;

;;;; prefixedNonTypeName `( argumentList )

rule TableAction_ok/prefixedNonTypeName-argumentList:
  C TC_0 |- annotationList (prefixedNonTypeName `( argumentList )) `;
          : TC_1 tableActionIR
  ---- ;; check that the action exists
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if ACTION `( parameterTypeIR* )
      = $find_routine_non_overloaded(BLOCK, C, prefixedNameIR)
  ---- ;; check arguments
  -- if argument* = $flatten_argumentList(argumentList)
  -- (Argument_ok: BLOCK C |- argument : argumentIR)*
  ---- ;; check that the action reference is a valid data-plane call
  -- Call_action_partial_ok: C |- parameterTypeIR* `@ argumentIR*
                                : parameterTypeIR_data* `, parameterTypeIR_control*
                                  `@ argumentIR_cast*
  ---- ;; update the table context with the action
  -- if TC_1 = $add_action(TC_0, prefixedNameIR, parameterTypeIR*, argumentIR_cast*)
  ---- ;; create IR
  -- if tableActionIR = annotationList (prefixedNameIR `( argumentIR_cast* )) `;

;;
;; Table action property list typing
;;
;; syntax tableActionList
;;

rule TableActions_ok/nil:
  C TC |- eps : TC eps

rule TableActions_ok/cons:
  C TC_0 |- (tableAction_h :: tableAction_t*)
          : TC_2 (tableActionIR_h :: tableActionIR_t*)
  -- TableAction_ok: C TC_0 |- tableAction_h : TC_1 tableActionIR_h
  -- TableActions_ok: C TC_1 |- tableAction_t* : TC_2 tableActionIR_t*

;;
;; Table default action property typing
;;
;; syntax tableDefaultAction (doesn't exist in the grammar)
;;

rule Call_action_default_ok:
  C |- parameterTypeIR* `@ argumentIR*
     : parameterTypeIR_data* `, parameterTypeIR_control*
       `@ argumentIR_cast*
  ---- ;; split parameters into data- and control-planes
  -- if (parameterTypeIR_data*, parameterTypeIR_control*)
      = $split_dataplane_parameters(parameterTypeIR*)
  ---- ;; check calling convention
  -- Call_convention_ok:
      BLOCK C ACTION |- parameterTypeIR* `@ argumentIR*
                      : argumentIR_cast*

;;; prefixedNonTypeName

rule TableDefaultAction_ok/prefixedNonTypeName:
  C TC |- `= prefixedNonTypeName
        : prefixedNameIR `( eps )
  ---- ;; find matching action
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if (eps, eps) = $find_action(TC, prefixedNameIR)

;;; prefixedNonTypeName `( argumentList )

rule TableDefaultAction_ok/prefixedNonTypeName-argumentList:
  C TC |- `= (prefixedNonTypeName `( argumentList ))
        : prefixedNameIR `( argumentIR_cast* )
  ---- ;; find matching action
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if (parameterTypeIR_action*, argumentIR_action*)
      = $find_action(TC, prefixedNameIR)
  ---- ;; check arguments
  -- if argument* = $flatten_argumentList(argumentList)
  -- (Argument_ok: BLOCK C |- argument : argumentIR)*
  ---- ;; check calling convention
  -- Call_action_default_ok:
      C |- parameterTypeIR_action* `@ argumentIR*
         : parameterTypeIR_action_data* `, parameterTypeIR_action_control*
           `@ argumentIR_cast*
  ---- ;; arguments must be syntatcially equivalent to
  ---- ;; dataplane arguments specified in the actions list property
  -- if argumentIR_action_data*
      = argumentIR_action*[0 : |parameterTypeIR_action_data*|] 
  -- if argumentIR_cast_data*
      = argumentIR_cast*[0 : |parameterTypeIR_action_data*|]
  -- if (argumentIR_action_data = argumentIR_cast_data)*

;;
;; Table property typing
;;
;; syntax tableProperty
;;

;;; KEY `= `{ tableKeyList }

rule TableProperty_ok/key:
  C TC_0 |- KEY `= `{ tableKeyList }
          : TC_1 (KEY `= `{ tableKeyIR* })
  -- if tableKey* = $flatten_tableKeyList(tableKeyList)
  -- TableKeys_ok: C TC_0 |- tableKey* : TC_1 tableKeyIR*

;;; ACTIONS `= `{ tableActionList }

rule TableProperty_ok/actions:
  C TC_0 |- ACTIONS `= `{ tableActionList }
          : TC_1 (ACTIONS `= `{ tableActionIR* })
  -- if tableAction* = $flatten_tableActionList(tableActionList)
  -- TableActions_ok: C TC_0 |- tableAction* : TC_1 tableActionIR*

;;; annotationList constOpt ENTRIES `= `{ tableEntryList }

;;; annotationList constOpt tableCustomName initializer `;

rule TableProperty_ok/custom-default-action:
  C TC |- annotationList constOpt tableCustomName initializer `;
        : TC tablePropertyIR
  ---- ;; check that the custom property is for default action
  -- if "default_action" = $tableCustomName(tableCustomName)
  ---- ;; check the initializer
  -- TableDefaultAction_ok: C TC |- initializer : tableActionReferenceIR
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR DEFAULT_ACTION `= tableActionReferenceIR `;

rule TableProperty_ok/custom-size:
  C TC |- annotationList constOpt tableCustomName (`= expression) `;
        : TC tablePropertyIR
  ---- ;; check that the custom property is for size
  -- if "size" = $tableCustomName(tableCustomName)
  ---- ;; check initializer
  -- Expr_ok: BLOCK C |- expression : typedExpressionIR
  -- if _ `# `( typeIR _ ) = typedExpressionIR
  -- if $is_arbitrary_int_typeIR(typeIR)
        \/ $is_fixed_int_typeIR(typeIR)
        \/ $is_fixed_bit_typeIR(typeIR)
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR "size" (`= typedExpressionIR) `;

rule TableProperty_ok/custom-largest-priority-wins:
  C TC_0 |- annotationList constOpt tableCustomName (`= expression) `;
          : TC_1 tablePropertyIR
  ---- ;; check that the custom property is for largest_priority_wins
  -- if "largest_priority_wins" = $tableCustomName(tableCustomName)
  ---- ;; check initializer
  -- Expr_ok: BLOCK C |- expression : typedExpressionIR
  -- if _ `# `( BOOL _ ) = typedExpressionIR
  -- Eval_static: BLOCK C |- typedExpressionIR ~> B b_largest_priority_wins
  ---- ;; update table context
  -- if TC_1 = TC_0[ .PRIORITIES.LARGEST_WINS = b_largest_priority_wins ]
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR "largest_priority_wins" (`= typedExpressionIR) `;

rule TableProperty_ok/custom-priority-delta:
  C TC_0 |- annotationList constOpt tableCustomName (`= expression) `;
          : TC_1 tablePropertyIR
  ---- ;; check that the custom property is for priority_delta
  -- if "priority_delta" = $tableCustomName(tableCustomName)
  ---- ;; check initializer
  -- Expr_ok: BLOCK C |- expression : typedExpressionIR
  -- if _ `# `( typeIR _ ) = typedExpressionIR
  -- if $is_arbitrary_int_typeIR(typeIR)
        \/ $is_fixed_int_typeIR(typeIR)
        \/ $is_fixed_bit_typeIR(typeIR)
  -- Eval_static: BLOCK C |- typedExpressionIR ~> value
  -- if n_delta = $to_number(value)
  -- if $(n_delta > 0)
  ---- ;; update table context
  -- if TC_1 = TC_0[ .PRIORITIES.DELTA = n_delta ]
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR "priority_delta" (`= typedExpressionIR) `;

rule TableProperty_ok/custom:
  C TC |- annotationList constOpt tableCustomName (`= expression) `;
        : TC tablePropertyIR
  ---- ;; check that the custom property is not one of the predefined ones
  -- if nameIR = $tableCustomName(tableCustomName)
  -- if nameIR =/= "size"
        /\ nameIR =/= "largest_priority_wins"
        /\ nameIR =/= "priority_delta"
  ---- ;; check initializer
  -- Expr_ok: BLOCK C |- expression : typedExpressionIR
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR nameIR (`= typedExpressionIR) `;

;;
;; Table property list typing
;;
;; syntax tablePropertyList
;;

rule TableProperties_ok/nil:
  C TC |- eps : TC eps

rule TableProperties_ok/cons:
  C TC_0 |- (tableProperty_h :: tableProperty_t*)
          : TC_2 (tablePropertyIR_h :: tablePropertyIR_t*)
  -- TableProperty_ok: C TC_0 |- tableProperty_h : TC_1 tablePropertyIR_h
  -- TableProperties_ok: C TC_1 |- tableProperty_t* : TC_2 tablePropertyIR_t*

;;
;; Table typing
;;
;; syntax table
;;

rule Table_ok:
  C |- tableProperty* : TC_1 tablePropertyIR*
  -- if TC_0 = $empty_tblctx
  -- TableProperties_ok: C TC_0 |- tableProperty* : TC_1 tablePropertyIR*

rule TableType_ok:
  C_0 TC |- name : C_1 typeIR_table
  -- if nameIR = $name(name)
  ---- ;; create table enum type
  -- if tid_enum = "action_list(" ++ nameIR ++ ")"
  -- if (prefixedNameIR_action, _, _)* = TC.ACTIONS
  -- if (id_enum_field = $flatten_prefixedNameIR(prefixedNameIR_action))*
  -- if typeIR_table_enum = TABLE_ENUM tid_enum `{ id_enum_field* }
  ---- ;; add enum fields to context
  -- if (value_enum_field = TABLE_ENUM tid_enum `. id_enum_field)*
  -- if (varTypeIR_enum_field
        = `EMPTY typeIR_table_enum LCTK value_enum_field)*
  -- if C_1
      = $add_vars(
          BLOCK, C_0,
          (tid_enum ++ "." ++ id_enum_field)*,
          varTypeIR_enum_field*
        )
  ---- ;; create table struct type
  -- if tid_struct = "apply_result(" ++ nameIR ++ ")"
  -- if typeIR_table_struct
      = TABLE_STRUCT tid_struct
          `{ [ (BOOL "hit" `;),
               (BOOL "miss" `;),
               (typeIR_table_enum "action_run" `;) ] }
  ---- ;; create table type
  -- if typeIR_table = TABLE nameIR `# typeIR_table_struct
