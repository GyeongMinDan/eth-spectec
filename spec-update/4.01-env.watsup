;;
;; Static type representation
;;

syntax varTypeIR = typeIR direction val? ctk

;;
;; Environments
;;

;; Map from variable identifiers to static types
syntax frame = map<name, varTypeIR>

dec $empty_frame() : frame
def $empty_frame() = $empty_map<name, varTypeIR>

;; Map from type identifiers to type definitions
syntax tdenv = map<name, typeDefIR>

dec $empty_tdenv() : tdenv
def $empty_tdenv() = $empty_map<name, typeDefIR>

;; Map from function identifiers to function type definitions
syntax fdenv = map<funcName, funcTypeDefIR>

dec $empty_fdenv() : fdenv
def $empty_fdenv() = $empty_map<funcName, funcTypeDefIR>

;; Map from constructor identifiers to constructor type definitions
syntax cdenv = map<consName, consTypeDefIR>

dec $empty_cdenv() : cdenv
def $empty_cdenv() = $empty_map<consName, consTypeDefIR>

;;
;; Function/method/constructor overload resolution
;;

dec $find_func_by_name(map<funcName, funcTypeDefIR>, name) : funcTypeDefIR?
dec $find_func_by_name'(map<funcName, funcTypeDefIR>, name) : funcTypeDefIR*

def $find_func_by_name(fdenv, name) = funcTypeDefIR
  -- if funcTypeDefIR = $find_func_by_name'(fdenv, name)

def $find_func_by_name(fdenv, name) = eps
  -- otherwise

def $find_func_by_name'(`{ eps }, name) = eps

def $find_func_by_name'(
    `{ (funcName_h `: funcTypeDefIR_h) :: (funcName_t `: funcTypeDefIR_t)* },
    name
  )
  = [ funcTypeDefIR_h ] ++ funcTypeDefIR_t_found*
  -- if name _ = funcName_h
  -- if funcTypeDefIR_t_found*
      = $find_func_by_name'(`{ (funcName_t `: funcTypeDefIR_t)* }, name)

def $find_func_by_name'(
    `{ (funcName_h `: funcTypeDefIR_h) :: (funcName_t `: funcTypeDefIR_t)* },
    name
  )
  = funcTypeDefIR_t_found*
  -- if name_h _ = funcName_h
  -- if name =/= name_h
  -- if funcTypeDefIR_t_found*
      = $find_func_by_name'(`{ (funcName_t `: funcTypeDefIR_t)* }, name)
