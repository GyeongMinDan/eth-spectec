;;
;; Static type representation
;;

syntax varTypeIR = typeIR direction val? ctk

;;
;; Environments
;;

;; Map from variable identifiers to static types
syntax frame = map<id, varTypeIR>

dec $empty_frame() : frame
def $empty_frame() = $empty_map<id, varTypeIR>

;; Map from type identifiers to type definitions
syntax tdenv = map<tid, typeDefIR>

dec $empty_tdenv() : tdenv
def $empty_tdenv() = $empty_map<tid, typeDefIR>

;; Map from function identifiers to function type definitions
syntax fdenv = map<fid, funcTypeDefIR>

dec $empty_fdenv() : fdenv
def $empty_fdenv() = $empty_map<fid, funcTypeDefIR>

;; Map from constructor identifiers to constructor type definitions
syntax cdenv = map<cid, consTypeDefIR>

dec $empty_cdenv() : cdenv
def $empty_cdenv() = $empty_map<cid, consTypeDefIR>

;;
;; Function/method/constructor overload resolution
;;

dec $find_func_by_id(map<fid, funcTypeDefIR>, id) : funcTypeDefIR?
dec $find_func_by_id'(map<fid, funcTypeDefIR>, id) : funcTypeDefIR*

def $find_func_by_id(fdenv, id) = funcTypeDefIR
  -- if funcTypeDefIR = $find_func_by_id'(fdenv, id)
def $find_func_by_id(fdenv, id) = eps
  -- otherwise

def $find_func_by_id'(`{ eps }, id) = eps
def $find_func_by_id'(
    `{ (fid_h `: funcTypeDefIR_h) :: (fid_t `: funcTypeDefIR_t)* },
    id
  )
  = [ funcTypeDefIR_h ] ++ funcTypeDefIR_t_found*
  -- if id_h `( _ ) = fid_h
  -- if funcTypeDefIR_t_found*
      = $find_func_by_id'(`{ (fid_t `: funcTypeDefIR_t)* }, id)
def $find_func_by_id'(
    `{ (fid_h `: funcTypeDefIR_h) :: (fid_t `: funcTypeDefIR_t)* },
    id
  )
  = funcTypeDefIR_t_found*
  -- if id_h `( _ ) = fid_h
  -- if id =/= id_h
  -- if funcTypeDefIR_t_found*
      = $find_func_by_id'(`{ (fid_t `: funcTypeDefIR_t)* }, id)
