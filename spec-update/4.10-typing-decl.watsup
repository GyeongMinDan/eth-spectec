;;
;; syntax declaration
;;

;;; | constantDeclaration
;;; syntax constantDeclaration =
;;;   optAnnotations CONST typeRef name initializer `;

rule Decl_ok/constantDeclaration:
  p C |- optAnnotations CONST typeRef name (`= expression) `;
       : C' (optAnnotations CONST typeIR name (`= val_init) `;)
  -- Type_ok: p C |- typeRef : typeIR eps
  -- Expr_ok: p C |- expression : expressionIR
  -- if _ `( _ `; LCTK) = expressionIR
  -- if expressionIR_cast = $coerce_unary(expressionIR, typeIR)
  -- Eval_static: p C |- expressionIR_cast ~> val_init
  -- if id = $id(name)
  -- if C' = $add_var(p, C, id, typeIR `EMPTY val_init LCTK)

;;; | errorDeclaration
;;; syntax errorDeclaration = ERROR `{ identifierList }

;;; | matchKindDeclaration
;;; syntax matchKindDeclaration =
;;;   MATCH_KIND `{ identifierList optTrailingComma }

;;; | externDeclaration
;;; syntax externDeclaration =
;;;   | optAnnotations EXTERN nonTypeName optTypeParameters `{ methodPrototypes }
;;;   | optAnnotations EXTERN functionPrototype `;

;;; | instantiation
;;; syntax instantiation

;;;; | optAnnotations typeRef `( argumentList ) name `;

rule Decl_ok/instantiation-typeName:
  p C_0 |- optAnnotations typeName `( argumentList ) name `;
         : C_1 (optAnnotations typeIR `( argumentListIR ) name `;)
  ---- ;; find constructor type
  -- Cons_ok: p C_0 |- typeName `< eps > `( argumentList )
                    : cid `< `# tid_fresh* > `( `# id_default* ) `@ consTypeIR
  ---- ;; check instantiation
  -- if id = $id(name)
  -- Inst_ok: p C_0 |- consTypeIR `< `EMPTY `# tid_fresh* > `( argumentList `# id_default* )
                     : typeIR `< typeArgListIR > `( argumentListIR )
  -- if C_1 = $add_var(p, C_0, id, typeIR `EMPTY eps CTK)

;;;; | optAnnotations typeRef `( argumentList ) name objInitializer `;

;;; | functionDeclaration
;;; syntax functionDeclaration =
;;;   optAnnotations functionPrototype blockStatement

;;; | actionDeclaration
;;; syntax actionDeclaration =
;;;   optAnnotations ACTION name `( parameterList ) blockStatement

rule Decl_ok/actionDeclaration:
  p C_0 |- optAnnotations ACTION name `( parameterList ) blockStatement
         : C_2 actionDeclarationIR
  ---- ;; check parameters
  -- Params_ok: LOCAL C_0 |- parameterList : parameterListIR eps
  -- if paramTypeIR* = $paramtypes(parameterListIR)
  -- if C_1 = $add_params(LOCAL, C_0, paramTypeIR*)
  ---- ;; check body
  -- Block_ok: C_1 CONT INIT |- blockStatement : _ _ blockStatementIR
  ---- ;; create action
  -- if fid = $fid(name, parameterList)
  -- if funcTypeIR = ACTION `( paramTypeIR* )
  -- FuncTypeDef_wf: $bound(GLOBAL, C_0) |- funcTypeIR
  -- if C_2 = $add_func(p, C_0, fid, funcTypeIR)
  ---- ;; assemble IR
  -- if actionDeclarationIR
      = optAnnotations ACTION name `( parameterListIR ) blockStatementIR

;;; | parserDeclaration
;;; syntax parserDeclaration =
;;;   parserTypeDeclaration optConstructorParameters
;;;     `{ parserLocalElements parserStates }

;;; | controlDeclaration 
;;; syntax controlDeclaration =
;;;   controlTypeDeclaration optConstructorParameters
;;;     `{ controlLocalDeclarations APPLY controlBody }

rule Decl_ok/controlDeclaration:
  GLOBAL C_0 |- controlTypeDeclaration optConstructorParameters
                `{ controlLocalDeclarations APPLY controlBody }
              : C_5 controlDeclarationIR
  ---- ;; unpack control type declaration
  -- if optAnnotations CONTROL name `EMPTY `( parameterList )
        = controlTypeDeclaration
  ---- ;; check constructor parameters
  -- ConsParams_ok: C_0 |- optConstructorParameters
                        : optConstructorParametersIR eps
  -- if consParamTypeIR*
      = $consParamtypes(optConstructorParametersIR)
  -- if C_1 = $add_consParams(C_0, consParamTypeIR*)
  ---- ;; check parameters to apply method
  -- Params_ok: LOCAL C_1 |- parameterList : parameterListIR eps
  -- if paramTypeIR* = $paramtypes(parameterListIR)
  -- if funcTypeIR = CONTROL_APPLY `( paramTypeIR* )
  -- FuncTypeDef_wf: $bound(GLOBAL, C_0) |- funcTypeIR
  -- if C_2 = $add_params(BLOCK, C_1, paramTypeIR*)
  ---- ;; check control local declarations
  -- ControlLocalDecls_ok: C_2 |- controlLocalDeclarations
                                : C_3 controlLocalDeclarationsIR
  ---- ;; check control apply method
  -- ControlBody_ok: C_3 |- controlBody : C_4 f controlBodyIR
  ---- ;; create control object constructor
  -- if cid = $cid(name, optConstructorParameters)
  -- if typeIR_control = CONTROL `( paramTypeIR* )
  -- if polyTypeDefIR_control = typeIR_control `< eps `, eps >
  -- if typeIR_spec = polyTypeDefIR_control `< eps >
  -- if consTypeIR = `( consParamTypeIR* ) -> typeIR_spec
  -- if consTypeDefIR = consTypeIR `< eps `, eps >
  -- ConsTypeDef_wf: $bound(GLOBAL, C_0) |- consTypeDefIR
  -- if C_5 = $add_cons(C_0, cid, consTypeDefIR)
  ---- ;; assemble IR
  -- if controlTypeDeclarationIR
      = optAnnotations CONTROL name `EMPTY `( parameterListIR )
  -- if controlDeclarationIR
      = controlTypeDeclarationIR optConstructorParametersIR
        `{ controlLocalDeclarationsIR APPLY controlBodyIR }

;;; | typeDeclaration
;;;; syntax typeDeclaration

;;;; | derivedTypeDeclaration

;;;; | typedefDeclaration `; 

;;;; | parserTypeDeclaration `;

;;;; | controlTypeDeclaration `;
;;;; syntax controlTypeDeclaration =
;;;;  optAnnotations CONTROL name optTypeParameters `( parameterList )

rule Decl_ok/controlTypeDeclaration:
  GLOBAL C_0 |- (optAnnotations CONTROL name `EMPTY `( parameterList )) `; 
              : C_1 (controlTypeDeclarationIR `;)
  -- Params_ok: LOCAL C_0 |- parameterList : parameterListIR tid_fresh*
  -- if paramTypeIR* = $paramtypes(parameterListIR)
  -- if typeIR = CONTROL `( paramTypeIR* )
  -- if typeDefIR = typeIR `< eps `, tid_fresh* >
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- typeDefIR
  -- if tid = $tid(name)
  -- if C_1 = $add_type(GLOBAL, C_0, tid, typeDefIR)
  -- if controlTypeDeclarationIR
      = optAnnotations CONTROL name `EMPTY `( parameterListIR )

;;;; | packageTypeDeclaration `;
;;;;; syntax packageTypeDeclaration =
;;;;;   optAnnotations PACKAGE name optTypeParameters `( parameterList )

rule Decl_ok/packageTypeDeclaration-epsilon:
  GLOBAL C_0 |- (optAnnotations PACKAGE name `EMPTY `( parameterList )) `; 
              : C_3 (packageTypeDeclarationIR `;)
  ---- ;; check type parameters
  -- ConsParams_ok: C_0 |- `( parameterList )
                         : `( parameterListIR ) tid_fresh*
  -- if consParamTypeIR*
      = $consParamtypes(`( parameterListIR ))
  -- if C_1 = $add_consParams(C_0, consParamTypeIR*)
  ---- ;; create package type
  -- if tid = $tid(name)
  -- if (_ _ typeIR_arg _ = consParamTypeIR)*
  -- if typeIR_package = PACKAGE `< typeIR_arg* >
  -- if polyTypeDefIR_package = typeIR_package `< eps `, tid_fresh* >
  -- TypeDef_wf: $bound(GLOBAL, C_0) |- polyTypeDefIR_package
  -- if C_2 = $add_type(GLOBAL, C_0, tid, polyTypeDefIR_package)
  ---- ;; create package object constructor
  -- if cid = $cid(name, `( parameterList ))
  -- if typeIR_spec = polyTypeDefIR_package `< (`@ tid_fresh)* >
  -- if consTypeIR = `( consParamTypeIR* ) -> typeIR_spec
  -- if consTypeDefIR = consTypeIR `< eps `, tid_fresh* >
  -- ConsTypeDef_wf: $bound(GLOBAL, C_0) |- consTypeDefIR
  -- if C_3 = $add_cons(C_2, cid, consTypeDefIR)
  ---- ;; assemble IR
  -- if packageTypeDeclarationIR
      = optAnnotations PACKAGE name `EMPTY `( parameterListIR )

;;
;; declaration*
;;

rule Decls_ok/nil:
  p C |- eps : C eps

rule Decls_ok/cons:
  p C |- declaration_h :: declaration_t*
        : C'' (declarationIR_h :: declarationIR_t*)
  -- Decl_ok: p C |- declaration_h : C' declarationIR_h
  -- Decls_ok: p C' |- declaration_t* : C'' declarationIR_t*

;;
;; syntax controlLocalDeclaration
;;

;;; | constantDeclaration

rule ControlLocalDecl_ok/constantDeclaration:
  C |- constantDeclaration : C' constantDeclarationIR
  -- Decl_ok: BLOCK C |- constantDeclaration
                       : C' constantDeclarationIR

;;; | actionDeclaration

rule ControlLocalDecl_ok/actionDeclaration:
  C |- actionDeclaration : C' actionDeclarationIR
  -- Decl_ok: BLOCK C |- actionDeclaration
                       : C' actionDeclarationIR

;;; | tableDeclaration
;;;; syntax tableDeclaration =
;;;;   optAnnotations TABLE name `{ tablePropertyList }

rule ControlLocalDecl_ok/tableDeclaration:
  C_0 |- optAnnotations TABLE name `{ tablePropertyList }
       : C_2 (optAnnotations TABLE name `{ tablePropertyListIR })
  -- Table_ok: C_0 $empty_tblctx |- tablePropertyList : tblctx' tablePropertyListIR
  -- TableType_ok: C_0 tblctx' |- name : C_1 typeIR_table
  -- if id = $id(name)
  -- if C_2 = $add_var(BLOCK, C_1, id, typeIR_table `EMPTY eps DYN)

;;; | instantiation
;;;; syntax instantiation

;;;; | optAnnotations typeRef `( argumentList ) name `;

;;;; | optAnnotations typeRef `( argumentList ) name objInitializer `;

;;; | variableDeclaration

;;
;; Control-local declaration typing
;;
;; controlLocalDeclaration*
;;

rule ControlLocalDecls_ok/empty:
  C |- `EMPTY : C `EMPTY

rule ControlLocalDecls_ok/controlLocalDeclarations-controlLocalDeclaration:
  C |- controlLocalDeclarations controlLocalDeclaration
     : C'' (controlLocalDeclarationsIR controlLocalDeclarationIR)
  -- ControlLocalDecls_ok: C |- controlLocalDeclarations
                              : C' controlLocalDeclarationsIR
  -- ControlLocalDecl_ok: C' |- controlLocalDeclaration
                              : C'' controlLocalDeclarationIR

;;
;; syntax p4program = declaration*
;;

rule Prog_ok/empty:
  C |- `EMPTY : C `EMPTY

rule Prog_ok/p4program-declaration:
  C |- p4program declaration : C'' (p4programIR declarationIR)
  -- Prog_ok: C |- p4program : C' p4programIR
  -- Decl_ok: GLOBAL C' |- declaration : C'' declarationIR

rule Prog_ok/p4program-semicolon:
  C |- p4program `; : C' (p4programIR `;)
  -- Prog_ok: C |- p4program : C' p4programIR

rule Prog_ok_entry:
  |- p4program : C' p4programIR
  -- if C = $empty_context
  -- Prog_ok: C |- p4program : C' p4programIR
