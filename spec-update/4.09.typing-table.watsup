;;
;; Table action typing
;;
;; syntax action = optAnnotations actionRef `;
;; syntax actionRef
;;

dec $split_directionless_params(paramTypeIR*) : (paramTypeIR*, paramTypeIR*)

def $split_directionless_params(eps) = (eps, eps)

def $split_directionless_params(paramTypeIR_h :: paramTypeIR_t*)
  = (paramTypeIR_data*, paramTypeIR_h :: paramTypeIR_control*)
  -- if _ `EMPTY _ _ = paramTypeIR_h
  -- if (paramTypeIR_data*, paramTypeIR_control*)
      = $split_directionless_params(paramTypeIR_t*)

def $split_directionless_params(paramTypeIR_h :: paramTypeIR_t*)
  = (paramTypeIR_h :: paramTypeIR_data*, paramTypeIR_control*)
  -- if _ direction _ _ = paramTypeIR_h
  -- if direction =/= `EMPTY
  -- if (paramTypeIR_data*, paramTypeIR_control*)
      = $split_directionless_params(paramTypeIR_t*)

rule Call_action_partial_ok:
  p C |- paramTypeIR* `@ typedArgumentListIR
       : (paramTypeIR_data*, paramTypeIR_control*) `@ argumentListIR_cast
  ---- ;; split data-plane and control-plane parameters
  -- if (paramTypeIR_data*, paramTypeIR_control*)
      = $split_directionless_params(paramTypeIR*)
  ---- ;; check calling convention for data-plane parameters
  -- if typedArgumentIR* = $flatten_typedArgumentListIR(typedArgumentListIR)
  -- if |paramTypeIR_data*| = |typedArgumentIR*|
  -- Call_convention_ok: p C ACT |- paramTypeIR_data* `@ typedArgumentIR* : argumentIR_cast*
  -- if argumentListIR_cast = $structure_argumentListIR(argumentIR_cast*)

;;; | prefixedNonTypeName

rule TableAction_ok/nonTypeName:
  C tblctx |- optAnnotations nonTypeName `;
            : tblctx' (optAnnotations nonTypeName `;)
  -- if id = $id(nonTypeName)
  -- if ACTION `( paramTypeIR* ) = $find_func_non_overloaded(BLOCK, C, id)
  -- Call_action_partial_ok: BLOCK C |- paramTypeIR* `@ `EMPTY
                                     : (paramTypeIR_data*, paramTypeIR_control*) `@ `EMPTY
  -- if tblctx' = $add_action(tblctx, id, paramTypeIR*, `EMPTY)

;;; | prefixedNonTypeName `( argumentList )

rule TableAction_ok/nonTypeName-argumentList:
  C tblctx |- optAnnotations (nonTypeName `( argumentList ))`;
            : tblctx' (optAnnotations (nonTypeName `( argumentListIR_cast )) `;)
  ---- ;; find action (non-overloaded)
  -- if id = $id(nonTypeName)
  -- if ACTION `( paramTypeIR* ) = $find_func_non_overloaded(BLOCK, C, id)
  ---- ;; check partial call
  -- Args_ok: BLOCK C |- argumentList : typedArgumentListIR
  -- Call_action_partial_ok:
      BLOCK C |- paramTypeIR* `@ typedArgumentListIR
              : (paramTypeIR_data*, paramTypeIR_control*) `@ argumentListIR_cast
  ---- ;; update table context
  -- if tblctx' = $add_action(tblctx, id, paramTypeIR*, argumentListIR_cast)

;;
;; Table action list typing
;;
;; syntax actionList = action*
;;

rule TableActions_ok/empty:
  C tblctx |- `EMPTY : tblctx `EMPTY

rule TableActions_ok/actionList-action:
  C tblctx |- actionList action
            : tblctx'' (actionListIR actionIR)
  -- TableActions_ok: C tblctx |- actionList
                                : tblctx' actionListIR
  -- TableAction_ok: C tblctx' |- action
                                : tblctx'' actionIR

;;
;; Table default action typing
;;
;; syntax actionRef
;;

rule Call_action_default_ok:
  p C |- paramTypeIR_action* `@ argumentListIR_action `@ typedArgumentListIR
       : argumentListIR_cast
  ---- ;; split dataplane and controlplane params
  -- if (paramTypeIR_data*, paramTypeIR_control*)
      = $split_directionless_params(paramTypeIR_action*)
  ---- ;; check syntactic equality of dataplane params
  -- if argumentIR_action* = $flatten_argumentListIR(argumentListIR_action)
  -- if typedArgumentIR* = $flatten_typedArgumentListIR(typedArgumentListIR)
  -- if (argumentIR `@ _ = typedArgumentIR)*
  -- if argumentIR_data* = argumentIR*[0 : |paramTypeIR_data*|]
  -- if argumentIR_data* = argumentIR_action*
  ---- ;; check call convention
  -- Call_convention_ok: p C ACT |- paramTypeIR_action* `@ typedArgumentIR*
                                  : argumentIR_cast*
  -- if argumentListIR_cast = $structure_argumentListIR(argumentIR_cast*)

;;; | prefixedNonTypeName

rule TableDefaultAction_ok/nonTypeName:
  C tblctx |- nonTypeName : nonTypeName
  -- if id = $id(nonTypeName)
  -- if (eps, `EMPTY) = $find_action(tblctx, id)

;;; | prefixedNonTypeName `( argumentList )

rule TableDefaultAction_ok/nonTypeName-argumentList:
  C tblctx |- nonTypeName `( argumentList )
            : nonTypeName `( argumentListIR_cast )
  ---- ;; find matching action
  -- if id = $id(nonTypeName)
  -- if (paramTypeIR_action*, argumentListIR_action) = $find_action(tblctx, id)
  ---- ;; check arguments
  -- Args_ok: BLOCK C |- argumentList : typedArgumentListIR
  ---- ;; check call
  -- Call_action_default_ok: BLOCK C |- paramTypeIR_action* `@ argumentListIR_action
                                                            `@ typedArgumentListIR
                                      : argumentListIR_cast

;;
;; Table property typing
;;
;; syntax tableProperty
;;

;;; | KEY `= `{ keyElementList }

;;; | ACTIONS `= `{ actionList }

rule TableProp_ok/actions:
  C tblctx |- ACTIONS `= `{ actionList }
            : tblctx' (ACTIONS `= `{ actionListIR })
  -- TableActions_ok: C tblctx |- actionList
                                : tblctx' actionListIR

;;; | optAnnotations optCONST ENTRIES `= `{ entriesList }

;;; | optAnnotations optCONST nonTableKwName `= expressionIR `;

rule TableProp_ok/nonTableKwName-initializer-default-action-prefixedNonTypeName:
  C tblctx |- optAnnotations optCONST
                (`ID "default_action") (`= prefixedNonTypeName) `;
            : tblctx
                (optAnnotations optCONST
                  (`ID "default_action") `= expressionIR `;)
  -- TableDefaultAction_ok: C tblctx |- prefixedNonTypeName : prefixedNonTypeName
  -- if expressionIR = prefixedNonTypeName `( VOID `; DYN )

rule TableProp_ok/nonTableKwName-initializer-default-action-prefixedNonTypeName-argumentList:
  C tblctx |- optAnnotations optCONST
                (`ID "default_action") (`= (prefixedNonTypeName `( argumentList ))) `;
            : tblctx
                (optAnnotations optCONST
                  (`ID "default_action") `= expressionIR `;)
  -- TableDefaultAction_ok: C tblctx |- prefixedNonTypeName `( argumentList )
                                      : (prefixedNonTypeName `( argumentListIR_cast ))
  -- if expressionIR
      = ((prefixedNonTypeName `( VOID `; DYN )) `( argumentListIR_cast )) `( VOID `; DYN )

;;
;; Table property list typing
;;
;; syntax tablePropertyList = tableProperty*
;;

rule Table_ok/empty:
  C tblctx |- `EMPTY : tblctx `EMPTY

rule Table_ok/tablePropertyList-tableProperty:
  C tblctx_0 |- tablePropertyList tableProperty
              : tblctx_2 (tablePropertyListIR tablePropertyIR)
  -- Table_ok: C tblctx_0 |- tablePropertyList
                           : tblctx_1 tablePropertyListIR
  -- TableProp_ok: C tblctx_1 |- tableProperty
                               : tblctx_2 tablePropertyIR

;;
;; Table type typing
;;

rule TableType_ok:
  C_0 tblctx |- name : C_1 typeIR_table
  ----
  -- if tid = $tid(name)
  ---- ;; create internal table enum type
  -- if tid_enum = "action_list(" ++ tid ++ ")"
  -- if (id_action, _, _)* = tblctx.ACTIONS
  -- if typeIR_enum = ENUM_TABLE tid_enum `{ id_action* }
  ---- ;; add enum fields to context
  -- if (val_enum_field = tid_enum `. id_action)*
  -- if (varTypeIR_enum_field
        = typeIR_enum `EMPTY val_enum_field LCTK)*
  -- if (id_enum_field = tid_enum ++ "." ++ id_action)*
  -- if C_1 = $add_vars(BLOCK, C_0, id_enum_field*, varTypeIR_enum_field*)
  ---- ;; create internal table struct type
  -- if tid_struct = "apply_result(" ++ tid ++ ")"
  -- if typeIR_struct
      = STRUCT_TABLE tid_struct
          `{ [ (BOOL, "hit"),
               (BOOL, "miss"),
               (typeIR_enum,"action_run") ] }
  ---- ;; create internal table type
  -- if typeIR_table = TABLE tid `{ typeIR_struct }
