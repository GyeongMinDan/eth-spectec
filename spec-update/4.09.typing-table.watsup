;;
;; Table action typing
;;
;; syntax action = optAnnotations actionRef `;
;; syntax actionRef
;;

dec $split_directionless_params(paramTypeIR*) : (paramTypeIR*, paramTypeIR*)

def $split_directionless_params(eps) = (eps, eps)

def $split_directionless_params(paramTypeIR_h :: paramTypeIR_t*)
  = (paramTypeIR_data*, paramTypeIR_h :: paramTypeIR_control*)
  -- if _ NONE _ _ = paramTypeIR_h
  -- if (paramTypeIR_data*, paramTypeIR_control*)
      = $split_directionless_params(paramTypeIR_t*)

def $split_directionless_params(paramTypeIR_h :: paramTypeIR_t*)
  = (paramTypeIR_h :: paramTypeIR_data*, paramTypeIR_control*)
  -- if _ direction _ _ = paramTypeIR_h
  -- if direction =/= NONE
  -- if (paramTypeIR_data*, paramTypeIR_control*)
      = $split_directionless_params(paramTypeIR_t*)

rule Call_action_partial_ok:
  p C |- paramTypeIR* `@ (argumentIR, typeIR)*
       : (paramTypeIR_data*, paramTypeIR_control*) `@ argumentIR_cast*
  -- if (paramTypeIR_data*, paramTypeIR_control*)
      = $split_directionless_params(paramTypeIR*)
  ----
  -- if |paramTypeIR_data*| = |argumentIR*|
  -- Call_convention_ok: p C ACT |- paramTypeIR_data* `@ (argumentIR, typeIR)*
                                  : argumentIR_cast*

;;; | prefixedNonTypeName

rule TableAction_ok/nonTypeName:
  C tblctx |- optAnnotations nonTypeName `;
            : tblctx' (nonTypeName `;)
  -- if id = $id(nonTypeName)
  -- if ACTION `( paramTypeIR* ) = $find_func_named(BLOCK, C, id)
  -- Call_action_partial_ok: BLOCK C |- paramTypeIR* `@ eps
                                     : (paramTypeIR_data*, paramTypeIR_control*) `@ eps
  -- if tblctx' = $add_action(tblctx, id, paramTypeIR*, eps)

;;; | prefixedNonTypeName `( argumentList )

rule TableAction_ok/nonTypeName-argumentList:
  C tblctx |- optAnnotations (nonTypeName `( argumentList ))`;
            : tblctx' ((nonTypeName `( argumentIR_cast* )) `;)
  -- if id = $id(nonTypeName)
  -- if ACTION `( paramTypeIR* ) = $find_func_named(BLOCK, C, id)
  -- if argument* = argumentList
  -- (Arg_ok: BLOCK C |- argument : argumentIR typeIR_arg)*
  -- Call_action_partial_ok:
      BLOCK C |- paramTypeIR* `@ (argumentIR, typeIR_arg)*
              : (paramTypeIR_data*, paramTypeIR_control*) `@ argumentIR_cast*
  -- if tblctx' = $add_action(tblctx, id, paramTypeIR*, argumentIR_cast*)

;;
;; Table action list typing
;;
;; syntax actionList = action*
;;

rule TableActions_ok/nil:
  C tblctx |- eps : tblctx eps

rule TableActions_ok/cons:
  C tblctx |- action_h :: action_t*
            : tblctx'' (actionIR_h :: actionIR_t*)
  -- TableAction_ok: C tblctx |- action_h
                               : tblctx' actionIR_h
  -- TableActions_ok: C tblctx' |- action_t*
                            : tblctx'' (actionIR_t*)

;;
;; Table default action typing
;;
;; syntax actionRef
;;

rule Call_action_default_ok:
  p C |- paramTypeIR_action* `@ argumentIR_action* `@ (argumentIR, typeIR)*
       : argumentIR_cast*
  ---- ;; split dataplane and controlplane params
  -- if (paramTypeIR_data*, paramTypeIR_control*)
      = $split_directionless_params(paramTypeIR_action*)
  ---- ;; check syntactic equality of dataplane params
  -- if argumentIR_data* = argumentIR*[0 : |paramTypeIR_data*|]
  -- if argumentIR_data* = argumentIR_action*
  ---- ;; check call convention
  -- Call_convention_ok: p C ACT |- paramTypeIR_action* `@ (argumentIR, typeIR)*
                                  : argumentIR_cast*

;;; | prefixedNonTypeName

rule TableDefaultAction_ok/nonTypeName:
  C tblctx |- nonTypeName : nonTypeName
  -- if id = $id(nonTypeName)
  -- if (eps, eps) = $find_action(tblctx, id)

;;; | prefixedNonTypeName `( argumentList )

rule TableDefaultAction_ok/nonTypeName-argumentList:
  C tblctx |- nonTypeName `( argumentList )
            : nonTypeName `( argumentIR_cast* )
  ---- ;; find matching action
  -- if id = $id(nonTypeName)
  -- if (paramTypeIR_action*, argumentIR_action*) = $find_action(tblctx, id)
  ---- ;; check arguments
  -- if argument* = argumentList
  -- (Arg_ok: BLOCK C |- argument : argumentIR typeIR_arg)*
  ---- ;; check call
  -- Call_action_default_ok: BLOCK C |- paramTypeIR_action* `@ argumentIR_action*
                                                            `@ (argumentIR, typeIR_arg)*
                                      : argumentIR_cast*

;;
;; Table property typing
;;
;; syntax tableProperty
;;

;;; | KEY `= `{ keyElementList }

;;; | ACTIONS `= `{ actionList }

rule TableProp_ok/actions:
  C tblctx |- ACTIONS `= `{ actionList }
            : tblctx' (ACTIONS `= `{ actionListIR })
  -- TableActions_ok: C tblctx |- actionList
                                : tblctx' actionListIR

;;; | optAnnotations optCONST ENTRIES `= `{ entriesList }

;;; | optAnnotations optCONST nonTableKwName `= expressionIR `;

rule TableProp_ok/nonTableKwName-initializer-default-action-prefixedNonTypeName:
  C tblctx |- optAnnotations optCONST
                (`$ "default_action") (`= prefixedNonTypeName) `;
            : tblctx (optCONST
                        (`$ "default_action") `= expressionIR `;)
  -- TableDefaultAction_ok: C tblctx |- prefixedNonTypeName : prefixedNonTypeName
  -- if expressionIR = prefixedNonTypeName `( VOID `; DYN )

rule TableProp_ok/nonTableKwName-initializer-default-action-prefixedNonTypeName-argumentList:
  C tblctx |- optAnnotations optCONST
                (`$ "default_action") (`= (prefixedNonTypeName `( argumentList ))) `;
            : tblctx (optCONST
                        (`$ "default_action") `= expressionIR `;)
  -- TableDefaultAction_ok: C tblctx |- prefixedNonTypeName `( argumentList )
                                      : (prefixedNonTypeName `( argumentIR_cast* ))
  -- if expressionIR
      = ((prefixedNonTypeName `( VOID `; DYN )) `( argumentIR_cast* )) `( VOID `; DYN )

;;
;; Table property list typing
;;
;; syntax tablePropertyList = tableProperty*
;;

rule Table_ok/nil:
  C tblctx |- eps : tblctx eps

rule Table_ok/cons:
  C tblctx_0 |- tableProperty_h :: tableProperty_t*
              : tblctx_2 (tablePropertyIR_h :: tablePropertyIR_t*)
  -- TableProp_ok: C tblctx_0 |- tableProperty_h
                             : tblctx_1 tablePropertyIR_h
  -- Table_ok: C tblctx_1 |- tableProperty_t*
                           : tblctx_2 (tablePropertyIR_t*)

;;
;; Table type typing
;;

rule TableType_ok:
  C_0 tblctx |- name : C_1 typeIR_table
  ----
  -- if tid = $tid(name)
  ---- ;; create internal table enum type
  -- if tid_enum = "action_list(" ++ tid ++ ")"
  -- if (id_action, _, _)* = tblctx.ACTIONS
  -- if typeIR_enum = ENUM_TABLE tid_enum `{ id_action* }
  ---- ;; add enum fields to context
  -- if (val_enum_field = tid_enum `. id_action)*
  -- if (varTypeIR_enum_field
        = typeIR_enum NONE val_enum_field LCTK)*
  -- if (id_enum_field = tid_enum ++ "." ++ id_action)*
  -- if C_1 = $add_vars(BLOCK, C_0, id_enum_field*, varTypeIR_enum_field*)
  ---- ;; create internal table struct type
  -- if tid_struct = "apply_result(" ++ tid ++ ")"
  -- if typeIR_struct
      = STRUCT_TABLE tid_struct
          `{ [ (BOOL, "hit"),
               (BOOL, "miss"),
               (typeIR_enum,"action_run") ] }
  ---- ;; create internal table type
  -- if typeIR_table = TABLE tid `{ typeIR_struct }
