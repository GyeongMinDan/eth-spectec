;;
;; Relations for well-formedness
;;

relation ParamType_wf:
  bound |- paramTypeIR
  hint(input %0 %1)

relation ParamTypes_wf:
  bound |- paramTypeIR*
  hint(input %0 %1)

relation Type_wf:
  bound |- typeIR
  hint(input %0 %1)

relation TypeDef_wf:
  bound |- typeDefIR
  hint(input %0 %1)

relation FuncType_wf:
  bound |- funcTypeIR
  hint(input %0 %1)

relation FuncTypeDef_wf:
  bound |- funcTypeDefIR
  hint(input %0 %1)

syntax consctxt = CONSCTXT

relation CParamType_wf:
  bound consctxt |- paramTypeIR
  hint(input %0 %1 %2)

relation CParamTypes_wf:
  bound consctxt |- paramTypeIR*
  hint(input %0 %1 %2)

relation ConsType_wf:
  bound |- consTypeIR
  hint(input %0 %1)

relation ConsTypeDef_wf:
  bound |- consTypeDefIR
  hint(input %0 %1)

;;
;;;; Well-formedness of parameter types
;;

dec $is_externtype(typeIR) : bool
dec $is_externtype'(typeIR) : bool

def $is_externtype(typeIR)
  = $is_externtype'($canon(typeIR))
def $is_externtype'(EXTERN _ _) = true
def $is_externtype'(_) = false
  -- otherwise

rule ParamType_wf/default-none-extern:
  bound |- _ NONE typeIR eps
  -- Type_wf: bound |- typeIR
  -- if $is_externtype(typeIR)

rule ParamType_wf/default-none-not-extern:
  bound |- _ direction typeIR eps
  -- Type_wf: bound |- typeIR
  -- if ~$is_externtype(typeIR)

rule ParamType_wf/default-some-extern:
  bound |- _ NONE typeIR val
  -- Type_wf: bound |- typeIR
  -- if $is_externtype(typeIR)

rule ParamType_wf/default-some-not-extern:
  bound |- _ direction typeIR val
  -- Type_wf: bound |- typeIR
  -- if ~$is_externtype(typeIR)
  -- if direction = IN \/ direction = NONE

rule ParamTypes_wf:
  bound |- paramTypeIR*
  -- if (name _ _ _ = paramTypeIR)*
  -- if $distinct_<name>(name*)
  -- (ParamType_wf: bound |- paramTypeIR)*

;;
;;;; Well-formedness of types
;;

;;; Base types

rule Type_wf/basetype:
  bound |- baseTypeIR

;;; Named types

rule Type_wf/nametype:
  bound |- name
  -- if $in_set<name>(name, bound)

rule Type_wf/spectype:
  bound |- polyTypeDefIR `< typeIR_a* >
  -- if typeIR = $specialize_typeDef(polyTypeDefIR, typeIR_a*)
  -- Type_wf: bound |- typeIR

;;; Typedef types

dec $nestable_typedef(typeIR) : bool
dec $nestable'_typedef(typeIR) : bool

def $nestable_typedef(typeIR) = $nestable'_typedef($canon(typeIR))
def $nestable'_typedef(BOOL) = true
def $nestable'_typedef(ERROR) = true
def $nestable'_typedef(STRING) = true
def $nestable'_typedef(numTypeIR) = true
def $nestable'_typedef(name) = true
def $nestable'_typedef(dataTypeIR) = true
def $nestable'_typedef(_) = false
  -- otherwise

rule Type_wf/typedeftype:
  bound |- TYPEDEF _ typeIR
  -- if $nestable_typedef(typeIR)
  -- TypeDef_wf: bound |- typeIR

dec $nestable_new(typeIR) : bool
dec $nestable'_new(typeIR) : bool

def $nestable_new(typeIR) = $nestable'_new($canon(typeIR))
def $nestable'_new(BOOL) = true
def $nestable'_new(BIT `< _ >) = true
def $nestable'_new(INT `< _ >) = true
def $nestable'_new(name) = true
def $nestable'_new(TYPE _ _) = true
def $nestable'_new(_) = false
  -- otherwise

rule Type_wf/newtype:
  bound |- TYPE _ typeIR
  -- if $nestable_new(typeIR)
  -- TypeDef_wf: bound |- typeIR 

;;; Data types

dec $nestable_list(typeIR) : bool
dec $nestable'_list(typeIR) : bool

def $nestable_list(typeIR) = $nestable'_list($canon(typeIR))
def $nestable'_list(BOOL) = true
def $nestable'_list(ERROR) = true
def $nestable'_list(MATCH_KIND) = true
def $nestable'_list(STRING) = true
def $nestable'_list(numTypeIR) = true
def $nestable'_list(name) = true
def $nestable'_list(dataTypeIR) = true
def $nestable'_list(_) = false
  -- otherwise

rule Type_wf/listttype:
  bound |- LIST `< typeIR >
  -- if $nestable_list(typeIR)
  -- Type_wf: bound |- typeIR

dec $nestable_tuple(typeIR) : bool
dec $nestable'_tuple(typeIR) : bool

def $nestable_tuple(typeIR) = $nestable'_tuple($canon(typeIR))
def $nestable'_tuple(BOOL) = true
def $nestable'_tuple(ERROR) = true
def $nestable'_tuple(BIT `< _ >) = true
def $nestable'_tuple(INT `< _ >) = true
def $nestable'_tuple(VARBIT `< _ >) = true
def $nestable'_tuple(name) = true
def $nestable'_tuple(TUPLE `< _ >) = true
def $nestable'_tuple(typeIR `[ _ ]) = true
def $nestable'_tuple(HEADER _ `{ _ }) = true
def $nestable'_tuple(HEADER_UNION _ `{ _ }) = true
def $nestable'_tuple(STRUCT _ `{ _ }) = true
def $nestable'_tuple(ENUM _ `{ _ }) = true
def $nestable'_tuple(ENUM _ _ `{ _ }) = true
def $nestable'_tuple(_) = false
  -- otherwise

rule Type_wf/tupletype:
  bound |- TUPLE `< typeIR* >
  -- if $nestable_tuple(typeIR)*
  -- (Type_wf: bound |- typeIR)*

dec $nestable_stack(typeIR) : bool
dec $nestable'_stack(typeIR) : bool

def $nestable_stack(typeIR) = $nestable'_stack($canon(typeIR))
def $nestable'_stack(name) = true
def $nestable'_stack(HEADER _ `{ _ }) = true
def $nestable'_stack(HEADER_UNION _ `{ _ }) = true
def $nestable'_stack(_) = false
  -- otherwise

rule Type_wf/stacktype:
  bound |- typeIR `[ _ ]
  -- if $nestable_stack(typeIR)
  -- Type_wf: bound |- typeIR

dec $nestable_header(typeIR) : bool
dec $nestable'_header(typeIR) : bool
dec $nestable_struct_in_header(typeIR) : bool
dec $nestable'_struct_in_header(typeIR) : bool

def $nestable_header(typeIR) = $nestable'_header($canon(typeIR))
def $nestable'_header(BOOL) = true
def $nestable'_header(BIT `< _ >) = true
def $nestable'_header(INT `< _ >) = true
def $nestable'_header(VARBIT `< _ >) = true
def $nestable'_header(name) = true
def $nestable'_header(TYPE _ _) = true
def $nestable'_header(STRUCT _ `{ (typeIR, _)* }) = true
  -- if $nestable_struct_in_header(typeIR)*
def $nestable'_header(ENUM _ _ `{ _ }) = true
def $nestable'_header(_) = false
  -- otherwise

def $nestable_struct_in_header(typeIR)
  = $nestable'_struct_in_header($canon(typeIR))
def $nestable'_struct_in_header(BOOL) = true
def $nestable'_struct_in_header(BIT `< _ >) = true
def $nestable'_struct_in_header(INT `< _ >) = true
def $nestable'_struct_in_header(name) = true
def $nestable'_struct_in_header(TYPE _ _) = true
def $nestable'_struct_in_header(ENUM _ _ `{ _ }) = true
def $nestable'_struct_in_header(STRUCT _ `{ (typeIR, _)* }) = true
  -- if $nestable_struct_in_header(typeIR)*
def $nestable'_struct_in_header(_) = false
  -- otherwise

rule Type_wf/headertype:
  bound |- HEADER _ `{ (typeIR, name)* }
  -- if $distinct_<name>(name*)
  -- if $nestable_header(typeIR)*
  -- (Type_wf: bound |- typeIR)*

dec $nestable_headerunion(typeIR) : bool
dec $nestable'_headerunion(typeIR) : bool

def $nestable_headerunion(typeIR)
  = $nestable'_headerunion($canon(typeIR))
def $nestable'_headerunion(name) = true
def $nestable'_headerunion(TYPE _ _) = true
def $nestable'_headerunion(HEADER _ `{ _ }) = true
def $nestable'_headerunion(_) = false
  -- otherwise

rule Type_wf/headeruniontype:
  bound |- HEADER_UNION _ `{ (typeIR, name)* }
  -- if $distinct_<name>(name*)
  -- if $nestable_headerunion(typeIR)*
  -- (Type_wf: bound |- typeIR)*

dec $nestable_struct(typeIR) : bool
dec $nestable'_struct(typeIR) : bool

def $nestable_struct(typeIR) = $nestable'_struct($canon(typeIR))
def $nestable'_struct(BOOL) = true
def $nestable'_struct(ERROR) = true
def $nestable'_struct(BIT `< _ >) = true
def $nestable'_struct(INT `< _ >) = true
def $nestable'_struct(VARBIT `< _ >) = true
def $nestable'_struct(name) = true
def $nestable'_struct(TUPLE `< _ >) = true
def $nestable'_struct(typeIR `[ _ ]) = true
def $nestable'_struct(HEADER _ `{ _ }) = true
def $nestable'_struct(HEADER_UNION _ `{ _ }) = true
def $nestable'_struct(STRUCT _ `{ _ }) = true
def $nestable'_struct(ENUM _ `{ _ }) = true
def $nestable'_struct(ENUM _ _ `{ _ }) = true
def $nestable'_struct(_) = false
  -- otherwise

rule Type_wf/structtype:
  bound |- STRUCT _ `{ (typeIR, name)* }
  -- if $distinct_<name>(name*)
  -- if $nestable_struct(typeIR)*
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/enumtype:
  bound |- ENUM _ `{ name* }
  -- if $distinct_<name>(name*)

dec $nestable_serenum(typeIR) : bool
dec $nestable'_serenum(typeIR) : bool
dec $nestable_new_in_serenum(typeIR) : bool
dec $nestable_new_in_serenum'(typeIR) : bool

def $nestable_serenum(typeIR)
  = $nestable'_serenum($canon(typeIR))
def $nestable'_serenum(BIT `< _ >) = true
def $nestable'_serenum(INT `< _ >) = true
def $nestable'_serenum(name) = true
def $nestable'_serenum(TYPE _ typeIR)
  = $nestable_new_in_serenum(typeIR)
def $nestable'_serenum(_) = false
  -- otherwise

def $nestable_new_in_serenum(typeIR)
  = $nestable_new_in_serenum'($canon(typeIR))
def $nestable_new_in_serenum'(BIT `< _ >) = true
def $nestable_new_in_serenum'(INT `< _ >) = true
def $nestable_new_in_serenum'(name) = true
def $nestable_new_in_serenum'(TYPE _ _) = true
def $nestable_new_in_serenum'(_) = false
  -- otherwise

rule Type_wf/serenumtype:
  bound |- ENUM typeIR _ `{ (name, _)* }
  -- if $distinct_<name>(name*)
  -- if $nestable_serenum(typeIR)
  -- Type_wf: bound |- typeIR

;;; Object types

rule Type_wf/externtype:
  bound |- EXTERN _ (`{ (_ `: funcTypeDefIR)* })
  -- (FuncTypeDef_wf: bound |- funcTypeDefIR)*

rule Type_wf/parsertype:
  bound |- PARSER `( paramTypeIR* )
  -- ParamTypes_wf: bound |- paramTypeIR*

rule Type_wf/controltype:
  bound |- CONTROL `( paramTypeIR* )
  -- ParamTypes_wf: bound |- paramTypeIR*

rule Type_wf/packagetype:
  bound |- PACKAGE `< typeIR* >
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/tabletype:
  bound |- TABLE name `{ typeIR }
  -- if STRUCT_TABLE _ = $canon(typeIR)
  -- Type_wf: bound |- typeIR

;;; Synthesized types

rule Type_wf/defaulttype:
  bound |- DEFAULT

rule Type_wf/sequencetype:
  bound |- SEQ `< typeIR* >
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/sequencedefaulttype:
  bound |- SEQ `< typeIR* `, `... >
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/recordtype:
  bound |- RECORD `{ (typeIR, name)* }
  -- if $distinct_<name>(name*)
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/recorddefaulttype:
  bound |- RECORD `{ (typeIR, name)* `, `... }
  -- if $distinct_<name>(name*)
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/invalidtype:
  bound |- INVALID

dec $nestable_set(typeIR) : bool
dec $nestable'_set(typeIR) : bool
dec $nestable_tuple_in_set(typeIR) : bool
dec $nestable'_tuple_in_set(typeIR) : bool
dec $nestable_sequence_in_set(typeIR) : bool
dec $nestable'_sequence_in_set(typeIR) : bool

def $nestable_set(typeIR) = $nestable'_set($canon(typeIR))
def $nestable'_set(BOOL) = true
def $nestable'_set(ERROR) = true
def $nestable'_set(BIT `< _ >) = true
def $nestable'_set(INT `< _ >) = true
def $nestable'_set(name) = true
def $nestable'_set(TYPE _ _) = true
def $nestable'_set(TUPLE `< typeIR* >) = true
  -- if $nestable_tuple_in_set(typeIR)*
def $nestable'_set(ENUM _ `{ _ }) = true
def $nestable'_set(ENUM _ _ `{ _ }) = true
def $nestable'_set(SEQ `< typeIR* >) = true
  -- if $nestable_sequence_in_set(typeIR)*
def $nestable'_set(_) = false
  -- otherwise

def $nestable_tuple_in_set(typeIR)
  = $nestable'_tuple_in_set($canon(typeIR))
def $nestable'_tuple_in_set(BOOL) = true
def $nestable'_tuple_in_set(BIT `< _ >) = true
def $nestable'_tuple_in_set(INT `< _ >) = true
def $nestable'_tuple_in_set(name) = true
def $nestable'_tuple_in_set(TYPE _ _) = true
def $nestable'_tuple_in_set(TUPLE `< typeIR* >) = true
  -- if $nestable_tuple_in_set(typeIR)*
def $nestable'_tuple_in_set(ENUM _ `{ _ }) = true
def $nestable'_tuple_in_set(ENUM _ _ `{ _ }) = true
def $nestable'_tuple_in_set(_) = false
  -- otherwise

def $nestable_sequence_in_set(typeIR)
  = $nestable'_sequence_in_set($canon(typeIR))
def $nestable'_sequence_in_set(BOOL) = true
def $nestable'_sequence_in_set(BIT `< _ >) = true
def $nestable'_sequence_in_set(INT `< _ >) = true
def $nestable'_sequence_in_set(name) = true
def $nestable'_sequence_in_set(TYPE _ _) = true
def $nestable'_sequence_in_set(TUPLE `< typeIR* >) = true
  -- if $nestable_sequence_in_set(typeIR)*
def $nestable'_sequence_in_set(ENUM _ `{ _ }) = true
def $nestable'_sequence_in_set(ENUM _ _ `{ _ }) = true
def $nestable'_sequence_in_set(SEQ `< typeIR* >) = true
  -- if $nestable_sequence_in_set(typeIR)*
def $nestable'_sequence_in_set(_) = false
  -- otherwise

rule Type_wf/settype:
  bound |- SET `< typeIR >
  -- if $nestable_set(typeIR)
  -- Type_wf: bound |- typeIR

rule Type_wf/parserstatetype:
  bound |- PARSERSTATE

rule Type_wf/tableenumtype:
  bound |- ENUM_TABLE _ `{ name* }
  -- if $distinct_<name>(name*)

rule Type_wf/tablestructtype:
  bound |- STRUCT_TABLE _

rule Type_wf/dontcaretype:
  bound |- `_

;;
;;;; Well-formedness of type definitions
;;

dec $definable_type_mono(typeIR) : bool

def $definable_type_mono(name) = true
def $definable_type_mono(typedefTypeIR) = true
def $definable_type_mono(ENUM _ `{ _ }) = true
def $definable_type_mono(ENUM _ _ `{ _ }) = true
def $definable_type_mono(TABLE _ `{ _ }) = true
def $definable_type_mono(_) = false
  -- otherwise

rule TypeDef_wf/mono:
  bound |- typeIR
  -- if $definable_type_mono(typeIR)
  -- Type_wf: bound |- typeIR

dec $definable_type_poly(typeIR) : bool

def $definable_type_poly(TUPLE `< _ >) = true
def $definable_type_poly(_ `[ _ ]) = true
def $definable_type_poly(HEADER _ `{ _ }) = true
def $definable_type_poly(HEADER_UNION _ `{ _ }) = true
def $definable_type_poly(STRUCT _ `{ _ }) = true
def $definable_type_poly(EXTERN _ _) = true
def $definable_type_poly(PARSER `( _ )) = true
def $definable_type_poly(CONTROL `( _ )) = true
def $definable_type_poly(PACKAGE `< _ >) = true
def $definable_type_poly(_) = false
  -- otherwise

rule TypeDef_wf/poly:
  bound |- typeIR `< name* `, name_hidden* >
  -- if $definable_type_poly(typeIR)
  -- if $distinct_<name>(name* ++ name_hidden*)
  -- if bound_inner
      = $union_set<name>(bound, `{ name* ++ name_hidden* })
  -- Type_wf: bound_inner |- typeIR

;;
;;;; Well-formedness of function types
;;

dec $directionless_trailing(direction*) : bool
dec $directionless_trailing'(bool, direction*) : bool

def $directionless_trailing(direction*)
  = $directionless_trailing'(true, $rev_<direction>(direction*))

def $directionless_trailing'(_, eps) = true
def $directionless_trailing'(true, NONE :: direction_t*)
  = $directionless_trailing'(true, direction_t*)
def $directionless_trailing'(false, NONE :: direction_t*) = false
def $directionless_trailing'(_, direction_h :: direction_t*)
  = $directionless_trailing'(false, direction_t*)
  -- if direction_h =/= NONE

dec $nestable_action(direction, typeIR) : bool
dec $nestable_action'(direction, typeIR) : bool

def $nestable_action(direction, typeIR)
  = $nestable_action'(direction, $canon(typeIR))
def $nestable_action'(direction, STRING) = false
  -- if direction =/= NONE
def $nestable_action'(_, INT) = false
def $nestable_action'(_, objTypeIR) = false
def $nestable_action'(_, _) = true
  -- otherwise

rule FuncType_wf/actiontype:
  bound |- ACTION `( paramTypeIR* )
  -- ParamTypes_wf: bound |- paramTypeIR*
  -- if (name direction typeIR val? = paramTypeIR)*
  -- if $directionless_trailing(direction*)
  -- if $nestable_action(direction, typeIR)*

dec $nestable_externfunc(direction, typeIR) : bool
dec $nestable_externfunc'(direction, typeIR) : bool

def $nestable_externfunc(direction, typeIR)
  = $nestable_externfunc'(direction, $canon(typeIR))
def $nestable_externfunc'(direction, STRING) = false
  -- if direction =/= NONE
def $nestable_externfunc'(direction, INT) = false
  -- if direction =/= NONE
def $nestable_externfunc'(direction, PARSER `( _ )) = false
def $nestable_externfunc'(direction, CONTROL `( _ )) = false
def $nestable_externfunc'(direction, PACKAGE `< _ >) = false
def $nestable_externfunc'(direction, TABLE _ `{ _ }) = false
def $nestable_externfunc'(_, _) = true
  -- otherwise

rule FuncType_wf/externfunctype:
  bound |- EXTERN_FUNC `( paramTypeIR* ) -> typeIR_ret
  -- ParamTypes_wf: bound |- paramTypeIR*
  -- if (name direction typeIR val? = paramTypeIR)* 
  -- if $nestable_externfunc(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_func(direction, typeIR) : bool
dec $nestable_func'(direction, typeIR) : bool

def $nestable_func(direction, typeIR)
  = $nestable_func'(direction, $canon(typeIR))
def $nestable_func'(direction, STRING) = false
  -- if direction =/= NONE
def $nestable_func'(direction, INT) = false
  -- if direction =/= NONE
def $nestable_func'(direction, objTypeIR) = false
def $nestable_func'(_, _) = true
  -- otherwise

rule FuncType_wf/functype:
  bound |- FUNC `( paramTypeIR* ) -> typeIR_ret
  -- ParamTypes_wf: bound |- paramTypeIR*
  -- if (name direction typeIR val? = paramTypeIR)* 
  -- if $nestable_func(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

rule FuncType_wf/builtinmethod:
  bound |- BUILTIN `( paramTypeIR* ) -> typeIR_ret
  -- ParamTypes_wf: bound |- paramTypeIR*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_externmethod(direction, typeIR) : bool
dec $nestable_externmethod'(direction, typeIR) : bool

def $nestable_externmethod(direction, typeIR)
  = $nestable_externmethod'(direction, $canon(typeIR))
def $nestable_externmethod'(direction, STRING) = false
  -- if direction =/= NONE
def $nestable_externmethod'(direction, INT) = false
  -- if direction =/= NONE
def $nestable_externmethod'(direction, PARSER `( _ )) = false
def $nestable_externmethod'(direction, CONTROL `( _ )) = false
def $nestable_externmethod'(direction, PACKAGE `< _ >) = false
def $nestable_externmethod'(direction, TABLE _ `{ _ }) = false
def $nestable_externmethod'(_, _) = true
  -- otherwise

rule FuncType_wf/externmethod:
  bound |- EXTERN_METHOD `( paramTypeIR* ) -> typeIR_ret
  -- ParamTypes_wf: bound |- paramTypeIR*
  -- if (name direction typeIR val? = paramTypeIR)* 
  -- if $nestable_externmethod(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_externabstractmethod(direction, typeIR) : bool
dec $nestable_externabstractmethod'(direction, typeIR) : bool

def $nestable_externabstractmethod(direction, typeIR)
  = $nestable_externabstractmethod'(direction, $canon(typeIR))
def $nestable_externabstractmethod'(direction, STRING) = false
  -- if direction =/= NONE
def $nestable_externabstractmethod'(direction, INT) = false
  -- if direction =/= NONE
def $nestable_externabstractmethod'(direction, PARSER `( _ )) = false
def $nestable_externabstractmethod'(direction, CONTROL `( _ )) = false
def $nestable_externabstractmethod'(direction, PACKAGE `< _ >) = false
def $nestable_externabstractmethod'(direction, TABLE _ `{ _ }) = false
def $nestable_externabstractmethod'(_, _) = true
  -- otherwise

rule FuncType_wf/externabstractmethod:
  bound |- EXTERN_ABSTRACT_METHOD `( paramTypeIR* ) -> typeIR_ret
  -- ParamTypes_wf: bound |- paramTypeIR*
  -- if (name direction typeIR val? = paramTypeIR)* 
  -- if $nestable_externabstractmethod(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_parserapplymethod(direction, typeIR) : bool
dec $nestable_parserapplymethod'(direction, typeIR) : bool

def $nestable_parserapplymethod(direction, typeIR)
  = $nestable_parserapplymethod'(direction, $canon(typeIR))
def $nestable_parserapplymethod'(direction, STRING) = false
  -- if direction =/= NONE
def $nestable_parserapplymethod'(direction, INT) = false
  -- if direction =/= NONE
def $nestable_parserapplymethod'(direction, CONTROL `( _ )) = false
def $nestable_parserapplymethod'(direction, PACKAGE `< _ >) = false
def $nestable_parserapplymethod'(direction, TABLE _ `{ _ }) = false
def $nestable_parserapplymethod'(_, _) = true
  -- otherwise

rule FuncType_wf/parserapplymethod:
  bound |- PARSER_APPLY `( paramTypeIR* )
  -- ParamTypes_wf: bound |- paramTypeIR*
  -- if (name direction typeIR val? = paramTypeIR)* 
  -- if $nestable_externabstractmethod(direction, typeIR)*

dec $nestable_controlapplymethod(direction, typeIR) : bool
dec $nestable_controlapplymethod'(direction, typeIR) : bool

def $nestable_controlapplymethod(direction, typeIR)
  = $nestable_controlapplymethod'(direction, $canon(typeIR))
def $nestable_controlapplymethod'(direction, STRING) = false
  -- if direction =/= NONE
def $nestable_controlapplymethod'(direction, INT) = false
  -- if direction =/= NONE
def $nestable_controlapplymethod'(direction, PARSER `( _ )) = false
def $nestable_controlapplymethod'(direction, PACKAGE `< _ >) = false
def $nestable_controlapplymethod'(direction, TABLE _ `{ _ }) = false
def $nestable_controlapplymethod'(_, _) = true
  -- otherwise

rule FuncType_wf/controlapplymethod:
  bound |- CONTROL_APPLY `( paramTypeIR* )
  -- ParamTypes_wf: bound |- paramTypeIR*
  -- if (name direction typeIR val? = paramTypeIR)* 
  -- if $nestable_externabstractmethod(direction, typeIR)*

rule FuncType_wf/tableapplymethod:
  bound |- TABLE_APPLY -> (STRUCT_TABLE _)

;;
;;;; Well-formedness of function type definitions
;;

dec $definable_func_mono(funcTypeIR) : bool

def $definable_func_mono(ACTION `( _ )) = true
def $definable_func_mono(BUILTIN `( _ ) -> _) = true
def $definable_func_mono(PARSER_APPLY `( _ )) = true
def $definable_func_mono(CONTROL_APPLY `( _ )) = true
def $definable_func_mono(TABLE_APPLY -> _) = true
def $definable_func_mono(_) = false
  -- otherwise

rule FuncTypeDef_wf/mono:
  bound |- funcTypeIR
  -- if $definable_func_mono(funcTypeIR)
  -- FuncType_wf: bound |- funcTypeIR

dec $definable_func_poly(funcTypeIR) : bool

def $definable_func_poly(EXTERN_FUNC `( _ ) -> _) = true
def $definable_func_poly(FUNC `( _ ) -> _) = true
def $definable_func_poly(EXTERN_METHOD `( _ ) -> _) = true
def $definable_func_poly(EXTERN_ABSTRACT_METHOD `( _ ) -> _) = true
def $definable_func_poly(_) = false
  -- otherwise

rule FuncTypeDef_wf/poly:
  bound |- funcTypeIR `< name* `, name_hidden* >
  -- if $definable_func_poly(funcTypeIR)
  -- if $distinct_<name>(name* ++ name_hidden*)
  -- if bound_inner
      = $union_set<name>(bound, `{ name* ++ name_hidden* })
  -- FuncType_wf: bound_inner |- funcTypeIR

;;
;;;; Well-formedness of constructor paramter types
;;

rule CParamType_wf:
  bound consctxt |- name NONE typeIR val?
  -- Type_wf: bound |- typeIR

rule CParamTypes_wf:
  bound consctxt |- paramTypeIR*
  -- if (name _ _ _ = paramTypeIR)*
  -- if $distinct_<name>(name*)
  -- (CParamType_wf: bound consctxt |- paramTypeIR)*

;;
;;;; Well-formedness of constructor types
;;

dec $nestable_cons_extern(typeIR) : bool
dec $nestable'_cons_extern(typeIR) : bool

def $nestable_cons_extern(typeIR)
  = $nestable'_cons_extern($canon(typeIR))
def $nestable_cons_extern(PARSER `( _ )) = false
def $nestable'_cons_extern(CONTROL `( _ )) = false
def $nestable'_cons_extern(PACKAGE `< _ >) = false
def $nestable'_cons_extern(TABLE _ `{ _ }) = false
def $nestable'_cons_extern(_) = true
  -- otherwise

rule ConsType_wf/externtype:
  bound |- `( paramTypeIR* ) -> typeIR
  -- CParamTypes_wf: bound CONSCTXT |- paramTypeIR*
  -- Type_wf: bound |- typeIR
  -- if EXTERN _ _ = $canon(typeIR)
  -- if (_ _ typeIR_p _ = paramTypeIR)*
  -- if $nestable_cons_extern(typeIR_p)*

dec $nestable_cons_parser(typeIR) : bool
dec $nestable'_cons_parser(typeIR) : bool

def $nestable_cons_parser(typeIR)
  = $nestable'_cons_parser($canon(typeIR))
def $nestable'_cons_parser(CONTROL `( _ )) = false
def $nestable'_cons_parser(PACKAGE `< _ >) = false
def $nestable'_cons_parser(TABLE _ `{ _ }) = false
def $nestable'_cons_parser(_) = true
  -- otherwise

rule ConsType_wf/parsertype:
  bound |- `( paramTypeIR* ) -> typeIR
  -- CParamTypes_wf: bound CONSCTXT |- paramTypeIR*
  -- Type_wf: bound |- typeIR
  -- if PARSER `( _ ) = $canon(typeIR)
  -- if (_ _ typeIR_p _ = paramTypeIR)*
  -- if $nestable_cons_parser(typeIR_p)*

dec $nestable_cons_control(typeIR) : bool
dec $nestable'_cons_control(typeIR) : bool

def $nestable_cons_control(typeIR)
  = $nestable'_cons_control($canon(typeIR))
def $nestable'_cons_control(PARSER `( _ )) = false
def $nestable'_cons_control(PACKAGE `< _ >) = false
def $nestable'_cons_control(TABLE _ `{ _ }) = false
def $nestable'_cons_control(_) = true
  -- otherwise

rule ConsType_wf/externtype:
  bound |- `( paramTypeIR* ) -> typeIR
  -- CParamTypes_wf: bound CONSCTXT |- paramTypeIR*
  -- Type_wf: bound |- typeIR
  -- if CONTROL `( _ ) = $canon(typeIR)
  -- if (_ _ typeIR_p _ = paramTypeIR)*
  -- if $nestable_cons_control(typeIR_p)*

dec $nestable_cons_package(typeIR) : bool
dec $nestable'_cons_package(typeIR) : bool

def $nestable_cons_package(typeIR)
  = $nestable'_cons_package($canon(typeIR))
def $nestable'_cons_package(TABLE _ `{ _ }) = false
def $nestable'_cons_package(_) = true
  -- otherwise

rule ConsType_wf/packagetype:
  bound |- `( paramTypeIR* ) -> typeIR
  -- CParamTypes_wf: bound CONSCTXT |- paramTypeIR*
  -- Type_wf: bound |- typeIR
  -- if PACKAGE `< _ > = $canon(typeIR)
  -- if (_ _ typeIR_p _ = paramTypeIR)*
  -- if $nestable_cons_package(typeIR_p)*

;;
;;;; Well-formedness of constructor definitions
;;

dec $definable_cons(typeIR) : bool
dec $definable'_cons(typeIR) : bool

def $definable_cons(typeIR) = $definable'_cons($canon(typeIR))
def $definable'_cons(EXTERN _ _) = true
def $definable'_cons(PARSER `( _ )) = true
def $definable'_cons(CONTROL `( _ )) = true
def $definable'_cons(PACKAGE `< _ >) = true
def $definable'_cons(_) = false
  -- otherwise

rule ConsTypeDef_wf:
  bound |- consTypeIR `< name* `, name_hidden* >
  -- if `( _ ) -> typeIR_obj = consTypeIR
  -- if $definable_cons(typeIR_obj)
  -- if $distinct_<name>(name* ++ name_hidden*)
  -- if bound_inner
      = $union_set<name>(bound, `{ name* ++ name_hidden* })
  -- ConsType_wf: bound_inner |- consTypeIR
