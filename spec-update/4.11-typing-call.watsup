;;
;; Calling convention (single)
;;

rule Call_convention_ok_/in:
  p C actctxt |- (id IN typeIR_param val?) `@ (expressionIR, typeIR_arg)
               : expressionIR_cast
  -- if expressionIR_cast = $coerce_unary(expressionIR, typeIR_param)

rule Call_convention_ok_/out-inout:
  p C actctxt |- (id direction typeIR_param val?) `@ (expressionIR, typeIR_arg)
               : expressionIR
  -- if direction = OUT \/ direction = INOUT
  -- Type_alpha: typeIR_param ~~ typeIR_arg

rule Call_convention_ok_/none-action:
  p C ACT |- (id NONE typeIR_param val?) `@ (expressionIR, typeIR_arg)
           : expressionIR_cast
  -- if expressionIR_cast = $coerce_unary(expressionIR, typeIR_param)

rule Call_convention_ok_/none-not-action:
  p C NOACT |- (id NONE typeIR_param val?) `@ (expressionIR, typeIR_arg)
            : expressionIR
  -- if _ `(_ `; ctk) = expressionIR
  -- if ctk = LCTK \/ ctk = CTK
  -- Type_alpha: typeIR_param ~~ typeIR_arg

;;
;; Calling convention (multiple)
;;

rule Call_convention_ok:
  p C actctxt |- paramTypeIR* `@ (argumentIR, typeIR)*
               : argumentIR_cast*
  -- (Call_convention_ok_:
        p C actctxt |- paramTypeIR `@ (argumentIR, typeIR)
                     : argumentIR_cast)*

;;
;; Function and method typing
;;

rule Method_ok/table-apply:
  p C |- (prefixedNonTypeName `. APPLY) `< eps > `( eps )
       : prefixedNonTypeName `< `# eps > `( `# eps )
         `@ funcTypeIR
  ---- ;; check lvalue
  -- Expr_ok: p C |- prefixedNonTypeName
                   : prefixedNonTypeName `( typeIR_base `; _ )
  -- if TABLE _ `{ typeIR_table } = $canon(typeIR_base)
  ---- ;; create method type
  -- if funcTypeIR = TABLE_APPLY -> typeIR_table

;;
;; Call typing
;;

rule Call_ok/table-apply-method:
  p C |- (TABLE_APPLY -> typeIR_table)
          `< eps `# eps > `( eps `# eps )
       : typeIR_table `< eps > `( eps )
  -- FuncType_wf: $bound(p, C) |- TABLE_APPLY -> typeIR_table
