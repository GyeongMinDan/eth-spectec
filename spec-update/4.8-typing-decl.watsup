;;
;; Constant declaration
;;

rule Decl_ok/constantDeclaration:
  p C |- optAnnotations CONST typeRef name (`= expression) `;
       : C' (eps CONST typeIR name (`= expressionIR_cast) `;)
  -- Type_ok: p C |- typeRef : typeIR eps
  -- Expr_ok: p C |- expression : expressionIR
  -- if _ `( _ `; LCTK) = expressionIR
  -- if expressionIR_cast = $coerce_unary(expressionIR, typeIR)
  -- Eval_static: p C |- expressionIR_cast ~> val
  -- if C' = $add_var(p, C, name, typeIR NONE val LCTK)

;;
;; Declaration sequence
;;

rule Decls_ok/nil:
  p C |- eps : C eps

rule Decls_ok/cons:
  p C |- declaration_h :: declaration_t*
        : C'' (declarationIR_h :: declarationIR_t*)
  -- Decl_ok: p C |- declaration_h : C' declarationIR_h
  -- Decls_ok: p C' |- declaration_t* : C'' declarationIR_t*

;;
;; Program
;;

rule Prog_ok:
  |- declaration* : C' declarationIR*
  -- if C = $empty_context
  -- Decls_ok: GLOBAL C |- declaration* : C' declarationIR*
