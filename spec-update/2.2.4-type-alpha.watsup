;;
;; Relations for type alpha-equivalence
;;

relation Type_alpha:
  typeIR ~~ typeIR
  hint(input %0 %1)

relation FuncType_alpha:
  funcTypeIR ~~ funcTypeIR
  hint(input %0 %1)

relation FuncTypeDef_alpha:
  funcTypeDefIR ~~ funcTypeDefIR
  hint(input %0 %1)

;;
;;;; Alpha-equivalence of types
;;

;;; Base types

rule Type_alpha/basetype:
  baseTypeIR ~~ baseTypeIR

;;; Named types

rule Type_alpha/nametype:
  (`@ tid) ~~  (`@ tid)

rule Type_alpha/spectype-nominal:
  (polyTypeDefIR_a `< typeIR_a* >) ~~ (polyTypeDefIR_b `< typeIR_b* >)
  -- if typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a, typeIR_a*)
  -- if typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b, typeIR_b*)
  -- Type_alpha: typeIR_a_spec ~~ typeIR_b_spec
  -- if $is_nominal(typeIR_a_spec) /\ $is_nominal(typeIR_b_spec)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/spectype-structural:
  (polyTypeDefIR_a `< typeIR_a* >) ~~ (polyTypeDefIR_b `< typeIR_b* >)
  -- if typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a, typeIR_a*)
  -- if typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b, typeIR_b*)
  -- Type_alpha: typeIR_a_spec ~~ typeIR_b_spec
  -- if ~$is_nominal(typeIR_a_spec) /\ ~$is_nominal(typeIR_b_spec)

;;; Typedef types

rule Type_alpha/typedeftype-left:
  (TYPEDEF _ typeIR_a) ~~ typeIR_b
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/typedeftype-right:
  typeIR_a ~~ (TYPEDEF _ typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/newtype:
  (TYPE tid typeIR_a) ~~ (TYPE tid typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;; Data types

rule Type_alpha/listtype:
  (LIST `< typeIR_a >) ~~ (LIST `< typeIR_b >)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/tupletype:
  (TUPLE `< typeIR_a* >) ~~ (TUPLE `< typeIR_b* >)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/stacktype:
  (typeIR_a `[ n_s ]) ~~ (typeIR_b `[ n_s ])
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/headertype:
  (HEADER tid `{ (typeIR_f_a, id_f)* })
  ~~ (HEADER tid `{ (typeIR_f_b, id_f)* })
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/headeruniontype:
  (HEADER_UNION tid `{ (typeIR_f_a, id_f)* })
  ~~ (HEADER_UNION tid `{ (typeIR_f_b, id_f)* })
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/structtype:
  (STRUCT tid `{ (typeIR_f_a, id_f)* })
  ~~ (STRUCT tid `{ (typeIR_f_b, id_f)* })
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/enumtype:
  (ENUM tid `{ id_f* }) ~~ (ENUM tid `{ id_f* })

rule Type_alpha/serenumtype:
  (ENUM typeIR_a tid `{ (id_f, val_f)* })
  ~~ (ENUM typeIR_b tid `{ (id_f, val_f)* })
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;; Object types

rule Type_alpha/externtype:
  (EXTERN tid (`{ (fid_a `: funcTypeDefIR_a)* }))
  ~~ (EXTERN tid (`{ (fid_b `: funcTypeDefIR_b)* }))
  -- if $eq_set<fid>(`{ fid_a* }, `{ fid_b* })
  -- if (funcTypeDefIR_a'
        = $find_map<fid, funcTypeDefIR>(
            `{ (fid_a `: funcTypeDefIR_a)* },
            fid_a))*
  -- if (funcTypeDefIR_b'
        = $find_map<fid, funcTypeDefIR>(
            `{ (fid_b `: funcTypeDefIR_b)* },
            fid_a))*
  -- (FuncTypeDef_alpha: funcTypeDefIR_a' ~~ funcTypeDefIR_b')*

rule Type_alpha/parsertype:
  (PARSER `( paramTypeIR_a* )) ~~ (PARSER `( paramTypeIR_b* ))
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/controltype:
  (CONTROL `( paramTypeIR_a* )) ~~ (CONTROL `( paramTypeIR_b* ))
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/packagetype:
  (PACKAGE `< typeIR_a* >) ~~ (PACKAGE `< typeIR_b* >)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/tabletype:
  (TABLE tid `{ typeIR_a }) ~~ (TABLE tid `{ typeIR_b })
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;; Synthesized types

rule Type_alpha/defaulttype:
  DEFAULT ~~ DEFAULT

rule Type_alpha/sequencetype:
  (SEQ `< typeIR_a* >) ~~ (SEQ `< typeIR_b* >)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/sequencedefaulttype:
  (SEQ `< typeIR_a* `, `... >) ~~ (SEQ `< typeIR_b* `, `... >)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/recordtype:
  (RECORD `{ (typeIR_a, id)* }) ~~ (RECORD `{ (typeIR_b, id)* })
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/recorddefaulttype:
  (RECORD `{ (typeIR_a, id)* `, `... })
  ~~ (RECORD `{ (typeIR_b, id)* `, `... })
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/invalidtype:
  INVALID ~~ INVALID

rule Type_alpha/settype:
  (SET `< typeIR_a >) ~~ (SET `< typeIR_b >)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/parserstatetype:
  PARSERSTATE ~~ PARSERSTATE

rule Type_alpha/tableenumtype:
  (ENUM_TABLE tid `{ id_f* }) ~~ (ENUM_TABLE tid `{ id_f* })

rule Type_alpha/tablestructtype:
  (STRUCT_TABLE tid `{ (typeIR_f_a, id_f)* })
  ~~ (STRUCT_TABLE tid `{ (typeIR_f_b, id_f)* })
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/dontcaretype:
  `_ ~~ `_

;;
;;;; Alpha-equivalence of function types
;;

rule FuncType_alpha/actiontype:
  (ACTION `( paramTypeIR_a* )) ~~ (ACTION `( paramTypeIR_b* ))
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule FuncType_alpha/externfunctype:
  (EXTERN_FUNC `( paramTypeIR_a* ) -> typeIR_ret_a)
  ~~ (EXTERN_FUNC `( paramTypeIR_b* ) -> typeIR_ret_b)
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule FuncType_alpha/functype:
  (FUNC `( paramTypeIR_a* ) -> typeIR_ret_a)
  ~~ (FUNC `( paramTypeIR_b* ) -> typeIR_ret_b)
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule FuncType_alpha/builtinfunctype:
  (BUILTIN `( paramTypeIR_a* ) -> typeIR_ret_a)
  ~~ (BUILTIN `( paramTypeIR_b* ) -> typeIR_ret_b)
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule FuncType_alpha/externmethodtype:
  (EXTERN_METHOD `( paramTypeIR_a* ) -> typeIR_ret_a)
  ~~ (EXTERN_METHOD `( paramTypeIR_b* ) -> typeIR_ret_b)
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule FuncType_alpha/externabstractmethodtype:
  (EXTERN_ABSTRACT_METHOD `( paramTypeIR_a* ) -> typeIR_ret_a)
  ~~ (EXTERN_ABSTRACT_METHOD `( paramTypeIR_b* ) -> typeIR_ret_b)
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule FuncType_alpha/parserapplymethodtype:
  (PARSER_APPLY `( paramTypeIR_a* ))
  ~~ (PARSER_APPLY `( paramTypeIR_b* ))
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule FuncType_alpha/controlapplymethodtype:
  (CONTROL_APPLY `( paramTypeIR_a* ))
  ~~ (CONTROL_APPLY `( paramTypeIR_b* ))
  -- if (_ direction typeIR_a _ = paramTypeIR_a)*
  -- if (_ direction typeIR_b _ = paramTypeIR_b)*
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule FuncType_alpha/tableapplymethodtype:
  (TABLE_APPLY -> typeIR_a) ~~ (TABLE_APPLY -> typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;
;;;; Alpha-equivalence of function definitions
;;

rule FuncTypeDef_alpha/mono:
  funcTypeIR_a ~~ funcTypeIR_b
  -- FuncType_alpha: funcTypeIR_a ~~ funcTypeIR_b

rule FuncTypeDef_alpha/poly:
  (funcTypeIR_a `< tid_a* `, tid_hidden_a* >)
  ~~ (funcTypeIR_b `< tid_b* `, tid_hidden_b* >)
  -- if |tid_a*| = |tid_b*|
  -- if |tid_hidden_a*| = |tid_hidden_b*|
  ----
  -- if tid_fresh* = $fresh_tids($(|tid_a*| + |tid_hidden_a*|))
  ----
  -- if tid_a'* = tid_a* ++ tid_hidden_a*
  -- if theta_a = `{ (tid_a' `: (`@ tid_fresh))* }
  -- if funcTypeIR_a_subst = $subst_funcType(theta_a, funcTypeIR_a)
  ----
  -- if tid_b'* = tid_b* ++ tid_hidden_b*
  -- if theta_b = `{ (tid_b' `: (`@ tid_fresh))* }
  -- if funcTypeIR_b_subst = $subst_funcType(theta_b, funcTypeIR_b)
  ----
  -- FuncType_alpha: funcTypeIR_a_subst ~~ funcTypeIR_b_subst
