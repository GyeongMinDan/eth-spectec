;;
;; Static evaluation
;; of expressions that are local compile-time known
;;

relation Eval_static:
  cursor context |- expressionIR ~> val
  hint(input %0 %1 %2)

;;
;; Type evaluation and subtyping
;;

;;
;;;; Type evaluation
;;

relation Type_ok:
  cursor context |- typeOrVoid : typeIR tid*
  hint(input %0 %1 %2)

relation TypeArg_ok:
  cursor context |- typeArg : typeArgIR tid*
  hint(input %0 %1 %2)

relation TypeArgs_ok:
  cursor context |- typeArgList : typeArgListIR tid*
  hint(input %0 %1 %2)

dec $flatten_typeArgListIR(typeArgListIR) : typeArgIR*

def $flatten_typeArgListIR(`EMPTY) = eps
def $flatten_typeArgListIR(typeArgIR) = typeArgIR
def $flatten_typeArgListIR(typeArgListIR `, typeArgIR)
  = $flatten_typeArgListIR(typeArgListIR) ++ [ typeArgIR ]

;;
;;;; Subtyping, explicit and implicit
;;

relation Sub_expl: typeIR <: typeIR hint(input %0 %1)
relation Sub_expl_canon: typeIR <: typeIR hint(input %0 %1)
relation Sub_expl_canon_neq: typeIR <: typeIR hint(input %0 %1)

relation Sub_impl: typeIR <: typeIR hint(input %0 %1)
relation Sub_impl_canon: typeIR <: typeIR hint(input %0 %1)
relation Sub_impl_canon_neq: typeIR <: typeIR hint(input %0 %1)

;;
;; Expression, Statement, and Declaration typing
;;

;;
;;;; Expression typing
;;

relation Expr_ok:
  cursor context |- expression : expressionIR
  hint(input %0 %1 %2)

;;
;;;; Argument typing,
;;

relation Arg_ok:
  cursor context |- argument : typedArgumentIR
  hint(input %0 %1 %2)

relation Args_ok:
  cursor context |- argumentList : typedArgumentListIR
  hint(input %0 %1 %2)

dec $flatten_argumentListIR(argumentListIR) : argumentIR*

def $flatten_argumentListIR(`EMPTY) = eps
def $flatten_argumentListIR(argumentIR) = argumentIR
def $flatten_argumentListIR(argumentListIR `, argumentIR)
  = $flatten_argumentListIR(argumentListIR) ++ [ argumentIR ]

;; (TODO) Might want to define SpecTec lists
;; as left-associative instead of right-associative
dec $structure_argumentListIR(argumentIR*) : argumentListIR

def $structure_argumentListIR(eps) = `EMPTY
def $structure_argumentListIR(argumentIR_h :: argumentIR_t*)
  = $structure_argumentListIR(argumentIR_h''*) `, argumentIR_t'
  -- if argumentIR_t' :: argumentIR_h'*
      = $rev_<argumentIR*>(argumentIR_h :: argumentIR_t*)
  -- if argumentIR_h''* = $rev_<argumentIR*>(argumentIR_h'*)

dec $flatten_typedArgumentListIR(typedArgumentListIR) : typedArgumentIR*

def $flatten_typedArgumentListIR(`EMPTY) = eps
def $flatten_typedArgumentListIR(typedArgumentIR) = typedArgumentIR
def $flatten_typedArgumentListIR(typedArgumentListIR `, typedArgumentIR)
  = $flatten_typedArgumentListIR(typedArgumentListIR) ++ [ typedArgumentIR ]

;;
;;;; Statement typing
;;;; note that block typing depends on whether it is the initial block or not
;;

relation Lval_ok:
  cursor context |- lvalue : lvalueIR typeIR
  hint(input %0 %1 %2)

relation Stmt_ok:
  cursor context flow |- statementOrDeclaration
                       : context flow statementOrDeclarationIR
  hint(input %0 %1 %2 %3)

relation Stmts_ok:
  cursor context flow |- statOrDeclList
                       : context flow statOrDeclListIR
  hint(input %0 %1 %2 %3)

syntax blkctxt = INIT | NOINIT

relation Block_ok:
  context flow blkctxt |- blockStatement
                        : context flow blockStatementIR
  hint(input %0 %1 %2 %3)

relation ControlBody_ok:
  context |- controlBody : context flow controlBodyIR
  hint(input %0 %1)

;;
;;;; Parameter typing
;;;; inserts fresh type variables for parameters with don't care types
;;

relation Param_ok:
  cursor context |- parameter : parameterIR id*
  hint(input %0 %1 %2)

relation Params_ok:
  cursor context |- parameterList : parameterListIR id*
  hint(input %0 %1 %2)

dec $paramtypes(parameterListIR) : paramTypeIR*
dec $paramtype(parameterIR) : paramTypeIR

def $paramtypes(`EMPTY) = eps
def $paramtypes(parameterIR) = $paramtype(parameterIR)
def $paramtypes(parameterListIR `, parameterIR)
  = $paramtypes(parameterListIR) ++ [ $paramtype(parameterIR) ]

def $paramtype(_ direction typeIR name)
  = $id(name) direction typeIR eps
def $paramtype(_ direction typeIR name (`= val))
  = $id(name) direction typeIR val

relation ConsParam_ok:
  context |- parameter : parameterIR id*
  hint(input %0 %1)

relation ConsParams_ok:
  context |- optConstructorParameters
           : optConstructorParametersIR id*
  hint(input %0 %1)

dec $consParamtypes(optConstructorParametersIR) : consParamTypeIR*

def $consParamtypes(eps) = eps
def $consParamtypes(`( parameterListIR ))
  = $paramtypes(parameterListIR)

;;
;;;; Table typing
;;

relation Call_action_partial_ok:
  cursor context |- paramTypeIR* `@ typedArgumentListIR
                  : (paramTypeIR*, paramTypeIR*) `@ argumentListIR
  hint(input %0 %1 %2 %3)

relation TableAction_ok:
  context tblctx |- action : tblctx actionIR
  hint(input %0 %1 %2)

relation TableActions_ok:
  context tblctx |- actionList : tblctx actionListIR
  hint(input %0 %1 %2)

relation Call_action_default_ok:
  cursor context |- paramTypeIR* `@ argumentListIR `@ typedArgumentListIR
                  : argumentListIR
  hint(input %0 %1 %2 %3 %4)

relation TableDefaultAction_ok:
  context tblctx |- actionRef : actionRefIR
  hint(input %0 %1 %2)

relation TableProp_ok:
  context tblctx |- tableProperty : tblctx tablePropertyIR
  hint(input %0 %1 %2)

relation Table_ok:
  context tblctx |- tablePropertyList : tblctx tablePropertyListIR
  hint(input %0 %1 %2)

relation TableType_ok:
  context tblctx |- name : context typeIR
  hint(input %0 %1 %2)

;;
;;;; Declaration typing
;;

relation Decl_ok:
  cursor context |- declaration : context declarationIR
  hint(input %0 %1 %2)

relation Decls_ok:
  cursor context |- declaration* : context declarationIR*
  hint(input %0 %1 %2)

relation ControlLocalDecl_ok:
  context |- controlLocalDeclaration
           : context controlLocalDeclarationIR
  hint(input %0 %1)

relation ControlLocalDecls_ok:
  context |- controlLocalDeclarations
           : context controlLocalDeclarationsIR
  hint(input %0 %1)

;;
;;;; Program typing
;;

relation Prog_ok:
  context |- p4program : context p4programIR
  hint(input %0 %1)

relation Prog_ok_entry:
  |- p4program : context p4programIR
  hint(input %0)

;;
;; Call typing
;;

;;
;;;; Copy-in/out calling convention,
;;;; note that it depends on whether an action is being called or not
;;

syntax actctxt = ACT | NOACT

relation Call_convention_ok_:
  cursor context actctxt |- paramTypeIR `@ typedArgumentIR : argumentIR
  hint(input %0 %1 %2 %3 %4)

relation Call_convention_ok:
  cursor context actctxt |- paramTypeIR* `@ typedArgumentIR* : argumentIR*
  hint(input %0 %1 %2 %3 %4)

;;
;;;; Finds the type of a function/method,
;;;; inserts fresh type variables for parameters with don't care types,
;;;; and also identifies the ids of default arguments
;;

relation Func_ok:
  cursor context |- name typeArgIR* argumentIR* : funcTypeIR tid* id*
  hint(input %0 %1 %2 %3 %4)

relation Method_ok:
  cursor context |- lvalue `< typeArgListIR > `( typedArgumentListIR )
                  : lvalueIR `< `# tid* > `( `# id* ) `@ funcTypeIR
  hint(input %0 %1 %2 %3 %4)

;;
;;;; Checks that an action/function/method invocation is valid,
;;;; gets the return type,
;;;; infers the types of missing type arguments,
;;;; and inserts implicit casts for arguments, if necessary
;;

relation Call_site_ok:
  cursor context |- funcTypeIR : CALLSITE_OK
  hint(input %0 %1 %2)

relation Call_ok:
  cursor context |- funcTypeIR `< typeArgListIR `# tid* >
                               `( typedArgumentListIR `# id* )
                  : typeIR `< typeArgListIR > `( argumentListIR )
  hint(input %0 %1 %2 %3 %4 %5 %6)

;;
;;;; Finds the type of a constructor,
;;;; inserts fresh type variables for parameters with don't care types,
;;;; and also identifies the ids of default arguments
;;

relation Cons_ok:
  cursor context |- name `< typeArgIR* > `( argumentList )
                  : cid `< `# tid* > `( `# id* ) `@ consTypeIR
  hint(input %0 %1 %2 %3 %4)

;;
;;;; Checks that a constructor invocation is valid,
;;;; gets the constructed object type,
;;;; infers the types of missing type arguments,
;;;; and inserts implicit casts for arguments, if necessary
;;

relation Inst_site_ok:
  cursor context |- consTypeIR : INSTSITE_OK
  hint(input %0 %1 %2)

relation Inst_ok:
  cursor context |- consTypeIR `< typeArgListIR `# tid* >
                               `( argumentList `# id* )
                  : typeIR `< typeArgListIR > `( argumentListIR )
  hint(input %0 %1 %2 %3 %4 %5 %6)
