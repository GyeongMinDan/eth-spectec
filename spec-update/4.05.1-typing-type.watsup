;; syntax typeOrVoid =
;;   | typeRef
;;   | VOID

;;; syntax typeRef =
;;;   | baseType
;;;   | namedType
;;;   | headerStackType
;;;   | listType
;;;   | tupleType

;;;; syntax baseType =
;;;;   | BOOL
;;;;   | MATCH_KIND
;;;;   | ERROR
;;;;   | BIT
;;;;   | STRING
;;;;   | INT
;;;;   | BIT `< int >
;;;;   | INT `< int >
;;;;   | VARBIT `< int >
;;;;   | BIT `< `( expression ) >
;;;;   | INT `< `( expression ) >
;;;;   | VARBIT `< `( expression ) >

rule Type_ok/boolean:
  p C |- BOOL : BOOL eps

rule Type_ok/matchkind:
  p C |- MATCH_KIND : MATCH_KIND eps

rule Type_ok/error:
  p C |- ERROR : ERROR eps

rule Type_ok/bit:
  p C |- BIT : (BIT `< 1 >) eps

rule Type_ok/string:
  p C |- STRING : STRING eps

rule Type_ok/arbint:
  p C |- INT : INT eps

rule Type_ok/fixbit:
  p C |- BIT `< n > : (BIT `< n >) eps

rule Type_ok/fixbit-expr:
  p C |- BIT `< `( expression ) > : (BIT `< n >) eps
  -- Expr_ok: p C |- expression : expressionIR
  -- if _ `( _ `; LCTK) = expressionIR
  -- Eval_static: p C |- expressionIR ~> val
  -- if n = $number(val)

rule Type_ok/fixint:
  p C |- INT `< n > : (INT `< n >) eps

rule Type_ok/fixint-expr:
  p C |- INT `< `( expression ) > : (INT `< n >) eps
  -- Expr_ok: p C |- expression : expressionIR
  -- if _ `( _ `; LCTK) = expressionIR
  -- Eval_static: p C |- expressionIR ~> val
  -- if n = $number(val)

rule Type_ok/varbit:
  p C |- VARBIT `< n > : (VARBIT `< n >) eps

rule Type_ok/varbit-expr:
  p C |- VARBIT `< `( expression ) > : (VARBIT `< n >) eps
  -- Expr_ok: p C |- expression : expressionIR
  -- if _ `( _ `; LCTK) = expressionIR
  -- Eval_static: p C |- expressionIR ~> val
  -- if n = $number(val)

;;;; syntax namedType =
;;;;   | prefixedTypeName
;;;;   | specializedType

rule Type_ok/typeName-mono:
  p C |- typeName : typeIR eps
  -- if tid = $tid(typeName)
  -- if typeIR = $find_type(p, C, tid)

rule Type_ok/typeName-poly:
  p C |- typeName : (polyTypeDefIR `< eps >) eps
  -- if tid = $tid(typeName)
  -- if polyTypeDefIR = $find_type(p, C, tid)

rule Type_ok/dotPrefix-typeName-mono:
  p C |- `.. typeName : typeIR eps
  -- if tid = $tid(typeName)
  -- if typeIR = $find_type(GLOBAL, C, tid)

rule Type_ok/dotPrefix-typeName-poly:
  p C |- `.. typeName : (polyTypeDefIR `< eps >) eps
  -- if tid = $tid(typeName)
  -- if polyTypeDefIR = $find_type(GLOBAL, C, tid)

;;;;; syntax specializedType = prefixedTypeName `< typeArgList >

rule Type_ok/specializedType-typeName-nil:
  p C |- typeName `< `EMPTY > : typeIR eps
  -- if tid = $tid(typeName)
  -- if typeIR = $find_type(p, C, tid)

rule Type_ok/specializedType-dotPrefix-typeName-nil:
  p C |- (`.. typeName) `< `EMPTY > : typeIR eps
  -- if tid = $tid(typeName)
  -- if typeIR = $find_type(GLOBAL, C, tid)

;; rule Type_ok/specializedType-typeName-typeArg:
;;   p C |- typeName `< typeArg* > : (polyTypeDefIR `< typeIR_a* >) tid_fresh*
;;   -- if tid = $tid(typeName)
;;   -- if polyTypeDefIR = $find_type(p, C, tid)
;;   -- if typeIR `< tid_def* `, tid_hidden* > = polyTypeDefIR
;;   -- (TypeArg_ok: p C |- typeArg : typeIR_a tid_fresh_a*)*
;;   -- if tid_fresh* = $concat_<tid>(tid_fresh_a**)

;;;; syntax headerStackType =
;;;;   | typeName `[ expression ]
;;;;   | specializedType `[ expression ]

rule Type_ok/headerStackType-typeName-expression:
  p C |- typeName `[ expression ] : (polyTypeDefIR_stack `< typeIR_base >) eps
  -- Type_ok: p C |- typeName : typeIR_base eps
  -- Expr_ok: p C |- expression : expressionIR
  -- if _ `( _ `; LCTK) = expressionIR
  -- Eval_static: p C |- expressionIR ~> val
  -- if n_size = $number(val)
  -- if typeIR_stack = (`@ "T") `[ n_size ]
  -- if polyTypeDefIR_stack = typeIR_stack `< "T" `, eps >

rule Type_ok/headerStackType-specializedType-expression:
  p C |- specializedType `[ expression ] : (polyTypeDefIR_stack `< typeIR_base >) tid_fresh*
  -- Type_ok: p C |- specializedType : typeIR_base tid_fresh*
  -- Expr_ok: p C |- expression : expressionIR
  -- if _ `( _ `; LCTK) = expressionIR
  -- Eval_static: p C |- expressionIR ~> val
  -- if n_size = $number(val)
  -- if typeIR_stack = (`@ "T") `[ n_size ]
  -- if polyTypeDefIR_stack = typeIR_stack `< "T" `, eps >

;;;; syntax listType = LIST `< typeArg >

rule Type_ok/listType:
  p C |- LIST `< typeArg > : (polyTypeDefIR_list `< typeIR_arg >) tid_fresh*
  -- TypeArg_ok: p C |- typeArg : typeIR_arg tid_fresh*
  -- if typeIR_list = LIST `< (`@ "T") >
  -- if polyTypeDefIR_list = typeIR_list `< "T" `, eps >

;;;; syntax tupleType = TUPLE `< typeArgList >

rule Type_ok/tupleType:
  p C |- TUPLE `< typeArgList > : (polyTypeDefIR_tuple `< typeIR_arg* >) tid_fresh*
  ---- ;; check type arguments
  -- TypeArgs_ok: p C |- typeArgList : typeArgListIR tid_fresh*
  ---- ;; create fresh type parameters
  -- if typeIR_arg* = $flatten_typeArgListIR(typeArgListIR)
  -- if i_idx* = $init_(|typeIR_arg*|)
  -- if (tid_tparam = "T" ++ $int_to_text(i_idx))* 
  ---- ;; create tuple type definition, as specialized type definition
  -- if typeIR_tuple = TUPLE `< (`@ tid_tparam)* >
  -- if polyTypeDefIR_tuple = typeIR_tuple `< tid_tparam* `, eps >

;;; VOID

rule Type_ok/void:
  p C |- VOID : VOID eps
