;;
;; syntax declaration =
;;

;;; | constantDeclaration
;;; syntax constantDeclaration =
;;;   optAnnotations CONST typeRef name initializer `;

rule Decl_ok/constantDeclaration:
  p C |- optAnnotations CONST typeRef name (`= expression) `;
       : C' (eps CONST typeIR name (`= val_init) `;)
  -- Type_ok: p C |- typeRef : typeIR eps
  -- Expr_ok: p C |- expression : expressionIR
  -- if _ `( _ `; LCTK) = expressionIR
  -- if expressionIR_cast = $coerce_unary(expressionIR, typeIR)
  -- Eval_static: p C |- expressionIR_cast ~> val_init
  -- if C' = $add_var(p, C, name, typeIR NONE val_init LCTK)

;;; | errorDeclaration
;;; syntax errorDeclaration = ERROR `{ identifierList }

;;; | matchKindDeclaration
;;; syntax matchKindDeclaration =
;;;   MATCH_KIND `{ identifierList optTrailingComma }

;;; | externDeclaration
;;; syntax externDeclaration =
;;;   | optAnnotations EXTERN nonTypeName optTypeParameters `{ methodPrototypes }
;;;   | optAnnotations EXTERN functionPrototype `;

;;; | instantiation
;;; syntax instantiation =
;;;   | optAnnotations typeRef `( argumentList ) name `;
;;;   | optAnnotations typeRef `( argumentList ) name objInitializer `;

;;; | functionDeclaration
;;; syntax functionDeclaration =
;;;   optAnnotations functionPrototype blockStatement

;;; | actionDeclaration
;;; syntax actionDeclaration =
;;;   optAnnotations ACTION name `( parameterList ) blockStatement

rule Decl_ok/actionDeclaration:
  p C_0 |- optAnnotations ACTION name `( parameterList ) blockStatement
         : C_2 actionDeclarationIR
  ---- ;; check parameters
  -- Params_ok: LOCAL C_0 |- parameterList : parameterListIR eps
  -- if paramTypeIR* = $paramtypes(parameterListIR)
  -- if C_1 = $add_params(LOCAL, C_0, paramTypeIR*)
  ---- ;; check body
  -- Block_ok: C_1 CONT INIT |- blockStatement : _ _ blockStatementIR
  ---- ;; create action
  -- if funcName = $funcName(name, parameterList)
  -- if funcTypeIR = ACTION `( paramTypeIR* )
  -- FuncTypeDef_wf: $bound(GLOBAL, C_0) |- funcTypeIR
  -- if C_2 = $add_func(p, C_0, funcName, funcTypeIR)
  ---- ;; assemble IR
  -- if actionDeclarationIR
      = ACTION name `( parameterListIR ) blockStatementIR

;;; | parserDeclaration
;;; syntax parserDeclaration =
;;;   parserTypeDeclaration optConstructorParameters `{ parserLocalElements parserStates }

;;; | controlDeclaration 
;;; syntax controlDeclaration =
;;;   controlTypeDeclaration optConstructorParameters `{ controlLocalDeclarations APPLY controlBody }

rule ControlLocalDecl_ok/constantDeclaration:
  C |- constantDeclaration : C' constantDeclarationIR
  -- Decl_ok: BLOCK C |- constantDeclaration
                       : C' constantDeclarationIR

rule ControlLocalDecls_ok/nil:
  C |- eps : C eps

rule ControlLocalDecls_ok/cons:
  C |- constantDeclaration_h :: constantDeclaration_t*
    : C'' (constantDeclarationIR_h :: constantDeclarationIR_t*)
  -- ControlLocalDecl_ok: C |- constantDeclaration_h
                          : C' constantDeclarationIR_h
  -- ControlLocalDecls_ok: C' |- constantDeclaration_t*
                          : C'' constantDeclarationIR_t*

rule Decl_ok/controlDeclaration:
  GLOBAL C_0 |- controlTypeDeclaration optConstructorParameters
                `{ controlLocalDeclarations APPLY controlBody }
              : C_5 controlDeclarationIR
  ---- ;; unpack control type declaration
  -- if optAnnotations CONTROL name optTypeParameters `( parameterList )
        = controlTypeDeclaration
  ---- ;; check type parameters
  -- if optTypeParameters = eps
  ---- ;; check constructor parameters
  -- ConsParams_ok: C_0 |- optConstructorParameters
                        : optConstructorParametersIR eps
  -- if consParamTypeIR*
      = $consParamtypes(optConstructorParametersIR)
  -- if C_1 = $add_consParams(C_0, consParamTypeIR*)
  ---- ;; check parameters to apply method
  -- Params_ok: LOCAL C_1 |- parameterList : parameterListIR eps
  -- if paramTypeIR* = $paramtypes(parameterListIR)
  -- if funcTypeIR = CONTROL_APPLY `( paramTypeIR* )
  -- FuncTypeDef_wf: $bound(GLOBAL, C_0) |- funcTypeIR
  -- if C_2 = $add_params(BLOCK, C_1, paramTypeIR*)
  ---- ;; check control local declarations
  -- ControlLocalDecls_ok: C_2 |- controlLocalDeclarations
                                : C_3 controlLocalDeclarationsIR
  ---- ;; check control apply method
  -- ControlBody_ok: C_3 |- controlBody : C_4 f controlBodyIR
  ---- ;; create control object constructor
  -- if consName = $consName(name, optConstructorParameters)
  -- if typeIR_control = CONTROL `( paramTypeIR* )
  -- if polyTypeDefIR_control = typeIR_control `< eps `, eps >
  -- if typeIR_spec = polyTypeDefIR_control `< eps >
  -- if consTypeIR = `( consParamTypeIR* ) -> typeIR_spec
  -- if consTypeDefIR = consTypeIR `< eps `, eps >
  -- ConsTypeDef_wf: $bound(GLOBAL, C_0) |- consTypeDefIR
  -- if C_5 = $add_cons(C_0, consName, consTypeDefIR)
  ---- ;; assemble IR
  -- if controlTypeDeclarationIR = eps CONTROL name eps `( parameterListIR )
  -- if controlDeclarationIR
      = controlTypeDeclarationIR optConstructorParametersIR
        `{ controlLocalDeclarationsIR APPLY controlBodyIR }

;;; | typeDeclaration

;;
;; declaration*
;;

rule Decls_ok/nil:
  p C |- eps : C eps

rule Decls_ok/cons:
  p C |- declaration_h :: declaration_t*
        : C'' (declarationIR_h :: declarationIR_t*)
  -- Decl_ok: p C |- declaration_h : C' declarationIR_h
  -- Decls_ok: p C' |- declaration_t* : C'' declarationIR_t*

;;
;; syntax p4program = declaration*
;;

rule Prog_ok:
  |- declaration* : C' declarationIR*
  -- if C = $empty_context
  -- Decls_ok: GLOBAL C |- declaration* : C' declarationIR*
