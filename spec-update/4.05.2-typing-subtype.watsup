;;
;; Explicit subtyping
;;

;;
;; Implicit subtyping
;;

rule Sub_impl:
  typeIR_a <: typeIR_b
  -- if typeIR_a_canon = $canon(typeIR_a)
  -- if typeIR_b_canon = $canon(typeIR_b)
  -- Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon

rule Sub_impl_canon/eq:
  typeIR_a <: typeIR_b
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Sub_impl_canon/neq:
  typeIR_a <: typeIR_b
  -- Type_alpha:/ typeIR_a ~~ typeIR_b
  -- Sub_impl_canon_neq: typeIR_a <: typeIR_b

rule Sub_impl_canon_neq/arbint-fixbit:
  INT <: BIT `< _ >

rule Sub_impl_canon_neq/arbint-fixint:
  INT <: INT `< _ >

;;
;; Serializable enum reduction
;;

dec $reduce_serenum_unary(
    expressionIR,
    def $check(typeIR) : bool
  )
  : expressionIR
dec $reduce_serenum_binary(
    expressionIR,
    expressionIR,
    def $check(typeIR, typeIR) : bool
  )
  : (expressionIR, expressionIR)

;;
;; Coercions
;;

dec $coerce_unary(expressionIR, typeIR) : expressionIR?

def $coerce_unary(expressionIR, typeIR_to) = expressionIR
  -- if _ `( typeIR `; _ ) = expressionIR
  -- Type_alpha: typeIR ~~ typeIR_to

def $coerce_unary(expressionIR, typeIR_to) = expressionIR_cast
  -- if _ `( typeIR `; ctk ) = expressionIR
  -- Type_alpha:/ typeIR ~~ typeIR_to
  -- Sub_impl: typeIR <: typeIR_to
  -- if expressionIR_cast
      = (`(typeIR_to) expressionIR) `( typeIR_to `; ctk )

dec $coerce_binary(expressionIR, expressionIR) : (expressionIR, expressionIR)
