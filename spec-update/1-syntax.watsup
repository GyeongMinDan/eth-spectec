;;
;; Misc
;;

;; (TODO) comma parsing
syntax trailingComma = `, PHTM_0

syntax optTrailingComma = trailingComma?

syntax const = CONST

syntax optCONST = const?

;;
;; Numbers
;;

syntax number =
  ;; (TODO) extension of plaintyp
  | int PHTM_1
  | nat W int
  | nat S int

;;
;; Strings
;;

;; (TODO) extension of plaintyp
syntax stringLiteral = text PHTM_2

;;
;; Names
;;

syntax dotPrefix = `.

;; (TODO) extension of plaintyp
syntax identifier = `$ text
;; (TODO) extension of plaintyp
syntax typeIdentifier = `@ text

syntax nonTypeName =
  | identifier
  | APPLY | KEY | ACTIONS | STATE
  | ENTRIES | TYPE | PRIORITY

syntax prefixedNonTypeName =
  | nonTypeName
  | dotPrefix nonTypeName

syntax nonTableKwName = nonTypeName

syntax prefixedType =
  | typeIdentifier
  | dotPrefix typeIdentifier

syntax typeName = prefixedType

syntax name =
  | nonTypeName
  | LIST
  | typeIdentifier

;; (TODO) Add comma separator as hint?
syntax identifierList = name*

syntax member = name

;;
;; Directions
;;

syntax direction = IN | OUT | INOUT | NONE

;;
;; Types
;;

;; Forward declarations

syntax typeRef, typeArg, typeArgumentList
syntax expression, initializer
syntax derivedTypeDeclaration
syntax optAnnotations

;;
;;;; Base types
;;

syntax baseType =
  | BOOL
  | MATCH_KIND
  | ERROR
  | BIT
  | STRING
  | INT
  | BIT `< int >
  | INT `< int >
  | VARBIT `< int >
  | BIT `< `( expression ) >
  | INT `< `( expression ) >
  | VARBIT `< `( expression ) >

;;
;;;; Named types
;;

syntax specializedType = typeName `< typeArgumentList >

syntax namedType =
  | typeName
  | specializedType

;;
;;;; Header stack types
;;

syntax headerStackType =
  | typeName `[ expression ]
  ;; (TODO) disambiguate with (typeName `[ expression ])
  | specializedType `[ expression ] PHTM_16

;;
;;;; List types
;;

syntax listType = LIST `< typeArg >

;;
;;;; Tuple types
;;

syntax tupleType = TUPLE `< typeArgumentList >

;;
;;;; Type references
;;

syntax typeRef =
  | baseType
  | namedType
  | headerStackType
  | listType
  | tupleType

syntax typeOrVoid =
  | typeRef
  | VOID
;; (TODO) Why is this necessary? typeRef already includes identifier
;;  | identifier

;;
;; Type parameters
;;

syntax typeParameterList = name*

syntax typeParameters = `< typeParameterList >

syntax optTypeParameters = typeParameters?

;;
;; Parameters
;;

syntax parameter =
  | optAnnotations direction typeRef name
  | optAnnotations direction typeRef name initializer

;; (TODO) Add comma separator as hint?
syntax parameterList = parameter*

;;
;; Constructor parameters
;;

syntax constructorParameters = `( parameterList )

syntax optConstructorParameters = constructorParameters?

;;
;; Expressions
;;

;; Forward declarations

syntax realTypeArgumentList
syntax argumentList
syntax expressionList, kvList

syntax nonBraceExpression =
  | number
  | stringLiteral
  | TRUE
  | FALSE
  | THIS
  | nonBraceExpression `[ expression ]
  | nonBraceExpression `[ expression `: expression ]
  | `( expression )
  | `! expression
  | `~ expression
  | `- expression
  | `+ expression
  | typeName `. member
  | ERROR `. member
  ;; (TODO) disambiguate with (typeName `. member)
  | nonBraceExpression `. member PHTM_5
  | nonBraceExpression `* expression
  | nonBraceExpression `/ expression
  | nonBraceExpression `% expression
  | nonBraceExpression `+ expression
  | nonBraceExpression `- expression
  | nonBraceExpression `|+| expression
  | nonBraceExpression `|-| expression
  | nonBraceExpression `<< expression
  | nonBraceExpression `>> expression
  | nonBraceExpression `<= expression
  | nonBraceExpression `>= expression
  | nonBraceExpression ``< expression
  | nonBraceExpression ``> expression
  | nonBraceExpression `!= expression
  | nonBraceExpression `== expression
  | nonBraceExpression `& expression
  | nonBraceExpression `^ expression
  | nonBraceExpression `| expression
  | nonBraceExpression `++ expression
  | nonBraceExpression `&& expression
  | nonBraceExpression `|| expression
  | nonBraceExpression `? expression `: expression
  | nonBraceExpression `< realTypeArgumentList > `( argumentList )
  | nonBraceExpression `( argumentList )
  ;; (TODO) disambiguate with (nonBraceExpression `( argumentList ))
  | namedType `( argumentList ) PHTM_6
  | `( typeRef ) expression

syntax expression =
  | number
  | `...
  | stringLiteral
  | TRUE
  | FALSE
  | THIS
  | prefixedNonTypeName
  | expression `[ expression ]
  | expression `[ expression `: expression ]
  | `{ expressionList optTrailingComma }
  | `{#}
  ;; (TODO) disambiguate with (`{ expressionList optTrailingComma })
  | `{ kvList optTrailingComma } PHTM_7
  | `{ kvList `, `... optTrailingComma }
  | `( expression )
  | `! expression
  | `~ expression
  | `- expression
  | `+ expression
  | typeName `. member
  | ERROR `. member
  ;; (TODO) disambiguate with (typeName `. member)
  | expression `. member PHTM_8
  | expression `* expression
  | expression `/ expression
  | expression `% expression
  | expression `+ expression
  | expression `- expression
  | expression `|+| expression
  | expression `|-| expression
  | expression `<< expression
  | expression `>> expression
  | expression `<= expression
  | expression `>= expression
  | expression ``< expression
  | expression ``> expression
  | expression `!= expression
  | expression `== expression
  | expression `& expression
  | expression `^ expression
  | expression `| expression
  | expression `++ expression
  | expression `&& expression
  | expression `|| expression
  | expression `? expression `: expression
  | expression `< realTypeArgumentList > `( argumentList )
  | expression `( argumentList )
  ;; (TODO) disambiguate with (expression `( argumentList ))
  | namedType `( argumentList ) PHTM_9
  | `( typeRef ) expression

;; (TODO) Add comma separator as hint?
syntax expressionList = expression*

;;
;; Keyset expressions
;;

syntax simpleKeysetExpression =
  | expression
  | expression `&&& expression
  | expression `.. expression
  | DEFAULT
  | `_

syntax reducedSimpleKeysetExpression =
  | expression `&&& expression
  | expression `.. expression
  | DEFAULT
  | `_ 

;; (TODO) Add comma separator as hint?
syntax simpleExpressionList = simpleKeysetExpression*

syntax tupleKeysetExpression =
  | `( simpleKeysetExpression `, simpleExpressionList )
  ;; (TODO) disambiguate with `( expression )
  | `( reducedSimpleKeysetExpression ) PHTM_19

syntax keysetExpression =
  | tupleKeysetExpression
  | simpleKeysetExpression

;;
;; Expression key-value pairs
;;

syntax kvPair = name `= expression

;; (TODO) Add comma separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax kvList = kvPair*

;;
;; Type arguments
;;

syntax realTypeArg =
  | typeRef
  | VOID
  | `_

;; (TODO) Add comma separator as hint?
syntax realTypeArgumentList = realTypeArg*

syntax typeArg =
  | typeRef
  | nonTypeName
  | VOID
  | `_

;; (TODO) Add comma separator as hint?
syntax typeArgumentList = typeArg*

;;
;; Arguments
;;

syntax argument =
  | expression
  | name `= expression
  | `_
  | name `= `_

;; (TODO) Add comma separator as hint?
syntax argumentList = argument*

;;
;; L-values
;;

syntax lvalue =
  | prefixedNonTypeName
  | THIS
  | lvalue `. member
  | lvalue `[ expression ]
  | lvalue `[ expression `: expression ]
  | `( lvalue )

;;
;; Statements and declarations
;;

;; Forward declarations

syntax statement, parserStatements, statOrDeclList
syntax objDeclarations
syntax annotations

;;
;;;; Variable and constant declarations
;;

syntax initializer = `= expression

syntax optInitializer = initializer?

syntax variableDeclarationWithoutSemicolon =
  optAnnotations typeRef name optInitializer

syntax variableDeclaration =
  variableDeclarationWithoutSemicolon `;

syntax constantDeclaration =
  optAnnotations CONST typeRef name initializer `;

;;
;;;; Assignment and method call statements
;;

syntax assignmentOrMethodCallStatementWithoutSemicolon =
  | lvalue `( argumentList )
  | lvalue `< typeArgumentList > `( argumentList )
  | lvalue `= expression
  | lvalue `+= expression
  | lvalue `|+|= expression
  | lvalue `-= expression
  | lvalue `|-|= expression
  | lvalue `*= expression
  | lvalue `/= expression
  | lvalue `%= expression
  | lvalue `<<= expression
  | lvalue `>>= expression
  | lvalue `&= expression
  | lvalue `^= expression
  | lvalue `|= expression

syntax assignmentOrMethodCallStatement =
  assignmentOrMethodCallStatementWithoutSemicolon `; PHTM_11

;;
;;;; Direct application statements
;;

syntax directApplication =
  | namedType `. APPLY `( argumentList ) `;

;;
;;;; Conditional statements
;;

syntax conditionalStatement =
  | IF `( expression ) statement
  | IF `( expression ) statement ELSE statement

;;
;;;; Empty statements
;;

syntax emptyStatement = `;

;;
;;;; Block statements
;;

syntax blockStatement = optAnnotations `{ statOrDeclList }

;;
;;;; Return statements
;;

syntax returnStatement =
  | RETURN `;
  | RETURN expression `;

;;
;;;; Break statements
;;

syntax breakStatement = BREAK `;

;;
;;;; Continue statements
;;

syntax continueStatement = CONTINUE `;

;;
;;;; Exit statements
;;

syntax exitStatement = EXIT `;

;;
;;;; Switch statements
;;

syntax switchLabel =
  | DEFAULT
  | nonBraceExpression

syntax switchCase =
  | switchLabel `: blockStatement
  | switchLabel `: 

;; (TODO) Add whitespace separator as hint?
syntax switchCases = switchCase*

syntax switchStatement = SWITCH `( expression ) `{ switchCases }

;;
;;;; For statements
;;

syntax declOrAssignmentOrMethodCallStatement =
  | variableDeclarationWithoutSemicolon
  | assignmentOrMethodCallStatementWithoutSemicolon

;; (TODO) Add comma separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax forInitStatementNonEmpty = declOrAssignmentOrMethodCallStatement*

;; (TODO) Add comma separator as hint?
syntax forInitStatements = declOrAssignmentOrMethodCallStatement*

;; (TODO) Add comma separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax forUpdateStatementsNonEmpty = assignmentOrMethodCallStatementWithoutSemicolon*

;; (TODO) Add comma separator as hint?
syntax forUpdateStatements = assignmentOrMethodCallStatementWithoutSemicolon*

syntax forCollectionExpr =
  | expression
  | expression `.. expression

syntax forStatement =
  | optAnnotations FOR `( forInitStatements `; expression `; forUpdateStatements ) statement
  | optAnnotations FOR `( typeRef name IN forCollectionExpr ) statement
  | optAnnotations FOR `( annotations typeRef name IN forCollectionExpr ) statement

;;
;;;; Statements
;;

syntax statement =
  | assignmentOrMethodCallStatement
  | directApplication
  | conditionalStatement
  | emptyStatement
  | blockStatement
  | returnStatement
  | breakStatement
  | continueStatement
  | exitStatement
  | switchStatement
  | forStatement

syntax statementOrDeclaration =
  | variableDeclaration
  | constantDeclaration
  | statement

;; (TODO) Add whitespace separator as hint?
syntax statOrDeclList = statementOrDeclaration*

;;
;;;; Error and match kind declarations
;;

syntax matchKindDeclaration =
  MATCH_KIND `{ identifierList optTrailingComma }

syntax errorDeclaration = ERROR `{ identifierList }

;;
;;;; Extern declarations
;;

syntax functionPrototype =
  typeOrVoid name optTypeParameters `( parameterList )

syntax methodPrototype =
  | optAnnotations functionPrototype `;
  | optAnnotations ABSTRACT functionPrototype `;
  | optAnnotations typeIdentifier `( parameterList ) `;

;; (TODO) Add whitespace separator as hint?
syntax methodPrototypes = methodPrototype*

syntax externDeclaration =
  | optAnnotations EXTERN nonTypeName optTypeParameters `{ methodPrototypes }
  | optAnnotations EXTERN functionPrototype `;

;;
;;;; Function declarations
;;

syntax functionDeclaration =
  optAnnotations functionPrototype blockStatement

;;
;;;; Instantiations
;;

syntax objInitializer = `= `{ objDeclarations }

syntax instantiation =
  | optAnnotations typeRef `( argumentList ) name `;
  | optAnnotations typeRef `( argumentList ) name objInitializer `;

syntax objDeclaration =
  | functionDeclaration
  | instantiation

;; (TODO) Add whitespace separator as hint?
syntax objDeclarations = objDeclaration*

;;
;;;; Action declarations
;;

syntax actionDeclaration =
  optAnnotations ACTION name `( parameterList ) blockStatement

;;
;;;; Table declarations
;;

;;
;;;;;; Table key property 
;;

syntax keyElement =
  expression `: name optAnnotations `;

;; (TODO) Add whitespace separator as hint?
syntax keyElementList = keyElement*

;;
;;;;;; Table actions property
;;

syntax actionRef =
  | prefixedNonTypeName
  | prefixedNonTypeName `( argumentList )

syntax action = optAnnotations actionRef `;

;; (TODO) Add whitespace separator as hint?
syntax actionList = action*

;;
;;;;;; Table entry property
;;

syntax entryPriority =
  | PRIORITY `= number `: 
  | PRIORITY `= `( expression ) `:

syntax entry =
  | optCONST entryPriority keysetExpression `: actionRef optAnnotations`; 
  | optCONST keysetExpression `: actionList optAnnotations `; 

syntax entriesList = entry*

;;
;;;;;; Table properties
;;

syntax tableProperty =
  | KEY `= `{ keyElementList }
  | ACTIONS `= `{ actionList }
  | optAnnotations optCONST ENTRIES `= `{ entriesList }
  | optAnnotations optCONST nonTableKwName initializer `;

;; (TODO) Add whitespace separator as hint?
syntax tablePropertyList = tableProperty*

syntax tableDeclaration =
  optAnnotations TABLE name `{ tablePropertyList }

;;
;;;; Control and control type declarations
;;

syntax controlBody = blockStatement

syntax controlLocalDeclaration =
  | constantDeclaration
  | actionDeclaration
  | tableDeclaration
  | instantiation
  | variableDeclaration

;; (TODO) Add whitespace separator as hint?
syntax controlLocalDeclarations = controlLocalDeclaration*

syntax controlTypeDeclaration =
  optAnnotations CONTROL name optTypeParameters `( parameterList )

syntax controlDeclaration =
  controlTypeDeclaration optConstructorParameters `{ controlLocalDeclarations APPLY controlBody }

;;
;;;; Value set declarations
;;

syntax valueSetDeclaration =
  | optAnnotations VALUESET `< baseType > `( expression ) name `; 
  ;; (TODO) disambiguate with (optAnnotations VALUESET `< baseType > `( expression ) name `;)
  | optAnnotations VALUESET `< tupleType > `( expression ) name `; PHTM_17
  ;; (TODO) disambiguate with (optAnnotations VALUESET `< baseType > `( expression ) name `;)
  | optAnnotations VALUESET `< typeName > `( expression ) name `; PHTM_18

;;
;;;; Select expressions
;;

syntax selectCase = keysetExpression `: name `;

;; (TODO) Add whitespace separator as hint?
syntax selectCaseList = selectCase*

syntax selectExpression = SELECT `( expressionList ) `{ selectCaseList }

;;
;;;; Transition statements
;;

syntax stateExpression =
  | name `;
  | selectExpression

syntax transitionStatement = TRANSITION stateExpression

;;
;;;; Parser and parser type declarations
;;

syntax parserBlockStatement = optAnnotations `{ parserStatements }

syntax parserStatement =
  | assignmentOrMethodCallStatement
  | directApplication
  | emptyStatement
  | variableDeclaration
  | constantDeclaration
  | parserBlockStatement
  | conditionalStatement

;; (TODO) Add whitespace separator as hint?
syntax parserStatements = parserStatement*

syntax parserState =
  optAnnotations STATE name `{ parserStatements transitionStatement }

;; (TODO) Add whitespace separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax parserStates = parserState*

syntax parserTypeDeclaration =
  optAnnotations PARSER name optTypeParameters `( parameterList )

syntax parserLocalElement =
  | constantDeclaration
  | variableDeclaration
  | instantiation
  | valueSetDeclaration

;; (TODO) Add whitespace separator as hint?
syntax parserLocalElements = parserLocalElement*

syntax parserDeclaration =
  parserTypeDeclaration optConstructorParameters `{ parserLocalElements parserStates }

;;
;;;; Package type declaration
;;

syntax packageTypeDeclaration =
  optAnnotations PACKAGE name optTypeParameters `( parameterList )

;;
;;;; Enum type declaration
;;

syntax specifiedIdentifier = name initializer

;; (TODO) Add comma separator as hint?
syntax specifiedIdentifierList = specifiedIdentifier*

syntax enumDeclaration =
  | optAnnotations ENUM name `{ identifierList optTrailingComma }
  | optAnnotations ENUM typeRef name `{ specifiedIdentifierList optTrailingComma }

;;
;;;; Struct, header, and union type declarations
;;

syntax structField = optAnnotations typeRef name `;

;; (TODO) Add whitespace separator as hint?
syntax structFieldList = structField*

syntax headerUnionDeclaration =
  optAnnotations HEADER_UNION name optTypeParameters `{ structFieldList }

syntax structTypeDeclaration =
  optAnnotations STRUCT name optTypeParameters `{ structFieldList }

syntax headerTypeDeclaration =
  optAnnotations HEADER name optTypeParameters `{ structFieldList }

;;
;;;; Derived type declarations
;;

syntax derivedTypeDeclaration =
  | headerTypeDeclaration
  | headerUnionDeclaration
  | structTypeDeclaration
  | enumDeclaration

;;
;;;; Typedef and newtype declarations
;;

syntax typedefDeclaration =
  | optAnnotations TYPEDEF typeRef name
  ;; (TODO) disambiguate with (optAnnotations TYPEDEF typeRef name)
  | optAnnotations TYPEDEF derivedTypeDeclaration name PHTM_12
  | optAnnotations TYPE typeRef name

;;
;;;; Type declarations
;;

syntax typeDeclaration =
  | derivedTypeDeclaration
  | typedefDeclaration `; 
  ;; (TODO) disambiguate with (typedefDeclaration `;)
  | parserTypeDeclaration `; PHTM_13
  ;; (TODO) disambiguate with (typedefDeclaration `;)
  | controlTypeDeclaration `; PHTM_14
  ;; (TODO) disambiguate with (typedefDeclaration `;)
  | packageTypeDeclaration `; PHTM_15

;;
;;;; Declaration
;;

syntax declaration =
  | constantDeclaration
  | errorDeclaration
  | matchKindDeclaration
  | externDeclaration
  | instantiation
  | functionDeclaration
  | actionDeclaration
  | parserDeclaration
  | controlDeclaration 
  | typeDeclaration

;;
;; Annotations
;;

;; Forward declarations

syntax simpleAnnotationBody

;; -------------------

syntax annotationToken =
  | UNEXPECTED_TOKEN | ABSTRACT | ACTION | ACTIONS | APPLY
  | BOOL | BIT | BREAK | CONST | CONTINUE
  | CONTROL | DEFAULT | ELSE | ENTRIES | ENUM
  | ERROR | EXIT | EXTERN | FALSE | FOR
  | HEADER | HEADER_UNION | IF | IN | INOUT
  | INT | KEY | MATCH_KIND | TYPE | OUT
  | PARSER | PACKAGE | PRAGMA | RETURN | SELECT
  | STATE | STRING | STRUCT | SWITCH | TABLE
  | THIS | TRANSITION | TRUE | TUPLE | TYPEDEF
  | VARBIT | VALUESET | LIST | VOID | `_
  | identifier | typeIdentifier | stringLiteral | number
  | `&&& | `.. | `<< | `&& | `|| 
  | `== | `!= | `>= | `<=  | `++
  | `+ | `|+| | `- | `|-| | `*
  | `/ | `% | `| | `& | `^
  | `~ | ``[ | ``] | ``{ | ``}
  | ``< | ``> | `! | `:
  ;; (TODO) comma parsing
  | `, PHTM_21
  | `? | `. | `= | `; | `@

syntax simpleAnnotation =
  | `( simpleAnnotationBody )
  | annotationToken

;; (TODO) Add whitespace separator as hint?
syntax simpleAnnotationBody = simpleAnnotation*

syntax structuredAnnotationBody =
  | expressionList optTrailingComma
  ;; (TODO) disambiguate with (expressionList optTrailingComma)
  | kvList optTrailingComma PHTM_20

syntax annotation =
  | `@ name
  | `@ name `( simpleAnnotationBody )
  | `@ name `[ structuredAnnotationBody ]

;; (TODO) Add whitespace separator as hint?
syntax annotations = annotation*

syntax optAnnotations = annotations?

;;
;; P4 program
;;

;; (TODO) nonempty sequence with + iterator
syntax p4program = declaration*
