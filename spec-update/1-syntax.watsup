;;
;; Misc
;;

syntax trailingComma = COMMA

syntax optTrailingComma = trailingComma?

syntax const = CONST

syntax optCONST = const?

;;
;; Numbers
;;

syntax number =
  | int PHTM_1 ;; (TODO) extension of plaintyp
  | nat W int
  | nat S int

;;
;; Strings
;;

syntax stringLiteral = text PHTM_2 ;; (TODO) extension of plaintyp

;;
;; Names
;;

syntax dotPrefix = DOT

syntax identifier = text PHTM_3 ;; (TODO) extension of plaintyp
syntax typeIdentifier = text PHTM_4 ;; (TODO) extension of plaintyp

syntax nonTableKwName =
  | identifier
  | APPLY
  | KEY
  | ACTIONS
  | STATE
  | ENTRIES
  | TYPE
  | PRIORITY

syntax nonTypeName =
  | identifier
  | APPLY
  | KEY
  | ACTIONS
  | STATE
  | ENTRIES
  | TYPE
  | PRIORITY

syntax prefixedNonTypeName =
  | nonTypeName
  | dotPrefix nonTypeName

syntax prefixedType =
  | typeIdentifier
  | dotPrefix typeIdentifier

syntax typeName = prefixedType

syntax name =
  | nonTypeName
  | LIST
  | typeIdentifier

syntax member = name

;;
;; Directions
;;

syntax direction = | IN | OUT | INOUT | NONE

;;
;; Types
;;

;; Forward declarations

syntax typeRef, typeArg, typeArgumentList
syntax expression, initializer
syntax derivedTypeDeclaration
syntax optAnnotations

;; -------------------

;;;; Base types

syntax baseType =
  | BOOL
  | MATCH_KIND
  | ERROR
  | BIT
  | STRING
  | INT
  | BIT `< int >
  | INT `< int >
  | VARBIT `< int >
  | BIT `< `( expression ) >
  | INT `< `( expression ) >
  | VARBIT `< `( expression ) >

;;;; Named types

syntax specializedType = typeName `< typeArgumentList >

syntax namedType =
  | typeName
  | specializedType

;;;; Header stack types

syntax headerStackType =
  | typeName `[ expression ]
  ;; (TODO) disambiguate with (typeName `[ expression ])
  | specializedType `[ expression ] PHTM_16

;;;; List types

syntax listType = LIST `< typeArg >

;;;; Tuple types

syntax tupleType = TUPLE `< typeArgumentList >

;;;; Type references

syntax typeRef =
  | baseType
  | namedType
  | headerStackType
  | listType
  | tupleType

syntax typeOrVoid =
  | typeRef
  | VOID
  | identifier

;;
;; Type parameters
;;

syntax typeParameterList = name*

syntax typeParameters = `< typeParameterList >

syntax optTypeParameters = typeParameters?

;;
;; Parameters
;;

syntax parameter =
  | optAnnotations direction typeRef name
  | optAnnotations direction typeRef name initializer

;; (TODO) Add comma separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax nonEmptyParameterList = parameter*

;; (TODO) Add comma separator as hint?
syntax parameterList = parameter*

;;
;; Constructor parameters
;;

syntax constructorParameters = `( parameterList )

syntax optConstructorParameters = constructorParameters?

;;
;; Expressions
;;

;; Forward declarations

syntax realTypeArgumentList
syntax argumentList
syntax expressionList, kvList

;; -------------------

syntax nonBraceExpression =
  | number
  | stringLiteral
  | TRUE
  | FALSE
  | THIS
  | nonBraceExpression `[ expression ]
  | nonBraceExpression `[ expression : expression ]
  | `( expression )
  | BANG expression
  | TILDE expression
  | MINUS expression
  | PLUS expression
  | typeName DOT member
  | ERROR DOT member
  ;; (TODO) disambiguate with (typeName DOT member)
  | nonBraceExpression DOT member PHTM_5
  | nonBraceExpression MULT expression
  | nonBraceExpression DIV expression
  | nonBraceExpression MOD expression
  | nonBraceExpression PLUS expression
  | nonBraceExpression MINUS expression
  | nonBraceExpression SPLUS expression
  | nonBraceExpression SMINUS expression
  | nonBraceExpression LSHIFT expression
  | nonBraceExpression RSHIFT expression
  | nonBraceExpression LE expression
  | nonBraceExpression GE expression
  | nonBraceExpression LT expression
  | nonBraceExpression GT expression
  | nonBraceExpression NE expression
  | nonBraceExpression EQEQ expression
  | nonBraceExpression BAND expression
  | nonBraceExpression BXOR expression
  | nonBraceExpression BOR expression
  | nonBraceExpression CONCAT expression
  | nonBraceExpression LAND expression
  | nonBraceExpression LOR expression
  | nonBraceExpression QUEST expression COLON expression
  | nonBraceExpression `< realTypeArgumentList > `( argumentList )
  | nonBraceExpression `( argumentList )
  ;; (TODO) disambiguate with (nonBraceExpression `( argumentList ))
  | namedType `( argumentList ) PHTM_6
  | `( typeRef ) expression

syntax expression =
  | DOTS
  | TRUE
  | FALSE
  | THIS
  | prefixedNonTypeName
  | expression `[ expression ]
  | expression `[ expression : expression ]
  | `{ expressionList optTrailingComma }
  | `{ HASH }
  ;; (TODO) disambiguate with (`{ expressionList optTrailingComma })
  | `{ kvList optTrailingComma } PHTM_7
  | `{ kvList COMMA DOTS optTrailingComma }
  | `( expression )
  | BANG expression
  | TILDE expression
  | MINUS expression
  | PLUS expression
  | typeName DOT member
  | ERROR DOT member
  ;; (TODO) disambiguate with (typeName DOT member)
  | expression DOT member PHTM_8
  | expression MULT expression
  | expression DIV expression
  | expression MOD expression
  | expression PLUS expression
  | expression MINUS expression
  | expression SPLUS expression
  | expression SMINUS expression
  | expression LSHIFT expression
  | expression RSHIFT expression
  | expression LE expression
  | expression GE expression
  | expression LT expression
  | expression GT expression
  | expression NE expression
  | expression EQEQ expression
  | expression BAND expression
  | expression BXOR expression
  | expression BOR expression
  | expression CONCAT expression
  | expression LAND expression
  | expression LOR expression
  | expression QUEST expression COLON expression
  | expression `< realTypeArgumentList > `( argumentList )
  | expression `( argumentList )
  ;; (TODO) disambiguate with (expression `( argumentList ))
  | namedType `( argumentList ) PHTM_9
  | `( typeRef ) expression

;; (TODO) Add comma separator as hint?
syntax expressionList = expression*

;;
;; Keyset expressions
;;

syntax simpleKeysetExpression =
  | expression
  | expression MASK expression
  | expression RANGE expression
  | DEFAULT
  | UNDERSCORE

syntax reducedSimpleKeysetExpression =
  | expression MASK expression
  | expression RANGE expression
  | DEFAULT
  | UNDERSCORE

;; (TODO) Add comma separator as hint?
syntax simpleExpressionList = simpleKeysetExpression*

syntax tupleKeysetExpression =
  | `( simpleKeysetExpression COMMA simpleExpressionList )
  ;; (TODO) disambiguate with `( expression )
  | `( reducedSimpleKeysetExpression ) PHTM_19

syntax keysetExpression =
  | tupleKeysetExpression
  | simpleKeysetExpression

;;
;; Expression key-value pairs
;;

syntax kvPair = name EQ expression

;; (TODO) Add comma separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax kvList = kvPair*

;;
;; Type arguments
;;

syntax realTypeArg =
  | typeRef
  | VOID
  | UNDERSCORE

;; (TODO) Add comma separator as hint?
syntax realTypeArgumentList = realTypeArg*

syntax typeArg =
  | typeRef
  | nonTypeName
  | VOID
  | UNDERSCORE

;; (TODO) Add comma separator as hint?
syntax typeArgumentList = typeArg*

;;
;; Arguments
;;

syntax argument =
  | expression
  | name EQ expression
  | UNDERSCORE
  | name EQ UNDERSCORE

;; (TODO) Add comma separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax nonEmptyArgList = argument*

;; (TODO) Add comma separator as hint?
syntax argumentList = argument*

;;
;; L-values
;;

syntax lvalue =
  | prefixedNonTypeName
  | THIS
  | lvalue DOT member
  | lvalue `[ expression ]
  | lvalue `[ expression : expression ]
  | `( lvalue )

;;
;; Statements and declarations
;;

;; Forward declarations

syntax statement, parserStatements, statOrDeclList
syntax objDeclarations
syntax annotations

;; -------------------

;;;; Variable and constant declarations

syntax initializer = EQ expression

syntax optInitializer = initializer?

syntax variableDeclarationWithoutSemicolon =
  optAnnotations typeRef name optInitializer

syntax variableDeclaration =
  variableDeclarationWithoutSemicolon SEMICOLON

syntax constantDeclaration =
  optAnnotations CONST typeRef name EQ initializer SEMICOLON

;;;; Assignment and method call statements

syntax assignmentOrMethodCallStatementWithoutSemicolon =
  | lvalue `( argumentList )
  | lvalue `< typeArgumentList > `( argumentList )
  | lvalue EQ expression
  | lvalue MULTEQ expression
  | lvalue DIVEQ expression
  | lvalue MODEQ expression
  | lvalue PLUSEQ expression
  | lvalue MINUSEQ expression
  | lvalue SPLUSEQ expression
  | lvalue SMINUSEQ expression
  | lvalue LSHIFTEQ expression
  | lvalue RSHIFTEQ expression
  | lvalue BANDEQ expression
  | lvalue BXOREQ expression
  | lvalue BOREQ expression

syntax assignmentOrMethodCallStatement =
  assignmentOrMethodCallStatementWithoutSemicolon SEMICOLON PHTM_11

;;;; Direct application statements

syntax directApplication =
  | typeName DOT APPLY `( argumentList ) SEMICOLON
  ;; (TODO) disambiguate with (typeName DOT APPLY `( argumentList ) SEMICOLON)
  | specializedType DOT APPLY `( argumentList ) SEMICOLON PHTM_10

;;;; Conditional statements

syntax conditionalStatement =
  | IF `( expression ) statement
  | IF `( expression ) statement ELSE statement

;;;; Empty statements

syntax emptyStatement = SEMICOLON

;;;; Block statements

syntax blockStatement =
  optAnnotations `{ statOrDeclList }

;;;; Return statements

syntax returnStatement =
  | RETURN SEMICOLON
  | RETURN expression SEMICOLON

;;;; Break statements

syntax breakStatement = BREAK SEMICOLON

;;;; Continue statements

syntax continueStatement = CONTINUE SEMICOLON

;;;; Exit statements

syntax exitStatement = EXIT SEMICOLON

;;;; Switch statements

syntax switchLabel =
  | DEFAULT
  | nonBraceExpression

syntax switchCase =
  | switchLabel COLON blockStatement
  | switchLabel COLON

;; (TODO) Add whitespace separator as hint?
syntax switchCases = switchCase*

syntax switchStatement = SWITCH `( expression ) `{ switchCases }

;;;; For statements

syntax declOrAssignmentOrMethodCallStatement =
  | variableDeclarationWithoutSemicolon
  | assignmentOrMethodCallStatementWithoutSemicolon

;; (TODO) Add comma separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax forInitStatementNonEmpty = declOrAssignmentOrMethodCallStatement*

;; (TODO) Add comma separator as hint?
syntax forInitStatements = declOrAssignmentOrMethodCallStatement*

;; (TODO) Add comma separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax forUpdateStatementsNonEmpty = assignmentOrMethodCallStatementWithoutSemicolon*

;; (TODO) Add comma separator as hint?
syntax forUpdateStatements = assignmentOrMethodCallStatementWithoutSemicolon*

syntax forCollectionExpr =
  | expression
  | expression DOTDOT expression

syntax forStatement =
  | optAnnotations FOR `( forInitStatements ; expression ; forUpdateStatements ) statement
  | optAnnotations FOR `( typeRef name IN forCollectionExpr ) statement
  | optAnnotations FOR `( annotations typeRef name IN forCollectionExpr ) statement

;;;; Statements

syntax statement =
  | assignmentOrMethodCallStatement
  | directApplication
  | conditionalStatement
  | emptyStatement
  | blockStatement
  | returnStatement
  | breakStatement
  | continueStatement
  | exitStatement
  | switchStatement
  | forStatement

syntax statementOrDeclaration =
  | variableDeclaration
  | constantDeclaration
  | statement

;; (TODO) Add whitespace separator as hint?
syntax statOrDeclList = statementOrDeclaration*

;;;; Error and match kind declarations

;; (TODO) Add comma separator as hint?
syntax identifierList = name*

syntax matchKindDeclaration =
  MATCH_KIND `{ identifierList optTrailingComma }

syntax errorDeclaration = ERROR `{ identifierList }

;;;; Extern declarations

syntax functionPrototype =
  typeOrVoid name optTypeParameters `( parameterList )

syntax methodPrototype =
  | optAnnotations functionPrototype SEMICOLON
  | optAnnotations ABSTRACT functionPrototype SEMICOLON
  | optAnnotations typeIdentifier `( parameterList ) SEMICOLON

;; (TODO) Add whitespace separator as hint?
syntax methodPrototypes = methodPrototype*

syntax externDeclaration =
  | optAnnotations EXTERN nonTypeName optTypeParameters `{ methodPrototypes }
  | optAnnotations EXTERN functionPrototype SEMICOLON

;;;; Function declarations

syntax functionDeclaration =
  optAnnotations functionPrototype blockStatement

;;;; Instantiations

syntax objInitializer = EQ `{ objDeclarations }

syntax instantiation =
  | optAnnotations typeRef `( argumentList ) name SEMICOLON
  | optAnnotations typeRef `( argumentList ) name objInitializer SEMICOLON

syntax objDeclaration =
  | functionDeclaration
  | instantiation

;; (TODO) Add whitespace separator as hint?
syntax objDeclarations = objDeclaration*

;;;; Action declarations

syntax actionDeclaration =
  optAnnotations ACTION name `( parameterList ) blockStatement

;;;; Table declarations

;;;;;; Table key property 

syntax keyElement =
  expression COLON name optAnnotations SEMICOLON

;; (TODO) Add whitespace separator as hint?
syntax keyElementList = keyElement*

;;;;;; Table actions property

syntax actionRef =
  | prefixedNonTypeName
  | prefixedNonTypeName `( argumentList )

syntax action = optAnnotations actionRef SEMICOLON

;; (TODO) Add whitespace separator as hint?
syntax actionList = action*

;;;;;; Table entry property

syntax entryPriority =
  | PRIORITY EQ number COLON
  | PRIORITY EQ `( expression ) COLON

syntax entry =
  | optCONST entryPriority keysetExpression COLON actionRef optAnnotations SEMICOLON
  | optCONST keysetExpression COLON actionList optAnnotations SEMICOLON

syntax entriesList = entry*

;;;;;; Table properties

syntax tableProperty =
  | KEY EQ `{ keyElementList }
  | ACTIONS EQ `{ actionList }
  | optAnnotations optCONST ENTRIES EQ `{ entriesList }
  | optAnnotations optCONST nonTableKwName initializer SEMICOLON

;; (TODO) Add whitespace separator as hint?
syntax tablePropertyList = tableProperty*

syntax tableDeclaration =
  optAnnotations TABLE name `{ tablePropertyList }

;;;; Control and control type declarations

syntax controlBody = blockStatement

syntax controlLocalDeclaration =
  | constantDeclaration
  | actionDeclaration
  | tableDeclaration
  | instantiation
  | variableDeclaration

;; (TODO) Add whitespace separator as hint?
syntax controlLocalDeclarations = controlLocalDeclaration*

syntax controlTypeDeclaration =
  optAnnotations CONTROL name optTypeParameters `( parameterList )

syntax controlDeclaration =
  controlTypeDeclaration optConstructorParameters `{ controlLocalDeclarations APPLY controlBody }

;;;; Value set declarations

syntax valueSetDeclaration =
  | optAnnotations VALUESET `< baseType > `( expression ) name SEMICOLON
  ;; (TODO) disambiguate with (optAnnotations VALUESET `< baseType > `( expression ) name SEMICOLON)
  | optAnnotations VALUESET `< tupleType > `( expression ) name SEMICOLON PHTM_17
  ;; (TODO) disambiguate with (optAnnotations VALUESET `< baseType > `( expression ) name SEMICOLON)
  | optAnnotations VALUESET `< typeName > `( expression ) name SEMICOLON PHTM_18

;;;; Select expressions

syntax selectCase = keysetExpression COLON name SEMICOLON

;; (TODO) Add whitespace separator as hint?
syntax selectCaseList = selectCase*

syntax selectExpression =
  SELECT `( expressionList ) `{ selectCaseList }

;;;; State expressions

syntax stateExpression =
  | name SEMICOLON
  | selectExpression

syntax transitionStatement = TRANSITION stateExpression

;;;; Parser and parser type declarations

syntax parserBlockStatement = optAnnotations `{ parserStatements }

syntax parserStatement =
  | assignmentOrMethodCallStatement
  | directApplication
  | emptyStatement
  | variableDeclaration
  | constantDeclaration
  | parserBlockStatement
  | conditionalStatement

;; (TODO) Add whitespace separator as hint?
syntax parserStatements = parserStatement*

syntax parserState =
  optAnnotations STATE name `{ parserStatements transitionStatement }

;; (TODO) Add whitespace separator as hint?
;; (TODO) nonempty sequence with + iterator
syntax parserStates = parserState*

syntax parserTypeDeclaration =
  optAnnotations PARSER name optTypeParameters `( parameterList )

syntax parserLocalElement =
  | constantDeclaration
  | variableDeclaration
  | instantiation
  | valueSetDeclaration

;; (TODO) Add whitespace separator as hint?
syntax parserLocalElements = parserLocalElement*

syntax parserDeclaration =
  parserTypeDeclaration optConstructorParameters `{ parserLocalElements parserStates }

;;;; Package type declaration

syntax packageTypeDeclaration =
  optAnnotations PACKAGE name optTypeParameters `( parameterList )

;;;; Enum type declaration

syntax specifiedIdentifier = name initializer

;; (TODO) Add comma separator as hint?
syntax specifiedIdentifierList = specifiedIdentifier*

syntax enumDeclaration =
  | optAnnotations ENUM name `{ identifierList optTrailingComma }
  | optAnnotations ENUM typeRef name `{ specifiedIdentifierList optTrailingComma }

;;;; Struct, header, and union type declarations

syntax structField = optAnnotations typeRef name SEMICOLON

;; (TODO) Add whitespace separator as hint?
syntax structFieldList = structField*

syntax headerUnionDeclaration =
  optAnnotations HEADER_UNION name optTypeParameters `{ structFieldList }

syntax structTypeDeclaration =
  optAnnotations STRUCT name optTypeParameters `{ structFieldList }

syntax headerTypeDeclaration =
  optAnnotations HEADER name optTypeParameters `{ structFieldList }

;;;; Derived type declarations

syntax derivedTypeDeclaration =
  | headerTypeDeclaration
  | headerUnionDeclaration
  | structTypeDeclaration
  | enumDeclaration

;;;; Typedef and newtype declarations

syntax typedefDeclaration =
  | optAnnotations TYPEDEF typeRef name
  ;; (TODO) disambiguate with (optAnnotations TYPEDEF typeRef name)
  | optAnnotations TYPEDEF derivedTypeDeclaration name PHTM_12
  | optAnnotations TYPE typeRef name

;;;; Type declarations

syntax typeDeclaration =
  | derivedTypeDeclaration
  | typedefDeclaration SEMICOLON
  ;; (TODO) disambiguate with (typedefDeclaration SEMICOLON)
  | parserTypeDeclaration SEMICOLON PHTM_13
  ;; (TODO) disambiguate with (typedefDeclaration SEMICOLON)
  | controlTypeDeclaration SEMICOLON PHTM_14
  ;; (TODO) disambiguate with (typedefDeclaration SEMICOLON)
  | packageTypeDeclaration SEMICOLON PHTM_15

;;;; Declaration

syntax declaration =
  | constantDeclaration
  | errorDeclaration
  | matchKindDeclaration
  | externDeclaration
  | instantiation
  | functionDeclaration
  | actionDeclaration
  | parserDeclaration
  | controlDeclaration 
  | typeDeclaration

;;
;; Annotations
;;

syntax annotationToken =
  | UNEXPECTED_TOKEN | ABSTRACT | ACTION | ACTIONS | APPLY
  | BOOL | BIT | BREAK | CONST | CONTINUE
  | CONTROL | DEFAULT | ELSE | ENTRIES | ENUM
  | ERROR | EXIT | EXTERN | FALSE | FOR
  | HEADER | HEADER_UNION | IF | IN | INOUT
  | INT | KEY | MATCH_KIND | TYPE | OUT
  | PARSER | PACKAGE | PRAGMA | RETURN | SELECT
  | STATE | STRING | STRUCT | SWITCH | TABLE
  | THIS | TRANSITION | TRUE | TUPLE | TYPEDEF
  | VARBIT | VALUESET | LIST | VOID | UNDERSCORE
  | identifier | typeIdentifier | stringLiteral | number
  | MASK | RANGE | SHL | LAND | LOR
  | EQEQ | NE | GE | LE  | CONCAT
  | PLUS | SPLUS | MINUS | SMINUS | MULT
  | DIV | MOD | BOR | BAND | BXOR
  | TILDE | LBRACK | RBRACK | LBRACE | RBRACE
  | LANGLE | RANGLE | BANG | COLON | COMMA
  | QUEST | DOT | EQ | SEMICOLON | AT

syntax annotationBody =
  | annotationBody `( annotationBody )
  | annotationBody annotationToken

syntax structuredAnnotationBody =
  | expressionList optTrailingComma
  ;; (TODO) disambiguate with (expressionList optTrailingComma)
  | kvList optTrailingComma PHTM_20

syntax annotation =
  | AT name
  | AT name `( annotationBody )
  | AT name `[ structuredAnnotationBody ]

;; (TODO) Add whitespace separator as hint?
syntax annotations = annotation*

syntax optAnnotations = annotations?

;;
;; P4 program
;;

;; (TODO) nonempty sequence with + iterator
syntax p4program = declaration*
