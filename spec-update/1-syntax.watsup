;;
;; Misc
;;

syntax trailingComma = `,

syntax optTrailingComma = trailingComma?

syntax const = CONST

syntax optCONST = const?

;;
;; Numbers
;;

syntax number =
  | D int
  | nat W int
  | nat S int

;;
;; Strings
;;

syntax stringLiteral = `" text `"

;;
;; Names
;;

syntax dotPrefix = `.

;; (TODO) extension of plaintyp
syntax identifier = `$ text
;; (TODO) extension of plaintyp
syntax typeIdentifier = `@ text

syntax nonTypeName =
  | identifier
  | APPLY | KEY | ACTIONS | STATE
  | ENTRIES | TYPE | PRIORITY

syntax prefixedNonTypeName =
  | nonTypeName
  | `. nonTypeName

syntax typeName = typeIdentifier

syntax prefixedTypeName =
  | typeName 
  | `.. typeName

syntax name =
  | nonTypeName
  | typeName
  | LIST

syntax nonTableKwName =
  | identifier
  | typeIdentifier
  | APPLY | STATE | TYPE | PRIORITY

syntax nameList =
  | `EMPTY
  | name
  | nameList `, name

syntax member = name

;;
;; Directions
;;

syntax direction = IN | OUT | INOUT | NONE

;;
;; Types
;;

;; Forward declarations

syntax typeRef, typeArg, typeArgList
syntax expression, initializer
syntax derivedTypeDeclaration
syntax optAnnotations

;;
;;;; Base types
;;

syntax baseType =
  | BOOL
  | MATCH_KIND
  | ERROR
  | BIT
  | STRING
  | INT
  | BIT `< int >
  | INT `< int >
  | VARBIT `< int >
  | BIT `< `( expression ) >
  | INT `< `( expression ) >
  | VARBIT `< `( expression ) >

;;
;;;; Named types
;;

syntax specializedType = prefixedTypeName `< typeArgList >

syntax namedType =
  | prefixedTypeName
  | specializedType

;;
;;;; Header stack types
;;

syntax headerStackBaseType =
  | prefixedTypeName
  | specializedType

syntax headerStackType = headerStackBaseType `[ expression ]

;;
;;;; List types
;;

syntax listType = LIST `< typeArg >

;;
;;;; Tuple types
;;

syntax tupleType = TUPLE `< typeArgList >

;;
;;;; Type references
;;

syntax typeRef =
  | baseType
  | namedType
  | headerStackType
  | listType
  | tupleType

syntax typeOrVoid =
  | typeRef
  | VOID
  | identifier

;;
;; Type parameters
;;

syntax typeParameterList =
  | `EMPTY
  | name 
  | typeParameterList `, name

syntax typeParameters = `< typeParameterList >

syntax optTypeParameters = typeParameters?

;;
;; Parameters
;;

syntax parameter =
  | optAnnotations direction typeRef name
  | optAnnotations direction typeRef name initializer

syntax parameterList =
  | `EMPTY
  | parameter
  | parameterList `, parameter

;;
;; Constructor parameters
;;

syntax constructorParameters = `( parameterList )

syntax optConstructorParameters = constructorParameters?

;;
;; Expression key-value pairs
;;

syntax kvPair = name `= expression

syntax kvList =
  | `EMPTY
  | kvPair
  | kvList `, kvPair

syntax kvListNonEmpty =
  | kvPair
  | kvListNonEmpty `, kvPair

;;
;; Expressions
;;

;; Forward declarations

syntax realTypeArgumentList
syntax argumentList
syntax accessBaseNonBrace, accessBase
syntax callBaseNonBrace, callBase
syntax recordExpression, expressionList

syntax nonBraceExpression =
  | number
  | stringLiteral
  | TRUE
  | FALSE
  | THIS
  | prefixedNonTypeName
  | nonBraceExpression `[ expression ]
  | nonBraceExpression `[ expression `: expression ]
  | `( expression )
  | `! expression
  | `~ expression
  | `- expression
  | `+ expression
  | accessBaseNonBrace `. member
  | nonBraceExpression `* expression
  | nonBraceExpression `/ expression
  | nonBraceExpression `% expression
  | nonBraceExpression `+ expression
  | nonBraceExpression `- expression
  | nonBraceExpression `|+| expression
  | nonBraceExpression `|-| expression
  | nonBraceExpression `<< expression
  | nonBraceExpression `>> expression
  | nonBraceExpression `<= expression
  | nonBraceExpression `>= expression
  | nonBraceExpression ``< expression
  | nonBraceExpression ``> expression
  | nonBraceExpression `!= expression
  | nonBraceExpression `== expression
  | nonBraceExpression `& expression
  | nonBraceExpression `^ expression
  | nonBraceExpression `| expression
  | nonBraceExpression `++ expression
  | nonBraceExpression `&& expression
  | nonBraceExpression `|| expression
  | nonBraceExpression `? expression `: expression
  | nonBraceExpression `< realTypeArgumentList > `( argumentList )
  | callBaseNonBrace `( argumentList )
  | `( typeRef ) expression

syntax accessBaseNonBrace =
  | prefixedTypeName
  | ERROR
  | nonBraceExpression

syntax callBaseNonBrace =
  | namedType
  | nonBraceExpression

syntax expression =
  | number
  | `...
  | stringLiteral
  | TRUE
  | FALSE
  | THIS
  | prefixedNonTypeName
  | expression `[ expression ]
  | expression `[ expression `: expression ]
  | `{#}
  | `{ recordExpression optTrailingComma }
  | `( expression )
  | `! expression
  | `~ expression
  | `- expression
  | `+ expression
  | accessBase `. member
  | expression `* expression
  | expression `/ expression
  | expression `% expression
  | expression `+ expression
  | expression `- expression
  | expression `|+| expression
  | expression `|-| expression
  | expression `<< expression
  | expression `>> expression
  | expression `<= expression
  | expression `>= expression
  | expression ``< expression
  | expression ``> expression
  | expression `!= expression
  | expression `== expression
  | expression `& expression
  | expression `^ expression
  | expression `| expression
  | expression `++ expression
  | expression `&& expression
  | expression `|| expression
  | expression `? expression `: expression
  | expression `< realTypeArgumentList > `( argumentList )
  | callBase `( argumentList )
  | `( typeRef ) expression

syntax expressionList =
  | `EMPTY
  | expression
  | expressionList `, expression

syntax accessBase =
  | prefixedTypeName
  | ERROR
  | expression

syntax callBase =
  | namedType
  | expression

syntax kvPairRecordExpression =
  | name `= expression
  | name `= expression `, `...
  | name `= expression `, kvListNonEmpty
  | name `= expression `, kvListNonEmpty `, `...

syntax recordExpression =
  | expressionList
  | kvPairRecordExpression

;;
;; Keyset expressions
;;

syntax simpleKeysetExpression =
  | expression
  | expression `&&& expression
  | expression `.. expression
  | DEFAULT
  | `_

syntax simpleExpressionList = 
  | `EMPTY
  | simpleKeysetExpression
  | simpleExpressionList `, simpleKeysetExpression

syntax tupleKeysetExpression =
  | `( simpleKeysetExpression `, simpleExpressionList )
  | `( expression `&&& expression )
  | `( expression `.. expression )
  | `( DEFAULT )
  | `( `_ )

syntax keysetExpression =
  | tupleKeysetExpression
  | simpleKeysetExpression

;;
;; Type arguments
;;

syntax realTypeArg =
  | typeRef
  | VOID
  | `_

syntax realTypeArgumentList =
  | `EMPTY
  | realTypeArg
  | realTypeArgumentList `, realTypeArg

syntax typeArg =
  | typeRef
  | nonTypeName
  | VOID
  | `_

syntax typeArgList =
  | `EMPTY
  | typeArg
  | typeArgList `, typeArg

;;
;; Arguments
;;

syntax argument =
  | expression
  | name `= expression
  | `_
  | name `= `_

syntax argumentList =
  | `EMPTY
  | argument
  | argumentList `, argument

;;
;; L-values
;;

syntax lvalue =
  | prefixedNonTypeName
  | THIS
  | lvalue `. member
  | lvalue `[ expression ]
  | lvalue `[ expression `: expression ]
  | `( lvalue )

;;
;; Statements and declarations
;;

;; Forward declarations

syntax statement, parserStatements, statOrDeclList
syntax objDeclarations
syntax annotations

;;
;;;; Variable and constant declarations
;;

syntax initializer = `= expression

syntax optInitializer = initializer?

syntax variableDeclarationWithoutSemicolon =
  optAnnotations typeRef name optInitializer

syntax variableDeclaration =
  optAnnotations typeRef name optInitializer `;

syntax constantDeclaration =
  optAnnotations CONST typeRef name initializer `;

;;
;;;; Assignment and method call statements
;;

syntax assignmentOrMethodCallStatementWithoutSemicolon =
  | lvalue `( argumentList )
  | lvalue `< typeArgList > `( argumentList )
  | lvalue `= expression
  | lvalue `+= expression
  | lvalue `|+|= expression
  | lvalue `-= expression
  | lvalue `|-|= expression
  | lvalue `*= expression
  | lvalue `/= expression
  | lvalue `%= expression
  | lvalue `<<= expression
  | lvalue `>>= expression
  | lvalue `&= expression
  | lvalue `^= expression
  | lvalue `|= expression

syntax assignmentOrMethodCallStatement =
  assignmentOrMethodCallStatementWithoutSemicolon `;

;;
;;;; Direct application statements
;;

syntax directApplication = namedType `. APPLY `( argumentList ) `;

;;
;;;; Conditional statements
;;

syntax conditionalStatement =
  | IF `( expression ) statement
  | IF `( expression ) statement ELSE statement

;;
;;;; Empty statements
;;

syntax emptyStatement = `;

;;
;;;; Block statements
;;

syntax blockStatement = optAnnotations `{ statOrDeclList }

;;
;;;; Return statements
;;

syntax returnStatement =
  | RETURN `;
  | RETURN expression `;

;;
;;;; Break statements
;;

syntax breakStatement = BREAK `;

;;
;;;; Continue statements
;;

syntax continueStatement = CONTINUE `;

;;
;;;; Exit statements
;;

syntax exitStatement = EXIT `;

;;
;;;; Switch statements
;;

syntax switchLabel =
  | DEFAULT
  | nonBraceExpression

syntax switchCase =
  | switchLabel `: blockStatement
  | switchLabel `: 

;; (TODO) Add whitespace separator as hint?
syntax switchCases = switchCase*

syntax switchStatement = SWITCH `( expression ) `{ switchCases }

;;
;;;; For statements
;;

syntax declOrAssignmentOrMethodCallStatement =
  | variableDeclarationWithoutSemicolon
  | assignmentOrMethodCallStatementWithoutSemicolon

syntax forInitStatementsNonEmpty =
  | declOrAssignmentOrMethodCallStatement 
  | forInitStatementsNonEmpty `, declOrAssignmentOrMethodCallStatement

syntax forInitStatements =
  | `EMPTY
  | forInitStatementsNonEmpty

syntax forUpdateStatementsNonEmpty =
  | assignmentOrMethodCallStatementWithoutSemicolon
  | forUpdateStatementsNonEmpty `, assignmentOrMethodCallStatementWithoutSemicolon

syntax forUpdateStatements =
  | `EMPTY
  | forUpdateStatementsNonEmpty

syntax forCollectionExpr =
  | expression
  | expression `.. expression

syntax forStatement =
  | optAnnotations FOR `( forInitStatements `; expression `; forUpdateStatements ) statement
  | optAnnotations FOR `( typeRef name IN forCollectionExpr ) statement
  | optAnnotations FOR `( annotations typeRef name IN forCollectionExpr ) statement

;;
;;;; Statements
;;

syntax statement =
  | assignmentOrMethodCallStatement
  | directApplication
  | conditionalStatement
  | emptyStatement
  | blockStatement
  | returnStatement
  | breakStatement
  | continueStatement
  | exitStatement
  | switchStatement
  | forStatement

syntax statementOrDeclaration =
  | variableDeclaration
  | constantDeclaration
  | statement

syntax statOrDeclList =
  | `EMPTY
  | statementOrDeclaration
  | statOrDeclList statementOrDeclaration


;;
;;;; Error and match kind declarations
;;

syntax matchKindDeclaration =
  MATCH_KIND `{ nameList optTrailingComma }

syntax errorDeclaration = ERROR `{ nameList }

;;
;;;; Extern declarations
;;

syntax functionPrototype =
  typeOrVoid name optTypeParameters `( parameterList )

syntax methodPrototype =
  | optAnnotations functionPrototype `;
  | optAnnotations ABSTRACT functionPrototype `;
  | optAnnotations typeIdentifier `( parameterList ) `;

syntax methodPrototypes =
  | `EMPTY
  | methodPrototype
  | methodPrototypes methodPrototype

syntax externDeclaration =
  | optAnnotations EXTERN nonTypeName optTypeParameters `{ methodPrototypes }
  | optAnnotations EXTERN functionPrototype `;

;;
;;;; Function declarations
;;

syntax functionDeclaration =
  optAnnotations functionPrototype blockStatement

;;
;;;; Instantiations
;;

syntax objInitializer = `= `{ objDeclarations }

syntax instantiation =
  | optAnnotations typeRef `( argumentList ) name `;
  | optAnnotations typeRef `( argumentList ) name objInitializer `;

syntax objDeclaration =
  | functionDeclaration
  | instantiation

syntax objDeclarations =
  | `EMPTY
  | objDeclaration
  | objDeclarations objDeclaration

;;
;;;; Action declarations
;;

syntax actionDeclaration =
  optAnnotations ACTION name `( parameterList ) blockStatement

;;
;;;; Table declarations
;;

;;
;;;;;; Table key property 
;;

syntax keyElement = expression `: name optAnnotations `;

;; (TODO) Add whitespace separator as hint?
syntax keyElementList = keyElement*

;;
;;;;;; Table actions property
;;

syntax actionRef =
  | prefixedNonTypeName
  | prefixedNonTypeName `( argumentList )

syntax action = optAnnotations actionRef `;

syntax actionList =
  | `EMPTY
  | action
  | actionList action

;;
;;;;;; Table entry property
;;

syntax entryPriority =
  | PRIORITY `= number `: 
  | PRIORITY `= `( expression ) `:

syntax entry =
  | optCONST entryPriority keysetExpression `: actionRef optAnnotations`; 
  | optCONST keysetExpression `: actionRef optAnnotations `; 

syntax entriesList =
  | `EMPTY
  | entry
  | entriesList entry

;;
;;;;;; Table properties
;;

syntax tableProperty =
  | KEY `= `{ keyElementList }
  | ACTIONS `= `{ actionList }
  | optAnnotations optCONST ENTRIES `= `{ entriesList }
  | optAnnotations optCONST nonTableKwName initializer `;

syntax tablePropertyList =
  | `EMPTY
  | tableProperty
  | tablePropertyList tableProperty

syntax tableDeclaration =
  optAnnotations TABLE name `{ tablePropertyList }

;;
;;;; Control and control type declarations
;;

syntax controlBody = blockStatement

syntax controlLocalDeclaration =
  | constantDeclaration
  | actionDeclaration
  | tableDeclaration
  | instantiation
  | variableDeclaration

syntax controlLocalDeclarations =
  | `EMPTY
  | controlLocalDeclaration
  | controlLocalDeclarations controlLocalDeclaration

syntax controlTypeDeclaration =
  optAnnotations CONTROL name optTypeParameters `( parameterList )

syntax controlDeclaration =
  controlTypeDeclaration optConstructorParameters `{ controlLocalDeclarations APPLY controlBody }

;;
;;;; Value set declarations
;;

syntax valueSetType =
  | baseType
  | tupleType
  | prefixedTypeName

syntax valueSetDeclaration =
  optAnnotations VALUESET `< valueSetType > `( expression ) name `;

;;
;;;; Select expressions
;;

syntax selectCase = keysetExpression `: name `;

syntax selectCaseList =
  | `EMPTY
  | selectCase
  | selectCaseList selectCase

syntax selectExpression = SELECT `( expressionList ) `{ selectCaseList }

;;
;;;; Transition statements
;;

syntax stateExpression =
  | name `;
  | selectExpression

syntax transitionStatement = TRANSITION stateExpression

;;
;;;; Parser and parser type declarations
;;

syntax parserBlockStatement = optAnnotations `{ parserStatements }

syntax parserStatement =
  | assignmentOrMethodCallStatement
  | directApplication
  | emptyStatement
  | variableDeclaration
  | constantDeclaration
  | parserBlockStatement
  | conditionalStatement

syntax parserStatements =
  | `EMPTY
  | parserStatement
  | parserStatements parserStatement

syntax parserState =
  optAnnotations STATE name `{ parserStatements transitionStatement }

syntax parserStates =
  | parserState
  | parserStates parserState

syntax parserTypeDeclaration =
  optAnnotations PARSER name optTypeParameters `( parameterList )

syntax parserLocalElement =
  | constantDeclaration
  | variableDeclaration
  | instantiation
  | valueSetDeclaration

syntax parserLocalElements =
  | `EMPTY
  | parserLocalElement
  | parserLocalElements parserLocalElement

syntax parserDeclaration =
  parserTypeDeclaration optConstructorParameters `{ parserLocalElements parserStates }

;;
;;;; Package type declaration
;;

syntax packageTypeDeclaration =
  optAnnotations PACKAGE name optTypeParameters `( parameterList )

;;
;;;; Enum type declaration
;;

syntax specifiedName = name initializer

syntax specifiedNameList =
  | `EMPTY
  | specifiedName
  | specifiedNameList `, specifiedName

syntax enumDeclaration =
  | optAnnotations ENUM name `{ nameList optTrailingComma }
  | optAnnotations ENUM typeRef name `{ specifiedNameList optTrailingComma }

;;
;;;; Struct, header, and union type declarations
;;

syntax structField = optAnnotations typeRef name `;

syntax structFieldList =
  | `EMPTY
  | structField
  | structFieldList structField

syntax headerUnionDeclaration =
  optAnnotations HEADER_UNION name optTypeParameters `{ structFieldList }

syntax structTypeDeclaration =
  optAnnotations STRUCT name optTypeParameters `{ structFieldList }

syntax headerTypeDeclaration =
  optAnnotations HEADER name optTypeParameters `{ structFieldList }

;;
;;;; Derived type declarations
;;

syntax derivedTypeDeclaration =
  | headerTypeDeclaration
  | headerUnionDeclaration
  | structTypeDeclaration
  | enumDeclaration

;;
;;;; Typedef and newtype declarations
;;

syntax typedefType =
  | typeRef
  | derivedTypeDeclaration

syntax typedefDeclaration =
  | optAnnotations TYPEDEF typedefType name
  | optAnnotations TYPE typeRef name

;;
;;;; Type declarations
;;

syntax typeDeclarationWithoutSemicolon =
  | typedefDeclaration
  | parserTypeDeclaration
  | controlTypeDeclaration
  | packageTypeDeclaration

syntax typeDeclaration =
  | derivedTypeDeclaration
  | typeDeclarationWithoutSemicolon `;

;;
;;;; Declaration
;;

syntax declaration =
  | constantDeclaration
  | errorDeclaration
  | matchKindDeclaration
  | externDeclaration
  | instantiation
  | functionDeclaration
  | actionDeclaration
  | parserDeclaration
  | controlDeclaration 
  | typeDeclaration

;;
;; Annotations
;;

syntax annotationToken =
  | UNEXPECTED_TOKEN | ABSTRACT | ACTION | ACTIONS | APPLY
  | BOOL | BIT | BREAK | CONST | CONTINUE
  | CONTROL | DEFAULT | ELSE | ENTRIES | ENUM
  | ERROR | EXIT | EXTERN | FALSE | FOR
  | HEADER | HEADER_UNION | IF | IN | INOUT
  | INT | KEY | MATCH_KIND | TYPE | OUT
  | PARSER | PACKAGE | PRAGMA | RETURN | SELECT
  | STATE | STRING | STRUCT | SWITCH | TABLE
  | THIS | TRANSITION | TRUE | TUPLE | TYPEDEF
  | VARBIT | VALUESET | LIST | VOID | `_
  | identifier | typeIdentifier | stringLiteral | number
  | `&&& | `.. | `<< | `&& | `|| 
  | `== | `!= | `>= | `<=  | `++
  | `+ | `|+| | `- | `|-| | `*
  | `/ | `% | `| | `& | `^
  | `~ | ``[ | ``] | ``{ | ``}
  | ``< | ``> | `! | `: | `,
  | `? | `. | `= | `; | `@

syntax annotationBody =
  | `EMPTY
  | annotationBody `( annotationBody )
  | annotationBody annotationToken

syntax structuredAnnotationBody =
  recordExpression optTrailingComma

syntax annotation =
  | `@ name
  | `@ name `( annotationBody )
  | `@ name `[ structuredAnnotationBody ]

syntax annotations =
  | `EMPTY
  | annotation
  | annotations annotation

syntax optAnnotations = annotations?

;;
;; P4 program
;;

syntax p4program =
  | `EMPTY
  | p4program declaration
  | p4program `;
