;;
;; Substitution (capture-avoiding)
;;

syntax bound = set<tid>
syntax theta = map<tid, typeIR>

dec $fresh_tid() : tid
dec $fresh_tids(nat) : tid*

def $fresh_tids(0) = eps
def $fresh_tids(n) = $fresh_tid() :: $fresh_tids($(n - 1))
  -- otherwise

dec $free_type(typeIR) : bound
dec $free_typeDef(typeDefIR) : bound
dec $free_funcType(funcTypeIR) : bound
dec $free_funcTypeDef(funcTypeDefIR) : bound

dec $subst_type(theta, typeIR) : typeIR
dec $subst_typeDef(theta, typeDefIR) : typeDefIR
dec $subst_funcType(theta, funcTypeIR) : funcTypeIR
dec $subst_funcTypeDef(theta, funcTypeDefIR) : funcTypeDefIR
dec $subst_consType(theta, consTypeIR) : consTypeIR

;;
;;;; Free type variables in types
;;

;;; Base types

def $free_type(baseTypeIR) = `{ eps }

;;; Named types

def $free_type(TID tid) = `{ tid }

def $free_type(polyTypeDefIR `< typeIR* >)
  = $union_set<tid>(bound_base, bound_args)
  -- if bound_base = $free_typeDef(polyTypeDefIR)
  -- if bound_args = $unions_set<tid>($free_type(typeIR)*)

;;; Typedef types

def $free_type(TYPEDEF _ typeIR) = $free_type(typeIR)

def $free_type(TYPE _ typeIR) = $free_type(typeIR)

;;; Data types

def $free_type(LIST `< typeIR >) = $free_type(typeIR)

def $free_type(TUPLE `< typeIR* >)
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(typeIR `[ _ ]) = $free_type(typeIR)

def $free_type(HEADER _ `{ (typeIR, _)* })
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(HEADER_UNION _ `{ (typeIR, _)* })
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(STRUCT _ `{ (typeIR, _)* })
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(ENUM _ `{ _ }) = `{ eps }

def $free_type(ENUM typeIR _ `{ _ }) = $free_type(typeIR)

;;; Object types

def $free_type(EXTERN _ (`{ (_ `: funcTypeDefIR)* }))
  = $unions_set<tid>($free_funcTypeDef(funcTypeDefIR)*)

def $free_type(PARSER `( paramTypeIR* ))
  = $unions_set<tid>($free_type(typeIR)*)
  -- if (_ _ typeIR _ = paramTypeIR)*

def $free_type(CONTROL `( paramTypeIR* ))
  = $unions_set<tid>($free_type(typeIR)*)
  -- if (_ _ typeIR _ = paramTypeIR)*

def $free_type(PACKAGE `< typeIR* >)
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(TABLE _ `{ typeIR }) = $free_type(typeIR)

;;; Synthesized types

def $free_type(DEFAULT) = `{ eps }

def $free_type(SEQ `< typeIR* >)
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(SEQ `< typeIR* `, `... >)
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(RECORD `{ (typeIR, _)* })
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(RECORD `{ (typeIR, _)* `, `... })
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(INVALID) = `{ eps }

def $free_type(SET `< typeIR* >)
  = $unions_set<tid>($free_type(typeIR)*)

def $free_type(PARSERSTATE) = `{ eps }

def $free_type(ENUM_TABLE _ `{ _ }) = `{ eps }

def $free_type(STRUCT_TABLE _ `{ _ }) = `{ eps }

def $free_type(`_) = `{ eps }

;;
;;;; Free type variables in type definitions
;;

def $free_typeDef(typeIR) = $free_type(typeIR)

def $free_typeDef(typeIR_base `< tid* `, tid_hidden* >)
  = $diff_set<tid>(bound_base, bound_tparams)
  -- if bound_base = $free_typeDef(typeIR_base)
  -- if bound_tparams = `{ tid* ++ tid_hidden* }

;;
;;;; Free type variables in function types
;;

def $free_funcType(ACTION `( paramTypeIR*))
  = $unions_set<tid>($free_type(typeIR)*)
  -- if (_ _ typeIR _ = paramTypeIR)*

def $free_funcType(
    EXTERN_FUNC `( paramTypeIR* ) -> typeIR_ret
  )
  = $union_set<tid>(bound_params, bound_ret)
  -- if (_ _ typeIR _ = paramTypeIR)*
  -- if bound_params
      = $unions_set<tid>($free_type(typeIR)*)
  -- if bound_ret = $free_type(typeIR_ret)

def $free_funcType(
    FUNC `( paramTypeIR* ) -> typeIR_ret
  )
  = $union_set<tid>(bound_params, bound_ret)
  -- if (_ _ typeIR _ = paramTypeIR)*
  -- if bound_params = $unions_set<tid>($free_type(typeIR)*)
  -- if bound_ret = $free_type(typeIR_ret)

def $free_funcType(
    BUILTIN `( paramTypeIR* ) -> typeIR_ret
  )
  = $union_set<tid>(bound_params, bound_ret)
  -- if (_ _ typeIR _ = paramTypeIR)*
  -- if bound_params = $unions_set<tid>($free_type(typeIR)*)
  -- if bound_ret = $free_type(typeIR_ret)

def $free_funcType(
    EXTERN_METHOD `( paramTypeIR* ) -> typeIR_ret
  )
  = $union_set<tid>(bound_params, bound_ret)
  -- if (_ _ typeIR _ = paramTypeIR)*
  -- if bound_params = $unions_set<tid>($free_type(typeIR)*)
  -- if bound_ret = $free_type(typeIR_ret)

def $free_funcType(
    EXTERN_ABSTRACT_METHOD `( paramTypeIR* ) -> typeIR_ret
  )
  = $union_set<tid>(bound_params, bound_ret)
  -- if (_ _ typeIR _ = paramTypeIR)*
  -- if bound_params
      = $unions_set<tid>($free_type(typeIR)*)
  -- if bound_ret = $free_type(typeIR_ret)

def $free_funcType(PARSER_APPLY `( paramTypeIR* ))
  = $unions_set<tid>($free_type(typeIR)*)
  -- if (_ _ typeIR _ = paramTypeIR)*

def $free_funcType(CONTROL_APPLY `( paramTypeIR* ))
  = $unions_set<tid>($free_type(typeIR)*)
  -- if (_ _ typeIR _ = paramTypeIR)*

def $free_funcType(
    TABLE_APPLY -> typeIR_ret
  )
  = $free_type(typeIR_ret)

;;
;;;; Free type variables in function type definitions
;;

def $free_funcTypeDef(funcTypeIR)
  = $free_funcType(funcTypeIR)

def $free_funcTypeDef(
    funcTypeIR_base `< tid* `, tid_hidden* >
  )
  = $diff_set<tid>(bound_base, bound_tparams)
  -- if bound_base = $free_funcTypeDef(funcTypeIR_base)
  -- if bound_tparams = `{ tid* ++ tid_hidden* }

;;
;;;; Type substitutions
;;

def $subst_type(theta, TID tid) = typeIR
  -- if typeIR = $find_map<tid, typeIR>(theta, tid)

def $subst_type(theta, polyTypeDefIR `< typeIR* >)
  = polyTypeDefIR_subst `< typeIR_subst* >
  -- if polyTypeDefIR_subst
      = $subst_typeDef(theta, polyTypeDefIR)
  -- if (typeIR_subst = $subst_type(theta, typeIR))*

def $subst_type(theta, TYPEDEF tid typeIR)
  = TYPEDEF tid typeIR_subst
  -- if typeIR_subst = $subst_type(theta, typeIR)

def $subst_type(theta, TYPE tid typeIR)
  = TYPE tid typeIR_subst
  -- if typeIR_subst = $subst_type(theta, typeIR)

def $subst_type(theta, LIST `< typeIR >)
  = LIST `< typeIR_subst >
  -- if typeIR_subst = $subst_type(theta, typeIR)

def $subst_type(theta, TUPLE `< typeIR* >)
  = TUPLE `< typeIR_subst* >
  -- if (typeIR_subst = $subst_type(theta, typeIR))*

def $subst_type(theta, typeIR `[ n ])
  = typeIR_subst `[ n ]
  -- if typeIR_subst = $subst_type(theta, typeIR)

def $subst_type(
    theta,
    HEADER tid `{ (typeIR_f, id_f)* }
  )
  = HEADER tid `{ (typeIR_f_subst, id_f)* }
  -- if (typeIR_f_subst = $subst_type(theta, typeIR_f))*

def $subst_type(
    theta,
    HEADER_UNION tid `{ (typeIR_f, id_f)* }
  )
  = HEADER_UNION tid `{ (typeIR_f_subst, id_f)* }
  -- if (typeIR_f_subst = $subst_type(theta, typeIR_f))*

def $subst_type(
    theta,
    STRUCT tid `{ (typeIR_f, id_f)* }
  )
  = STRUCT tid `{ (typeIR_f_subst, id_f)* }
  -- if (typeIR_f_subst = $subst_type(theta, typeIR_f))*

def $subst_type(
    theta,
    ENUM typeIR tid `{ (id_f, val_f)* }
  )
  = ENUM typeIR_subst tid `{ (id_f, val_f)* }
  -- if typeIR_subst = $subst_type(theta, typeIR)

def $subst_type(
    theta,
    EXTERN tid (`{ (fid `: funcTypeDefIR)* })
  )
  = EXTERN tid (`{ (fid `: funcTypeDefIR_subst)* })
  -- if (funcTypeDefIR_subst
        = $subst_funcTypeDef(theta, funcTypeDefIR))*

def $subst_type(theta, PARSER `( paramTypeIR* ))
  = PARSER `( paramTypeIR_subst* )
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
        = id direction typeIR_subst val?)*

def $subst_type(theta, CONTROL `( paramTypeIR* ))
  = PARSER `( paramTypeIR_subst* )
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
        = id direction typeIR_subst val?)*

def $subst_type(theta, PACKAGE `< typeIR* >)
  = PACKAGE `< typeIR_subst* >
  -- if (typeIR_subst = $subst_type(theta, typeIR))*

def $subst_type(theta, TABLE tid `{ typeIR })
  = TABLE tid `{ typeIR_subst }
  -- if typeIR_subst = $subst_type(theta, typeIR)

def $subst_type(theta, SEQ `< typeIR* >)
  = SEQ `< typeIR_subst* >
  -- if (typeIR_subst = $subst_type(theta, typeIR))*

def $subst_type(theta, SEQ `< typeIR* `, `... >)
  = SEQ `< typeIR_subst* `, `... >
  -- if (typeIR_subst = $subst_type(theta, typeIR))*

def $subst_type(
    theta,
    RECORD `{ (typeIR_f, id_f)* }
  )
  = RECORD `{ (typeIR_f_subst, id_f)* }
  -- if (typeIR_f_subst = $subst_type(theta, typeIR_f))*

def $subst_type(
    theta,
    RECORD `{ (typeIR_f, id_f)* `, `... }
  )
  = RECORD `{ (typeIR_f_subst, id_f)* `, `... }
  -- if (typeIR_f_subst = $subst_type(theta, typeIR_f))*

def $subst_type(theta, SET `< typeIR* >)
  = SET `< typeIR_subst* >
  -- if (typeIR_subst = $subst_type(theta, typeIR))*

def $subst_type(theta, typeIR) = typeIR
  -- otherwise

;;
;;;; Type definition substitutions
;;

def $subst_typeDef(theta, typeIR) = $subst_type(theta, typeIR)

def $subst_typeDef(theta, typeIR_base `< tid* `, tid_hidden* >)
  = typeIR_base_subst `< tid_fresh* `, tid_fresh_hidden* >
  -- if `{ tid_free* } = $diff_set<tid>(
                            $free_type(typeIR_base),
                            `{ tid* ++ tid_hidden* })
  -- if (typeIR_free = $find_map<tid, typeIR>(theta, tid_free))*
  -- if bound_capture = $unions_set<tid>($free_type(typeIR_free)*)
  -- if tid_fresh* = $fresh_tids(|tid* ++ tid_hidden*|)
  -- if (~$in_set<tid>(tid_fresh, bound_capture))*
  -- if tid_fresh_spec* = tid_fresh*[0 : |tid*|]
  -- if tid_fresh_hidden* = tid_fresh*[|tid*| : |tid_hidden*|]
  -- if theta' = $adds_map<tid, typeIR>(
                    theta, tid*, (TID tid_fresh_spec)*)
  -- if theta'' = $adds_map<tid, typeIR>(
                    theta', tid_hidden*, (TID tid_fresh_hidden)*)
  -- if typeIR_base_subst = $subst_type(theta'', typeIR_base)

;;
;;;; Function type substitutions
;;

def $subst_funcType(theta, ACTION `( paramTypeIR* ))
  = ACTION `( paramTypeIR_subst* )
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
      = id direction typeIR_subst val?)*

def $subst_funcType(
    theta,
    EXTERN_FUNC `( paramTypeIR* ) -> typeIR_ret
  )
  = EXTERN_FUNC `( paramTypeIR_subst* ) -> typeIR_ret_subst
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
        = id direction typeIR_subst val?)*
  -- if typeIR_ret_subst = $subst_type(theta, typeIR_ret)

def $subst_funcType(
    theta,
    FUNC `( paramTypeIR* ) -> typeIR_ret
  )
  = FUNC `( paramTypeIR_subst* ) -> typeIR_ret_subst
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
        = id direction typeIR_subst val?)*
  -- if typeIR_ret_subst = $subst_type(theta, typeIR_ret)

def $subst_funcType(
    theta,
    BUILTIN `( paramTypeIR* ) -> typeIR_ret
  )
  = BUILTIN `( paramTypeIR_subst* ) -> typeIR_ret_subst
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
        = id direction typeIR_subst val?)*
  -- if typeIR_ret_subst = $subst_type(theta, typeIR_ret)

def $subst_funcType(
    theta,
    EXTERN_METHOD `( paramTypeIR* ) -> typeIR_ret
  )
  = EXTERN_METHOD `( paramTypeIR_subst* ) -> typeIR_ret_subst
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
        = id direction typeIR_subst val?)*
  -- if typeIR_ret_subst = $subst_type(theta, typeIR_ret)

def $subst_funcType(
    theta,
    EXTERN_ABSTRACT_METHOD `( paramTypeIR* ) -> typeIR_ret
  )
  = EXTERN_ABSTRACT_METHOD `( paramTypeIR_subst* ) -> typeIR_ret_subst
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
        = id direction typeIR_subst val?)*
  -- if typeIR_ret_subst = $subst_type(theta, typeIR_ret)

def $subst_funcType(theta, PARSER_APPLY `( paramTypeIR* ))
  = PARSER_APPLY `( paramTypeIR_subst* )
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
      = id direction typeIR_subst val?)*

def $subst_funcType(theta, CONTROL_APPLY `( paramTypeIR* ))
  = CONTROL_APPLY `( paramTypeIR_subst* )
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
      = id direction typeIR_subst val?)*

def $subst_funcType(theta, TABLE_APPLY -> typeIR_ret)
  = TABLE_APPLY -> typeIR_ret_subst
  -- if typeIR_ret_subst = $subst_type(theta, typeIR_ret)

;;
;;;; Function type definition substitutions
;;

def $subst_funcTypeDef(theta, funcTypeIR) = $subst_funcType(theta, funcTypeIR)

def $subst_funcTypeDef(theta, funcTypeIR `< tid* `, tid_hidden* >)
  = funcTypeIR_subst `< tid_fresh* `, tid_fresh_hidden* >
  -- if `{ tid_free* } = $diff_set<tid>(
                            $free_funcType(funcTypeIR),
                            `{ tid* ++ tid_hidden* })
  -- if (typeIR_free = $find_map<tid, typeIR>(theta, tid_free))*
  -- if bound_capture = $unions_set<tid>($free_type(typeIR_free)*)
  -- if tid_fresh* = $fresh_tids(|tid* ++ tid_hidden*|)
  -- if (~$in_set<tid>(tid_fresh, bound_capture))*
  -- if tid_fresh_spec* = tid_fresh*[0 : |tid*|]
  -- if tid_fresh_hidden* = tid_fresh*[|tid*| : |tid_hidden*|]
  -- if theta' = $adds_map<tid, typeIR>(
                    theta, tid*, (TID tid_fresh_spec)*)
  -- if theta'' = $adds_map<tid, typeIR>(
                    theta', tid_hidden*, (TID tid_fresh_hidden)*)
  -- if funcTypeIR_subst = $subst_funcType(theta'', funcTypeIR)

;;
;;;; Constructor type substitutions
;;

def $subst_consType(theta, `( paramTypeIR* ) -> typeIR_obj)
  = `( paramTypeIR_subst* ) -> typeIR_obj_subst
  -- if (id direction typeIR val? = paramTypeIR)*
  -- if (typeIR_subst = $subst_type(theta, typeIR))*
  -- if (paramTypeIR_subst
      = id direction typeIR_subst val?)*
  -- if typeIR_obj_subst = $subst_type(theta, typeIR_obj)

;;
;; Specializations
;;

;;
;;;; Typedef specializations
;;

dec $specialize_typeDef(typeDefIR, typeIR*) : typeIR

def $specialize_typeDef(typeIR, eps) = typeIR

def $specialize_typeDef(typeIR_base `< tid* `, tid_hidden* >, typeIR_arg*)
  = $subst_type(theta, typeIR_base)
  -- if tid_tparam* = tid* ++ tid_hidden*
  -- if theta = `{ (tid_tparam `: typeIR_arg)* }

;;
;;;; Function type definition specializations
;;

dec $specialize_funcTypeDef(funcTypeDefIR, typeIR*) : (funcTypeDefIR, tid*)

def $specialize_funcTypeDef(funcTypeIR, eps) = (funcTypeIR, eps)

def $specialize_funcTypeDef(
    funcTypeIR `< tid* `, tid_hidden* >,
    typeIR_arg*
  )
  = ($subst_funcType(theta, funcTypeIR), eps)
  -- if tid_tparam* = tid* ++ tid_hidden*
  -- if |tid_tparam*| = |typeIR_arg*|
  -- if theta = `{ (tid_tparam `: typeIR_arg)* }

def $specialize_funcTypeDef(
    funcTypeIR `< tid* `, tid_hidden* >,
    typeIR_arg*
  )
  = ($subst_funcType(theta, funcTypeIR), tid_fresh*)
  -- if tid_tparam* = tid* ++ tid_hidden*
  -- if $(|tid_tparam*| > 0) /\ $(|typeIR_arg*| = 0)
  -- if tid_fresh* = $fresh_tids(|tid_tparam*|)
  -- if theta = `{ (tid_tparam `: (TID tid_fresh))* }

def $specialize_funcTypeDef(
    funcTypeIR `< tid* `, tid_hidden* >,
    typeIR_arg*
  )
  = ($subst_funcType(theta, funcTypeIR), tid_fresh*)
  -- if tid_tparam* = tid* ++ tid_hidden*
  -- if $(|tid_hidden*| > 0)
        /\ $(|tid*| = |typeIR_arg*|)
        /\ $(|typeIR_arg*| > 0)
  -- if tid_fresh* = $fresh_tids(|tid_hidden*|)
  -- if typeIR_arg_new* = typeIR_arg* ++ (TID tid_fresh)*
  -- if theta = `{ (tid_tparam `: typeIR_arg_new)* }

;;
;;;; Constructor type definition specializations
;;

dec $specialize_consTypeDef(consTypeDefIR, typeIR*) : (consTypeIR, tid*)

def $specialize_consTypeDef(
    consTypeIR `< tid* `, tid_hidden* >,
    typeIR_arg*
  )
  = ($subst_consType(theta, consTypeIR), eps)
  -- if tid_tparam* = tid* ++ tid_hidden*
  -- if |tid_tparam*| = |typeIR_arg*|
  -- if theta = `{ (tid_tparam `: typeIR_arg)* }

def $specialize_consTypeDef(
    consTypeIR `< tid* `, tid_hidden* >,
    typeIR_arg*
  )
  = ($subst_consType(theta, consTypeIR), tid_fresh*)
  -- if tid_tparam* = tid* ++ tid_hidden*
  -- if $(|tid_tparam*| > 0) /\ $(|typeIR_arg*| = 0)
  -- if tid_fresh* = $fresh_tids(|tid_tparam*|)
  -- if theta = `{ (tid_tparam `: (TID tid_fresh))* }

def $specialize_consTypeDef(
    consTypeIR `< tid* `, tid_hidden* >,
    typeIR_arg*
  )
  = ($subst_consType(theta, consTypeIR), tid_fresh*)
  -- if tid_tparam* = tid* ++ tid_hidden*
  -- if $(|tid_hidden*| > 0)
        /\ $(|tid*| = |typeIR_arg*|)
        /\ $(|typeIR_arg*| > 0)
  -- if tid_fresh* = $fresh_tids(|tid_hidden*|)
  -- if typeIR_arg_new* = typeIR_arg* ++ (TID tid_fresh)*
  -- if theta = `{ (tid_tparam `: typeIR_arg_new)* }

;;
;; Canonicalization
;; recursive specialization and typedef unrolling
;;

dec $canon(typeIR) : typeIR

def $canon(polyTypeDefIR `< typeIR_arg* >) = $canon(typeIR)
  -- if typeIR = $specialize_typeDef(polyTypeDefIR, typeIR_arg*)

def $canon(TYPEDEF _ typeIR) = $canon(typeIR)

def $canon(typeIR) = typeIR
  -- otherwise
