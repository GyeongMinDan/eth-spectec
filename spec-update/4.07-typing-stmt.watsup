;;
;; L-value typing
;;
;; syntax lvalue
;;

;;; | prefixedNonTypeName
;;;; syntax prefixedNonTypeName

;;;; | nonTypeName

rule Lval_ok/prefixedNonTypeName-nonTypeName:
  p C |- nonTypeName : nonTypeName typeIR
  -- if id = $id(nonTypeName)
  -- if typeIR direction _ ctk = $find_var(p, C, id)
  -- if direction = OUT \/ direction = INOUT
  -- if ctk = DYN

;;;; | dotPrefix nonTypeName

rule Lval_ok/prefixedNonTypeName-nonTypeName:
  p C |- `. nonTypeName : nonTypeName typeIR
  -- if id = $id(nonTypeName)
  -- if typeIR direction _ ctk = $find_var(GLOBAL, C, id)
  -- if direction = OUT \/ direction = INOUT
  -- if ctk = DYN

;;; | THIS

;;; | lvalue `. member

;;; | lvalue `[ expression ]

;;; | lvalue `[ expression `: expression ]

;;; | `( lvalue )

;;
;; Statement typing (including declaration statements)
;;
;; syntax statementOrDeclaration
;;

;;; | variableDeclaration

;;; | constantDeclaration

rule Stmt_ok/constantdeclaration:
  p C f |- constantDeclaration : C' f constantDeclarationIR
  -- Decl_ok: p C |- constantDeclaration : C' constantDeclarationIR

;;; | statement
;;; syntax statement

;;;; | assignmentOrMethodCallStatement
;;;; syntax assignmentOrMethodCallStatement =
;;;;   assignmentOrMethodCallStatementWithoutSemicolon `;

;;;;; syntax assignmentOrMethodCallStatementWithoutSemicolon

;;;;;; | lvalue `( argumentList )

rule Stmt_ok/assignmentOrMethodCallStatement-lvalue-argumentList:
  p C f |- (lvalue `( argumentList )) `;
         : C f ((lvalueIR `( argumentListIR_cast )) `;)
  ---- ;; check arguments
  -- Args_ok: p C |- argumentList : typedArgumentListIR
  ---- ;; check lvalue
  -- Method_ok: p C |- lvalue `< `EMPTY > `( typedArgumentListIR )
                     : lvalueIR `< `# eps > `( `# id_default* ) `@ funcTypeIR
  ---- ;; check call convention
  -- Call_ok: p C |- funcTypeIR `< `EMPTY `# eps > `( typedArgumentListIR `# id_default* )
                   : typeIR `< `EMPTY > `( argumentListIR_cast )

;;;;;; | lvalue `< typeArgumentList > `( argumentList )

;;;;;; | lvalue `= expression

rule Stmt_ok/assignmentOrMethodCallStatement-lvalue-eq-expression:
  p C f |- (lvalue `= expression) `;
         : C f ((lvalueIR `= expressionIR_cast) `;)
  ---- ;; check lvalue
  -- Lval_ok: p C |- lvalue : lvalueIR typeIR
  ---- ;; check expression
  -- Expr_ok: p C |- expression : expressionIR
  ---- ;; check type compatibility
  -- if expressionIR_cast
      = $coerce_unary(expressionIR, typeIR)

;;;;;; | lvalue `+= expression

;;;;;; | lvalue `|+|= expression

;;;;;; | lvalue `-= expression

;;;;;; | lvalue `|-|= expression

;;;;;; | lvalue `*= expression

;;;;;; | lvalue `/= expression

;;;;;; | lvalue `%= expression

;;;;;; | lvalue `<<= expression

;;;;;; | lvalue `>>= expression

;;;;;; | lvalue `&= expression

;;;;;; | lvalue `^= expression

;;;;;; | lvalue `|= expression

;;;; | directApplication
;;;; syntax directApplication = namedType `. APPLY `( argumentList ) `;

;;;; | conditionalStatement
;;;; syntax conditionalStatement =
;;;;   | IF `( expression ) statement
;;;;   | IF `( expression ) statement ELSE statement

rule Stmt_ok/conditionalstatement-noelse:
  p C f |- IF `( expression_c ) statement_t
        : C f (IF `( expressionIR_c ) statementIR_t)
  -- Expr_ok: p C |- expression_c : expressionIR_c
  -- if _ `( BOOL `; _) = expressionIR_c
  -- Stmt_ok: p C f |- statement_t : C_t f_t statementIR_t

rule Stmt_ok/conditionalstatement-else:
  p C f |- IF `( expression_c ) statement_t ELSE statement_f
        : C f_join (IF `( expressionIR_c ) statementIR_t)
  -- Expr_ok: p C |- expression_c : expressionIR_c
  -- if _ `( BOOL `; _) = expressionIR_c
  -- Stmt_ok: p C f |- statement_t : C_t f_t statementIR_t
  -- Stmt_ok: p C f |- statement_f : C_f f_f statementIR_f
  -- if f_join = $join_flow(f_t, f_f)

;;;; | emptyStatement
;;;; syntax emptyStatement = `;

rule Stmt_ok/emptystatement:
  p C f |- `; : C f `;

;;;; | blockStatement
;;;; syntax blockStatement = optAnnotations `{ statOrDeclList }

rule Block_ok/init:
  C f INIT |- optAnnotations `{ statOrDeclList }
            : C' f' (optAnnotations `{ statOrDeclListIR })
  -- Stmts_ok: LOCAL C f |- statOrDeclList
                          : C' f' statOrDeclListIR

rule Block_ok/noinit:
  C f NOINIT |- optAnnotations `{ statOrDeclList }
              : C_exit f_end (optAnnotations `{ statOrDeclListIR })
  -- if C_enter = $enter(C)
  -- Stmts_ok: LOCAL C_enter f |- statOrDeclList
                                : C_end f_end statOrDeclListIR
  -- if C_exit = $exit(C_end)

;;;; | returnStatement
;;;; syntax returnStatement =
;;;;   | RETURN `;
;;;;   | RETURN expression `;

rule Stmt_ok/return:
  LOCAL C f |- RETURN `; : C RET (RETURN `;)
  -- if VOID = $return(C.LOCAL)

rule Stmt_ok/return-expression:
  LOCAL C f |- RETURN expression `;
            : C RET (RETURN expressionIR_cast `;)
  -- Expr_ok: LOCAL C |- expression : expressionIR
  -- if typeIR_ret = $return(C.LOCAL)
  -- if expressionIR_cast = $coerce_unary(expressionIR, typeIR_ret)

;;;; | breakStatement
;;;; syntax breakStatement = BREAK `;

;;;; | continueStatement
;;;; syntax continueStatement = CONTINUE `;

;;;; | exitStatement
;;;; syntax exitStatement = EXIT `;

rule Stmt_ok/exit:
  p C f |- EXIT `; : C f (EXIT `;)

;;;; | switchStatement
;;;; syntax switchStatement = SWITCH `( expression ) `{ switchCases }

;;;; | forStatement
;;;; syntax forStatement =
;;;;   | optAnnotations FOR `( forInitStatements `; expression `; forUpdateStatements ) statement
;;;;   | optAnnotations FOR `( typeRef name IN forCollectionExpr ) statement
;;;;   | optAnnotations FOR `( annotations typeRef name IN forCollectionExpr ) statement

;;
;; Statement list typing (including declaration statements)
;;
;; syntax statOrDeclList
;;

rule Stmts_ok/empty:
  p C f |- `EMPTY : C f `EMPTY

rule Stmts_ok/statementOrDeclaration:
  p C f |- statementOrDeclaration
         : C' f' statementOrDeclarationIR
  -- Stmt_ok: p C f |- statementOrDeclaration
                     : C' f' statementOrDeclarationIR

rule Stmts_ok/statOrDeclList-statementOrDeclaration:
  p C f |- statOrDeclList statementOrDeclaration
         : C'' f'' (statOrDeclListIR statementOrDeclarationIR)
  -- Stmts_ok: p C f |- statOrDeclList : C' f' statOrDeclListIR
  -- Stmt_ok: p C' f' |- statementOrDeclaration
                     : C'' f'' statementOrDeclarationIR

;;
;; Control body typing
;;
;; syntax controlBody = blockStatement
;;

rule ControlBody_ok:
  C |- controlBody : C' f controlBodyIR
  -- Block_ok: C CONT INIT |- controlBody : C' f controlBodyIR
