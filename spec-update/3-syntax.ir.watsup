;;
;; Parameters
;;

;; Forward declarations

syntax initializerIR

syntax parameterIR =
  | optAnnotations direction typeIR name
  | optAnnotations direction typeIR name initializerIR

syntax parameterListIR =
  | `EMPTY
  | parameterIR
  | parameterListIR `, parameterIR

;;
;; Constructor parameters
;;

syntax constructorParametersIR = `( parameterListIR )

syntax optConstructorParametersIR = constructorParametersIR?

;;
;; Expressions
;;

;;
;; Expression key-value pairs
;;

;; Forward declarations

syntax expressionIR

syntax kvPairIR = name `= expressionIR

syntax kvListIR =
  | `EMPTY
  | kvPairIR
  | kvListIR `, kvPairIR

syntax kvListNonEmptyIR =
  | kvPairIR
  | kvListNonEmptyIR `, kvPairIR

;; Forward declarations

syntax typeArgListIR
syntax argumentListIR
syntax accessBaseNonBraceIR, accessBaseIR
syntax callBaseNonBraceIR, callBaseIR
syntax nonBraceExpressionInnerIR
syntax recordExpressionIR
syntax expressionInnerIR
syntax expressionListIR

syntax noteIL = `( typeIR `; ctk )

syntax nonBraceExpressionIR = nonBraceExpressionInnerIR noteIL

syntax nonBraceExpressionInnerIR =
  | number
  | stringLiteral
  | TRUE
  | FALSE
  | THIS
  | nonBraceExpressionIR `[ expressionIR ]
  | nonBraceExpressionIR `[ expressionIR `: expressionIR ]
  | `( expressionIR )
  | `! expressionIR
  | `~ expressionIR
  | `- expressionIR
  | `+ expressionIR
  | accessBaseNonBraceIR `. member
  | nonBraceExpressionIR `* expressionIR
  | nonBraceExpressionIR `/ expressionIR
  | nonBraceExpressionIR `% expressionIR
  | nonBraceExpressionIR `+ expressionIR
  | nonBraceExpressionIR `- expressionIR
  | nonBraceExpressionIR `|+| expressionIR
  | nonBraceExpressionIR `|-| expressionIR
  | nonBraceExpressionIR `<< expressionIR
  | nonBraceExpressionIR `>> expressionIR
  | nonBraceExpressionIR `<= expressionIR
  | nonBraceExpressionIR `>= expressionIR
  | nonBraceExpressionIR ``< expressionIR
  | nonBraceExpressionIR ``> expressionIR
  | nonBraceExpressionIR `!= expressionIR
  | nonBraceExpressionIR `== expressionIR
  | nonBraceExpressionIR `& expressionIR
  | nonBraceExpressionIR `^ expressionIR
  | nonBraceExpressionIR `| expressionIR
  | nonBraceExpressionIR `++ expressionIR
  | nonBraceExpressionIR `&& expressionIR
  | nonBraceExpressionIR `|| expressionIR
  | nonBraceExpressionIR `? expressionIR `: expressionIR
  | nonBraceExpressionIR `< typeArgListIR > `( argumentListIR )
  | callBaseNonBraceIR `( argumentListIR )
  | `( typeIR ) expressionIR

syntax accessBaseNonBraceIR =
  | prefixedTypeName
  | ERROR
  | nonBraceExpression

syntax callBaseNonBraceIR =
  | namedTypeIR
  | nonBraceExpressionIR

syntax expressionIR = expressionInnerIR noteIL

syntax expressionInnerIR =
  | number
  | `...
  | stringLiteral
  | TRUE
  | FALSE
  | THIS
  | prefixedNonTypeName
  | expressionIR `[ expressionIR ]
  | expressionIR `[ expressionIR `: expressionIR ]
  | `{#}
  | `{ recordExpressionIR optTrailingComma }
  | `( expressionIR )
  | `! expressionIR
  | `~ expressionIR
  | `- expressionIR
  | `+ expressionIR
  | prefixedTypeName `. member `ACC_1
  | ERROR `. member
  | expressionIR `. member `ACC_2
  | expressionIR `* expressionIR
  | expressionIR `/ expressionIR
  | expressionIR `% expressionIR
  | expressionIR `+ expressionIR
  | expressionIR `- expressionIR
  | expressionIR `|+| expressionIR
  | expressionIR `|-| expressionIR
  | expressionIR `<< expressionIR
  | expressionIR `>> expressionIR
  | expressionIR `<= expressionIR
  | expressionIR `>= expressionIR
  | expressionIR ``< expressionIR
  | expressionIR ``> expressionIR
  | expressionIR `!= expressionIR
  | expressionIR `== expressionIR
  | expressionIR `& expressionIR
  | expressionIR `^ expressionIR
  | expressionIR `| expressionIR
  | expressionIR `++ expressionIR
  | expressionIR `&& expressionIR
  | expressionIR `|| expressionIR
  | expressionIR `? expressionIR `: expressionIR
  | expressionIR `< typeArgListIR > `( argumentListIR )
  | callBaseIR `( argumentListIR )
  | `( typeIR ) expressionIR

syntax expressionListIR =
  | `EMPTY
  | expressionIR
  | expressionListIR `, expressionIR

syntax accessBaseIR =
  | prefixedTypeName
  | ERROR
  | expressionIR

syntax callBaseIR =
  | namedTypeIR
  | expressionIR

syntax kvPairRecordExpressionIR =
  | name `= expressionIR
  | name `= expressionIR `, `...
  | name `= expressionIR `, kvListNonEmptyIR
  | name `= expressionIR `, kvListNonEmptyIR `, `...

syntax recordExpressionIR =
  | expressionListIR
  | kvPairRecordExpressionIR

;;
;; Keyset expressions
;;

syntax simpleKeysetExpressionIR =
  | expressionIR
  | expressionIR `&&& expressionIR
  | expressionIR `.. expressionIR
  | DEFAULT
  | `_

syntax simpleExpressionListIR =
  | `EMPTY
  | simpleKeysetExpressionIR
  | simpleExpressionListIR `, simpleKeysetExpressionIR

syntax tupleKeySetExpressionIR =
  | `( simpleKeysetExpressionIR `, simpleExpressionListIR )
  | `( expressionIR `&&& expressionIR )
  | `( expressionIR `.. expressionIR )
  | `( DEFAULT )
  | `( `_ )

syntax keysetExpressionIR =
  | tupleKeySetExpressionIR
  | simpleKeysetExpressionIR

;;
;; Type arguments
;;

syntax typeArgIR = typeIR

syntax typeArgListIR =
  | `EMPTY
  | typeArgIR
  | typeArgListIR `, typeArgIR

;;
;; Arguments
;;

syntax argumentIR =
  | expressionIR
  | name `= expressionIR
  | `_
  | name `= `_

syntax argumentListIR =
  | `EMPTY
  | argumentIR
  | argumentListIR `, argumentIR

syntax typedArgumentIR = argumentIR `@ typeIR

syntax typedArgumentListIR =
  | `EMPTY
  | typedArgumentIR
  | typedArgumentListIR `, typedArgumentIR

;;
;; L-values
;;

syntax lvalueIR =
  | prefixedNonTypeName
  | THIS
  | lvalueIR `. member
  | lvalue `[ expressionIR ]
  | lvalueIR `[ expressionIR `: expressionIR ]
  | `( lvalueIR )

;;
;; Statements and declarations
;;

;; Forward declarations

syntax statementIR, parserStatementsIR, statOrDeclListIR
syntax objDeclarationsIR
syntax annotationsIR, optAnnotationsIR

;;
;; Variable and constant declarations
;;

syntax initializerIR = `= val

syntax optInitializerIR = initializerIR?

syntax variableDeclarationWithoutSemicolonIR =
  optAnnotations typeIR name optInitializerIR

syntax variableDeclarationIR =
  optAnnotations typeIR name optInitializerIR `;

syntax constantDeclarationIR =
  optAnnotations CONST typeIR name initializerIR `;

;;
;;;; Assignment and method call statements
;;

syntax assignmentOrMethodCallStatementWithoutSemicolonIR =
  | lvalueIR `( argumentListIR )
  | lvalueIR `< typeArgListIR > `( argumentListIR )
  | lvalueIR `= expressionIR
  | lvalueIR `+= expressionIR
  | lvalueIR `|+|= expressionIR
  | lvalueIR `-= expressionIR
  | lvalueIR `|-|= expressionIR
  | lvalueIR `*= expressionIR
  | lvalueIR `/= expressionIR
  | lvalueIR `%= expressionIR
  | lvalueIR `<<= expressionIR
  | lvalueIR `>>= expressionIR
  | lvalueIR `&= expressionIR
  | lvalueIR `^= expressionIR
  | lvalueIR `|= expressionIR

syntax assignmentOrMethodCallStatementIR =
  assignmentOrMethodCallStatementWithoutSemicolonIR `;

;;
;;;; Direct application statements
;;

syntax directApplicationIR =
  | namedTypeIR `. APPLY `( argumentListIR ) `;

;;
;;;; Conditional statements
;;

syntax conditionalStatementIR =
  | IF `( expressionIR ) statementIR
  | IF `( expressionIR ) statementIR ELSE statementIR

;;
;;;; Empty statements
;;

syntax emptyStatementIR = `;

;;
;;;; Block statements
;;

syntax blockStatementIR = optAnnotations `{ statOrDeclListIR }

;;
;;;; Return statements
;;

syntax returnStatementIR =
  | RETURN `;
  | RETURN expressionIR `;

;;
;;;; Break statements
;;

syntax breakStatementIR = BREAK `;

;;
;;;; Continue statements
;;

syntax continueStatementIR = CONTINUE `;

;;
;;;; Exit statements
;;

syntax exitStatementIR = EXIT `;

;;
;;;; Switch statements
;;

syntax switchLabelIR =
  | DEFAULT
  | nonBraceExpressionIR

syntax switchCaseIR =
  | switchLabelIR `: blockStatementIR
  | switchLabelIR `: 

syntax switchCasesIR =
  | `EMPTY
  | switchCaseIR
  | switchCasesIR switchCaseIR

syntax switchStatementIR = SWITCH `( expressionIR ) `{ switchCasesIR }

;;
;;;; For statements
;;

syntax declOrAssignmentOrMethodCallStatementIR =
  | variableDeclarationWithoutSemicolonIR
  | assignmentOrMethodCallStatementWithoutSemicolonIR

syntax forInitStatementsIR =
  | `EMPTY
  | declOrAssignmentOrMethodCallStatementIR
  | forInitStatementsIR `, declOrAssignmentOrMethodCallStatementIR

syntax forUpdateStatementsIR =
  | `EMPTY
  | assignmentOrMethodCallStatementWithoutSemicolonIR
  | forUpdateStatementsIR `, assignmentOrMethodCallStatementWithoutSemicolonIR

syntax forCollectionExprIR =
  | expressionIR
  | expressionIR `.. expressionIR

syntax forStatementIR =
  | optAnnotations FOR `( forInitStatementsIR `; expressionIR `; forUpdateStatementsIR ) statementIR
  | optAnnotations FOR `( typeIR name IN forCollectionExprIR ) statementIR
  | optAnnotations FOR `( annotationsIR typeIR name IN forCollectionExprIR ) statementIR

;;
;;;; Statements
;;

syntax statementIR =
  | assignmentOrMethodCallStatementIR
  | directApplicationIR
  | conditionalStatementIR
  | emptyStatementIR
  | blockStatementIR
  | returnStatementIR
  | breakStatementIR
  | continueStatementIR
  | exitStatementIR
  | switchStatementIR
  | forStatementIR

syntax statementOrDeclarationIR =
  | variableDeclarationIR
  | constantDeclarationIR
  | statementIR

syntax statOrDeclListIR =
  | `EMPTY
  | statementOrDeclarationIR
  | statOrDeclListIR statementOrDeclarationIR

;;
;;;; Error and match kind declarations
;;

syntax matchKindDeclarationIR =
  MATCH_KIND `{ nameList optTrailingComma }

syntax errorDeclarationIR = ERROR `{ nameList }

;;
;;;; Extern declarations
;;

syntax functionPrototypeIR =
  typeIR name optTypeParameters `( parameterListIR )

syntax methodPrototypeIR =
  | optAnnotations functionPrototypeIR `;
  | optAnnotations ABSTRACT functionPrototypeIR `;
  | optAnnotations typeIdentifier `( parameterListIR ) `;

syntax methodPrototypesIR =
  | `EMPTY
  | methodPrototypeIR
  | methodPrototypesIR methodPrototypeIR

syntax externDeclarationIR =
  | optAnnotations EXTERN nonTypeName optTypeParameters `{ methodPrototypesIR }
  | optAnnotations EXTERN functionPrototypeIR `;

;;
;;;; Function declarations
;;

syntax functionDeclarationIR =
  optAnnotations functionPrototypeIR blockStatementIR

;;
;;;; Instantiations
;;

syntax objInitializerIR = `= `{ objDeclarationsIR }

syntax instantiationIR =
  | optAnnotations typeIR `( argumentListIR ) name `;
  | optAnnotations typeIR `( argumentListIR ) name objInitializerIR `;

syntax objDeclarationIR =
  | functionDeclarationIR
  | instantiationIR

syntax objDeclarationsIR =
  | `EMPTY
  | objDeclarationIR
  | objDeclarationsIR objDeclarationIR

;;
;;;; Action declarations
;;

syntax actionDeclarationIR =
  optAnnotations ACTION name `( parameterListIR ) blockStatementIR

;;
;;;; Table declarations
;;

;;
;;;;;; Table key property 
;;

syntax keyElementIR =
  expressionIR `: name optAnnotations `;

syntax keyElementListIR =
  | `EMPTY
  | keyElementIR
  | keyElementListIR keyElementIR

;;
;;;;;; Table actions property
;;

syntax actionRefIR =
  | prefixedNonTypeName
  | prefixedNonTypeName `( argumentListIR )

syntax actionIR = optAnnotations actionRefIR `;

syntax actionListIR =
  | `EMPTY
  | actionIR
  | actionListIR actionIR

;;
;;;;;; Table entry property
;;

syntax entryPriorityIR =
  | PRIORITY `= number `: 
  | PRIORITY `= `( expressionIR ) `:

syntax entryIR =
  | optCONST entryPriorityIR keysetExpressionIR `: actionRefIR optAnnotations `; 
  | optCONST keysetExpressionIR `: actionRefIR optAnnotations `; 

syntax entriesListIR =
  | `EMPTY
  | entryIR
  | entriesListIR entryIR

;;
;;;;;; Table properties
;;

syntax tablePropertyIR =
  | KEY `= `{ keyElementListIR }
  | ACTIONS `= `{ actionListIR }
  | optAnnotations optCONST ENTRIES `= `{ entriesListIR }
  ;; (TODO) `= expressionIR should be initializerIR
  | optAnnotations optCONST nonTableKwName `= expressionIR `;

syntax tablePropertyListIR =
  | `EMPTY
  | tablePropertyIR
  | tablePropertyListIR tablePropertyIR

syntax tableDeclarationIR =
  optAnnotations TABLE name `{ tablePropertyListIR }

;;
;;;; Control and control type declarations
;;

syntax controlBodyIR = blockStatementIR

syntax controlLocalDeclarationIR =
  | constantDeclarationIR
  | actionDeclarationIR
  | tableDeclarationIR
  | instantiationIR
  | variableDeclarationIR

syntax controlLocalDeclarationsIR =
  | `EMPTY
  | controlLocalDeclarationIR
  | controlLocalDeclarationsIR controlLocalDeclarationIR

syntax controlTypeDeclarationIR =
  optAnnotations CONTROL name optTypeParameters `( parameterListIR )

syntax controlDeclarationIR =
  controlTypeDeclarationIR optConstructorParametersIR `{ controlLocalDeclarationsIR APPLY controlBodyIR }

;;
;;;; Value set declarations
;;

syntax valueSetDeclarationIR =
  optAnnotations VALUESET `< typeIR > `( expressionIR ) name `; 

;;
;;;; Select expressions
;;

syntax selectCaseIR = keysetExpressionIR `: name `;

syntax selectCaseListIR =
  | `EMPTY
  | selectCaseIR
  | selectCaseListIR selectCaseIR

syntax selectExpressionIR = SELECT `( expressionListIR ) `{ selectCaseListIR }

;;
;;;; Transition statements
;;

syntax stateExpressionIR =
  | name `;
  | selectExpressionIR

syntax transitionStatementIR = TRANSITION stateExpressionIR

;;
;;;; Parser and parser type declarations
;;

syntax parserBlockStatementIR = optAnnotations `{ parserStatementsIR }

syntax parserStatementIR =
  | assignmentOrMethodCallStatementIR
  | directApplicationIR
  | emptyStatementIR
  | variableDeclarationIR
  | constantDeclarationIR
  | parserBlockStatementIR
  | conditionalStatementIR

syntax parserStatementsIR =
  | `EMPTY
  | parserStatementIR
  | parserStatementsIR parserStatementIR

syntax parserStateIR =
  optAnnotations STATE name `{ parserStatementsIR transitionStatementIR }

syntax parserStatesIR =
  | parserStateIR
  | parserStatesIR parserStateIR

syntax parserTypeDeclarationIR =
  optAnnotations PARSER name optTypeParameters `( parameterListIR )

syntax parserLocalElementIR =
  | constantDeclarationIR
  | variableDeclarationIR
  | instantiationIR
  | valueSetDeclarationIR

syntax parserLocalElementsIR =
  | `EMPTY
  | parserLocalElementIR
  | parserLocalElementsIR parserLocalElementIR

syntax parserDeclarationIR =
  parserTypeDeclarationIR optConstructorParametersIR `{ parserLocalElementsIR parserStatesIR }

;;
;;;; Package type declaration
;;

syntax packageTypeDeclarationIR =
  optAnnotations PACKAGE name optTypeParameters `( parameterListIR )

;;
;;;; Enum type declaration
;;

syntax specifiedNameIR = name initializerIR

;; (TODO) Add comma separator as hint?
syntax specifiedNameListIR = specifiedNameIR*

syntax enumDeclarationIR =
  | optAnnotations ENUM name `{ nameList optTrailingComma }
  | optAnnotations ENUM typeIR name `{ specifiedNameListIR optTrailingComma }

;;
;;;; Struct, header, and union type declarations
;;

syntax structFieldIR = optAnnotations typeIR name `;

syntax structFieldListIR =
  | `EMPTY
  | structFieldIR
  | structFieldListIR structFieldIR

syntax headerUnionDeclarationIR =
  optAnnotations HEADER_UNION name optTypeParameters `{ structFieldListIR }

syntax structTypeDeclarationIR =
  optAnnotations STRUCT name optTypeParameters `{ structFieldListIR }

syntax headerTypeDeclarationIR =
  optAnnotations HEADER name optTypeParameters `{ structFieldListIR }

;;
;;;; Derived type declarations
;;

syntax derivedTypeDeclarationIR =
  | headerTypeDeclarationIR
  | headerUnionDeclarationIR
  | structTypeDeclarationIR
  | enumDeclarationIR

;;
;;;; Typedef and newtype declarations
;;

syntax typedefBaseTypeIR =
  | typeIR
  | derivedTypeDeclarationIR

syntax typedefDeclarationIR =
  | optAnnotations TYPEDEF typedefBaseTypeIR name
  | optAnnotations TYPE typeIR name

;;
;;;; Type declarations
;;

syntax typeDeclarationWithoutSemicolonIR =
  | typedefDeclarationIR
  | parserTypeDeclarationIR
  | controlTypeDeclarationIR
  | packageTypeDeclarationIR

syntax typeDeclarationIR =
  | derivedTypeDeclarationIR
  | typeDeclarationWithoutSemicolonIR `;

;;
;;;; Declaration
;;

syntax declarationIR =
  | constantDeclarationIR
  | errorDeclarationIR
  | matchKindDeclarationIR
  | externDeclarationIR
  | instantiationIR
  | functionDeclarationIR
  | actionDeclarationIR
  | parserDeclarationIR
  | controlDeclarationIR
  | typeDeclarationIR

;;
;; Annotations
;;

syntax annotationBodyIR =
  | `EMPTY
  | annotationBodyIR `( annotationBodyIR )
  | annotationBodyIR annotationToken

syntax structuredAnnotationBodyIR =
  recordExpressionIR optTrailingComma

syntax annotationIR =
  | `@ name
  | `@ name `( annotationBodyIR )
  | `@ name `[ structuredAnnotationBodyIR ]

syntax annotationsIR =
  | `EMPTY
  | annotationIR
  | annotationsIR annotationIR

syntax optAnnotationsIR = annotationsIR?

;;
;; P4 program
;;

syntax p4programIR =
  | `EMPTY
  | p4programIR declarationIR
  | p4programIR `;
