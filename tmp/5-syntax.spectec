;;
;; Primitive Types
;;

syntax bytes = int
syntax bytes4 = int
syntax bytes32 = int
syntax bytes1 = int
syntax bytes8 = int
syntax bytes20 = int
syntax bytes28 = int
syntax bytes48 = int
syntax bytes96 = int
syntax bytes256 = int
syntax uint = nat
syntax uint8 = nat
syntax uint64 = nat
syntax uint256 = nat


;;
;; Custom eth2spec Types
;;

syntax slot = uint64
syntax epoch = uint64
syntax validatorIndex = uint64
syntax gwei = uint64
syntax root = bytes32
syntax hash32 = bytes32
syntax version = bytes4
syntax committeeIndex = uint64
syntax boolean = bool
syntax domainType = bytes4
syntax forkDigest = bytes4
syntax domain = bytes32
syntax blsPubkey = bytes48
syntax blsSignature = bytes96
syntax nodeID = bytes256
syntax subnetID = uint64
syntax ether = uint64
syntax participationFlags = uint8
syntax executionAddress = bytes20
syntax payloadId = bytes8
syntax withdrawalIndex = uint64

;;
;; Constants: defined as parameterless functions
;;
dec $UINT64_MAX : uint64
def $UINT64_MAX = 18446744073709551615

dec $UINT64_MAX_SQRT : uint64
def $UINT64_MAX_SQRT = 4294967295

dec $GENESIS_SLOT : slot
def $GENESIS_SLOT = 0

dec $GENESIS_EPOCH : epoch
def $GENESIS_EPOCH = 0

dec $FAR_FUTURE_EPOCH : epoch
def $FAR_FUTURE_EPOCH = 18446744073709551615

dec $BASE_REWARDS_PER_EPOCH : uint64
def $BASE_REWARDS_PER_EPOCH = 4

dec $DEPOSIT_CONTRACT_TREE_DEPTH : uint64
def $DEPOSIT_CONTRACT_TREE_DEPTH = 32

dec $JUSTIFICATION_BITS_LENGTH : uint64
def $JUSTIFICATION_BITS_LENGTH = 4


dec $BLS_WITHDRAWAL_PREFIX : bytes1
def $BLS_WITHDRAWAL_PREFIX = 0        ;; 0x00

dec $ETH1_ADDRESS_WITHDRAWAL_PREFIX : bytes1
def $ETH1_ADDRESS_WITHDRAWAL_PREFIX = 1  ;; 0x01

dec $DOMAIN_BEACON_PROPOSER : domainType
def $DOMAIN_BEACON_PROPOSER = 0           ;; 0x00000000

dec $DOMAIN_BEACON_ATTESTER : domainType
def $DOMAIN_BEACON_ATTESTER = 16777216    ;; 0x01000000

dec $DOMAIN_RANDAO : domainType
def $DOMAIN_RANDAO = 33554432             ;; 0x02000000

dec $DOMAIN_DEPOSIT : domainType
def $DOMAIN_DEPOSIT = 50331648            ;; 0x03000000

dec $DOMAIN_VOLUNTARY_EXIT : domainType
def $DOMAIN_VOLUNTARY_EXIT = 67108864     ;; 0x04000000

dec $DOMAIN_SELECTION_PROOF : domainType
def $DOMAIN_SELECTION_PROOF = 83886080    ;; 0x05000000

dec $DOMAIN_AGGREGATE_AND_PROOF : domainType
def $DOMAIN_AGGREGATE_AND_PROOF = 100663296  ;; 0x06000000

dec $DOMAIN_APPLICATION_MASK : domainType
def $DOMAIN_APPLICATION_MASK = 1          ;; 0x00000001

dec $INTERVALS_PER_SLOT : uint64
def $INTERVALS_PER_SLOT = 3

dec $BASIS_POINTS : uint64
def $BASIS_POINTS = 10000

dec $NODE_ID_BITS : nat
def $NODE_ID_BITS = 256

dec $MAX_CONCURRENT_REQUESTS : nat
def $MAX_CONCURRENT_REQUESTS = 2

dec $TARGET_AGGREGATORS_PER_COMMITTEE_CONST : nat
def $TARGET_AGGREGATORS_PER_COMMITTEE_CONST = 16   ;; 2**4

dec $ETH_TO_GWEI : uint64
def $ETH_TO_GWEI = 1000000000

dec $SAFETY_DECAY : uint64
def $SAFETY_DECAY = 10

dec $TIMELY_SOURCE_FLAG_INDEX : nat
def $TIMELY_SOURCE_FLAG_INDEX = 0

dec $TIMELY_TARGET_FLAG_INDEX : nat
def $TIMELY_TARGET_FLAG_INDEX = 1

dec $TIMELY_HEAD_FLAG_INDEX : nat
def $TIMELY_HEAD_FLAG_INDEX = 2

dec $TIMELY_SOURCE_WEIGHT : uint64
def $TIMELY_SOURCE_WEIGHT = 14

dec $TIMELY_TARGET_WEIGHT : uint64
def $TIMELY_TARGET_WEIGHT = 26

dec $TIMELY_HEAD_WEIGHT : uint64
def $TIMELY_HEAD_WEIGHT = 14

dec $SYNC_REWARD_WEIGHT : uint64
def $SYNC_REWARD_WEIGHT = 2

dec $PROPOSER_WEIGHT : uint64
def $PROPOSER_WEIGHT = 8

dec $WEIGHT_DENOMINATOR : uint64
def $WEIGHT_DENOMINATOR = 64

dec $DOMAIN_SYNC_COMMITTEE : domainType
def $DOMAIN_SYNC_COMMITTEE = 117440512           ;; 0x07000000

dec $DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF : domainType
def $DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF = 134217728  ;; 0x08000000

dec $DOMAIN_CONTRIBUTION_AND_PROOF : domainType
def $DOMAIN_CONTRIBUTION_AND_PROOF = 150994944   ;; 0x09000000

dec $PARTICIPATION_FLAG_WEIGHTS : uint64*
def $PARTICIPATION_FLAG_WEIGHTS = [ $TIMELY_SOURCE_WEIGHT, $TIMELY_TARGET_WEIGHT, $TIMELY_HEAD_WEIGHT ]

;; we encode as 0 placeholder (bytes96 = int).
;; OCaml 에 bls-12-381 라이브러리가 존재하던데 이걸 사용하면?
dec $G2_POINT_AT_INFINITY : blsSignature
def $G2_POINT_AT_INFINITY = 0

dec $TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE : nat
def $TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE = 16   ;; 2**4

dec $SYNC_COMMITTEE_SUBNET_COUNT : nat
def $SYNC_COMMITTEE_SUBNET_COUNT = 4

dec $MAX_REQUEST_LIGHT_CLIENT_UPDATES : nat
def $MAX_REQUEST_LIGHT_CLIENT_UPDATES = 128          ;; 2**7

dec $SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY : nat
def $SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY = 128

dec $DOMAIN_BLS_TO_EXECUTION_CHANGE : domainType
def $DOMAIN_BLS_TO_EXECUTION_CHANGE = 167772160      ;; 0x0A000000


;;
;; Preset vars (mainnet Configuration)  →  parameterless functions
;;

dec $MAX_COMMITTEES_PER_SLOT : uint64
def $MAX_COMMITTEES_PER_SLOT = 64

dec $TARGET_COMMITTEE_SIZE : uint64
def $TARGET_COMMITTEE_SIZE = 128

dec $MAX_VALIDATORS_PER_COMMITTEE : uint64
def $MAX_VALIDATORS_PER_COMMITTEE = 2048

dec $SHUFFLE_ROUND_COUNT : uint64
def $SHUFFLE_ROUND_COUNT = 90

dec $HYSTERESIS_QUOTIENT : uint64
def $HYSTERESIS_QUOTIENT = 4

dec $HYSTERESIS_DOWNWARD_MULTIPLIER : uint64
def $HYSTERESIS_DOWNWARD_MULTIPLIER = 1

dec $HYSTERESIS_UPWARD_MULTIPLIER : uint64
def $HYSTERESIS_UPWARD_MULTIPLIER = 5

dec $MIN_DEPOSIT_AMOUNT : gwei
def $MIN_DEPOSIT_AMOUNT = 1000000000

dec $MAX_EFFECTIVE_BALANCE : gwei
def $MAX_EFFECTIVE_BALANCE = 32000000000

dec $EFFECTIVE_BALANCE_INCREMENT : gwei
def $EFFECTIVE_BALANCE_INCREMENT = 1000000000

dec $MIN_ATTESTATION_INCLUSION_DELAY : uint64
def $MIN_ATTESTATION_INCLUSION_DELAY = 1

dec $SLOTS_PER_EPOCH : uint64
def $SLOTS_PER_EPOCH = 32

dec $MIN_SEED_LOOKAHEAD : uint64
def $MIN_SEED_LOOKAHEAD = 1

dec $MAX_SEED_LOOKAHEAD : uint64
def $MAX_SEED_LOOKAHEAD = 4

dec $MIN_EPOCHS_TO_INACTIVITY_PENALTY : uint64
def $MIN_EPOCHS_TO_INACTIVITY_PENALTY = 4

dec $EPOCHS_PER_ETH1_VOTING_PERIOD : uint64
def $EPOCHS_PER_ETH1_VOTING_PERIOD = 64

dec $SLOTS_PER_HISTORICAL_ROOT : uint64
def $SLOTS_PER_HISTORICAL_ROOT = 8192

dec $EPOCHS_PER_HISTORICAL_VECTOR : uint64
def $EPOCHS_PER_HISTORICAL_VECTOR = 65536

dec $EPOCHS_PER_SLASHINGS_VECTOR : uint64
def $EPOCHS_PER_SLASHINGS_VECTOR = 8192

dec $HISTORICAL_ROOTS_LIMIT : uint64
def $HISTORICAL_ROOTS_LIMIT = 16777216

dec $VALIDATOR_REGISTRY_LIMIT : uint64
def $VALIDATOR_REGISTRY_LIMIT = 1099511627776

dec $BASE_REWARD_FACTOR : uint64
def $BASE_REWARD_FACTOR = 64

dec $WHISTLEBLOWER_REWARD_QUOTIENT : uint64
def $WHISTLEBLOWER_REWARD_QUOTIENT = 512

dec $PROPOSER_REWARD_QUOTIENT : uint64
def $PROPOSER_REWARD_QUOTIENT = 8

dec $INACTIVITY_PENALTY_QUOTIENT : uint64
def $INACTIVITY_PENALTY_QUOTIENT = 67108864

dec $MIN_SLASHING_PENALTY_QUOTIENT : uint64
def $MIN_SLASHING_PENALTY_QUOTIENT = 128

dec $PROPORTIONAL_SLASHING_MULTIPLIER : uint64
def $PROPORTIONAL_SLASHING_MULTIPLIER = 1

dec $MAX_PROPOSER_SLASHINGS : nat
def $MAX_PROPOSER_SLASHINGS = 16

dec $MAX_ATTESTER_SLASHINGS : nat
def $MAX_ATTESTER_SLASHINGS = 2

dec $MAX_ATTESTATIONS : nat
def $MAX_ATTESTATIONS = 128

dec $MAX_DEPOSITS : nat
def $MAX_DEPOSITS = 16

dec $MAX_VOLUNTARY_EXITS : nat
def $MAX_VOLUNTARY_EXITS = 16

dec $INACTIVITY_PENALTY_QUOTIENT_ALTAIR : uint64
def $INACTIVITY_PENALTY_QUOTIENT_ALTAIR = 50331648

dec $MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR : uint64
def $MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR = 64

dec $PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR : uint64
def $PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR = 2

dec $SYNC_COMMITTEE_SIZE : uint64
def $SYNC_COMMITTEE_SIZE = 512

dec $EPOCHS_PER_SYNC_COMMITTEE_PERIOD : uint64
def $EPOCHS_PER_SYNC_COMMITTEE_PERIOD = 256

dec $MIN_SYNC_COMMITTEE_PARTICIPANTS : nat
def $MIN_SYNC_COMMITTEE_PARTICIPANTS = 1

dec $UPDATE_TIMEOUT : nat
def $UPDATE_TIMEOUT = 8192

dec $INACTIVITY_PENALTY_QUOTIENT_BELLATRIX : uint64
def $INACTIVITY_PENALTY_QUOTIENT_BELLATRIX = 16777216

dec $MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX : uint64
def $MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX = 32

dec $PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX : uint64
def $PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX = 3

dec $MAX_BYTES_PER_TRANSACTION : uint64
def $MAX_BYTES_PER_TRANSACTION = 1073741824

dec $MAX_TRANSACTIONS_PER_PAYLOAD : uint64
def $MAX_TRANSACTIONS_PER_PAYLOAD = 1048576

dec $BYTES_PER_LOGS_BLOOM : uint64
def $BYTES_PER_LOGS_BLOOM = 256

dec $MAX_EXTRA_DATA_BYTES : nat
def $MAX_EXTRA_DATA_BYTES = 32

dec $MAX_BLS_TO_EXECUTION_CHANGES : nat
def $MAX_BLS_TO_EXECUTION_CHANGES = 16

dec $MAX_WITHDRAWALS_PER_PAYLOAD : uint64
def $MAX_WITHDRAWALS_PER_PAYLOAD = 16

dec $MAX_VALIDATORS_PER_WITHDRAWALS_SWEEP : nat
def $MAX_VALIDATORS_PER_WITHDRAWALS_SWEEP = 16384

;; Configuration-derived constants (parameterless functions)

dec $MIN_GENESIS_ACTIVE_VALIDATOR_COUNT : uint64
def $MIN_GENESIS_ACTIVE_VALIDATOR_COUNT = 16384

dec $MIN_GENESIS_TIME : uint64
def $MIN_GENESIS_TIME = 1606824000

dec $GENESIS_FORK_VERSION : version
def $GENESIS_FORK_VERSION = 0                     ;; 0x00000000

dec $GENESIS_DELAY : uint64
def $GENESIS_DELAY = 604800

dec $SECONDS_PER_SLOT : uint64
def $SECONDS_PER_SLOT = 12

dec $SLOT_DURATION_MS : uint64
def $SLOT_DURATION_MS = 12000

dec $SECONDS_PER_ETH1_BLOCK : uint64
def $SECONDS_PER_ETH1_BLOCK = 14

dec $MIN_VALIDATOR_WITHDRAWABILITY_DELAY : uint64
def $MIN_VALIDATOR_WITHDRAWABILITY_DELAY = 256

dec $SHARD_COMMITTEE_PERIOD : uint64
def $SHARD_COMMITTEE_PERIOD = 256

dec $ETH1_FOLLOW_DISTANCE : uint64
def $ETH1_FOLLOW_DISTANCE = 2048

dec $EJECTION_BALANCE : gwei
def $EJECTION_BALANCE = 16000000000

dec $MIN_PER_EPOCH_CHURN_LIMIT : uint64
def $MIN_PER_EPOCH_CHURN_LIMIT = 4

dec $CHURN_LIMIT_QUOTIENT : uint64
def $CHURN_LIMIT_QUOTIENT = 65536

dec $PROPOSER_SCORE_BOOST : uint64
def $PROPOSER_SCORE_BOOST = 40

dec $REORG_HEAD_WEIGHT_THRESHOLD : uint64
def $REORG_HEAD_WEIGHT_THRESHOLD = 20

dec $REORG_PARENT_WEIGHT_THRESHOLD : uint64
def $REORG_PARENT_WEIGHT_THRESHOLD = 160

dec $REORG_MAX_EPOCHS_SINCE_FINALIZATION : epoch
def $REORG_MAX_EPOCHS_SINCE_FINALIZATION = 2

dec $PROPOSER_REORG_CUTOFF_BPS : uint64
def $PROPOSER_REORG_CUTOFF_BPS = 1667

dec $MAX_PAYLOAD_SIZE : nat
def $MAX_PAYLOAD_SIZE = 10485760

dec $MAX_REQUEST_BLOCKS : nat
def $MAX_REQUEST_BLOCKS = 1024

dec $EPOCHS_PER_SUBNET_SUBSCRIPTION : nat
def $EPOCHS_PER_SUBNET_SUBSCRIPTION = 256

dec $MIN_EPOCHS_FOR_BLOCK_REQUESTS : nat
def $MIN_EPOCHS_FOR_BLOCK_REQUESTS = 33024

dec $ATTESTATION_PROPAGATION_SLOT_RANGE : nat
def $ATTESTATION_PROPAGATION_SLOT_RANGE = 32

dec $MAXIMUM_GOSSIP_CLOCK_DISPARITY : nat
def $MAXIMUM_GOSSIP_CLOCK_DISPARITY = 500

dec $MESSAGE_DOMAIN_INVALID_SNAPPY : domainType
def $MESSAGE_DOMAIN_INVALID_SNAPPY = 0            ;; 0x00000000

dec $MESSAGE_DOMAIN_VALID_SNAPPY : domainType
def $MESSAGE_DOMAIN_VALID_SNAPPY = 16777216       ;; 0x01000000

dec $SUBNETS_PER_NODE : nat
def $SUBNETS_PER_NODE = 2

dec $ATTESTATION_SUBNET_COUNT : nat
def $ATTESTATION_SUBNET_COUNT = 64

dec $ATTESTATION_SUBNET_EXTRA_BITS : nat
def $ATTESTATION_SUBNET_EXTRA_BITS = 0

dec $ATTESTATION_SUBNET_PREFIX_BITS : nat
def $ATTESTATION_SUBNET_PREFIX_BITS = 6

dec $ATTESTATION_DUE_BPS : uint64
def $ATTESTATION_DUE_BPS = 3333

dec $AGGREGATE_DUE_BPS : uint64
def $AGGREGATE_DUE_BPS = 6667

dec $INACTIVITY_SCORE_BIAS : uint64
def $INACTIVITY_SCORE_BIAS = 4

dec $INACTIVITY_SCORE_RECOVERY_RATE : uint64
def $INACTIVITY_SCORE_RECOVERY_RATE = 16

dec $ALTAIR_FORK_VERSION : version
def $ALTAIR_FORK_VERSION = 16777216              ;; 0x01000000

dec $ALTAIR_FORK_EPOCH : epoch
def $ALTAIR_FORK_EPOCH = 74240

dec $SYNC_MESSAGE_DUE_BPS : uint64
def $SYNC_MESSAGE_DUE_BPS = 3333

dec $CONTRIBUTION_DUE_BPS : uint64
def $CONTRIBUTION_DUE_BPS = 6667

dec $TERMINAL_TOTAL_DIFFICULTY : uint256
def $TERMINAL_TOTAL_DIFFICULTY = 58750000000000000000000

dec $TERMINAL_BLOCK_HASH : hash32
def $TERMINAL_BLOCK_HASH = 0                      ;; 0x00..00 (32 bytes)

dec $TERMINAL_BLOCK_HASH_ACTIVATION_EPOCH : epoch
def $TERMINAL_BLOCK_HASH_ACTIVATION_EPOCH = $FAR_FUTURE_EPOCH

dec $BELLATRIX_FORK_VERSION : version
def $BELLATRIX_FORK_VERSION = 33554432            ;; 0x02000000

dec $BELLATRIX_FORK_EPOCH : epoch
def $BELLATRIX_FORK_EPOCH = 144896

dec $CAPELLA_FORK_VERSION : version
def $CAPELLA_FORK_VERSION = 50331648              ;; 0x03000000

dec $CAPELLA_FORK_EPOCH : epoch
def $CAPELLA_FORK_EPOCH = 194048

;; 0x0000....
;; not defined in eth2spec but needed
dec $ZERO_ROOT : root
def $ZERO_ROOT = 0

;;
;; Containers: defined as SpecTec struct types
;;

syntax fork =
  { PREVIOUS_VERSION version,
    CURRENT_VERSION version,
    EPOCH epoch }

syntax forkdata =
  { CURRENT_VERSION version,
    GENESIS_VALIDATORS_ROOT root }

syntax checkpoint =
  { EPOCH epoch,
    ROOT root }

syntax eth1Data =
  { DEPOSIT_ROOT root,
    DEPOSIT_COUNT uint64,
    BLOCK_HASH hash32 }

syntax beaconBlockHeader =
  { SLOT slot,
    PROPOSER_INDEX validatorIndex,
    PARENT_ROOT root,
    STATE_ROOT root,
    BODY_ROOT root }



;; Additional container types
syntax validator =
  { PUBKEY blsPubkey,
    WITHDRAWAL_CREDENTIALS bytes32,
    EFFECTIVE_BALANCE gwei,
    SLASHED boolean,
    ACTIVATION_ELIGIBILITY_EPOCH epoch,
    ACTIVATION_EPOCH epoch,
    EXIT_EPOCH epoch,
    WITHDRAWABLE_EPOCH epoch }

syntax attestationData =
  { SLOT slot,
    INDEX committeeIndex,
    BEACON_BLOCK_ROOT root,
    SOURCE checkpoint,
    TARGET checkpoint }

syntax indexedAttestation =
  { ATTESTING_INDICES validatorIndex*,
    DATA attestationData,
    SIGNATURE blsSignature }

syntax pendingAttestation =
  { AGGREGATION_BITS boolean*,
    DATA attestationData,
    INCLUSION_DELAY slot,
    PROPOSER_INDEX validatorIndex }

syntax historicalBatch =
  { BLOCK_ROOTS root*,
    STATE_ROOTS root* }

syntax depositMessage =
  { PUBKEY blsPubkey,
    WITHDRAWAL_CREDENTIALS bytes32,
    AMOUNT gwei }

syntax depositData =
  { PUBKEY blsPubkey,
    WITHDRAWAL_CREDENTIALS bytes32,
    AMOUNT gwei,
    SIGNATURE blsSignature }

syntax signingData =
  { OBJECT_ROOT root,
    DOMAIN domain }

syntax attesterSlashing =
  { ATTESTATION_1 indexedAttestation,
    ATTESTATION_2 indexedAttestation }

syntax attestation =
  { AGGREGATION_BITS boolean*,
    DATA attestationData,
    SIGNATURE blsSignature }

syntax deposit =
  { PROOF bytes32*,
    DATA depositData }

syntax voluntaryExit =
  { EPOCH epoch,
    VALIDATOR_INDEX validatorIndex }

syntax signedVoluntaryExit =
  { MESSAGE voluntaryExit,
    SIGNATURE blsSignature }

syntax signedBeaconBlockHeader =
  { MESSAGE beaconBlockHeader,
    SIGNATURE blsSignature }

syntax proposerSlashing =
  { SIGNED_HEADER_1 signedBeaconBlockHeader,
    SIGNED_HEADER_2 signedBeaconBlockHeader }

syntax eth1Block =
  { TIMESTAMP uint64,
    DEPOSIT_ROOT root,
    DEPOSIT_COUNT uint64 }

syntax aggregateAndProof =
  { AGGREGATOR_INDEX validatorIndex,
    AGGREGATE attestation,
    SELECTION_PROOF blsSignature }

syntax signedAggregateAndProof =
  { MESSAGE aggregateAndProof,
    SIGNATURE blsSignature }

syntax syncAggregate =
  { SYNC_COMMITTEE_BITS boolean*,
    SYNC_COMMITTEE_SIGNATURE blsSignature }

syntax syncCommittee =
  { PUBKEYS blsPubkey*,
    AGGREGATE_PUBKEY blsPubkey }

syntax syncCommitteeMessage =
  { SLOT slot,
    BEACON_BLOCK_ROOT root,
    VALIDATOR_INDEX validatorIndex,
    SIGNATURE blsSignature }

syntax syncCommitteeContribution =
  { SLOT slot,
    BEACON_BLOCK_ROOT root,
    SUBCOMMITTEE_INDEX uint64,
    AGGREGATION_BITS boolean*,
    SIGNATURE blsSignature }

syntax contributionAndProof =
  { AGGREGATOR_INDEX validatorIndex,
    CONTRIBUTION syncCommitteeContribution,
    SELECTION_PROOF blsSignature }

syntax signedContributionAndProof =
  { MESSAGE contributionAndProof,
    SIGNATURE blsSignature }

syntax syncAggregatorSelectionData =
  { SLOT slot,
    SUBCOMMITTEE_INDEX uint64 }

syntax executionPayloadHeader =
  { PARENT_HASH hash32,
    FEE_RECIPIENT executionAddress,
    STATE_ROOT bytes32,
    RECEIPTS_ROOT bytes32,
    LOGS_BLOOM bytes32*,
    PREV_RANDAO bytes32,
    BLOCK_NUMBER uint64,
    GAS_LIMIT uint64,
    GAS_USED uint64,
    TIMESTAMP uint64,
    EXTRA_DATA bytes32*,
    BASE_FEE_PER_GAS uint256,
    BLOCK_HASH hash32,
    TRANSACTIONS_ROOT root,
    WITHDRAWALS_ROOT root }

syntax lightClientHeader =
  { BEACON beaconBlockHeader,
    EXECUTION executionPayloadHeader,
    EXECUTION_BRANCH bytes32* }

syntax lightClientOptimisticUpdate =
  { ATTESTED_HEADER lightClientHeader,
    SYNC_AGGREGATE syncAggregate,
    SIGNATURE_SLOT slot }

syntax lightClientFinalityUpdate =
  { ATTESTED_HEADER lightClientHeader,
    FINALIZED_HEADER lightClientHeader,
    FINALITY_BRANCH bytes32*,
    SYNC_AGGREGATE syncAggregate,
    SIGNATURE_SLOT slot }

syntax lightClientUpdate =
  { ATTESTED_HEADER lightClientHeader,
    NEXT_SYNC_COMMITTEE syncCommittee,
    NEXT_SYNC_COMMITTEE_BRANCH bytes32*,
    FINALIZED_HEADER lightClientHeader,
    FINALITY_BRANCH bytes32*,
    SYNC_AGGREGATE syncAggregate,
    SIGNATURE_SLOT slot }

syntax lightClientBootstrap =
  { HEADER lightClientHeader,
    CURRENT_SYNC_COMMITTEE syncCommittee,
    CURRENT_SYNC_COMMITTEE_BRANCH bytes32* }

syntax powBlock =
  { BLOCK_HASH hash32,
    PARENT_HASH hash32,
    TOTAL_DIFFICULTY uint256 }

syntax withdrawal =
  { INDEX withdrawalIndex,
    VALIDATOR_INDEX validatorIndex,
    ADDRESS executionAddress,
    AMOUNT gwei }

syntax executionPayload =
  { PARENT_HASH hash32,
    FEE_RECIPIENT executionAddress,
    STATE_ROOT bytes32,
    RECEIPTS_ROOT bytes32,
    LOGS_BLOOM bytes32*,
    PREV_RANDAO bytes32,
    BLOCK_NUMBER uint64,
    GAS_LIMIT uint64,
    GAS_USED uint64,
    TIMESTAMP uint64,
    EXTRA_DATA bytes32*,
    BASE_FEE_PER_GAS uint256,
    BLOCK_HASH hash32,
    TRANSACTIONS bytes32*,
    WITHDRAWALS withdrawal* }

syntax blsToExecutionChange =
  { VALIDATOR_INDEX validatorIndex,
    FROM_BLS_PUBKEY blsPubkey,
    TO_EXECUTION_ADDRESS executionAddress }

syntax signedBlsToExecutionChange =
  { MESSAGE blsToExecutionChange,
    SIGNATURE blsSignature }



syntax historicalSummary =
  { BLOCK_SUMMARY_ROOT root,
    STATE_SUMMARY_ROOT root }

syntax beaconState =
  { GENESIS_TIME uint64,
    GENESIS_VALIDATORS_ROOT bytes32,
    SLOT slot,
    FORK fork,
    LATEST_BLOCK_HEADER beaconBlockHeader,
    BLOCK_ROOTS root*,
    STATE_ROOTS root*,
    HISTORICAL_ROOTS root*,
    ETH1_DATA eth1Data,
    ETH1_DATA_VOTES eth1Data*,
    ETH1_DEPOSIT_INDEX uint64,
    VALIDATORS validator*,
    BALANCES gwei*,
    RANDAO_MIXES bytes32*,
    SLASHINGS gwei*,
    PREVIOUS_EPOCH_PARTICIPATION participationFlags*,
    CURRENT_EPOCH_PARTICIPATION participationFlags*,
    JUSTIFICATION_BITS boolean*,
    PREVIOUS_JUSTIFIED_CHECKPOINT checkpoint,
    CURRENT_JUSTIFIED_CHECKPOINT checkpoint,
    FINALIZED_CHECKPOINT checkpoint,
    INACTIVITY_SCORES uint64*,
    CURRENT_SYNC_COMMITTEE syncCommittee,
    NEXT_SYNC_COMMITTEE syncCommittee,
    LATEST_EXECUTION_PAYLOAD_HEADER executionPayloadHeader,
    NEXT_WITHDRAWAL_INDEX withdrawalIndex,
    NEXT_WITHDRAWAL_VALIDATOR_INDEX validatorIndex,
    HISTORICAL_SUMMARIES historicalSummary* }

syntax beaconBlockBody =
  {
    RANDAO_REVEAL blsSignature,
    ETH1_DATA eth1Data,
    GRAFFITI bytes32,
    PROPOSER_SLASHINGS proposerSlashing*,
    ATTESTER_SLASHINGS attesterSlashing*,
    ATTESTATIONS attestation*,
    DEPOSITS deposit*,
    VOLUNTARY_EXITS voluntaryExit*,
    ;; [Altair] sync committee aggregation
    SYNC_AGGREGATE syncAggregate,
    ;; [Bellatrix/Capella] execution-layer payload
    EXECUTION_PAYLOAD executionPayload,
    ;; [Capella] BLS to Execution address change
    BLS_TO_EXECUTION_CHANGES signedBlsToExecutionChange*
  }

syntax beaconBlock =
  { SLOT slot,
    PROPOSER_INDEX validatorIndex,
    PARENT_ROOT root,
    STATE_ROOT root,
    BODY beaconBlockBody }

syntax signedBeaconBlock =
  { MESSAGE beaconBlock,
    SIGNATURE blsSignature }

syntax seedInput =
  { DOMAIN domainType,
    BYTES bytes,
    MIX bytes32 }

syntax proposerSeedInput =
  { BASE bytes32,     ;; get_seed(state, epoch, DOMAIN_BEACON_PROPOSER)
    BYTES bytes }     ;; uint_to_bytes(state.SLOT)


;;
;; Variables
;;

var i : int
var n : nat
var state : beaconState
var body : beaconBlockBody
var block : beaconBlock

var delta           : gwei
var idx             : nat
var current         : gwei
var newBalance      : gwei
var balancesUpdate  : gwei*

var attd1 : attestationData
var attd2 : attestationData

var curVer  : version
var genRoot : root

var balance : gwei

;; =========================
;; 03-builtins-decls.spectec
;; (dec-only: 인터프리터/런타임 제공)
;; =========================

;; --- 해시/암호 ---
dec $hash_<X>(X) : bytes32
dec $bls_verify(blsPubkey, root, blsSignature) : boolean

;; --- hash_tree_root 계열 ---
dec $hash_tree_root_beaconBlockHeader(beaconBlockHeader) : root
dec $hash_tree_root_beaconBlockBody(beaconBlockBody) : root
dec $hash_tree_root_depositData(depositData) : root
dec $hash_tree_root_forkdata(forkdata) : root
dec $hash_tree_root_tx(bytes32*) : root
dec $hash_tree_root_withdrawals(withdrawal*) : root
dec $hash_tree_root_roots(root*) : root

;; --- 실행 엔진 ---
dec $ee_verify_and_notify_new_payload(executionPayload) : boolean

;; --- 바이트/도메인 유틸 ---
dec $bytes_to_uint64(bytes32) : uint64
dec $uint_to_bytes(uint) : bytes
dec $xor(bytes32, bytes32) : bytes32
dec $first_28_bytes(bytes32) : bytes28
dec $concat_domain(domainType, bytes28) : domain
dec $get_first_byte(bytes32) : bytes1
dec $strip_first_byte(bytes32) : bytes32
dec $make_withdrawal_credentials_eth1(executionAddress) : bytes32

;; --- 서명 루트 계산 ---
dec $compute_signing_root(epoch, domain) : root
dec $compute_signing_root_voluntary_exit(voluntaryExit, domain) : root
dec $compute_signing_root_bls_to_execution_change(blsToExecutionChange, domain) : root

;; --- 머클 검증 ---
dec $is_valid_merkle_branch(bytes32, bytes32*, uint64, uint64, root) : boolean

;; --- 수치 유틸  ---
dec $integer_squareroot(uint64) : uint64

;; --- 리스트 안에 원소 개수 세기 ---
;; count occurrences of element in list
dec $count_occurrences_<X>(X*, X) : nat

;; --- 2의 제곱 연산 --- 
dec $pow2(nat) : nat

;; 리스트 set 함수(리스트 내 중복 제거)
dec $to_set_<X>(X*) : X*

;; 리스트 sum 함수
dec $sum_<X>(X*) : X

;; 리스트 값채우기
dec $repeat_<X>(X, nat) : X*

;; --------------------------------------------
;; has_flag: flags의 i번째 비트가 1인가? 와 동일한 의미
;; --------------------------------------------

;; uint8 범위 내에 없으면 false
dec $has_flag(participationFlags, nat) : boolean

def $has_flag(participationFlags, n) = false
  -- if $( n >= 8 )

def $has_flag(participationFlags, n) = true
  -- if $( ((participationFlags / $pow2(n)) \ 2) = 1 )

def $has_flag(participationFlags, n) = false
  -- otherwise


;; --------------------------------------------
;; add_flag: flags의 i번째 비트를 더해서(or) 반환
;; --------------------------------------------
dec $add_flag(participationFlags, nat) : participationFlags

;; uint8 범위 내에 없으면 false
def $add_flag(participationFlags, n) = participationFlags
  -- if $( n >= 8 )

def $add_flag(participationFlags, n) = participationFlags
  -- if $( ((participationFlags / $pow2(n)) \ 2) = 1 )

def $add_flag(participationFlags, n) = $( participationFlags + $pow2(n) )
  -- if $( ((participationFlags / $pow2(n)) \ 2) = 0 )


;; =========================
;; 04-helpers-epoch.spectec
;; epoch / slot / time helpers
;; =========================


;; compute_epoch_at_slot : slot -> epoch
dec $compute_epoch_at_slot(slot) : epoch
def $compute_epoch_at_slot(slot) =
  $(slot / $SLOTS_PER_EPOCH)

;; compute_start_slot_at_epoch : epoch -> slot
dec $compute_start_slot_at_epoch(epoch) : slot
def $compute_start_slot_at_epoch(epoch) =
  $(epoch * $SLOTS_PER_EPOCH)

;; get_current_epoch : state -> epoch
dec $get_current_epoch(beaconState) : epoch
def $get_current_epoch(state) = $compute_epoch_at_slot(state.SLOT)

;; get_previous_epoch : state -> epoch
dec $get_previous_epoch(beaconState) : epoch

def $get_previous_epoch(state) = $GENESIS_EPOCH
  -- if $get_current_epoch(state) = $GENESIS_EPOCH

def $get_previous_epoch(state) = $( $get_current_epoch(state) - 1 )
  -- otherwise

;; compute_time_at_slot : (state, slot) -> unix time (uint64)
dec $compute_time_at_slot(beaconState, slot) : uint64
def $compute_time_at_slot(state, slot) =
  $(state.GENESIS_TIME + (slot - $GENESIS_SLOT) * $SECONDS_PER_SLOT)

;; =========================
;; 05-helpers-domain.spectec
;; fork-data / domain helpers
;; =========================

;; ------------------------------------------------------------
;; compute_fork_data_root(version, genesis_root) : root
;; ------------------------------------------------------------
dec $compute_fork_data_root(version, root) : root
def $compute_fork_data_root(curVer, genRoot) =
  $hash_tree_root_forkdata({ CURRENT_VERSION curVer, GENESIS_VALIDATORS_ROOT genRoot })

;; ------------------------------------------------------------
;; compute_domain(domainType, [version], [genesis_root]) : domain
;; (옵셔널 인자 조합 4가지)
;; ------------------------------------------------------------
dec $compute_domain(domainType, version?, root?) : domain

def $compute_domain(domainType, version, root) =
  $concat_domain(domainType, $first_28_bytes($compute_fork_data_root(version, root)))

def $compute_domain(domainType, eps, eps) =
  $concat_domain(domainType, $first_28_bytes($compute_fork_data_root($GENESIS_FORK_VERSION, $ZERO_ROOT)))

def $compute_domain(domainType, version, eps) =
  $concat_domain(domainType, $first_28_bytes($compute_fork_data_root(version, $ZERO_ROOT)))

def $compute_domain(domainType, eps, root) =
  $concat_domain(domainType, $first_28_bytes($compute_fork_data_root($GENESIS_FORK_VERSION, root)))

;; ------------------------------------------------------------
;; get_domain(state, domainType, [epoch]) : domain
;; (epoch 미지정 시 현재 epoch 기준 분기)
;; ------------------------------------------------------------
dec $get_domain(beaconState, domainType, epoch?) : domain

;; epoch 생략: 현재 epoch 사용
def $get_domain(state, domainType, eps) =
  $compute_domain(domainType, state.FORK.PREVIOUS_VERSION, state.GENESIS_VALIDATORS_ROOT)
  -- if $get_current_epoch(state) = epoch_cur
  -- if $(epoch_cur < state.FORK.EPOCH)

def $get_domain(state, domainType, eps) =
  $compute_domain(domainType, state.FORK.CURRENT_VERSION, state.GENESIS_VALIDATORS_ROOT)
  -- if $get_current_epoch(state) = epoch_cur
  -- if $(state.FORK.EPOCH <= epoch_cur)

;; epoch 명시: 전달된 epoch 사용
def $get_domain(state, domainType, epoch) =
  $compute_domain(domainType, state.FORK.PREVIOUS_VERSION, state.GENESIS_VALIDATORS_ROOT)
  -- if $(epoch < state.FORK.EPOCH)

def $get_domain(state, domainType, epoch) =
  $compute_domain(domainType, state.FORK.CURRENT_VERSION, state.GENESIS_VALIDATORS_ROOT)
  -- if $(state.FORK.EPOCH <= epoch)

;; ================================
;; 06-helpers-validator.spectec
;; validator predicates & helpers
;; ================================


;; ------------------------------------------------------------
;; compute_activation_exit_epoch : epoch -> epoch
;; ------------------------------------------------------------
dec $compute_activation_exit_epoch(epoch) : epoch
def $compute_activation_exit_epoch(epoch) = $(epoch + 1 + $MAX_SEED_LOOKAHEAD)

;; ------------------------------------------------------------
;; is_active_validator : (validator, epoch) -> bool
;; ------------------------------------------------------------
dec $is_active_validator(validator, epoch) : boolean

def $is_active_validator(validator, epoch) = true
  -- if $(validator.ACTIVATION_EPOCH <= epoch)
  -- if $(epoch < validator.EXIT_EPOCH)

def $is_active_validator(validator, epoch) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_eligible_for_activation_queue : validator -> bool
;; ------------------------------------------------------------
dec $is_eligible_for_activation_queue(validator) : boolean

def $is_eligible_for_activation_queue(validator) = true
  -- if $(validator.ACTIVATION_ELIGIBILITY_EPOCH = $FAR_FUTURE_EPOCH)
  -- if $(validator.EFFECTIVE_BALANCE = $MAX_EFFECTIVE_BALANCE)

def $is_eligible_for_activation_queue(validator) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_eligible_for_activation : (state, validator) -> bool
;; ------------------------------------------------------------
dec $is_eligible_for_activation(beaconState, validator) : boolean

def $is_eligible_for_activation(state, validator) = true
  -- if $(validator.ACTIVATION_ELIGIBILITY_EPOCH <= state.FINALIZED_CHECKPOINT.EPOCH)
  -- if $(validator.ACTIVATION_EPOCH = $FAR_FUTURE_EPOCH)

def $is_eligible_for_activation(state, validator) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_slashable_validator : (validator, epoch) -> bool
;; ------------------------------------------------------------
dec $is_slashable_validator(validator, epoch) : boolean

def $is_slashable_validator(validator, epoch) = true
  -- if $(validator.SLASHED = false)
  -- if $(validator.ACTIVATION_EPOCH <= epoch)
  -- if $(epoch < validator.WITHDRAWABLE_EPOCH)

def $is_slashable_validator(validator, epoch) = false
  -- otherwise

;; ------------------------------------------------------------
;; has_eth1_withdrawal_credential : validator -> bool
;; ------------------------------------------------------------
dec $has_eth1_withdrawal_credential(validator) : boolean

def $has_eth1_withdrawal_credential(validator) = true
  -- if $get_first_byte(validator.WITHDRAWAL_CREDENTIALS) = $ETH1_ADDRESS_WITHDRAWAL_PREFIX

def $has_eth1_withdrawal_credential(validator) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_fully_withdrawable_validator : (validator, balance:gwei, epoch) -> bool
;; ------------------------------------------------------------
dec $is_fully_withdrawable_validator(validator, gwei, epoch) : boolean

def $is_fully_withdrawable_validator(validator, balance, epoch) = true
  -- if $has_eth1_withdrawal_credential(validator) = true
  -- if $(validator.WITHDRAWABLE_EPOCH <= epoch)
  -- if $(balance > 0)

def $is_fully_withdrawable_validator(validator, balance, epoch) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_partially_withdrawable_validator : (validator, balance:gwei) -> bool
;; ------------------------------------------------------------
dec $is_partially_withdrawable_validator(validator, gwei) : boolean

def $is_partially_withdrawable_validator(validator, balance) = true
  -- if $has_eth1_withdrawal_credential(validator) = true
  -- if $(validator.EFFECTIVE_BALANCE = $MAX_EFFECTIVE_BALANCE)
  -- if $(balance > $MAX_EFFECTIVE_BALANCE)

def $is_partially_withdrawable_validator(validator, balance) = false
  -- otherwise

;; =======================================
;; 07-helpers-roots-mixes.spectec
;; roots & randao mixes & time/leak helpers
;; =======================================

;; ------------------------------------------------------------
;; get_block_root_at_slot : (state, slot) -> root
;; ------------------------------------------------------------
dec $get_block_root_at_slot(beaconState, slot) : root

def $get_block_root_at_slot(state, slot) = root_ret
  -- if $(slot < state.SLOT)
  -- if $(state.SLOT <= slot + $SLOTS_PER_HISTORICAL_ROOT)
  -- if $(slot \ $SLOTS_PER_HISTORICAL_ROOT) = n
  -- if state.BLOCK_ROOTS[n] = root_ret

;; ------------------------------------------------------------
;; get_block_root : (state, epoch) -> root
;; ------------------------------------------------------------
dec $get_block_root(beaconState, epoch) : root

def $get_block_root(state, epoch) = $get_block_root_at_slot(state, slot)
  -- if $compute_start_slot_at_epoch(epoch) = slot

;; ------------------------------------------------------------
;; get_randao_mix : (state, epoch) -> bytes32
;; ------------------------------------------------------------
dec $get_randao_mix(beaconState, epoch) : bytes32

def $get_randao_mix(state, epoch) = bytes32_mix
  -- if $(epoch \ $EPOCHS_PER_HISTORICAL_VECTOR) = n
  -- if state.RANDAO_MIXES[n] = bytes32_mix


;; ------------------------------------------------------------
;; get_finality_delay : state -> uint64
;; ------------------------------------------------------------
dec $get_finality_delay(beaconState) : uint64
def $get_finality_delay(state) =
  $( $get_previous_epoch(state) - state.FINALIZED_CHECKPOINT.EPOCH )

;; ------------------------------------------------------------
;; is_in_inactivity_leak : state -> bool
;; ------------------------------------------------------------
dec $is_in_inactivity_leak(beaconState) : boolean
def $is_in_inactivity_leak(state) =
  $( $get_finality_delay(state) > $MIN_EPOCHS_TO_INACTIVITY_PENALTY )

;; max for uint64
dec $max_uint64(uint64, uint64) : uint64
def $max_uint64(uint64, uint64) = uint64
  -- if $(uint64 >= uint64)
def $max_uint64(uint64, uint64) = uint64
  -- otherwise

;; min for uint64
dec $min_uint64(uint64, uint64) : uint64
def $min_uint64(uint64, uint64) = uint64
  -- if $(uint64 <= uint64)
def $min_uint64(uint64, uint64) = uint64
  -- otherwise

;;
;; helper functions that have to be defined
;;

dec $compute_proposer_index(beaconState, validatorIndex*, bytes32) : validatorIndex

dec $initiate_validator_exit(beaconState, validatorIndex) : beaconState

dec $apply_deposit(beaconState, blsPubkey, bytes32, gwei, blsSignature) : beaconState


dec $get_unslashed_participating_indices(beaconState, nat, epoch) : validatorIndex*

dec $weigh_justification_and_finalization(beaconState, gwei, gwei, gwei) : beaconState

dec $get_next_sync_committee(beaconState) : syncCommittee

dec $compute_committee(validatorIndex*, bytes32, uint64, uint64) : validatorIndex*




syntax enumerated_<X> = (nat, X)
dec $enumerate_<X>(X*) : enumerated_<X>*

dec $filter_list_<X>(X*, def $cond(X) : bool)
  : X*
def $filter_list_<X>(eps, def $cond) = eps
def $filter_list_<X>(X_h :: X_t*, def $cond)
  = X_h :: $filter_list_<X>(X_t*, def $cond)
  -- if $cond(X_h) = true
def $filter_list_<X>(X_h :: X_t*, def $cond)
  = $filter_list_<X>(X_t*, def $cond)
  -- if $cond(X_h) = false

dec $filter_list_2_<X, Y>(X*, Y, def $cond(X, Y) : bool)
  : X*


dec $is_active_validator_enumerated(enumerated_<validator>, epoch) : bool
def $is_active_validator_enumerated((n, validator), epoch) = $is_active_validator(validator, epoch)

dec $get_active_validator_indices(beaconState, epoch) : validatorIndex*
def $get_active_validator_indices(state, epoch) = n_active*
  -- if state.VALIDATORS = validator*
  -- if $enumerate_<validator>(validator*) = (n, validator)*
  -- if $filter_list_2_<(nat, validator), epoch>(
      (n, validator)*,
      epoch,
      def $is_active_validator_enumerated
    )
    = (n_active, validator_active)*

;; ------------------------------------------------------------
;; get_validator_churn_limit
;; ------------------------------------------------------------
dec $get_validator_churn_limit(beaconState) : uint64
def $get_validator_churn_limit(state_beaconState) = uint64_churn_limit
  -- if $get_current_epoch(state_beaconState) = epoch_current
  -- if $get_active_validator_indices(state_beaconState, epoch_current) = validatorIndex_active*
  -- if $( |validatorIndex_active*| ) = uint64_len_active
  -- if $(uint64_len_active / $CHURN_LIMIT_QUOTIENT) = uint64_quota
  -- if $max_uint64($MIN_PER_EPOCH_CHURN_LIMIT, uint64_quota) = uint64_churn_limit


;; ------------------------------------------------------------
;; get_committee_count_per_slot
;; ------------------------------------------------------------
dec $get_committee_count_per_slot(beaconState, epoch) : uint64
def $get_committee_count_per_slot(state_beaconState, epoch_epoch) = uint64_committees_per_slot
  -- if $get_active_validator_indices(state_beaconState, epoch_epoch) = validatorIndex_active*
  -- if $( |validatorIndex_active*| ) = uint64_len_active
  -- if $(uint64_len_active / $SLOTS_PER_EPOCH) = uint64_per_slot
  -- if $(uint64_per_slot / $TARGET_COMMITTEE_SIZE) = uint64_estimate
  -- if $min_uint64($MAX_COMMITTEES_PER_SLOT, uint64_estimate) = uint64_capped
  -- if $max_uint64(1, uint64_capped) = uint64_committees_per_slot

;; --------------------------------------------
;; eligible cond: active(v, prev) OR (v.SLASHED ∧ prev+1 < v.WITHDRAWABLE_EPOCH)
;; almost same as get_active_validator_indices
;; --------------------------------------------
dec $is_eligible_validator_enumerated(enumerated_<validator>, epoch) : bool
def $is_eligible_validator_enumerated((n, validator), epoch_prev) =
  $is_active_validator(validator, epoch_prev)
  \/
  ( $(validator.SLASHED = true) /\ $(epoch_prev + 1 < validator.WITHDRAWABLE_EPOCH) )

;; --------------------------------------------
;; get_eligible_validator_indices(state) : validatorIndex*
;; --------------------------------------------
dec $get_eligible_validator_indices(beaconState) : validatorIndex*

def $get_eligible_validator_indices(state) = n_eligible*
  -- if $get_previous_epoch(state) = epoch_prev
  -- if state.VALIDATORS = validator*
  -- if $enumerate_<validator>(validator*) = (n, validator)*
  -- if $filter_list_2_<(nat, validator), epoch>(
       (n, validator)*,
       epoch_prev,
       def $is_eligible_validator_enumerated
     ) = (n_eligible, validator_eligible)*

;; --------------------------------------------
;; helpers for filtering by flag / unslashed
;; --------------------------------------------

;; cond: has_flag?
dec $has_flag_for_index(validatorIndex, (participationFlags*, nat)) : bool
def $has_flag_for_index(validatorIndex_vi, (participationFlags_list*, nat_flag))
  = $has_flag(participationFlags_list*[validatorIndex_vi], nat_flag)

;; cond: is validator unslashed?
dec $is_unslashed(validatorIndex, beaconState) : bool
def $is_unslashed(validatorIndex_vi, state) = true
  -- if $(validatorIndex_vi < |state.VALIDATORS|)
  -- if state.VALIDATORS[validatorIndex_vi] = validator
  -- if $(validator.SLASHED = false)
def $is_unslashed(validatorIndex_vi, state) = false
  -- otherwise

;; --------------------------------------------
;; get_unslashed_participating_indices
;; --------------------------------------------

;; case 1: epoch == current
def $get_unslashed_participating_indices(state, nat_flag_index, epoch_epoch) = validatorIndex_set*
  -- if $get_current_epoch(state) = epoch_epoch
  -- if $get_active_validator_indices(state, epoch_epoch) = validatorIndex_active*
  -- if $filter_list_2_<validatorIndex, (participationFlags*, nat)>(
         validatorIndex_active*,
         (state.CURRENT_EPOCH_PARTICIPATION, nat_flag_index),
         def $has_flag_for_index
       ) = validatorIndex_participating*
  -- if $filter_list_2_<validatorIndex, beaconState>(
         validatorIndex_participating*,
         state,
         def $is_unslashed
       ) = validatorIndex_unslashed*
  -- if $to_set_<validatorIndex>(validatorIndex_unslashed*) = validatorIndex_set*

;; case 2: epoch == previous
def $get_unslashed_participating_indices(state, nat_flag_index, epoch_epoch) = validatorIndex_set*
  -- if $get_previous_epoch(state) = epoch_epoch
  -- if $get_active_validator_indices(state, epoch_epoch) = validatorIndex_active*
  -- if $filter_list_2_<validatorIndex, (participationFlags*, nat)>(
         validatorIndex_active*,
         (state.PREVIOUS_EPOCH_PARTICIPATION, nat_flag_index),
         def $has_flag_for_index
       ) = validatorIndex_participating*
  -- if $filter_list_2_<validatorIndex, beaconState>(
         validatorIndex_participating*,
         state,
         def $is_unslashed
       ) = validatorIndex_unslashed*
  -- if $to_set_<validatorIndex>(validatorIndex_unslashed*) = validatorIndex_set*

;; ------------------------------------------------------------
;; is_slashable_attestation_data
;; ------------------------------------------------------------
dec $is_slashable_attestation_data(attestationData, attestationData) : bool
def $is_slashable_attestation_data(attd1, attd2) =
  ( ~(attd1 = attd2) /\ $( attd1.TARGET.EPOCH = attd2.TARGET.EPOCH ) )
  \/
  ( $( attd1.SOURCE.EPOCH < attd2.SOURCE.EPOCH ) /\ $( attd2.TARGET.EPOCH < attd1.TARGET.EPOCH ) )


;; ------------------------------------------------------------
;; get_seed
;; ------------------------------------------------------------
dec $get_seed(beaconState, epoch, domainType) : bytes32

def $get_seed(state, epoch, domainType) = bytes32_seed
  -- if $(epoch + $EPOCHS_PER_HISTORICAL_VECTOR - $MIN_SEED_LOOKAHEAD - 1) = epoch_mix_source
  -- if $get_randao_mix(state, epoch_mix_source) = bytes32_mix
  -- if $uint_to_bytes(epoch) = bytes_epoch
  -- if seedInput_pre = { DOMAIN domainType, BYTES bytes_epoch, MIX bytes32_mix }
  -- if $hash_<seedInput>(seedInput_pre) = bytes32_seed

;; ------------------------------------------------------------
;; get_beacon_proposer_index
;; ------------------------------------------------------------
dec $get_beacon_proposer_index(beaconState) : validatorIndex

def $get_beacon_proposer_index(state) = validatorIndex_prop
  -- if $get_current_epoch(state) = epoch_cur
  -- if $get_seed(state, epoch_cur, $DOMAIN_BEACON_PROPOSER) = bytes32_seed_base
  -- if $uint_to_bytes(state.SLOT) = bytes_slot
  -- if proposerSeedInput_pre = { BASE bytes32_seed_base, BYTES bytes_slot }
  -- if $hash_<proposerSeedInput>(proposerSeedInput_pre) = bytes32_seed
  -- if $get_active_validator_indices(state, epoch_cur) = validatorIndex_indices*
  -- if $compute_proposer_index(state, validatorIndex_indices*, bytes32_seed) = validatorIndex_prop

;; ------------------------------------------------------------
;; get_beacon_committee
;; ------------------------------------------------------------
dec $get_beacon_committee(beaconState, slot, committeeIndex) : validatorIndex*
def $get_beacon_committee(state, slot, committeeIndex) = validatorIndex_committee*
  -- if $compute_epoch_at_slot(slot) = epoch
  -- if $get_committee_count_per_slot(state, epoch) = uint64_committees_per_slot
  -- if $get_active_validator_indices(state, epoch) = validatorIndex_indices*
  -- if $get_seed(state, epoch, $DOMAIN_BEACON_ATTESTER) = bytes32_seed
  -- if $( (slot \ $SLOTS_PER_EPOCH) * uint64_committees_per_slot + committeeIndex ) = uint64_index
  -- if $( uint64_committees_per_slot * $SLOTS_PER_EPOCH ) = uint64_count
  -- if $compute_committee(
         validatorIndex_indices*,
         bytes32_seed,
         uint64_index,
         uint64_count
       ) = validatorIndex_committee*

dec $get_total_balance(beaconState, validatorIndex*) : gwei

def $get_total_balance(state, validatorIndex*) = gwei_total
  -- if (state.VALIDATORS[validatorIndex].EFFECTIVE_BALANCE = balance)*
  -- if $sum_<gwei>(balance*) = gwei_sum
  -- if $max_uint64($EFFECTIVE_BALANCE_INCREMENT, gwei_sum) = gwei_total

dec $get_total_active_balance(beaconState) : gwei

def $get_total_active_balance(state) = gwei_total
  -- if $get_current_epoch(state) = epoch_cur
  -- if $get_active_validator_indices(state, epoch_cur) = validatorIndex_active*
  -- if $to_set_<validatorIndex>(validatorIndex_active*) = validatorIndex_set*
  -- if $get_total_balance(state, validatorIndex_set*) = gwei_total

;; --------------------------------------------
;; get_base_reward_per_increment(state) : gwei
;;
;; --------------------------------------------
dec $get_base_reward_per_increment(beaconState) : gwei

def $get_base_reward_per_increment(state) = gwei_base
  -- if $get_total_active_balance(state) = gwei_total_active
  -- if $integer_squareroot(gwei_total_active) = uint64_sqrt_total
  -- if $( $EFFECTIVE_BALANCE_INCREMENT * $BASE_REWARD_FACTOR ) = uint64_num
  -- if $( uint64_num / uint64_sqrt_total ) = gwei_base

;; --------------------------------------------
;; get_base_reward(state, index) : gwei
;; --------------------------------------------
dec $get_base_reward(beaconState, validatorIndex) : gwei

def $get_base_reward(state, validatorIndex_vi) = gwei_reward
  -- if $(validatorIndex_vi < |state.VALIDATORS|)
  -- if state.VALIDATORS[validatorIndex_vi] = validator_i
  -- if $( validator_i.EFFECTIVE_BALANCE / $EFFECTIVE_BALANCE_INCREMENT ) = uint64_increments
  -- if $get_base_reward_per_increment(state) = gwei_per_inc
  -- if $( uint64_increments * gwei_per_inc ) = gwei_reward

;; for process_effective_balance_updates
;; ------------------------------------------------------------
;; map over a list with one extra captured argument
;; X*  ×  Y  ×  (X,Y)->Z   ==>   Z*
;; ------------------------------------------------------------
dec $map_list_2_<X, Y, Z>(X*, Y, def $f(X, Y) : Z) : Z*


;; predicate: apply update iff
;;   balance + DOWNWARD_THRESHOLD < effective_balance
;;   OR
;;   effective_balance + UPWARD_THRESHOLD < balance
dec $cond_hysteresis(gwei, gwei, uint64, uint64) : boolean

def $cond_hysteresis(gwei_balance, gwei_eff, uint64_down_th, uint64_up_th) = true
  -- if $( gwei_balance + uint64_down_th < gwei_eff )
   \/
       $( gwei_eff + uint64_up_th   < gwei_balance )

def $cond_hysteresis(gwei_balance, gwei_eff, uint64_down_th, uint64_up_th) = false
  -- otherwise

;; ------------------------------------------------------------
;; rebalance rule for a single (index, validator) pair
;; (computes hysteresis thresholds and updates EFFECTIVE_BALANCE if needed)
;; ------------------------------------------------------------
dec $rebalance_validator_enumerated((nat, validator), beaconState) : validator

def $rebalance_validator_enumerated((n, validator_v), state) = validator_updated
  -- if $(n < |state.BALANCES|)
  -- if state.BALANCES[n] = gwei_balance
  -- if $( $EFFECTIVE_BALANCE_INCREMENT / $HYSTERESIS_QUOTIENT ) = uint64_hyst_inc
  -- if $( uint64_hyst_inc * $HYSTERESIS_DOWNWARD_MULTIPLIER ) = uint64_down_th
  -- if $( uint64_hyst_inc * $HYSTERESIS_UPWARD_MULTIPLIER )  = uint64_up_th
  -- if $cond_hysteresis(
         gwei_balance,
         validator_v.EFFECTIVE_BALANCE,
         uint64_down_th,
         uint64_up_th
       ) = true
  -- if $( gwei_balance \ $EFFECTIVE_BALANCE_INCREMENT ) = gwei_mod
  -- if $( gwei_balance - gwei_mod ) = gwei_floor_inc
  -- if $min_uint64(gwei_floor_inc, $MAX_EFFECTIVE_BALANCE) = gwei_new_eff
  -- if validator_updated = validator_v[.EFFECTIVE_BALANCE = gwei_new_eff]

def $rebalance_validator_enumerated((n, validator_v), state) = validator_v
  -- otherwise


;; 09-state-balance.spectec
;; Increase / Decrease balance as helpers

dec $increase_balance(beaconState, validatorIndex, gwei) : beaconState
def $increase_balance(state, validatorIndex_vi, gwei_delta) = state_updated
  -- if $(validatorIndex_vi < |state.BALANCES|)
  -- if state.BALANCES[validatorIndex_vi] = gwei_current
  -- if $(gwei_current + gwei_delta) = gwei_new
  -- if state.BALANCES[[validatorIndex_vi] = gwei_new] = gwei_update*
  -- if state_updated = state[.BALANCES = gwei_update*]

dec $decrease_balance(beaconState, validatorIndex, gwei) : beaconState

;; case 1: delta > current ⇒ set to 0
def $decrease_balance(state, validatorIndex_vi, gwei_delta) = state_updated
  -- if $(validatorIndex_vi < |state.BALANCES|)
  -- if state.BALANCES[validatorIndex_vi] = gwei_current
  -- if $(gwei_delta > gwei_current)
  -- if state.BALANCES[[validatorIndex_vi] = $(gwei_current - gwei_current)] = gwei_update*
  -- if state_updated = state[.BALANCES = gwei_update*]

;; case 2: delta ≤ current ⇒ decrease delta
def $decrease_balance(state, validatorIndex_vi, gwei_delta) = state_updated
  -- if $(validatorIndex_vi < |state.BALANCES|)
  -- if state.BALANCES[validatorIndex_vi] = gwei_current
  -- if $(gwei_delta <= gwei_current)
  -- if state.BALANCES[[validatorIndex_vi] = $(gwei_current - gwei_delta)] = gwei_update*
  -- if state_updated = state[.BALANCES = gwei_update*]

;;
;; process_justification_and_finalization
;;
relation Process_justification_and_finalization:
  beaconState ~> beaconState
  hint(input %0)

rule Process_justification_and_finalization/skip:
  state_beaconState ~> state_beaconState
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $(epoch_cur <= ($GENESIS_EPOCH + 1))

rule Process_justification_and_finalization/main:
  state_beaconState ~> state_weighed
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $get_previous_epoch(state_beaconState) = epoch_prev
  -- if $get_unslashed_participating_indices(state_beaconState, $TIMELY_TARGET_FLAG_INDEX, epoch_prev) = validatorIndex_prev_indices*
  -- if $get_unslashed_participating_indices(state_beaconState, $TIMELY_TARGET_FLAG_INDEX, epoch_cur)  = validatorIndex_curr_indices*
  -- if $get_total_active_balance(state_beaconState) = gwei_total_active
  -- if $get_total_balance(state_beaconState, validatorIndex_prev_indices*) = gwei_prev_target_bal
  -- if $get_total_balance(state_beaconState, validatorIndex_curr_indices*) = gwei_curr_target_bal
  -- if $weigh_justification_and_finalization(state_beaconState, gwei_total_active, gwei_prev_target_bal, gwei_curr_target_bal) = state_weighed


;;
;; process_inactivity_updates
;;
relation Process_inactivity_updates:
  beaconState ~> beaconState
  hint(input %0)


;;
;; process_rewards_and_penalties
;;
relation Process_rewards_and_penalties:
  beaconState ~> beaconState
  hint(input %0)


;;
;; process_registry_updates
;;
relation Process_registry_updates:
  beaconState ~> beaconState
  hint(input %0)

;;
;; process_slashings
;;
relation Process_slashings:
  beaconState ~> beaconState
  hint(input %0)


;;
;; process_eth1_data_reset
;;
relation Process_eth1_data_reset:
  beaconState ~> beaconState
  hint(input %0)

rule Process_eth1_data_reset/skip:
  state_beaconState ~> state_beaconState
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_ETH1_VOTING_PERIOD) = uint64_r
  -- if ~(uint64_r = 0)

rule Process_eth1_data_reset/main:
  state_beaconState ~> state_updated
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_ETH1_VOTING_PERIOD) = 0
  -- if state_updated = state_beaconState[.ETH1_DATA_VOTES = eps]


;;
;; process_effective_balance_updates
;;
relation Process_effective_balance_updates:
  beaconState ~> beaconState
  hint(input %0)

rule Process_effective_balance_updates/main:
  state_beaconState ~> state_updated
  -- if state_beaconState.VALIDATORS = validator_list*
  -- if $enumerate_<validator>(validator_list*) = (n, validator_item)*
  -- if $map_list_2_<(nat, validator), beaconState, validator>(
         (n, validator_item)*,
         state_beaconState,
         def $rebalance_validator_enumerated
       ) = validator_updated_list*
  -- if state_updated = state_beaconState[.VALIDATORS = validator_updated_list*]


;;
;; process_slashings_reset
;;
relation Process_slashings_reset:
  beaconState ~> beaconState
  hint(input %0)

rule Process_slashings_reset/skip:
  state_beaconState ~> state_beaconState
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SLASHINGS_VECTOR) = uint64_n
  -- if $(uint64_n >= |state_beaconState.SLASHINGS|)

rule Process_slashings_reset/main:
  state_beaconState ~> state_updated
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SLASHINGS_VECTOR) = uint64_n
  -- if $(uint64_n < |state_beaconState.SLASHINGS|)
  -- if state_beaconState.SLASHINGS[[uint64_n] = 0] = gwei_update*
  -- if state_updated = state_beaconState[.SLASHINGS = gwei_update*]


;;
;; process_randao_mixes_reset
;;
relation Process_randao_mixes_reset:
  beaconState ~> beaconState
  hint(input %0)

rule Process_randao_mixes_reset/skip:
  state_beaconState ~> state_beaconState
  -- if $get_current_epoch(state_beaconState) = epoch_current
  -- if $(epoch_current + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_HISTORICAL_VECTOR) = uint64_n
  -- if $(uint64_n >= |state_beaconState.RANDAO_MIXES|)

rule Process_randao_mixes_reset/main:
  state_beaconState ~> state_updated
  -- if $get_current_epoch(state_beaconState) = epoch_current
  -- if $(epoch_current + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_HISTORICAL_VECTOR) = uint64_n
  -- if $get_randao_mix(state_beaconState, epoch_current) = bytes32_mix
  -- if $(uint64_n < |state_beaconState.RANDAO_MIXES|)
  -- if state_beaconState.RANDAO_MIXES[[uint64_n] = bytes32_mix] = bytes32_randao_mixes_update*
  -- if state_updated = state_beaconState[.RANDAO_MIXES = bytes32_randao_mixes_update*]



;;
;; process_historical_summaries_update
;;
relation Process_historical_summaries_update:
  beaconState ~> beaconState
  hint(input %0)

rule Process_historical_summaries_update/skip:
  state_beaconState ~> state_beaconState
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $(epoch_cur + 1) = epoch_next
  -- if $(epoch_next \ ($SLOTS_PER_HISTORICAL_ROOT / $SLOTS_PER_EPOCH)) = uint64_r
  -- if ~(uint64_r = 0)

rule Process_historical_summaries_update/main:
  state_beaconState ~> state_updated
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $(epoch_cur + 1) = epoch_next
  -- if $( epoch_next \ ($SLOTS_PER_HISTORICAL_ROOT / $SLOTS_PER_EPOCH) ) = 0
  -- if $hash_tree_root_roots(state_beaconState.BLOCK_ROOTS) = root_block_summary
  -- if $hash_tree_root_roots(state_beaconState.STATE_ROOTS) = root_state_summary
  -- if { BLOCK_SUMMARY_ROOT root_block_summary, STATE_SUMMARY_ROOT root_state_summary } = historicalSummary_new
  -- if state_beaconState.HISTORICAL_SUMMARIES ++ [ historicalSummary_new ] = historicalSummary_update*
  -- if state_updated = state_beaconState[.HISTORICAL_SUMMARIES = historicalSummary_update*]


;;
;; process_participation_flag_updates
;;
relation Process_participation_flag_updates:
  beaconState ~> beaconState
  hint(input %0)

rule Process_participation_flag_updates/main:
  state_beaconState ~> state_updated
  -- if participationFlags_prev* = state_beaconState.CURRENT_EPOCH_PARTICIPATION
  -- if $( |state_beaconState.VALIDATORS| ) = uint64_len_validators
  -- if $repeat_<participationFlags>(0, uint64_len_validators) = participationFlags_zero*
  -- if state_mid = state_beaconState[.PREVIOUS_EPOCH_PARTICIPATION = participationFlags_prev*]
  -- if state_updated = state_mid[.CURRENT_EPOCH_PARTICIPATION = participationFlags_zero*]


;;
;; process_sync_committee_updates
;;
relation Process_sync_committee_updates:
  beaconState ~> beaconState
  hint(input %0)

rule Process_sync_committee_updates/skip:
  state_beaconState ~> state_beaconState
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SYNC_COMMITTEE_PERIOD) = uint64_r
  -- if ~(uint64_r = 0)

rule Process_sync_committee_updates/main:
  state_beaconState ~> state_updated
  -- if $($get_current_epoch(state_beaconState) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SYNC_COMMITTEE_PERIOD) = 0
  -- if syncCommittee_next = $get_next_sync_committee(state_beaconState)
  -- if state_updated =
       state_beaconState[.CURRENT_SYNC_COMMITTEE = state_beaconState.NEXT_SYNC_COMMITTEE]
                        [.NEXT_SYNC_COMMITTEE    = syncCommittee_next]



;;
;; process_block_header
;;
relation Process_block_header:
  beaconState beaconBlock ~> beaconState
  hint(input %0 %1)

rule Process_block_header/main:
  state_beaconState block_beaconBlock ~> state_updated
  -- if $(block_beaconBlock.SLOT = state_beaconState.SLOT)
  -- if $(state_beaconState.LATEST_BLOCK_HEADER.SLOT < block_beaconBlock.SLOT)
  -- if $get_beacon_proposer_index(state_beaconState) = validatorIndex_prop_vi
  -- if $(block_beaconBlock.PROPOSER_INDEX = validatorIndex_prop_vi)
  -- if root_parent_expected_root = $hash_tree_root_beaconBlockHeader(state_beaconState.LATEST_BLOCK_HEADER)
  -- if $(block_beaconBlock.PARENT_ROOT = root_parent_expected_root)
  -- if root_body_root_new = $hash_tree_root_beaconBlockBody(block_beaconBlock.BODY)
  -- if beaconBlockHeader_new =
       { SLOT block_beaconBlock.SLOT,
         PROPOSER_INDEX block_beaconBlock.PROPOSER_INDEX,
         PARENT_ROOT block_beaconBlock.PARENT_ROOT,
         STATE_ROOT $ZERO_ROOT,
         BODY_ROOT root_body_root_new }
  -- if $(validatorIndex_prop_vi < |state_beaconState.VALIDATORS|)
  -- if state_beaconState.VALIDATORS[validatorIndex_prop_vi] = validator_proposer
  -- if $(validator_proposer.SLASHED = false)
  -- if state_updated = state_beaconState[.LATEST_BLOCK_HEADER = beaconBlockHeader_new]


;;
;; process_withdrawals
;;   
;;
relation Process_withdrawals:
  beaconState executionPayload ~> beaconState
  hint(input %0 %1)



;;
;; process_execution_payload
;;
relation Process_execution_payload:
  beaconState beaconBlockBody ~> beaconState
  hint(input %0 %1)

rule Process_execution_payload/main:
  state_beaconState body_beaconBlockBody ~> state_updated
  -- if executionPayload_block = body_beaconBlockBody.EXECUTION_PAYLOAD
  -- if $(executionPayload_block.PARENT_HASH = state_beaconState.LATEST_EXECUTION_PAYLOAD_HEADER.BLOCK_HASH)
  -- if $get_current_epoch(state_beaconState) = epoch_cur
  -- if $get_randao_mix(state_beaconState, epoch_cur) = bytes32_randao_expected
  -- if $(executionPayload_block.PREV_RANDAO = bytes32_randao_expected)
  -- if $compute_time_at_slot(state_beaconState, state_beaconState.SLOT) = uint64_ts_expected
  -- if $(executionPayload_block.TIMESTAMP = uint64_ts_expected)
  -- if $ee_verify_and_notify_new_payload(executionPayload_block) = true
  -- if $hash_tree_root_tx(executionPayload_block.TRANSACTIONS) = root_tx
  -- if $hash_tree_root_withdrawals(executionPayload_block.WITHDRAWALS) = root_withdrawal
  -- if executionPayloadHeader_new =
       { PARENT_HASH        executionPayload_block.PARENT_HASH,
         FEE_RECIPIENT      executionPayload_block.FEE_RECIPIENT,
         STATE_ROOT         executionPayload_block.STATE_ROOT,
         RECEIPTS_ROOT      executionPayload_block.RECEIPTS_ROOT,
         LOGS_BLOOM         executionPayload_block.LOGS_BLOOM,
         PREV_RANDAO        executionPayload_block.PREV_RANDAO,
         BLOCK_NUMBER       executionPayload_block.BLOCK_NUMBER,
         GAS_LIMIT          executionPayload_block.GAS_LIMIT,
         GAS_USED           executionPayload_block.GAS_USED,
         TIMESTAMP          executionPayload_block.TIMESTAMP,
         EXTRA_DATA         executionPayload_block.EXTRA_DATA,
         BASE_FEE_PER_GAS   executionPayload_block.BASE_FEE_PER_GAS,
         BLOCK_HASH         executionPayload_block.BLOCK_HASH,
         TRANSACTIONS_ROOT  root_tx,
         WITHDRAWALS_ROOT   root_withdrawal }
  -- if state_updated = state_beaconState[.LATEST_EXECUTION_PAYLOAD_HEADER = executionPayloadHeader_new]



;;
;; process_randao
;;
relation Process_randao:
  beaconState beaconBlockBody ~> beaconState
  hint(input %0 %1)

rule Process_randao/main:
  state_beaconState body_beaconBlockBody ~> state_updated
  -- if $get_current_epoch(state_beaconState) = epoch
  -- if $get_beacon_proposer_index(state_beaconState) = validatorIndex_prop_vi
  -- if $(validatorIndex_prop_vi < |state_beaconState.VALIDATORS|)
  -- if state_beaconState.VALIDATORS[validatorIndex_prop_vi] = validator_proposer
  -- if $get_domain(state_beaconState, $DOMAIN_RANDAO, eps) = domain_randao
  -- if $compute_signing_root(epoch, domain_randao) = root_signing
  -- if $bls_verify(validator_proposer.PUBKEY, root_signing, body_beaconBlockBody.RANDAO_REVEAL) = true
  -- if $get_randao_mix(state_beaconState, epoch) = bytes32_mix_old
  -- if $hash_<blsSignature>(body_beaconBlockBody.RANDAO_REVEAL) = bytes32_hash_reveal
  -- if $xor(bytes32_mix_old, bytes32_hash_reveal) = bytes32_mix_new
  -- if $(epoch \ $EPOCHS_PER_HISTORICAL_VECTOR) = uint64_n
  -- if state_beaconState.RANDAO_MIXES[[uint64_n] = bytes32_mix_new] = bytes32_randao_mixes_update*
  -- if state_updated = state_beaconState[.RANDAO_MIXES = bytes32_randao_mixes_update*]



;;
;; process_eth1_data
;;
relation Process_eth1_data:
  beaconState beaconBlockBody ~> beaconState
  hint(input %0 %1)

rule Process_eth1_data/majority:
  state_beaconState body_beaconBlockBody ~> state_updated
  -- if state_beaconState.ETH1_DATA_VOTES ++ [ body_beaconBlockBody.ETH1_DATA ] = eth1Data_update*
  -- if $count_occurrences_<eth1Data>(eth1Data_update*, body_beaconBlockBody.ETH1_DATA) = nat_occ
  -- if $(nat_occ * 2 > $EPOCHS_PER_ETH1_VOTING_PERIOD * $SLOTS_PER_EPOCH)
  -- if state_updated = state_beaconState[.ETH1_DATA_VOTES = eth1Data_update*][.ETH1_DATA = body_beaconBlockBody.ETH1_DATA]

rule Process_eth1_data/accumulate:
  state_beaconState body_beaconBlockBody ~> state_updated
  -- if state_beaconState.ETH1_DATA_VOTES ++ [ body_beaconBlockBody.ETH1_DATA ] = eth1Data_update*
  -- if $count_occurrences_<eth1Data>(eth1Data_update*, body_beaconBlockBody.ETH1_DATA) = nat_occ
  -- if $(nat_occ * 2 <= $EPOCHS_PER_ETH1_VOTING_PERIOD * $SLOTS_PER_EPOCH)
  -- if state_updated = state_beaconState[.ETH1_DATA_VOTES = eth1Data_update*]




;;
;; Epoch processing 
;;

relation ProcessEpoch:
  beaconState ~>* beaconState
  hint(input %0)

rule ProcessEpoch/main:
  state_beaconState ~>* state_11
  -- Process_justification_and_finalization:  state_beaconState ~> state_0
  -- Process_inactivity_updates:              state_0           ~> state_1
  -- Process_rewards_and_penalties:           state_1           ~> state_2
  -- Process_registry_updates:                state_2           ~> state_3
  -- Process_slashings:                       state_3           ~> state_4
  -- Process_eth1_data_reset:                 state_4           ~> state_5
  -- Process_effective_balance_updates:       state_5           ~> state_6
  -- Process_slashings_reset:                 state_6           ~> state_7
  -- Process_randao_mixes_reset:              state_7           ~> state_8
  -- Process_historical_summaries_update:     state_8           ~> state_9
  -- Process_participation_flag_updates:      state_9           ~> state_10
  -- Process_sync_committee_updates:          state_10          ~> state_11

;;
;; process_operations
;;   

relation Process_operations:
  beaconState beaconBlockBody ~> beaconState
  hint(input %0 %1)

;; 
;; process_deposit
;;
relation ProcessDeposit:
  beaconState deposit ~> beaconState
  hint(input %0 %1)

rule ProcessDeposit/main:
  state deposit ~> state_applied
  -- if $hash_tree_root_depositData(deposit.DATA) = root_leaf
  -- if $( $DEPOSIT_CONTRACT_TREE_DEPTH + 1 ) = uint64_depth_plus_1
  -- if $is_valid_merkle_branch(
         root_leaf,
         deposit.PROOF,
         uint64_depth_plus_1,
         state.ETH1_DEPOSIT_INDEX,
         state.ETH1_DATA.DEPOSIT_ROOT
       ) = true
  -- if $(state.ETH1_DEPOSIT_INDEX + 1) = uint64_deposit_index_next
  -- if state_inc = state[.ETH1_DEPOSIT_INDEX = uint64_deposit_index_next]
  -- if state_applied =
       $apply_deposit(
         state_inc,
         deposit.DATA.PUBKEY,
         deposit.DATA.WITHDRAWAL_CREDENTIALS,
         deposit.DATA.AMOUNT,
         deposit.DATA.SIGNATURE
       )

;; 
;; process_voluntary_exit
;; 

relation ProcessVoluntaryExit:
  beaconState signedVoluntaryExit ~> beaconState
  hint(input %0 %1)

rule ProcessVoluntaryExit/main:
  state signedVoluntaryExit ~> state_after_exit
  -- if voluntaryExit = signedVoluntaryExit.MESSAGE
  -- if validatorIndex_exit = voluntaryExit.VALIDATOR_INDEX
  -- if $(validatorIndex_exit < |state.VALIDATORS|)
  -- if state.VALIDATORS[validatorIndex_exit] = validator
  -- if $get_current_epoch(state) = epoch_cur
  -- if $is_active_validator(validator, epoch_cur) = true
  -- if $(validator.EXIT_EPOCH = $FAR_FUTURE_EPOCH)
  -- if $(epoch_cur >= voluntaryExit.EPOCH)
  -- if $(epoch_cur >= validator.ACTIVATION_EPOCH + $SHARD_COMMITTEE_PERIOD)
  -- if $get_domain(state, $DOMAIN_VOLUNTARY_EXIT, voluntaryExit.EPOCH) = domain_exit
  -- if $compute_signing_root_voluntary_exit(voluntaryExit, domain_exit) = root_vol_exit_signing_root
  -- if $bls_verify(validator.PUBKEY, root_vol_exit_signing_root, signedVoluntaryExit.SIGNATURE) = true
  -- if state_after_exit = $initiate_validator_exit(state, validatorIndex_exit)

;; 
;; process_bls_to_execution_change
;; 
relation ProcessBLSToExecutionChange:
  beaconState signedBlsToExecutionChange ~> beaconState
  hint(input %0 %1)

rule ProcessBLSToExecutionChange/main:
  state signedBlsToExecutionChange ~> state_updated
  -- if blsToExecutionChange = signedBlsToExecutionChange.MESSAGE
  -- if validatorIndex_change = blsToExecutionChange.VALIDATOR_INDEX
  -- if $(validatorIndex_change < |state.VALIDATORS|)
  -- if state.VALIDATORS[validatorIndex_change] = validator
  -- if $get_first_byte(validator.WITHDRAWAL_CREDENTIALS) = $BLS_WITHDRAWAL_PREFIX
  -- if $hash_<blsPubkey>(blsToExecutionChange.FROM_BLS_PUBKEY) = bytes32_pk_hash
  -- if $strip_first_byte(validator.WITHDRAWAL_CREDENTIALS) = bytes32_wc_tail
  -- if $strip_first_byte(bytes32_pk_hash) = bytes32_pk_tail
  -- if $(bytes32_wc_tail = bytes32_pk_tail)
  -- if $compute_domain($DOMAIN_BLS_TO_EXECUTION_CHANGE, eps, state.GENESIS_VALIDATORS_ROOT) = domain_btec
  -- if $compute_signing_root_bls_to_execution_change(blsToExecutionChange, domain_btec) = root_sign
  -- if $bls_verify(blsToExecutionChange.FROM_BLS_PUBKEY, root_sign, signedBlsToExecutionChange.SIGNATURE) = true
  -- if $make_withdrawal_credentials_eth1(blsToExecutionChange.TO_EXECUTION_ADDRESS) = bytes32_new_wc
  -- if validator_updated = validator[.WITHDRAWAL_CREDENTIALS = bytes32_new_wc]
  -- if state.VALIDATORS[[validatorIndex_change] = validator_updated] = validator_update*
  -- if state_updated = state[.VALIDATORS = validator_update*]

;;
;; process_sync_aggregate
;; 


;;
relation Process_sync_aggregate:
  beaconState syncAggregate ~> beaconState
  hint(input %0 %1)

;;
;; process_block
;;
relation ProcessBlock:
  beaconState beaconBlock ~>* beaconState
  hint(input %0 %1)

rule ProcessBlock/main:
  state_beaconState block_beaconBlock ~>* state_6
  -- Process_block_header:     state_beaconState                   block_beaconBlock                     ~>  state_0
  -- Process_withdrawals:      state_0                              block_beaconBlock.BODY.EXECUTION_PAYLOAD ~> state_1
  -- Process_execution_payload: state_1                             block_beaconBlock.BODY                ~>  state_2
  -- Process_randao:           state_2                              block_beaconBlock.BODY                ~>  state_3
  -- Process_eth1_data:        state_3                              block_beaconBlock.BODY                ~>  state_4
  -- Process_operations:       state_4                              block_beaconBlock.BODY                ~>  state_5
  -- Process_sync_aggregate:   state_5                              block_beaconBlock.BODY.SYNC_AGGREGATE ~>  state_6