syntax bytes4 = int
syntax bytes32 = int
syntax bytes1 = int
syntax bytes8 = int
syntax bytes20 = int
syntax bytes48 = int
syntax bytes96 = int
syntax bytes256 = int
syntax uint8 = nat
syntax uint64 = nat
syntax uint256 = nat
syntax bytes28 = int

;;
;; Custom Types
;;

syntax slot = uint64
syntax epoch = uint64
syntax validatorIndex = uint64
syntax gwei = uint64
syntax root = bytes32
syntax hash32 = bytes32
syntax version = bytes4
syntax committeeIndex = uint64
syntax boolean = bool
syntax domainType = bytes4
syntax forkDigest = bytes4
syntax domain = bytes32
syntax blsPubkey = bytes48
syntax blsSignature = bytes96
syntax nodeID = bytes256
syntax subnetID = uint64
syntax ether = uint64
syntax participationFlags = uint8
syntax executionAddress = bytes20
syntax payloadId = bytes8
syntax withdrawalIndex = uint64

;;
;; Constants: defined as parameterless functions
;;

;;
;; Constant vars  →  parameterless functions
;;

dec $UINT64_MAX : uint64
def $UINT64_MAX = 18446744073709551615

dec $UINT64_MAX_SQRT : uint64
def $UINT64_MAX_SQRT = 4294967295

dec $GENESIS_SLOT : slot
def $GENESIS_SLOT = 0

dec $GENESIS_EPOCH : epoch
def $GENESIS_EPOCH = 0

dec $FAR_FUTURE_EPOCH : epoch
def $FAR_FUTURE_EPOCH = 18446744073709551615

dec $BASE_REWARDS_PER_EPOCH : uint64
def $BASE_REWARDS_PER_EPOCH = 4

dec $DEPOSIT_CONTRACT_TREE_DEPTH : uint64
def $DEPOSIT_CONTRACT_TREE_DEPTH = 32

dec $JUSTIFICATION_BITS_LENGTH : uint64
def $JUSTIFICATION_BITS_LENGTH = 4


dec $BLS_WITHDRAWAL_PREFIX : bytes1
def $BLS_WITHDRAWAL_PREFIX = 0        ;; 0x00

dec $ETH1_ADDRESS_WITHDRAWAL_PREFIX : bytes1
def $ETH1_ADDRESS_WITHDRAWAL_PREFIX = 1  ;; 0x01

dec $DOMAIN_BEACON_PROPOSER : domainType
def $DOMAIN_BEACON_PROPOSER = 0           ;; 0x00000000

dec $DOMAIN_BEACON_ATTESTER : domainType
def $DOMAIN_BEACON_ATTESTER = 16777216    ;; 0x01000000

dec $DOMAIN_RANDAO : domainType
def $DOMAIN_RANDAO = 33554432             ;; 0x02000000

dec $DOMAIN_DEPOSIT : domainType
def $DOMAIN_DEPOSIT = 50331648            ;; 0x03000000

dec $DOMAIN_VOLUNTARY_EXIT : domainType
def $DOMAIN_VOLUNTARY_EXIT = 67108864     ;; 0x04000000

dec $DOMAIN_SELECTION_PROOF : domainType
def $DOMAIN_SELECTION_PROOF = 83886080    ;; 0x05000000

dec $DOMAIN_AGGREGATE_AND_PROOF : domainType
def $DOMAIN_AGGREGATE_AND_PROOF = 100663296  ;; 0x06000000

dec $DOMAIN_APPLICATION_MASK : domainType
def $DOMAIN_APPLICATION_MASK = 1          ;; 0x00000001

dec $INTERVALS_PER_SLOT : uint64
def $INTERVALS_PER_SLOT = 3

dec $BASIS_POINTS : uint64
def $BASIS_POINTS = 10000

dec $NODE_ID_BITS : nat
def $NODE_ID_BITS = 256

dec $MAX_CONCURRENT_REQUESTS : nat
def $MAX_CONCURRENT_REQUESTS = 2

dec $TARGET_AGGREGATORS_PER_COMMITTEE_CONST : nat
def $TARGET_AGGREGATORS_PER_COMMITTEE_CONST = 16   ;; 2**4

dec $ETH_TO_GWEI : uint64
def $ETH_TO_GWEI = 1000000000

dec $SAFETY_DECAY : uint64
def $SAFETY_DECAY = 10

dec $TIMELY_SOURCE_FLAG_INDEX : nat
def $TIMELY_SOURCE_FLAG_INDEX = 0

dec $TIMELY_TARGET_FLAG_INDEX : nat
def $TIMELY_TARGET_FLAG_INDEX = 1

dec $TIMELY_HEAD_FLAG_INDEX : nat
def $TIMELY_HEAD_FLAG_INDEX = 2

dec $TIMELY_SOURCE_WEIGHT : uint64
def $TIMELY_SOURCE_WEIGHT = 14

dec $TIMELY_TARGET_WEIGHT : uint64
def $TIMELY_TARGET_WEIGHT = 26

dec $TIMELY_HEAD_WEIGHT : uint64
def $TIMELY_HEAD_WEIGHT = 14

dec $SYNC_REWARD_WEIGHT : uint64
def $SYNC_REWARD_WEIGHT = 2

dec $PROPOSER_WEIGHT : uint64
def $PROPOSER_WEIGHT = 8

dec $WEIGHT_DENOMINATOR : uint64
def $WEIGHT_DENOMINATOR = 64

dec $DOMAIN_SYNC_COMMITTEE : domainType
def $DOMAIN_SYNC_COMMITTEE = 117440512           ;; 0x07000000

dec $DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF : domainType
def $DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF = 134217728  ;; 0x08000000

dec $DOMAIN_CONTRIBUTION_AND_PROOF : domainType
def $DOMAIN_CONTRIBUTION_AND_PROOF = 150994944   ;; 0x09000000

dec $PARTICIPATION_FLAG_WEIGHTS : uint64*
def $PARTICIPATION_FLAG_WEIGHTS = [ $TIMELY_SOURCE_WEIGHT, $TIMELY_TARGET_WEIGHT, $TIMELY_HEAD_WEIGHT ]

;; we encode as 0 placeholder (bytes96 = int).
;; OCaml 에 bls-12-381 라이브러리가 존재하던데 이걸 사용하면?
dec $G2_POINT_AT_INFINITY : blsSignature
def $G2_POINT_AT_INFINITY = 0

dec $TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE : nat
def $TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE = 16   ;; 2**4

dec $SYNC_COMMITTEE_SUBNET_COUNT : nat
def $SYNC_COMMITTEE_SUBNET_COUNT = 4

dec $MAX_REQUEST_LIGHT_CLIENT_UPDATES : nat
def $MAX_REQUEST_LIGHT_CLIENT_UPDATES = 128          ;; 2**7

dec $SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY : nat
def $SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY = 128

dec $DOMAIN_BLS_TO_EXECUTION_CHANGE : domainType
def $DOMAIN_BLS_TO_EXECUTION_CHANGE = 167772160      ;; 0x0A000000


;;
;; Preset vars  →  parameterless functions
;;

dec $MAX_COMMITTEES_PER_SLOT : uint64
def $MAX_COMMITTEES_PER_SLOT = 64

dec $TARGET_COMMITTEE_SIZE : uint64
def $TARGET_COMMITTEE_SIZE = 128

dec $MAX_VALIDATORS_PER_COMMITTEE : uint64
def $MAX_VALIDATORS_PER_COMMITTEE = 2048

dec $SHUFFLE_ROUND_COUNT : uint64
def $SHUFFLE_ROUND_COUNT = 90

dec $HYSTERESIS_QUOTIENT : uint64
def $HYSTERESIS_QUOTIENT = 4

dec $HYSTERESIS_DOWNWARD_MULTIPLIER : uint64
def $HYSTERESIS_DOWNWARD_MULTIPLIER = 1

dec $HYSTERESIS_UPWARD_MULTIPLIER : uint64
def $HYSTERESIS_UPWARD_MULTIPLIER = 5

dec $MIN_DEPOSIT_AMOUNT : gwei
def $MIN_DEPOSIT_AMOUNT = 1000000000

dec $MAX_EFFECTIVE_BALANCE : gwei
def $MAX_EFFECTIVE_BALANCE = 32000000000

dec $EFFECTIVE_BALANCE_INCREMENT : gwei
def $EFFECTIVE_BALANCE_INCREMENT = 1000000000

dec $MIN_ATTESTATION_INCLUSION_DELAY : uint64
def $MIN_ATTESTATION_INCLUSION_DELAY = 1

dec $SLOTS_PER_EPOCH : uint64
def $SLOTS_PER_EPOCH = 32

dec $MIN_SEED_LOOKAHEAD : uint64
def $MIN_SEED_LOOKAHEAD = 1

dec $MAX_SEED_LOOKAHEAD : uint64
def $MAX_SEED_LOOKAHEAD = 4

dec $MIN_EPOCHS_TO_INACTIVITY_PENALTY : uint64
def $MIN_EPOCHS_TO_INACTIVITY_PENALTY = 4

dec $EPOCHS_PER_ETH1_VOTING_PERIOD : uint64
def $EPOCHS_PER_ETH1_VOTING_PERIOD = 64

dec $SLOTS_PER_HISTORICAL_ROOT : uint64
def $SLOTS_PER_HISTORICAL_ROOT = 8192

dec $EPOCHS_PER_HISTORICAL_VECTOR : uint64
def $EPOCHS_PER_HISTORICAL_VECTOR = 65536

dec $EPOCHS_PER_SLASHINGS_VECTOR : uint64
def $EPOCHS_PER_SLASHINGS_VECTOR = 8192

dec $HISTORICAL_ROOTS_LIMIT : uint64
def $HISTORICAL_ROOTS_LIMIT = 16777216

dec $VALIDATOR_REGISTRY_LIMIT : uint64
def $VALIDATOR_REGISTRY_LIMIT = 1099511627776

dec $BASE_REWARD_FACTOR : uint64
def $BASE_REWARD_FACTOR = 64

dec $WHISTLEBLOWER_REWARD_QUOTIENT : uint64
def $WHISTLEBLOWER_REWARD_QUOTIENT = 512

dec $PROPOSER_REWARD_QUOTIENT : uint64
def $PROPOSER_REWARD_QUOTIENT = 8

dec $INACTIVITY_PENALTY_QUOTIENT : uint64
def $INACTIVITY_PENALTY_QUOTIENT = 67108864

dec $MIN_SLASHING_PENALTY_QUOTIENT : uint64
def $MIN_SLASHING_PENALTY_QUOTIENT = 128

dec $PROPORTIONAL_SLASHING_MULTIPLIER : uint64
def $PROPORTIONAL_SLASHING_MULTIPLIER = 1

dec $MAX_PROPOSER_SLASHINGS : nat
def $MAX_PROPOSER_SLASHINGS = 16

dec $MAX_ATTESTER_SLASHINGS : nat
def $MAX_ATTESTER_SLASHINGS = 2

dec $MAX_ATTESTATIONS : nat
def $MAX_ATTESTATIONS = 128

dec $MAX_DEPOSITS : nat
def $MAX_DEPOSITS = 16

dec $MAX_VOLUNTARY_EXITS : nat
def $MAX_VOLUNTARY_EXITS = 16

dec $INACTIVITY_PENALTY_QUOTIENT_ALTAIR : uint64
def $INACTIVITY_PENALTY_QUOTIENT_ALTAIR = 50331648

dec $MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR : uint64
def $MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR = 64

dec $PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR : uint64
def $PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR = 2

dec $SYNC_COMMITTEE_SIZE : uint64
def $SYNC_COMMITTEE_SIZE = 512

dec $EPOCHS_PER_SYNC_COMMITTEE_PERIOD : uint64
def $EPOCHS_PER_SYNC_COMMITTEE_PERIOD = 256

dec $MIN_SYNC_COMMITTEE_PARTICIPANTS : nat
def $MIN_SYNC_COMMITTEE_PARTICIPANTS = 1

dec $UPDATE_TIMEOUT : nat
def $UPDATE_TIMEOUT = 8192

dec $INACTIVITY_PENALTY_QUOTIENT_BELLATRIX : uint64
def $INACTIVITY_PENALTY_QUOTIENT_BELLATRIX = 16777216

dec $MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX : uint64
def $MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX = 32

dec $PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX : uint64
def $PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX = 3

dec $MAX_BYTES_PER_TRANSACTION : uint64
def $MAX_BYTES_PER_TRANSACTION = 1073741824

dec $MAX_TRANSACTIONS_PER_PAYLOAD : uint64
def $MAX_TRANSACTIONS_PER_PAYLOAD = 1048576

dec $BYTES_PER_LOGS_BLOOM : uint64
def $BYTES_PER_LOGS_BLOOM = 256

dec $MAX_EXTRA_DATA_BYTES : nat
def $MAX_EXTRA_DATA_BYTES = 32

dec $MAX_BLS_TO_EXECUTION_CHANGES : nat
def $MAX_BLS_TO_EXECUTION_CHANGES = 16

dec $MAX_WITHDRAWALS_PER_PAYLOAD : uint64
def $MAX_WITHDRAWALS_PER_PAYLOAD = 16

dec $MAX_VALIDATORS_PER_WITHDRAWALS_SWEEP : nat
def $MAX_VALIDATORS_PER_WITHDRAWALS_SWEEP = 16384

;; Configuration-derived constants (parameterless functions)

dec $MIN_GENESIS_ACTIVE_VALIDATOR_COUNT : uint64
def $MIN_GENESIS_ACTIVE_VALIDATOR_COUNT = 16384

dec $MIN_GENESIS_TIME : uint64
def $MIN_GENESIS_TIME = 1606824000

dec $GENESIS_FORK_VERSION : version
def $GENESIS_FORK_VERSION = 0                     ;; 0x00000000

dec $GENESIS_DELAY : uint64
def $GENESIS_DELAY = 604800

dec $SECONDS_PER_SLOT : uint64
def $SECONDS_PER_SLOT = 12

dec $SLOT_DURATION_MS : uint64
def $SLOT_DURATION_MS = 12000

dec $SECONDS_PER_ETH1_BLOCK : uint64
def $SECONDS_PER_ETH1_BLOCK = 14

dec $MIN_VALIDATOR_WITHDRAWABILITY_DELAY : uint64
def $MIN_VALIDATOR_WITHDRAWABILITY_DELAY = 256

dec $SHARD_COMMITTEE_PERIOD : uint64
def $SHARD_COMMITTEE_PERIOD = 256

dec $ETH1_FOLLOW_DISTANCE : uint64
def $ETH1_FOLLOW_DISTANCE = 2048

dec $EJECTION_BALANCE : gwei
def $EJECTION_BALANCE = 16000000000

dec $MIN_PER_EPOCH_CHURN_LIMIT : uint64
def $MIN_PER_EPOCH_CHURN_LIMIT = 4

dec $CHURN_LIMIT_QUOTIENT : uint64
def $CHURN_LIMIT_QUOTIENT = 65536

dec $PROPOSER_SCORE_BOOST : uint64
def $PROPOSER_SCORE_BOOST = 40

dec $REORG_HEAD_WEIGHT_THRESHOLD : uint64
def $REORG_HEAD_WEIGHT_THRESHOLD = 20

dec $REORG_PARENT_WEIGHT_THRESHOLD : uint64
def $REORG_PARENT_WEIGHT_THRESHOLD = 160

dec $REORG_MAX_EPOCHS_SINCE_FINALIZATION : epoch
def $REORG_MAX_EPOCHS_SINCE_FINALIZATION = 2

dec $PROPOSER_REORG_CUTOFF_BPS : uint64
def $PROPOSER_REORG_CUTOFF_BPS = 1667

dec $MAX_PAYLOAD_SIZE : nat
def $MAX_PAYLOAD_SIZE = 10485760

dec $MAX_REQUEST_BLOCKS : nat
def $MAX_REQUEST_BLOCKS = 1024

dec $EPOCHS_PER_SUBNET_SUBSCRIPTION : nat
def $EPOCHS_PER_SUBNET_SUBSCRIPTION = 256

dec $MIN_EPOCHS_FOR_BLOCK_REQUESTS : nat
def $MIN_EPOCHS_FOR_BLOCK_REQUESTS = 33024

dec $ATTESTATION_PROPAGATION_SLOT_RANGE : nat
def $ATTESTATION_PROPAGATION_SLOT_RANGE = 32

dec $MAXIMUM_GOSSIP_CLOCK_DISPARITY : nat
def $MAXIMUM_GOSSIP_CLOCK_DISPARITY = 500

dec $MESSAGE_DOMAIN_INVALID_SNAPPY : domainType
def $MESSAGE_DOMAIN_INVALID_SNAPPY = 0            ;; 0x00000000

dec $MESSAGE_DOMAIN_VALID_SNAPPY : domainType
def $MESSAGE_DOMAIN_VALID_SNAPPY = 16777216       ;; 0x01000000

dec $SUBNETS_PER_NODE : nat
def $SUBNETS_PER_NODE = 2

dec $ATTESTATION_SUBNET_COUNT : nat
def $ATTESTATION_SUBNET_COUNT = 64

dec $ATTESTATION_SUBNET_EXTRA_BITS : nat
def $ATTESTATION_SUBNET_EXTRA_BITS = 0

dec $ATTESTATION_SUBNET_PREFIX_BITS : nat
def $ATTESTATION_SUBNET_PREFIX_BITS = 6

dec $ATTESTATION_DUE_BPS : uint64
def $ATTESTATION_DUE_BPS = 3333

dec $AGGREGATE_DUE_BPS : uint64
def $AGGREGATE_DUE_BPS = 6667

dec $INACTIVITY_SCORE_BIAS : uint64
def $INACTIVITY_SCORE_BIAS = 4

dec $INACTIVITY_SCORE_RECOVERY_RATE : uint64
def $INACTIVITY_SCORE_RECOVERY_RATE = 16

dec $ALTAIR_FORK_VERSION : version
def $ALTAIR_FORK_VERSION = 16777216              ;; 0x01000000

dec $ALTAIR_FORK_EPOCH : epoch
def $ALTAIR_FORK_EPOCH = 74240

dec $SYNC_MESSAGE_DUE_BPS : uint64
def $SYNC_MESSAGE_DUE_BPS = 3333

dec $CONTRIBUTION_DUE_BPS : uint64
def $CONTRIBUTION_DUE_BPS = 6667

dec $TERMINAL_TOTAL_DIFFICULTY : uint256
def $TERMINAL_TOTAL_DIFFICULTY = 58750000000000000000000

dec $TERMINAL_BLOCK_HASH : hash32
def $TERMINAL_BLOCK_HASH = 0                      ;; 0x00..00 (32 bytes)

dec $TERMINAL_BLOCK_HASH_ACTIVATION_EPOCH : epoch
def $TERMINAL_BLOCK_HASH_ACTIVATION_EPOCH = $FAR_FUTURE_EPOCH

dec $BELLATRIX_FORK_VERSION : version
def $BELLATRIX_FORK_VERSION = 33554432            ;; 0x02000000

dec $BELLATRIX_FORK_EPOCH : epoch
def $BELLATRIX_FORK_EPOCH = 144896

dec $CAPELLA_FORK_VERSION : version
def $CAPELLA_FORK_VERSION = 50331648              ;; 0x03000000

dec $CAPELLA_FORK_EPOCH : epoch
def $CAPELLA_FORK_EPOCH = 194048

;; 0x0000....
dec $ZERO_ROOT : root
def $ZERO_ROOT = 0
;;
;; Containers: defined as SpecTec struct types
;;

syntax fork =
  { PREVIOUS_VERSION version,
    CURRENT_VERSION version,
    EPOCH epoch }

syntax forkdata =
  { CURRENT_VERSION version,
    GENESIS_VALIDATORS_ROOT root }

syntax checkpoint =
  { EPOCH epoch,
    ROOT root }

syntax eth1Data =
  { DEPOSIT_ROOT root,
    DEPOSIT_COUNT uint64,
    BLOCK_HASH hash32 }

syntax beaconBlockHeader =
  { SLOT slot,
    PROPOSER_INDEX validatorIndex,
    PARENT_ROOT root,
    STATE_ROOT root,
    BODY_ROOT root }



;; Additional container types
syntax validator =
  { PUBKEY blsPubkey,
    WITHDRAWAL_CREDENTIALS bytes32,
    EFFECTIVE_BALANCE gwei,
    SLASHED boolean,
    ACTIVATION_ELIGIBILITY_EPOCH epoch,
    ACTIVATION_EPOCH epoch,
    EXIT_EPOCH epoch,
    WITHDRAWABLE_EPOCH epoch }

syntax attestationData =
  { SLOT slot,
    INDEX committeeIndex,
    BEACON_BLOCK_ROOT root,
    SOURCE checkpoint,
    TARGET checkpoint }

syntax indexedAttestation =
  { ATTESTING_INDICES validatorIndex*,
    DATA attestationData,
    SIGNATURE blsSignature }

syntax pendingAttestation =
  { AGGREGATION_BITS boolean*,
    DATA attestationData,
    INCLUSION_DELAY slot,
    PROPOSER_INDEX validatorIndex }

syntax historicalBatch =
  { BLOCK_ROOTS root*,
    STATE_ROOTS root* }

syntax depositMessage =
  { PUBKEY blsPubkey,
    WITHDRAWAL_CREDENTIALS bytes32,
    AMOUNT gwei }

syntax depositData =
  { PUBKEY blsPubkey,
    WITHDRAWAL_CREDENTIALS bytes32,
    AMOUNT gwei,
    SIGNATURE blsSignature }

syntax signingData =
  { OBJECT_ROOT root,
    DOMAIN domain }

syntax attesterSlashing =
  { ATTESTATION_1 indexedAttestation,
    ATTESTATION_2 indexedAttestation }

syntax attestation =
  { AGGREGATION_BITS boolean*,
    DATA attestationData,
    SIGNATURE blsSignature }

syntax deposit =
  { PROOF bytes32*,
    DATA depositData }

syntax voluntaryExit =
  { EPOCH epoch,
    VALIDATOR_INDEX validatorIndex }

syntax signedVoluntaryExit =
  { MESSAGE voluntaryExit,
    SIGNATURE blsSignature }

syntax signedBeaconBlockHeader =
  { MESSAGE beaconBlockHeader,
    SIGNATURE blsSignature }

syntax proposerSlashing =
  { SIGNED_HEADER_1 signedBeaconBlockHeader,
    SIGNED_HEADER_2 signedBeaconBlockHeader }

syntax eth1Block =
  { TIMESTAMP uint64,
    DEPOSIT_ROOT root,
    DEPOSIT_COUNT uint64 }

syntax aggregateAndProof =
  { AGGREGATOR_INDEX validatorIndex,
    AGGREGATE attestation,
    SELECTION_PROOF blsSignature }

syntax signedAggregateAndProof =
  { MESSAGE aggregateAndProof,
    SIGNATURE blsSignature }

syntax syncAggregate =
  { SYNC_COMMITTEE_BITS boolean*,
    SYNC_COMMITTEE_SIGNATURE blsSignature }

syntax syncCommittee =
  { PUBKEYS blsPubkey*,
    AGGREGATE_PUBKEY blsPubkey }

syntax syncCommitteeMessage =
  { SLOT slot,
    BEACON_BLOCK_ROOT root,
    VALIDATOR_INDEX validatorIndex,
    SIGNATURE blsSignature }

syntax syncCommitteeContribution =
  { SLOT slot,
    BEACON_BLOCK_ROOT root,
    SUBCOMMITTEE_INDEX uint64,
    AGGREGATION_BITS boolean*,
    SIGNATURE blsSignature }

syntax contributionAndProof =
  { AGGREGATOR_INDEX validatorIndex,
    CONTRIBUTION syncCommitteeContribution,
    SELECTION_PROOF blsSignature }

syntax signedContributionAndProof =
  { MESSAGE contributionAndProof,
    SIGNATURE blsSignature }

syntax syncAggregatorSelectionData =
  { SLOT slot,
    SUBCOMMITTEE_INDEX uint64 }

syntax executionPayloadHeader =
  { PARENT_HASH hash32,
    FEE_RECIPIENT executionAddress,
    STATE_ROOT bytes32,
    RECEIPTS_ROOT bytes32,
    LOGS_BLOOM bytes32*,
    PREV_RANDAO bytes32,
    BLOCK_NUMBER uint64,
    GAS_LIMIT uint64,
    GAS_USED uint64,
    TIMESTAMP uint64,
    EXTRA_DATA bytes32*,
    BASE_FEE_PER_GAS uint256,
    BLOCK_HASH hash32,
    TRANSACTIONS_ROOT root,
    WITHDRAWALS_ROOT root }

syntax powBlock =
  { BLOCK_HASH hash32,
    PARENT_HASH hash32,
    TOTAL_DIFFICULTY uint256 }

syntax withdrawal =
  { INDEX withdrawalIndex,
    VALIDATOR_INDEX validatorIndex,
    ADDRESS executionAddress,
    AMOUNT gwei }

syntax executionPayload =
  { PARENT_HASH hash32,
    FEE_RECIPIENT executionAddress,
    STATE_ROOT bytes32,
    RECEIPTS_ROOT bytes32,
    LOGS_BLOOM bytes32*,
    PREV_RANDAO bytes32,
    BLOCK_NUMBER uint64,
    GAS_LIMIT uint64,
    GAS_USED uint64,
    TIMESTAMP uint64,
    EXTRA_DATA bytes32*,
    BASE_FEE_PER_GAS uint256,
    BLOCK_HASH hash32,
    TRANSACTIONS bytes32*,
    WITHDRAWALS withdrawal* }

syntax blsToExecutionChange =
  { VALIDATOR_INDEX validatorIndex,
    FROM_BLS_PUBKEY blsPubkey,
    TO_EXECUTION_ADDRESS executionAddress }

syntax signedBlsToExecutionChange =
  { MESSAGE blsToExecutionChange,
    SIGNATURE blsSignature }



syntax historicalSummary =
  { BLOCK_SUMMARY_ROOT root,
    STATE_SUMMARY_ROOT root }

syntax beaconState =
  { GENESIS_TIME uint64,
    GENESIS_VALIDATORS_ROOT bytes32,
    SLOT slot,
    FORK fork,
    LATEST_BLOCK_HEADER beaconBlockHeader,
    BLOCK_ROOTS root*,
    STATE_ROOTS root*,
    HISTORICAL_ROOTS root*,
    ETH1_DATA eth1Data,
    ETH1_DATA_VOTES eth1Data*,
    ETH1_DEPOSIT_INDEX uint64,
    VALIDATORS validator*,
    BALANCES gwei*,
    RANDAO_MIXES bytes32*,
    SLASHINGS gwei*,
    PREVIOUS_EPOCH_PARTICIPATION participationFlags*,
    CURRENT_EPOCH_PARTICIPATION participationFlags*,
    JUSTIFICATION_BITS boolean*,
    PREVIOUS_JUSTIFIED_CHECKPOINT checkpoint,
    CURRENT_JUSTIFIED_CHECKPOINT checkpoint,
    FINALIZED_CHECKPOINT checkpoint,
    INACTIVITY_SCORES uint64*,
    CURRENT_SYNC_COMMITTEE syncCommittee,
    NEXT_SYNC_COMMITTEE syncCommittee,
    LATEST_EXECUTION_PAYLOAD_HEADER executionPayloadHeader,
    NEXT_WITHDRAWAL_INDEX withdrawalIndex,
    NEXT_WITHDRAWAL_VALIDATOR_INDEX validatorIndex,
    HISTORICAL_SUMMARIES historicalSummary* }

syntax beaconBlockBody =
  {
    RANDAO_REVEAL blsSignature,
    ETH1_DATA eth1Data,
    GRAFFITI bytes32,
    PROPOSER_SLASHINGS proposerSlashing*,
    ATTESTER_SLASHINGS attesterSlashing*,
    ATTESTATIONS attestation*,
    DEPOSITS deposit*,
    VOLUNTARY_EXITS voluntaryExit*,
    ;; [Altair] sync committee aggregation
    SYNC_AGGREGATE syncAggregate,
    ;; [Bellatrix/Capella] execution-layer payload
    EXECUTION_PAYLOAD executionPayload,
    ;; [Capella] BLS to Execution address change
    BLS_TO_EXECUTION_CHANGES signedBlsToExecutionChange*
  }

syntax beaconBlock =
  { SLOT slot,
    PROPOSER_INDEX validatorIndex,
    PARENT_ROOT root,
    STATE_ROOT root,
    BODY beaconBlockBody }

syntax signedBeaconBlock =
  { MESSAGE beaconBlock,
    SIGNATURE blsSignature }

;;
;; Variables
;;

var i : int
var n : nat
var state : beaconState
var body : beaconBlockBody
var block : beaconBlock

var delta           : gwei
var idx             : nat
var current         : gwei
var newBalance      : gwei
var balancesUpdate  : gwei*

var attd1 : attestationData
var attd2 : attestationData

var curVer  : version
var genRoot : root

var balance : gwei

;;
;; Standard functions for list operations
;;

;; update list at position
dec $update_list_<X>(X*, nat, X) : X*

;; count occurrences of element in list
dec $count_occurrences_<X>(X*, X) : nat

;; list 인덱싱 헬퍼 함수 (리스트에서 몇번째 인덱스의 값)
dec $nth_<X>(X*, nat) : X

;; utility: structural inequality (서로 다른 구조체)
dec $neq_<X>(X, X) : boolean

;; validatorIndex nat 으로 캐스팅?
dec $as_nat_validatorIndex(validatorIndex) : nat


;; hash_tree_root for forkdata
dec $hash_tree_root_forkdata(forkdata) : root

;; hash_tree_root_for root
dec $hash_tree_root_roots(root*) : root


;; 첫 1바이트 슬라이싱
dec $get_first_byte(bytes32) : bytes1

;; integer squareroot 
dec $integer_squareroot(uint64) : uint64

;; xor
dec $xor(bytes32, bytes32) : bytes32

;; bytes_to_uint64 (little Endian!!)
dec $bytes_to_uint64(bytes32) : uint64

;; 28 바이트 슬라이싱
dec $first_28_bytes(bytes32) : bytes28

;; 바이트 값 이어붙이기
dec $concat_domain(domainType, bytes28) : domain

;; max for uint64
dec $max_uint64(uint64, uint64) : uint64
def $max_uint64(uint64, uint64) = uint64
  -- if $(uint64 >= uint64)
def $max_uint64(uint64, uint64) = uint64
  -- otherwise

;; min for uint64
dec $min_uint64(uint64, uint64) : uint64
def $min_uint64(uint64, uint64) = uint64
  -- if $(uint64 <= uint64)
def $min_uint64(uint64, uint64) = uint64
  -- otherwise

;;
;; Helper functions
;;


;; ------------------------------------------------------------
;; compute_epoch_at_slot
;; ------------------------------------------------------------
dec $compute_epoch_at_slot(slot) : epoch
def $compute_epoch_at_slot(slot) =
  $(slot / $SLOTS_PER_EPOCH)

;; ------------------------------------------------------------
;; compute_start_slot_at_epoch
;; ------------------------------------------------------------
dec $compute_start_slot_at_epoch(epoch) : slot
def $compute_start_slot_at_epoch(epoch) =
  $(epoch * $SLOTS_PER_EPOCH)

;; ------------------------------------------------------------
;; get_current_epoch
;; ------------------------------------------------------------
dec $get_current_epoch(beaconState) : epoch
def $get_current_epoch(state) = $compute_epoch_at_slot(state.SLOT)

;; ------------------------------------------------------------
;; gwei
;; ------------------------------------------------------------
dec $gwei(int) : gwei

;; ------------------------------------------------------------
;; compute_activation_exit_epoch
;; ------------------------------------------------------------
dec $compute_activation_exit_epoch(epoch) : epoch
def $compute_activation_exit_epoch(epoch) = $(epoch + 1 + $MAX_SEED_LOOKAHEAD)

;; ------------------------------------------------------------
;; is_active_validator
;; ------------------------------------------------------------
dec $is_active_validator(validator, epoch) : boolean

def $is_active_validator(validator, epoch) = true
  -- if $(validator.ACTIVATION_EPOCH <= epoch)
  -- if $(epoch < validator.EXIT_EPOCH)

def $is_active_validator(validator, epoch) = false
  -- otherwise

;; ------------------------------------------------------------
;; get_previous_epoch
;; ------------------------------------------------------------
dec $get_previous_epoch(beaconState) : epoch

def $get_previous_epoch(state) = $GENESIS_EPOCH
  -- if $get_current_epoch(state) = $GENESIS_EPOCH

def $get_previous_epoch(state) = $( $get_current_epoch(state) - 1 )
  -- otherwise

;; ------------------------------------------------------------
;; get_block_root_at_slot
;; ------------------------------------------------------------
dec $get_block_root_at_slot(beaconState, slot) : root

def $get_block_root_at_slot(state, slot) =
  $nth_<root>(state.BLOCK_ROOTS, $(slot \ $SLOTS_PER_HISTORICAL_ROOT))
  -- if $(slot < state.SLOT)
  -- if $(state.SLOT <= slot + $SLOTS_PER_HISTORICAL_ROOT)
  
;; ------------------------------------------------------------
;; get_block_root
;; ------------------------------------------------------------
dec $get_block_root(beaconState, epoch) : root

def $get_block_root(state, epoch) = $get_block_root_at_slot(state, slot)
  -- if $compute_start_slot_at_epoch(epoch) = slot

;; ------------------------------------------------------------
;; get_randao_mix
;; ------------------------------------------------------------
dec $get_randao_mix(beaconState, epoch) : bytes32

def $get_randao_mix(state, epoch) =
  $nth_<bytes32>(state.RANDAO_MIXES, $(epoch \ $EPOCHS_PER_HISTORICAL_VECTOR))

;; ------------------------------------------------------------
;; is_eligible_for_activation_queue
;; ------------------------------------------------------------
dec $is_eligible_for_activation_queue(validator) : boolean

def $is_eligible_for_activation_queue(validator) = true
  -- if $(validator.ACTIVATION_ELIGIBILITY_EPOCH = $FAR_FUTURE_EPOCH)
  -- if $(validator.EFFECTIVE_BALANCE = $MAX_EFFECTIVE_BALANCE)

def $is_eligible_for_activation_queue(validator) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_eligible_for_activation
;; ------------------------------------------------------------
dec $is_eligible_for_activation(beaconState, validator) : boolean

def $is_eligible_for_activation(state, validator) = true
  -- if $(validator.ACTIVATION_ELIGIBILITY_EPOCH <= state.FINALIZED_CHECKPOINT.EPOCH)
  -- if $(validator.ACTIVATION_EPOCH = $FAR_FUTURE_EPOCH)

def $is_eligible_for_activation(state, validator) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_slashable_validator
;; ------------------------------------------------------------
dec $is_slashable_validator(validator, epoch) : boolean

def $is_slashable_validator(validator, epoch) = true
  -- if $(validator.SLASHED = false)
  -- if $(validator.ACTIVATION_EPOCH <= epoch)
  -- if $(epoch < validator.WITHDRAWABLE_EPOCH)

def $is_slashable_validator(validator, epoch) = false
  -- otherwise
  
;; ------------------------------------------------------------
;; compute_time_at_slot
;; ------------------------------------------------------------
dec $compute_time_at_slot(beaconState, slot) : uint64
def $compute_time_at_slot(state, slot) =
  $(state.GENESIS_TIME + (slot - $GENESIS_SLOT) * $SECONDS_PER_SLOT)

;; ------------------------------------------------------------
;; is_slashable_attestation_data
;; ------------------------------------------------------------
dec $is_slashable_attestation_data(attestationData, attestationData) : bool
def $is_slashable_attestation_data(attd1, attd2) =
  ( ~(attd1 = attd2) /\ $( attd1.TARGET.EPOCH = attd2.TARGET.EPOCH ) )
  \/
  ( $( attd1.SOURCE.EPOCH < attd2.SOURCE.EPOCH ) /\ $( attd2.TARGET.EPOCH < attd1.TARGET.EPOCH ) )

;; ------------------------------------------------------------
;; compute_fork_data_root
;; ------------------------------------------------------------
dec $compute_fork_data_root(version, root) : root
def $compute_fork_data_root(curVer, genRoot) =
  $hash_tree_root_forkdata({ CURRENT_VERSION curVer, GENESIS_VALIDATORS_ROOT genRoot })

;; ------------------------------------------------------------
;; has_eth1_withdrawal_credential
;; ------------------------------------------------------------
dec $has_eth1_withdrawal_credential(validator) : boolean

def $has_eth1_withdrawal_credential(validator) = true
  -- if $get_first_byte(validator.WITHDRAWAL_CREDENTIALS) = $ETH1_ADDRESS_WITHDRAWAL_PREFIX

def $has_eth1_withdrawal_credential(validator) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_fully_withdrawable_validator
;; ------------------------------------------------------------
dec $is_fully_withdrawable_validator(validator, gwei, epoch) : boolean

def $is_fully_withdrawable_validator(validator, balance, epoch) = true
  -- if $has_eth1_withdrawal_credential(validator) = true
  -- if $(validator.WITHDRAWABLE_EPOCH <= epoch)
  -- if $(balance > 0)

def $is_fully_withdrawable_validator(validator, balance, epoch) = false
  -- otherwise

;; ------------------------------------------------------------
;; is_partially_withdrawable_validator
;; ------------------------------------------------------------
dec $is_partially_withdrawable_validator(validator, gwei) : boolean

def $is_partially_withdrawable_validator(validator, balance) = true
  -- if $has_eth1_withdrawal_credential(validator) = true
  -- if $(validator.EFFECTIVE_BALANCE = $MAX_EFFECTIVE_BALANCE)
  -- if $(balance > $MAX_EFFECTIVE_BALANCE)

def $is_partially_withdrawable_validator(validator, balance) = false
  -- otherwise

;; ------------------------------------------------------------
;; compute_domain 
;; ------------------------------------------------------------
dec $compute_domain(domainType, version?, root?) : domain
def $compute_domain(domainType, version, root) =
  $concat_domain(domainType, $first_28_bytes($compute_fork_data_root(version, root)))

def $compute_domain(domainType, eps, eps) =
  $concat_domain(domainType, $first_28_bytes($compute_fork_data_root($GENESIS_FORK_VERSION, $ZERO_ROOT)))

def $compute_domain(domainType, version, eps) =
  $concat_domain(domainType, $first_28_bytes($compute_fork_data_root(version, $ZERO_ROOT)))

def $compute_domain(domainType, eps, root) =
  $concat_domain(domainType, $first_28_bytes($compute_fork_data_root($GENESIS_FORK_VERSION, root)))

;; ------------------------------------------------------------
;; get_domain (epoch optional)
;; ------------------------------------------------------------
dec $get_domain(beaconState, domainType, epoch?) : domain

;; epoch 생략: 현재 epoch 사용
def $get_domain(state, domainType, eps) =
  $compute_domain(domainType, state.FORK.PREVIOUS_VERSION, state.GENESIS_VALIDATORS_ROOT)
  -- if $get_current_epoch(state) = epoch_cur
  -- if $(epoch_cur < state.FORK.EPOCH)

def $get_domain(state, domainType, eps) =
  $compute_domain(domainType, state.FORK.CURRENT_VERSION, state.GENESIS_VALIDATORS_ROOT)
  -- if $get_current_epoch(state) = epoch_cur
  -- if $(state.FORK.EPOCH <= epoch_cur)

;; epoch 명시: 전달된 epoch 사용
def $get_domain(state, domainType, epoch) =
  $compute_domain(domainType, state.FORK.PREVIOUS_VERSION, state.GENESIS_VALIDATORS_ROOT)
  -- if $(epoch < state.FORK.EPOCH)

def $get_domain(state, domainType, epoch) =
  $compute_domain(domainType, state.FORK.CURRENT_VERSION, state.GENESIS_VALIDATORS_ROOT)
  -- if $(state.FORK.EPOCH <= epoch)

;; ------------------------------------------------------------
;; get_finality_delay
;; ------------------------------------------------------------
dec $get_finality_delay(beaconState) : uint64
def $get_finality_delay(state) =
  $( $get_previous_epoch(state) - state.FINALIZED_CHECKPOINT.EPOCH )

;; ------------------------------------------------------------
;; is_in_inactivity_leak
;; ------------------------------------------------------------
dec $is_in_inactivity_leak(beaconState) : boolean
def $is_in_inactivity_leak(state) =
  $( $get_finality_delay(state) > $MIN_EPOCHS_TO_INACTIVITY_PENALTY )

;;
;; Updating beaconstate fields
;;

relation IncreaseBalance:
  beaconState validatorIndex gwei ~> beaconState
  hint(input %0 %1 %2)

rule IncreaseBalance:
  state validatorIndex delta ~> state[.BALANCES = balancesUpdate]
  -- if $as_nat_validatorIndex(validatorIndex) = idx
  -- if $( idx < |state.BALANCES| )
  -- if $nth_<gwei>(state.BALANCES, idx) = current
  -- if $(current + delta) = newBalance
  -- if $update_list_<gwei>(state.BALANCES, idx, newBalance) = balancesUpdate

;; ------------------------------------------------------------
;; decrease_balance
;; ------------------------------------------------------------
relation DecreaseBalance:
  beaconState validatorIndex gwei ~> beaconState
  hint(input %0 %1 %2)


;; case 1 delta > current ⇒ set to 0 
rule DecreaseBalance/decbalif:
  state validatorIndex delta ~> state[.BALANCES = balancesUpdate]
  -- if $as_nat_validatorIndex(validatorIndex) = idx
  -- if $( idx < |state.BALANCES| )
  -- if $nth_<gwei>(state.BALANCES, idx) = current
  -- if $(delta > current)
  -- if $(current - current) = newBalance
  -- if $update_list_<gwei>(state.BALANCES, idx, newBalance) = balancesUpdate

;; case 2 delta ≤ current ⇒ decrease delta
rule DecreaseBalance/decbalelse:
  state validatorIndex delta ~> state[.BALANCES = balancesUpdate]
  -- if $as_nat_validatorIndex(validatorIndex) = idx
  -- if $( idx < |state.BALANCES| )
  -- if $nth_<gwei>(state.BALANCES, idx) = current
  -- if $(delta <= current)
  -- if $(current - delta) = newBalance
  -- if $update_list_<gwei>(state.BALANCES, idx, newBalance) = balancesUpdate

syntax enumerated_<X> = (nat, X)
dec $enumerate_<X>(X*) : enumerated_<X>*

dec $filter_list_<X>(X*, def $cond(X) : bool)
  : X*
def $filter_list_<X>(eps, def $cond) = eps
def $filter_list_<X>(X_h :: X_t*, def $cond)
  = X_h :: $filter_list_<X>(X_t*, def $cond)
  -- if $cond(X_h) = true
def $filter_list_<X>(X_h :: X_t*, def $cond)
  = $filter_list_<X>(X_t*, def $cond)
  -- if $cond(X_h) = false

dec $filter_list_2_<X, Y>(X*, Y, def $cond(X, Y) : bool)
  : X*


dec $is_active_validator_enumerated(enumerated_<validator>, epoch) : bool
def $is_active_validator_enumerated((n, validator), epoch) = $is_active_validator(validator, epoch)

dec $get_active_validator_indices(beaconState, epoch) : validatorIndex*
def $get_active_validator_indices(state, epoch) = n_active*
  -- if state.VALIDATORS = validator*
  -- if $enumerate_<validator>(validator*) = (n, validator)*
  -- if $filter_list_2_<(nat, validator), epoch>(
      (n, validator)*,
      epoch,
      def $is_active_validator_enumerated
    )
    = (n_active, validator_active)*


;;
;; Epoch processing
;;

relation Process:
  beaconState ~> beaconState
  hint(input %0)

;; Set[ValidatorIndex]는 중복 없는 리스트 -> (validatorIndex*)
dec $get_unslashed_participating_indices(beaconState, nat, epoch) : validatorIndex*
dec $get_total_balance(beaconState, validatorIndex*) : gwei
dec $get_total_active_balance(beaconState) : gwei

dec $weigh_justification_and_finalization(beaconState, gwei, gwei, gwei) : beaconState

;; skip
rule Process/justification_and_finalization/skip:
  state ~> state
  -- if $get_current_epoch(state) = epoch_cur
  -- if $(epoch_cur <= ($GENESIS_EPOCH + 1))

;; no skip
rule Process/justification_and_finalization/main:
  state ~> state_weighed
  -- if $get_current_epoch(state) = epoch_cur
  -- if $get_previous_epoch(state) = epoch_prev
  -- if $get_unslashed_participating_indices(state, $TIMELY_TARGET_FLAG_INDEX, epoch_prev) = validatorIndex_prev_indices*
  -- if $get_unslashed_participating_indices(state, $TIMELY_TARGET_FLAG_INDEX, epoch_cur)  = validatorIndex_curr_indices*
  -- if $get_total_active_balance(state) = gwei_total_active
  -- if $get_total_balance(state, validatorIndex_prev_indices*) = gwei_prev_target_bal
  -- if $get_total_balance(state, validatorIndex_curr_indices*) = gwei_curr_target_bal
  -- if $weigh_justification_and_finalization(state, gwei_total_active, gwei_prev_target_bal, gwei_curr_target_bal) = state_weighed


rule Process/eth1_data_reset:
  state ~> state[.ETH1_DATA_VOTES = eps]
  -- if $($get_current_epoch(state) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_ETH1_VOTING_PERIOD) = 0

;; ------------------------------------------------------------
;; process_effective_balance_updates
;; ------------------------------------------------------------



rule Process/slashings_reset:
  state ~> state[.SLASHINGS = gwei_update*]
  -- if $($get_current_epoch(state) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SLASHINGS_VECTOR) = n
  -- if $update_list_<gwei>(state.SLASHINGS, n, 0) = gwei_update*

rule Process/randao_mixes_reset:
  state ~> state[.RANDAO_MIXES = bytes32_randao_mixes_update*]
  -- if $get_current_epoch(state) = epoch_current
  -- if $(epoch_current + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_HISTORICAL_VECTOR) = n
  -- if $get_randao_mix(state, epoch_current) = bytes32_mix
  -- if $update_list_<bytes32>(state.RANDAO_MIXES, n, bytes32_mix) = bytes32_randao_mixes_update*

rule Process/historical_summaries_update:
  state ~> state[.HISTORICAL_SUMMARIES = historicalSummary_update*]
  -- if $get_current_epoch(state) = epoch_cur
  -- if $(epoch_cur + 1) = epoch_next
  -- if $( epoch_next \ ( $SLOTS_PER_HISTORICAL_ROOT / $SLOTS_PER_EPOCH ) ) = 0
  -- if $hash_tree_root_roots(state.BLOCK_ROOTS) = root_block_summary
  -- if $hash_tree_root_roots(state.STATE_ROOTS) = root_state_summary
  -- if { BLOCK_SUMMARY_ROOT root_block_summary, STATE_SUMMARY_ROOT root_state_summary } = historicalSummary_new
  -- if state.HISTORICAL_SUMMARIES ++ [ historicalSummary_new ] = historicalSummary_update*

dec $get_next_sync_committee(beaconState) : syncCommittee

rule Process/sync_committee_updates:
  state ~> state[.CURRENT_SYNC_COMMITTEE = state.NEXT_SYNC_COMMITTEE]
              [.NEXT_SYNC_COMMITTEE    = syncCommittee_next]
  -- if $($get_current_epoch(state) + 1) = epoch_next
  -- if $(epoch_next \ $EPOCHS_PER_SYNC_COMMITTEE_PERIOD) = 0
  -- if syncCommittee_next = $get_next_sync_committee(state)

;;
;; Block processing
;;

relation ProcessBlock:
  beaconState beaconBlockBody ~> beaconState
  hint(input %0 %1)

;; process_block_header
dec $hash_tree_root_beaconBlockHeader(beaconBlockHeader) : root
dec $hash_tree_root_beaconBlockBody(beaconBlockBody) : root
dec $get_beacon_proposer_index(beaconState) : validatorIndex

relation ProcessBlockHeader:
  beaconState beaconBlock ~> beaconState
  hint(input %0 %1)

rule ProcessBlockHeader/main:
  state block ~> state[.LATEST_BLOCK_HEADER = beaconBlockHeader_new]
  ;; 1 슬롯 일치
  -- if $(block.SLOT = state.SLOT)
  ;; 2 이전 헤더보다 최신인지
  -- if $(state.LATEST_BLOCK_HEADER.SLOT < block.SLOT)
  ;; 3 제안자 인덱스 검증
  -- if $get_beacon_proposer_index(state) = validatorIndex_prop
  -- if $(block.PROPOSER_INDEX = validatorIndex_prop)
  ;; 4 부모 루트 검증
  -- if root_parent_expected = $hash_tree_root_beaconBlockHeader(state.LATEST_BLOCK_HEADER)
  -- if $(block.PARENT_ROOT = root_parent_expected)
  ;; 5 새 헤더 캐싱(STATE_ROOT는 0으로, BODY_ROOT는 블록 바디 해시)
  -- if root_body_root_new = $hash_tree_root_beaconBlockBody(block.BODY)
  -- if beaconBlockHeader_new =
       { SLOT block.SLOT,
         PROPOSER_INDEX block.PROPOSER_INDEX,
         PARENT_ROOT block.PARENT_ROOT,
         STATE_ROOT $ZERO_ROOT,
         BODY_ROOT root_body_root_new }
  ;; 6 제안자 슬래시 여부 확인 (not slashed)
  -- if $as_nat_validatorIndex(block.PROPOSER_INDEX) = idx
  -- if validator_proposer = $nth_<validator>(state.VALIDATORS, idx)
  -- if $(validator_proposer.SLASHED = false)

;; spec 대로 -> true 만 리턴하는 함수
dec $ee_verify_and_notify_new_payload(executionPayload) : boolean
def $ee_verify_and_notify_new_payload(executionPayload) = true

;; 필요한 hash_tree_root, tx hash_tree_root, withdrawal hash_tree_root
dec $hash_tree_root_tx(bytes32*) : root
dec $hash_tree_root_withdrawals(withdrawal*) : root


;; ------------------------------------------------------------
;; process_execution_payload
;; ------------------------------------------------------------
rule ProcessBlock/execution_payload:
  state body ~> state[.LATEST_EXECUTION_PAYLOAD_HEADER = executionPayloadHeader_new]
  -- if executionPayload_block = body.EXECUTION_PAYLOAD
  ;; 1 부모 해시 일치
  -- if $(executionPayload_block.PARENT_HASH = state.LATEST_EXECUTION_PAYLOAD_HEADER.BLOCK_HASH)
  ;; 2 prev_randao 일치
  -- if $get_current_epoch(state) = epoch_cur
  -- if $get_randao_mix(state, epoch_cur) = bytes32_randao_expected
  -- if $(executionPayload_block.PREV_RANDAO = bytes32_randao_expected)
  ;; 3 timestamp 일치
  -- if $compute_time_at_slot(state, state.SLOT) = uint64_ts_expected
  -- if $(executionPayload_block.TIMESTAMP = uint64_ts_expected)
  ;; 4 실행 엔진 검증 (항상 true)
  -- if $ee_verify_and_notify_new_payload(executionPayload_block) = true
  ;; 5 헤더 캐싱을 위한 루트 계산
  -- if $hash_tree_root_tx(executionPayload_block.TRANSACTIONS) = root_tx
  -- if $hash_tree_root_withdrawals(executionPayload_block.WITHDRAWALS) = root_withdrawal
  ;; 6 새 ExecutionPayloadHeader 구성 및 저장
  -- if executionPayloadHeader_new =
       { PARENT_HASH        executionPayload_block.PARENT_HASH,
         FEE_RECIPIENT      executionPayload_block.FEE_RECIPIENT,
         STATE_ROOT         executionPayload_block.STATE_ROOT,
         RECEIPTS_ROOT      executionPayload_block.RECEIPTS_ROOT,
         LOGS_BLOOM         executionPayload_block.LOGS_BLOOM,
         PREV_RANDAO        executionPayload_block.PREV_RANDAO,
         BLOCK_NUMBER       executionPayload_block.BLOCK_NUMBER,
         GAS_LIMIT          executionPayload_block.GAS_LIMIT,
         GAS_USED           executionPayload_block.GAS_USED,
         TIMESTAMP          executionPayload_block.TIMESTAMP,
         EXTRA_DATA         executionPayload_block.EXTRA_DATA,
         BASE_FEE_PER_GAS   executionPayload_block.BASE_FEE_PER_GAS,
         BLOCK_HASH         executionPayload_block.BLOCK_HASH,
         TRANSACTIONS_ROOT  root_tx,
         WITHDRAWALS_ROOT   root_withdrawal }

;; 여기서부터는 우선 필요한 헬퍼 dec 만 
;; process_randao

dec $hash_<X>(X) : bytes32
dec $bls_verify(blsPubkey, root, blsSignature) : boolean
dec $compute_signing_root(epoch, domain) : root

rule ProcessBlock/randao:
  state body ~> state[.RANDAO_MIXES = bytes32_randao_mixes_update*]
  -- if $get_current_epoch(state) = epoch
  -- if $get_beacon_proposer_index(state) = validatorIndex_prop
  -- if $as_nat_validatorIndex(validatorIndex_prop) = idx
  -- if $nth_<validator>(state.VALIDATORS, idx) = validator_proposer
  -- if $get_domain(state, $DOMAIN_RANDAO, eps) = domain_randao
  -- if $compute_signing_root(epoch, domain_randao) = root_signing
  -- if $bls_verify(validator_proposer.PUBKEY, root_signing, body.RANDAO_REVEAL) = true
  -- if $get_randao_mix(state, epoch) = bytes32_mix_old
  -- if $hash_<blsSignature>(body.RANDAO_REVEAL) = bytes32_hash_reveal
  -- if $xor(bytes32_mix_old, bytes32_hash_reveal) = bytes32_mix_new
  -- if $(epoch \ $EPOCHS_PER_HISTORICAL_VECTOR) = n
  -- if $update_list_<bytes32>(state.RANDAO_MIXES, n, bytes32_mix_new) = bytes32_randao_mixes_update*


rule ProcessBlock/eth1_data_if:
  state body ~> state[.ETH1_DATA_VOTES = eth1Data_update*][.ETH1_DATA = body.ETH1_DATA]
  -- if state.ETH1_DATA_VOTES ++ [ body.ETH1_DATA ] = eth1Data_update*
  -- if $count_occurrences_<eth1Data>(eth1Data_update*, body.ETH1_DATA) = n_occurences
  -- if $(n_occurences * 2 > $EPOCHS_PER_ETH1_VOTING_PERIOD * $SLOTS_PER_EPOCH)

rule ProcessBlock/eth1_data_else:
  state body ~> state[.ETH1_DATA_VOTES = eth1Data_update*]
  -- if state.ETH1_DATA_VOTES ++ [ body.ETH1_DATA ] = eth1Data_update*
  -- if $count_occurrences_<eth1Data>(eth1Data_update*, body.ETH1_DATA) = n_occurences
  -- if $(n_occurences * 2 <= $EPOCHS_PER_ETH1_VOTING_PERIOD * $SLOTS_PER_EPOCH)

;; ------------------------------------------------------------
;; Decls needed by process_deposit
;; ------------------------------------------------------------

dec $hash_tree_root_depositData(depositData) : root

dec $is_valid_merkle_branch(bytes32, bytes32*, uint64, uint64, root) : boolean

;; apply_deposit는 dec 만
dec $apply_deposit(beaconState, blsPubkey, bytes32, gwei, blsSignature) : beaconState

;; ------------------------------------------------------------
;; process_deposit
;; ------------------------------------------------------------

relation ProcessDeposit:
  beaconState deposit ~> beaconState
  hint(input %0 %1)

rule ProcessDeposit/main:
  state deposit ~> state_applied
  ;; 1 is_valid_merkle_branch
  -- if $hash_tree_root_depositData(deposit.DATA) = root_leaf
  -- if $( $DEPOSIT_CONTRACT_TREE_DEPTH + 1 ) = uint64_depth_plus_1
  -- if $is_valid_merkle_branch(
         root_leaf,
         deposit.PROOF,
         uint64_depth_plus_1,
         state.ETH1_DEPOSIT_INDEX,
         state.ETH1_DATA.DEPOSIT_ROOT
       ) = true
  ;; 2 인덱스 증가
  -- if $(state.ETH1_DEPOSIT_INDEX + 1) = uint64_deposit_index_next
  -- if state_inc = state[.ETH1_DEPOSIT_INDEX = uint64_deposit_index_next]
  ;; 3 apply_deposit 적용 (상태 반영)
  -- if state_applied =
       $apply_deposit(
         state_inc,
         deposit.DATA.PUBKEY,
         deposit.DATA.WITHDRAWAL_CREDENTIALS,
         deposit.DATA.AMOUNT,
         deposit.DATA.SIGNATURE
       )


;; ------------------------------------------------------------
;; Decl only (no def)
;; ------------------------------------------------------------
dec $initiate_validator_exit(beaconState, validatorIndex) : beaconState
dec $compute_signing_root_voluntary_exit(voluntaryExit, domain) : root


;; ------------------------------------------------------------
;; process_voluntary_exit
;; ------------------------------------------------------------
relation ProcessVoluntaryExit:
  beaconState signedVoluntaryExit ~> beaconState
  hint(input %0 %1)

rule ProcessVoluntaryExit/main:
  state signedVoluntaryExit ~> state_after_exit
  ;; 메시지, 인덱스, 검증 대상 validator 로컬 바인딩
  -- if voluntaryExit = signedVoluntaryExit.MESSAGE
  -- if validatorIndex_exit   = voluntaryExit.VALIDATOR_INDEX
  -- if $as_nat_validatorIndex(validatorIndex_exit) = idx
  -- if validator = $nth_<validator>(state.VALIDATORS, idx)
  ;; 현재 epoch
  -- if $get_current_epoch(state) = epoch_cur
  ;; 1 활성 검증자 확인
  -- if $is_active_validator(validator, epoch_cur) = true
  ;; 2 아직 exit 시작 안 됨
  -- if $(validator.EXIT_EPOCH = $FAR_FUTURE_EPOCH)
  ;; 3 voluntary exit epoch 도달
  -- if $(epoch_cur >= voluntaryExit.EPOCH)
  ;; 4 활성 기간 
  -- if $(epoch_cur >= validator.ACTIVATION_EPOCH + $SHARD_COMMITTEE_PERIOD)
  ;; 5 도메인 & 서명 루트
  -- if $get_domain(state, $DOMAIN_VOLUNTARY_EXIT, voluntaryExit.EPOCH) = domain_exit
  -- if $compute_signing_root_voluntary_exit(voluntaryExit, domain_exit) = root_vol_exit_signing_root
  ;; 6 BLS 서명 검증
  -- if $bls_verify(validator.PUBKEY, root_vol_exit_signing_root, signedVoluntaryExit.SIGNATURE) = true
  ;; 7 Exit 시작
  -- if state_after_exit = $initiate_validator_exit(state, validatorIndex_exit)

;; ------------------------------------------------------------
;; Decls needed by process_bls_to_execution_change
;; ------------------------------------------------------------
dec $compute_signing_root_bls_to_execution_change(blsToExecutionChange, domain) : root
dec $strip_first_byte(bytes32) : bytes32
dec $make_withdrawal_credentials_eth1(executionAddress) : bytes32


;; ------------------------------------------------------------
;; process_bls_to_execution_change
;; ------------------------------------------------------------
relation ProcessBLSToExecutionChange:
  beaconState signedBlsToExecutionChange ~> beaconState
  hint(input %0 %1)

rule ProcessBLSToExecutionChange/main:
  state signedBlsToExecutionChange ~> state_updated
  ;; 메시지/인덱스/검증자 바인딩
  -- if blsToExecutionChange = signedBlsToExecutionChange.MESSAGE
  -- if validatorIndex_change = blsToExecutionChange.VALIDATOR_INDEX
  -- if $as_nat_validatorIndex(validatorIndex_change) = idx
  -- if $(idx < |state.VALIDATORS|)
  -- if validator = $nth_<validator>(state.VALIDATORS, idx)
  ;; 1 기존 크레덴셜이 BLS 타입인지 확인 (prefix = 0x00)
  -- if $get_first_byte(validator.WITHDRAWAL_CREDENTIALS) = $BLS_WITHDRAWAL_PREFIX
  ;; 2 기존 크레덴셜의 [1:] 이 hash(pubkey)[1:] 와 같은지 확인
  -- if $hash_<blsPubkey>(blsToExecutionChange.FROM_BLS_PUBKEY) = bytes32_pk_hash
  -- if $strip_first_byte(validator.WITHDRAWAL_CREDENTIALS) = bytes32_wc_tail
  -- if $strip_first_byte(bytes32_pk_hash) = bytes32_pk_tail
  -- if $(bytes32_wc_tail = bytes32_pk_tail)
  ;; 3 도메인 (genesis_validators_root 사용)
  -- if $compute_domain($DOMAIN_BLS_TO_EXECUTION_CHANGE, eps, state.GENESIS_VALIDATORS_ROOT) = domain_btec
  -- if $compute_signing_root_bls_to_execution_change(blsToExecutionChange, domain_btec) = root_sign
  ;; 4 BLS 서명 검증
  -- if $bls_verify(blsToExecutionChange.FROM_BLS_PUBKEY, root_sign, signedBlsToExecutionChange.SIGNATURE) = true
  ;; 5 ETH1 주소형 크레덴셜로 갱신: 0x01 ++ 0x00*11 ++ to_execution_address
  -- if $make_withdrawal_credentials_eth1(blsToExecutionChange.TO_EXECUTION_ADDRESS) = bytes32_new_wc
  -- if validator_updated = validator[.WITHDRAWAL_CREDENTIALS = bytes32_new_wc]
  -- if validator_update* = $update_list_<validator>(state.VALIDATORS, idx, validator_updated)
  -- if state_updated = state[.VALIDATORS = validator_update*]




